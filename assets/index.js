function KW(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();function Z0(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function YW(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var zT={exports:{}},Fy={},UT={exports:{}},An={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Mk;function ZW(){if(Mk)return An;Mk=1;var n=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),o=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),h=Symbol.iterator;function f(B){return B===null||typeof B!="object"?null:(B=h&&B[h]||B["@@iterator"],typeof B=="function"?B:null)}var p={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,S={};function x(B,K,se){this.props=B,this.context=K,this.refs=S,this.updater=se||p}x.prototype.isReactComponent={},x.prototype.setState=function(B,K){if(typeof B!="object"&&typeof B!="function"&&B!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,B,K,"setState")},x.prototype.forceUpdate=function(B){this.updater.enqueueForceUpdate(this,B,"forceUpdate")};function w(){}w.prototype=x.prototype;function _(B,K,se){this.props=B,this.context=K,this.refs=S,this.updater=se||p}var T=_.prototype=new w;T.constructor=_,g(T,x.prototype),T.isPureReactComponent=!0;var C=Array.isArray,N=Object.prototype.hasOwnProperty,M={current:null},P={key:!0,ref:!0,__self:!0,__source:!0};function $(B,K,se){var te,ue={},fe=null,_e=null;if(K!=null)for(te in K.ref!==void 0&&(_e=K.ref),K.key!==void 0&&(fe=""+K.key),K)N.call(K,te)&&!P.hasOwnProperty(te)&&(ue[te]=K[te]);var Ie=arguments.length-2;if(Ie===1)ue.children=se;else if(1<Ie){for(var Ve=Array(Ie),qe=0;qe<Ie;qe++)Ve[qe]=arguments[qe+2];ue.children=Ve}if(B&&B.defaultProps)for(te in Ie=B.defaultProps,Ie)ue[te]===void 0&&(ue[te]=Ie[te]);return{$$typeof:n,type:B,key:fe,ref:_e,props:ue,_owner:M.current}}function R(B,K){return{$$typeof:n,type:B.type,key:K,ref:B.ref,props:B.props,_owner:B._owner}}function D(B){return typeof B=="object"&&B!==null&&B.$$typeof===n}function L(B){var K={"=":"=0",":":"=2"};return"$"+B.replace(/[=:]/g,function(se){return K[se]})}var G=/\/+/g;function Q(B,K){return typeof B=="object"&&B!==null&&B.key!=null?L(""+B.key):K.toString(36)}function W(B,K,se,te,ue){var fe=typeof B;(fe==="undefined"||fe==="boolean")&&(B=null);var _e=!1;if(B===null)_e=!0;else switch(fe){case"string":case"number":_e=!0;break;case"object":switch(B.$$typeof){case n:case e:_e=!0}}if(_e)return _e=B,ue=ue(_e),B=te===""?"."+Q(_e,0):te,C(ue)?(se="",B!=null&&(se=B.replace(G,"$&/")+"/"),W(ue,K,se,"",function(qe){return qe})):ue!=null&&(D(ue)&&(ue=R(ue,se+(!ue.key||_e&&_e.key===ue.key?"":(""+ue.key).replace(G,"$&/")+"/")+B)),K.push(ue)),1;if(_e=0,te=te===""?".":te+":",C(B))for(var Ie=0;Ie<B.length;Ie++){fe=B[Ie];var Ve=te+Q(fe,Ie);_e+=W(fe,K,se,Ve,ue)}else if(Ve=f(B),typeof Ve=="function")for(B=Ve.call(B),Ie=0;!(fe=B.next()).done;)fe=fe.value,Ve=te+Q(fe,Ie++),_e+=W(fe,K,se,Ve,ue);else if(fe==="object")throw K=String(B),Error("Objects are not valid as a React child (found: "+(K==="[object Object]"?"object with keys {"+Object.keys(B).join(", ")+"}":K)+"). If you meant to render a collection of children, use an array instead.");return _e}function H(B,K,se){if(B==null)return B;var te=[],ue=0;return W(B,te,"","",function(fe){return K.call(se,fe,ue++)}),te}function J(B){if(B._status===-1){var K=B._result;K=K(),K.then(function(se){(B._status===0||B._status===-1)&&(B._status=1,B._result=se)},function(se){(B._status===0||B._status===-1)&&(B._status=2,B._result=se)}),B._status===-1&&(B._status=0,B._result=K)}if(B._status===1)return B._result.default;throw B._result}var ie={current:null},V={transition:null},Y={ReactCurrentDispatcher:ie,ReactCurrentBatchConfig:V,ReactCurrentOwner:M};return An.Children={map:H,forEach:function(B,K,se){H(B,function(){K.apply(this,arguments)},se)},count:function(B){var K=0;return H(B,function(){K++}),K},toArray:function(B){return H(B,function(K){return K})||[]},only:function(B){if(!D(B))throw Error("React.Children.only expected to receive a single React element child.");return B}},An.Component=x,An.Fragment=t,An.Profiler=r,An.PureComponent=_,An.StrictMode=s,An.Suspense=l,An.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Y,An.cloneElement=function(B,K,se){if(B==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+B+".");var te=g({},B.props),ue=B.key,fe=B.ref,_e=B._owner;if(K!=null){if(K.ref!==void 0&&(fe=K.ref,_e=M.current),K.key!==void 0&&(ue=""+K.key),B.type&&B.type.defaultProps)var Ie=B.type.defaultProps;for(Ve in K)N.call(K,Ve)&&!P.hasOwnProperty(Ve)&&(te[Ve]=K[Ve]===void 0&&Ie!==void 0?Ie[Ve]:K[Ve])}var Ve=arguments.length-2;if(Ve===1)te.children=se;else if(1<Ve){Ie=Array(Ve);for(var qe=0;qe<Ve;qe++)Ie[qe]=arguments[qe+2];te.children=Ie}return{$$typeof:n,type:B.type,key:ue,ref:fe,props:te,_owner:_e}},An.createContext=function(B){return B={$$typeof:o,_currentValue:B,_currentValue2:B,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},B.Provider={$$typeof:i,_context:B},B.Consumer=B},An.createElement=$,An.createFactory=function(B){var K=$.bind(null,B);return K.type=B,K},An.createRef=function(){return{current:null}},An.forwardRef=function(B){return{$$typeof:a,render:B}},An.isValidElement=D,An.lazy=function(B){return{$$typeof:c,_payload:{_status:-1,_result:B},_init:J}},An.memo=function(B,K){return{$$typeof:u,type:B,compare:K===void 0?null:K}},An.startTransition=function(B){var K=V.transition;V.transition={};try{B()}finally{V.transition=K}},An.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},An.useCallback=function(B,K){return ie.current.useCallback(B,K)},An.useContext=function(B){return ie.current.useContext(B)},An.useDebugValue=function(){},An.useDeferredValue=function(B){return ie.current.useDeferredValue(B)},An.useEffect=function(B,K){return ie.current.useEffect(B,K)},An.useId=function(){return ie.current.useId()},An.useImperativeHandle=function(B,K,se){return ie.current.useImperativeHandle(B,K,se)},An.useInsertionEffect=function(B,K){return ie.current.useInsertionEffect(B,K)},An.useLayoutEffect=function(B,K){return ie.current.useLayoutEffect(B,K)},An.useMemo=function(B,K){return ie.current.useMemo(B,K)},An.useReducer=function(B,K,se){return ie.current.useReducer(B,K,se)},An.useRef=function(B){return ie.current.useRef(B)},An.useState=function(B){return ie.current.useState(B)},An.useSyncExternalStore=function(B,K,se){return ie.current.useSyncExternalStore(B,K,se)},An.useTransition=function(){return ie.current.useTransition()},An.version="18.2.0",An}var kk;function J0(){return kk||(kk=1,UT.exports=ZW()),UT.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rk;function JW(){if(Rk)return Fy;Rk=1;var n=J0(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function o(a,l,u){var c,h={},f=null,p=null;u!==void 0&&(f=""+u),l.key!==void 0&&(f=""+l.key),l.ref!==void 0&&(p=l.ref);for(c in l)s.call(l,c)&&!i.hasOwnProperty(c)&&(h[c]=l[c]);if(a&&a.defaultProps)for(c in l=a.defaultProps,l)h[c]===void 0&&(h[c]=l[c]);return{$$typeof:e,type:a,key:f,ref:p,props:h,_owner:r.current}}return Fy.Fragment=t,Fy.jsx=o,Fy.jsxs=o,Fy}var Dk;function QW(){return Dk||(Dk=1,zT.exports=JW()),zT.exports}var Ae=QW(),Ee=J0();const Ju=Z0(Ee);var I1={},BT={exports:{}},_o={},VT={exports:{}},WT={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Pk;function eG(){return Pk||(Pk=1,(function(n){function e(V,Y){var B=V.length;V.push(Y);e:for(;0<B;){var K=B-1>>>1,se=V[K];if(0<r(se,Y))V[K]=Y,V[B]=se,B=K;else break e}}function t(V){return V.length===0?null:V[0]}function s(V){if(V.length===0)return null;var Y=V[0],B=V.pop();if(B!==Y){V[0]=B;e:for(var K=0,se=V.length,te=se>>>1;K<te;){var ue=2*(K+1)-1,fe=V[ue],_e=ue+1,Ie=V[_e];if(0>r(fe,B))_e<se&&0>r(Ie,fe)?(V[K]=Ie,V[_e]=B,K=_e):(V[K]=fe,V[ue]=B,K=ue);else if(_e<se&&0>r(Ie,B))V[K]=Ie,V[_e]=B,K=_e;else break e}}return Y}function r(V,Y){var B=V.sortIndex-Y.sortIndex;return B!==0?B:V.id-Y.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,h=null,f=3,p=!1,g=!1,S=!1,x=typeof setTimeout=="function"?setTimeout:null,w=typeof clearTimeout=="function"?clearTimeout:null,_=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function T(V){for(var Y=t(u);Y!==null;){if(Y.callback===null)s(u);else if(Y.startTime<=V)s(u),Y.sortIndex=Y.expirationTime,e(l,Y);else break;Y=t(u)}}function C(V){if(S=!1,T(V),!g)if(t(l)!==null)g=!0,J(N);else{var Y=t(u);Y!==null&&ie(C,Y.startTime-V)}}function N(V,Y){g=!1,S&&(S=!1,w($),$=-1),p=!0;var B=f;try{for(T(Y),h=t(l);h!==null&&(!(h.expirationTime>Y)||V&&!L());){var K=h.callback;if(typeof K=="function"){h.callback=null,f=h.priorityLevel;var se=K(h.expirationTime<=Y);Y=n.unstable_now(),typeof se=="function"?h.callback=se:h===t(l)&&s(l),T(Y)}else s(l);h=t(l)}if(h!==null)var te=!0;else{var ue=t(u);ue!==null&&ie(C,ue.startTime-Y),te=!1}return te}finally{h=null,f=B,p=!1}}var M=!1,P=null,$=-1,R=5,D=-1;function L(){return!(n.unstable_now()-D<R)}function G(){if(P!==null){var V=n.unstable_now();D=V;var Y=!0;try{Y=P(!0,V)}finally{Y?Q():(M=!1,P=null)}}else M=!1}var Q;if(typeof _=="function")Q=function(){_(G)};else if(typeof MessageChannel<"u"){var W=new MessageChannel,H=W.port2;W.port1.onmessage=G,Q=function(){H.postMessage(null)}}else Q=function(){x(G,0)};function J(V){P=V,M||(M=!0,Q())}function ie(V,Y){$=x(function(){V(n.unstable_now())},Y)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(V){V.callback=null},n.unstable_continueExecution=function(){g||p||(g=!0,J(N))},n.unstable_forceFrameRate=function(V){0>V||125<V?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<V?Math.floor(1e3/V):5},n.unstable_getCurrentPriorityLevel=function(){return f},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(V){switch(f){case 1:case 2:case 3:var Y=3;break;default:Y=f}var B=f;f=Y;try{return V()}finally{f=B}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(V,Y){switch(V){case 1:case 2:case 3:case 4:case 5:break;default:V=3}var B=f;f=V;try{return Y()}finally{f=B}},n.unstable_scheduleCallback=function(V,Y,B){var K=n.unstable_now();switch(typeof B=="object"&&B!==null?(B=B.delay,B=typeof B=="number"&&0<B?K+B:K):B=K,V){case 1:var se=-1;break;case 2:se=250;break;case 5:se=1073741823;break;case 4:se=1e4;break;default:se=5e3}return se=B+se,V={id:c++,callback:Y,priorityLevel:V,startTime:B,expirationTime:se,sortIndex:-1},B>K?(V.sortIndex=B,e(u,V),t(l)===null&&V===t(u)&&(S?(w($),$=-1):S=!0,ie(C,B-K))):(V.sortIndex=se,e(l,V),g||p||(g=!0,J(N))),V},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(V){var Y=f;return function(){var B=f;f=Y;try{return V.apply(this,arguments)}finally{f=B}}}})(WT)),WT}var Lk;function tG(){return Lk||(Lk=1,VT.exports=eG()),VT.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ok;function nG(){if(Ok)return _o;Ok=1;var n=J0(),e=tG();function t(d){for(var m="https://reactjs.org/docs/error-decoder.html?invariant="+d,b=1;b<arguments.length;b++)m+="&args[]="+encodeURIComponent(arguments[b]);return"Minified React error #"+d+"; visit "+m+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,r={};function i(d,m){o(d,m),o(d+"Capture",m)}function o(d,m){for(r[d]=m,d=0;d<m.length;d++)s.add(m[d])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,u=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,c={},h={};function f(d){return l.call(h,d)?!0:l.call(c,d)?!1:u.test(d)?h[d]=!0:(c[d]=!0,!1)}function p(d,m,b,I){if(b!==null&&b.type===0)return!1;switch(typeof m){case"function":case"symbol":return!0;case"boolean":return I?!1:b!==null?!b.acceptsBooleans:(d=d.toLowerCase().slice(0,5),d!=="data-"&&d!=="aria-");default:return!1}}function g(d,m,b,I){if(m===null||typeof m>"u"||p(d,m,b,I))return!0;if(I)return!1;if(b!==null)switch(b.type){case 3:return!m;case 4:return m===!1;case 5:return isNaN(m);case 6:return isNaN(m)||1>m}return!1}function S(d,m,b,I,k,F,j){this.acceptsBooleans=m===2||m===3||m===4,this.attributeName=I,this.attributeNamespace=k,this.mustUseProperty=b,this.propertyName=d,this.type=m,this.sanitizeURL=F,this.removeEmptyString=j}var x={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(d){x[d]=new S(d,0,!1,d,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(d){var m=d[0];x[m]=new S(m,1,!1,d[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(d){x[d]=new S(d,2,!1,d.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(d){x[d]=new S(d,2,!1,d,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(d){x[d]=new S(d,3,!1,d.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(d){x[d]=new S(d,3,!0,d,null,!1,!1)}),["capture","download"].forEach(function(d){x[d]=new S(d,4,!1,d,null,!1,!1)}),["cols","rows","size","span"].forEach(function(d){x[d]=new S(d,6,!1,d,null,!1,!1)}),["rowSpan","start"].forEach(function(d){x[d]=new S(d,5,!1,d.toLowerCase(),null,!1,!1)});var w=/[\-:]([a-z])/g;function _(d){return d[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(d){var m=d.replace(w,_);x[m]=new S(m,1,!1,d,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(d){var m=d.replace(w,_);x[m]=new S(m,1,!1,d,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(d){var m=d.replace(w,_);x[m]=new S(m,1,!1,d,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(d){x[d]=new S(d,1,!1,d.toLowerCase(),null,!1,!1)}),x.xlinkHref=new S("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(d){x[d]=new S(d,1,!1,d.toLowerCase(),null,!0,!0)});function T(d,m,b,I){var k=x.hasOwnProperty(m)?x[m]:null;(k!==null?k.type!==0:I||!(2<m.length)||m[0]!=="o"&&m[0]!=="O"||m[1]!=="n"&&m[1]!=="N")&&(g(m,b,k,I)&&(b=null),I||k===null?f(m)&&(b===null?d.removeAttribute(m):d.setAttribute(m,""+b)):k.mustUseProperty?d[k.propertyName]=b===null?k.type===3?!1:"":b:(m=k.attributeName,I=k.attributeNamespace,b===null?d.removeAttribute(m):(k=k.type,b=k===3||k===4&&b===!0?"":""+b,I?d.setAttributeNS(I,m,b):d.setAttribute(m,b))))}var C=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,N=Symbol.for("react.element"),M=Symbol.for("react.portal"),P=Symbol.for("react.fragment"),$=Symbol.for("react.strict_mode"),R=Symbol.for("react.profiler"),D=Symbol.for("react.provider"),L=Symbol.for("react.context"),G=Symbol.for("react.forward_ref"),Q=Symbol.for("react.suspense"),W=Symbol.for("react.suspense_list"),H=Symbol.for("react.memo"),J=Symbol.for("react.lazy"),ie=Symbol.for("react.offscreen"),V=Symbol.iterator;function Y(d){return d===null||typeof d!="object"?null:(d=V&&d[V]||d["@@iterator"],typeof d=="function"?d:null)}var B=Object.assign,K;function se(d){if(K===void 0)try{throw Error()}catch(b){var m=b.stack.trim().match(/\n( *(at )?)/);K=m&&m[1]||""}return`
`+K+d}var te=!1;function ue(d,m){if(!d||te)return"";te=!0;var b=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(m)if(m=function(){throw Error()},Object.defineProperty(m.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(m,[])}catch(Le){var I=Le}Reflect.construct(d,[],m)}else{try{m.call()}catch(Le){I=Le}d.call(m.prototype)}else{try{throw Error()}catch(Le){I=Le}d()}}catch(Le){if(Le&&I&&typeof Le.stack=="string"){for(var k=Le.stack.split(`
`),F=I.stack.split(`
`),j=k.length-1,le=F.length-1;1<=j&&0<=le&&k[j]!==F[le];)le--;for(;1<=j&&0<=le;j--,le--)if(k[j]!==F[le]){if(j!==1||le!==1)do if(j--,le--,0>le||k[j]!==F[le]){var me=`
`+k[j].replace(" at new "," at ");return d.displayName&&me.includes("<anonymous>")&&(me=me.replace("<anonymous>",d.displayName)),me}while(1<=j&&0<=le);break}}}finally{te=!1,Error.prepareStackTrace=b}return(d=d?d.displayName||d.name:"")?se(d):""}function fe(d){switch(d.tag){case 5:return se(d.type);case 16:return se("Lazy");case 13:return se("Suspense");case 19:return se("SuspenseList");case 0:case 2:case 15:return d=ue(d.type,!1),d;case 11:return d=ue(d.type.render,!1),d;case 1:return d=ue(d.type,!0),d;default:return""}}function _e(d){if(d==null)return null;if(typeof d=="function")return d.displayName||d.name||null;if(typeof d=="string")return d;switch(d){case P:return"Fragment";case M:return"Portal";case R:return"Profiler";case $:return"StrictMode";case Q:return"Suspense";case W:return"SuspenseList"}if(typeof d=="object")switch(d.$$typeof){case L:return(d.displayName||"Context")+".Consumer";case D:return(d._context.displayName||"Context")+".Provider";case G:var m=d.render;return d=d.displayName,d||(d=m.displayName||m.name||"",d=d!==""?"ForwardRef("+d+")":"ForwardRef"),d;case H:return m=d.displayName||null,m!==null?m:_e(d.type)||"Memo";case J:m=d._payload,d=d._init;try{return _e(d(m))}catch{}}return null}function Ie(d){var m=d.type;switch(d.tag){case 24:return"Cache";case 9:return(m.displayName||"Context")+".Consumer";case 10:return(m._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return d=m.render,d=d.displayName||d.name||"",m.displayName||(d!==""?"ForwardRef("+d+")":"ForwardRef");case 7:return"Fragment";case 5:return m;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return _e(m);case 8:return m===$?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof m=="function")return m.displayName||m.name||null;if(typeof m=="string")return m}return null}function Ve(d){switch(typeof d){case"boolean":case"number":case"string":case"undefined":return d;case"object":return d;default:return""}}function qe(d){var m=d.type;return(d=d.nodeName)&&d.toLowerCase()==="input"&&(m==="checkbox"||m==="radio")}function Ye(d){var m=qe(d)?"checked":"value",b=Object.getOwnPropertyDescriptor(d.constructor.prototype,m),I=""+d[m];if(!d.hasOwnProperty(m)&&typeof b<"u"&&typeof b.get=="function"&&typeof b.set=="function"){var k=b.get,F=b.set;return Object.defineProperty(d,m,{configurable:!0,get:function(){return k.call(this)},set:function(j){I=""+j,F.call(this,j)}}),Object.defineProperty(d,m,{enumerable:b.enumerable}),{getValue:function(){return I},setValue:function(j){I=""+j},stopTracking:function(){d._valueTracker=null,delete d[m]}}}}function et(d){d._valueTracker||(d._valueTracker=Ye(d))}function ae(d){if(!d)return!1;var m=d._valueTracker;if(!m)return!0;var b=m.getValue(),I="";return d&&(I=qe(d)?d.checked?"true":"false":d.value),d=I,d!==b?(m.setValue(d),!0):!1}function Be(d){if(d=d||(typeof document<"u"?document:void 0),typeof d>"u")return null;try{return d.activeElement||d.body}catch{return d.body}}function De(d,m){var b=m.checked;return B({},m,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:b??d._wrapperState.initialChecked})}function He(d,m){var b=m.defaultValue==null?"":m.defaultValue,I=m.checked!=null?m.checked:m.defaultChecked;b=Ve(m.value!=null?m.value:b),d._wrapperState={initialChecked:I,initialValue:b,controlled:m.type==="checkbox"||m.type==="radio"?m.checked!=null:m.value!=null}}function Re(d,m){m=m.checked,m!=null&&T(d,"checked",m,!1)}function at(d,m){Re(d,m);var b=Ve(m.value),I=m.type;if(b!=null)I==="number"?(b===0&&d.value===""||d.value!=b)&&(d.value=""+b):d.value!==""+b&&(d.value=""+b);else if(I==="submit"||I==="reset"){d.removeAttribute("value");return}m.hasOwnProperty("value")?ee(d,m.type,b):m.hasOwnProperty("defaultValue")&&ee(d,m.type,Ve(m.defaultValue)),m.checked==null&&m.defaultChecked!=null&&(d.defaultChecked=!!m.defaultChecked)}function Qe(d,m,b){if(m.hasOwnProperty("value")||m.hasOwnProperty("defaultValue")){var I=m.type;if(!(I!=="submit"&&I!=="reset"||m.value!==void 0&&m.value!==null))return;m=""+d._wrapperState.initialValue,b||m===d.value||(d.value=m),d.defaultValue=m}b=d.name,b!==""&&(d.name=""),d.defaultChecked=!!d._wrapperState.initialChecked,b!==""&&(d.name=b)}function ee(d,m,b){(m!=="number"||Be(d.ownerDocument)!==d)&&(b==null?d.defaultValue=""+d._wrapperState.initialValue:d.defaultValue!==""+b&&(d.defaultValue=""+b))}var X=Array.isArray;function Se(d,m,b,I){if(d=d.options,m){m={};for(var k=0;k<b.length;k++)m["$"+b[k]]=!0;for(b=0;b<d.length;b++)k=m.hasOwnProperty("$"+d[b].value),d[b].selected!==k&&(d[b].selected=k),k&&I&&(d[b].defaultSelected=!0)}else{for(b=""+Ve(b),m=null,k=0;k<d.length;k++){if(d[k].value===b){d[k].selected=!0,I&&(d[k].defaultSelected=!0);return}m!==null||d[k].disabled||(m=d[k])}m!==null&&(m.selected=!0)}}function We(d,m){if(m.dangerouslySetInnerHTML!=null)throw Error(t(91));return B({},m,{value:void 0,defaultValue:void 0,children:""+d._wrapperState.initialValue})}function Xe(d,m){var b=m.value;if(b==null){if(b=m.children,m=m.defaultValue,b!=null){if(m!=null)throw Error(t(92));if(X(b)){if(1<b.length)throw Error(t(93));b=b[0]}m=b}m==null&&(m=""),b=m}d._wrapperState={initialValue:Ve(b)}}function je(d,m){var b=Ve(m.value),I=Ve(m.defaultValue);b!=null&&(b=""+b,b!==d.value&&(d.value=b),m.defaultValue==null&&d.defaultValue!==b&&(d.defaultValue=b)),I!=null&&(d.defaultValue=""+I)}function xt(d){var m=d.textContent;m===d._wrapperState.initialValue&&m!==""&&m!==null&&(d.value=m)}function it(d){switch(d){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function dt(d,m){return d==null||d==="http://www.w3.org/1999/xhtml"?it(m):d==="http://www.w3.org/2000/svg"&&m==="foreignObject"?"http://www.w3.org/1999/xhtml":d}var It,Yt=(function(d){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(m,b,I,k){MSApp.execUnsafeLocalFunction(function(){return d(m,b,I,k)})}:d})(function(d,m){if(d.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in d)d.innerHTML=m;else{for(It=It||document.createElement("div"),It.innerHTML="<svg>"+m.valueOf().toString()+"</svg>",m=It.firstChild;d.firstChild;)d.removeChild(d.firstChild);for(;m.firstChild;)d.appendChild(m.firstChild)}});function Ke(d,m){if(m){var b=d.firstChild;if(b&&b===d.lastChild&&b.nodeType===3){b.nodeValue=m;return}}d.textContent=m}var hn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},un=["Webkit","ms","Moz","O"];Object.keys(hn).forEach(function(d){un.forEach(function(m){m=m+d.charAt(0).toUpperCase()+d.substring(1),hn[m]=hn[d]})});function qt(d,m,b){return m==null||typeof m=="boolean"||m===""?"":b||typeof m!="number"||m===0||hn.hasOwnProperty(d)&&hn[d]?(""+m).trim():m+"px"}function Bt(d,m){d=d.style;for(var b in m)if(m.hasOwnProperty(b)){var I=b.indexOf("--")===0,k=qt(b,m[b],I);b==="float"&&(b="cssFloat"),I?d.setProperty(b,k):d[b]=k}}var yt=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function jt(d,m){if(m){if(yt[d]&&(m.children!=null||m.dangerouslySetInnerHTML!=null))throw Error(t(137,d));if(m.dangerouslySetInnerHTML!=null){if(m.children!=null)throw Error(t(60));if(typeof m.dangerouslySetInnerHTML!="object"||!("__html"in m.dangerouslySetInnerHTML))throw Error(t(61))}if(m.style!=null&&typeof m.style!="object")throw Error(t(62))}}function Nn(d,m){if(d.indexOf("-")===-1)return typeof m.is=="string";switch(d){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var jn=null;function sn(d){return d=d.target||d.srcElement||window,d.correspondingUseElement&&(d=d.correspondingUseElement),d.nodeType===3?d.parentNode:d}var ut=null,ge=null,ct=null;function pt(d){if(d=Za(d)){if(typeof ut!="function")throw Error(t(280));var m=d.stateNode;m&&(m=Up(m),ut(d.stateNode,d.type,m))}}function Kt(d){ge?ct?ct.push(d):ct=[d]:ge=d}function Gt(){if(ge){var d=ge,m=ct;if(ct=ge=null,pt(d),m)for(d=0;d<m.length;d++)pt(m[d])}}function Bn(d,m){return d(m)}function kn(){}var xs=!1;function Ys(d,m,b){if(xs)return d(m,b);xs=!0;try{return Bn(d,m,b)}finally{xs=!1,(ge!==null||ct!==null)&&(kn(),Gt())}}function Fn(d,m){var b=d.stateNode;if(b===null)return null;var I=Up(b);if(I===null)return null;b=I[m];e:switch(m){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(I=!I.disabled)||(d=d.type,I=!(d==="button"||d==="input"||d==="select"||d==="textarea")),d=!I;break e;default:d=!1}if(d)return null;if(b&&typeof b!="function")throw Error(t(231,m,typeof b));return b}var Zs=!1;if(a)try{var Ur={};Object.defineProperty(Ur,"passive",{get:function(){Zs=!0}}),window.addEventListener("test",Ur,Ur),window.removeEventListener("test",Ur,Ur)}catch{Zs=!1}function cd(d,m,b,I,k,F,j,le,me){var Le=Array.prototype.slice.call(arguments,3);try{m.apply(b,Le)}catch(st){this.onError(st)}}var Ua=!1,Ba=null,Go=!1,Dl=null,ip={onError:function(d){Ua=!0,Ba=d}};function op(d,m,b,I,k,F,j,le,me){Ua=!1,Ba=null,cd.apply(ip,arguments)}function Kg(d,m,b,I,k,F,j,le,me){if(op.apply(this,arguments),Ua){if(Ua){var Le=Ba;Ua=!1,Ba=null}else throw Error(t(198));Go||(Go=!0,Dl=Le)}}function Va(d){var m=d,b=d;if(d.alternate)for(;m.return;)m=m.return;else{d=m;do m=d,(m.flags&4098)!==0&&(b=m.return),d=m.return;while(d)}return m.tag===3?b:null}function ap(d){if(d.tag===13){var m=d.memoizedState;if(m===null&&(d=d.alternate,d!==null&&(m=d.memoizedState)),m!==null)return m.dehydrated}return null}function ne(d){if(Va(d)!==d)throw Error(t(188))}function Ce(d){var m=d.alternate;if(!m){if(m=Va(d),m===null)throw Error(t(188));return m!==d?null:d}for(var b=d,I=m;;){var k=b.return;if(k===null)break;var F=k.alternate;if(F===null){if(I=k.return,I!==null){b=I;continue}break}if(k.child===F.child){for(F=k.child;F;){if(F===b)return ne(k),d;if(F===I)return ne(k),m;F=F.sibling}throw Error(t(188))}if(b.return!==I.return)b=k,I=F;else{for(var j=!1,le=k.child;le;){if(le===b){j=!0,b=k,I=F;break}if(le===I){j=!0,I=k,b=F;break}le=le.sibling}if(!j){for(le=F.child;le;){if(le===b){j=!0,b=F,I=k;break}if(le===I){j=!0,I=F,b=k;break}le=le.sibling}if(!j)throw Error(t(189))}}if(b.alternate!==I)throw Error(t(190))}if(b.tag!==3)throw Error(t(188));return b.stateNode.current===b?d:m}function Fe(d){return d=Ce(d),d!==null?$e(d):null}function $e(d){if(d.tag===5||d.tag===6)return d;for(d=d.child;d!==null;){var m=$e(d);if(m!==null)return m;d=d.sibling}return null}var Pe=e.unstable_scheduleCallback,bt=e.unstable_cancelCallback,Vt=e.unstable_shouldYield,Zt=e.unstable_requestPaint,Ct=e.unstable_now,rn=e.unstable_getCurrentPriorityLevel,en=e.unstable_ImmediatePriority,nn=e.unstable_UserBlockingPriority,ts=e.unstable_NormalPriority,Cr=e.unstable_LowPriority,ns=e.unstable_IdlePriority,Rs=null,zt=null;function At(d){if(zt&&typeof zt.onCommitFiberRoot=="function")try{zt.onCommitFiberRoot(Rs,d,void 0,(d.current.flags&128)===128)}catch{}}var Cs=Math.clz32?Math.clz32:ha,xn=Math.log,Es=Math.LN2;function ha(d){return d>>>=0,d===0?32:31-(xn(d)/Es|0)|0}var ti=64,Ds=4194304;function ls(d){switch(d&-d){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return d&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return d&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return d}}function Bi(d,m){var b=d.pendingLanes;if(b===0)return 0;var I=0,k=d.suspendedLanes,F=d.pingedLanes,j=b&268435455;if(j!==0){var le=j&~k;le!==0?I=ls(le):(F&=j,F!==0&&(I=ls(F)))}else j=b&~k,j!==0?I=ls(j):F!==0&&(I=ls(F));if(I===0)return 0;if(m!==0&&m!==I&&(m&k)===0&&(k=I&-I,F=m&-m,k>=F||k===16&&(F&4194240)!==0))return m;if((I&4)!==0&&(I|=b&16),m=d.entangledLanes,m!==0)for(d=d.entanglements,m&=I;0<m;)b=31-Cs(m),k=1<<b,I|=d[b],m&=~k;return I}function Cc(d,m){switch(d){case 1:case 2:case 4:return m+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Er(d,m){for(var b=d.suspendedLanes,I=d.pingedLanes,k=d.expirationTimes,F=d.pendingLanes;0<F;){var j=31-Cs(F),le=1<<j,me=k[j];me===-1?((le&b)===0||(le&I)!==0)&&(k[j]=Cc(le,m)):me<=m&&(d.expiredLanes|=le),F&=~le}}function Pl(d){return d=d.pendingLanes&-1073741825,d!==0?d:d&1073741824?1073741824:0}function wi(){var d=ti;return ti<<=1,(ti&4194240)===0&&(ti=64),d}function Ec(d){for(var m=[],b=0;31>b;b++)m.push(d);return m}function hd(d,m,b){d.pendingLanes|=m,m!==536870912&&(d.suspendedLanes=0,d.pingedLanes=0),d=d.eventTimes,m=31-Cs(m),d[m]=b}function uT(d,m){var b=d.pendingLanes&~m;d.pendingLanes=m,d.suspendedLanes=0,d.pingedLanes=0,d.expiredLanes&=m,d.mutableReadLanes&=m,d.entangledLanes&=m,m=d.entanglements;var I=d.eventTimes;for(d=d.expirationTimes;0<b;){var k=31-Cs(b),F=1<<k;m[k]=0,I[k]=-1,d[k]=-1,b&=~F}}function Ic(d,m){var b=d.entangledLanes|=m;for(d=d.entanglements;b;){var I=31-Cs(b),k=1<<I;k&m|d[I]&m&&(d[I]|=m),b&=~k}}var $n=0;function Nc(d){return d&=-d,1<d?4<d?(d&268435455)!==0?16:536870912:4:1}var dd,Yg,Dv,lp,up,vu=!1,cp=[],da=null,vn=null,Wa=null,wu=new Map,Ac=new Map,Ll=[],cT="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Js(d,m){switch(d){case"focusin":case"focusout":da=null;break;case"dragenter":case"dragleave":vn=null;break;case"mouseover":case"mouseout":Wa=null;break;case"pointerover":case"pointerout":wu.delete(m.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ac.delete(m.pointerId)}}function Su(d,m,b,I,k,F){return d===null||d.nativeEvent!==F?(d={blockedOn:m,domEventName:b,eventSystemFlags:I,nativeEvent:F,targetContainers:[k]},m!==null&&(m=Za(m),m!==null&&Yg(m)),d):(d.eventSystemFlags|=I,m=d.targetContainers,k!==null&&m.indexOf(k)===-1&&m.push(k),d)}function hT(d,m,b,I,k){switch(m){case"focusin":return da=Su(da,d,m,b,I,k),!0;case"dragenter":return vn=Su(vn,d,m,b,I,k),!0;case"mouseover":return Wa=Su(Wa,d,m,b,I,k),!0;case"pointerover":var F=k.pointerId;return wu.set(F,Su(wu.get(F)||null,d,m,b,I,k)),!0;case"gotpointercapture":return F=k.pointerId,Ac.set(F,Su(Ac.get(F)||null,d,m,b,I,k)),!0}return!1}function hp(d){var m=Vl(d.target);if(m!==null){var b=Va(m);if(b!==null){if(m=b.tag,m===13){if(m=ap(b),m!==null){d.blockedOn=m,up(d.priority,function(){Dv(b)});return}}else if(m===3&&b.stateNode.current.memoizedState.isDehydrated){d.blockedOn=b.tag===3?b.stateNode.containerInfo:null;return}}}d.blockedOn=null}function dp(d){if(d.blockedOn!==null)return!1;for(var m=d.targetContainers;0<m.length;){var b=uo(d.domEventName,d.eventSystemFlags,m[0],d.nativeEvent);if(b===null){b=d.nativeEvent;var I=new b.constructor(b.type,b);jn=I,b.target.dispatchEvent(I),jn=null}else return m=Za(b),m!==null&&Yg(m),d.blockedOn=b,!1;m.shift()}return!0}function fd(d,m,b){dp(d)&&b.delete(m)}function fa(){vu=!1,da!==null&&dp(da)&&(da=null),vn!==null&&dp(vn)&&(vn=null),Wa!==null&&dp(Wa)&&(Wa=null),wu.forEach(fd),Ac.forEach(fd)}function pd(d,m){d.blockedOn===m&&(d.blockedOn=null,vu||(vu=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,fa)))}function md(d){function m(k){return pd(k,d)}if(0<cp.length){pd(cp[0],d);for(var b=1;b<cp.length;b++){var I=cp[b];I.blockedOn===d&&(I.blockedOn=null)}}for(da!==null&&pd(da,d),vn!==null&&pd(vn,d),Wa!==null&&pd(Wa,d),wu.forEach(m),Ac.forEach(m),b=0;b<Ll.length;b++)I=Ll[b],I.blockedOn===d&&(I.blockedOn=null);for(;0<Ll.length&&(b=Ll[0],b.blockedOn===null);)hp(b),b.blockedOn===null&&Ll.shift()}var ni=C.ReactCurrentBatchConfig,lo=!0;function fp(d,m,b,I){var k=$n,F=ni.transition;ni.transition=null;try{$n=1,pp(d,m,b,I)}finally{$n=k,ni.transition=F}}function Zg(d,m,b,I){var k=$n,F=ni.transition;ni.transition=null;try{$n=4,pp(d,m,b,I)}finally{$n=k,ni.transition=F}}function pp(d,m,b,I){if(lo){var k=uo(d,m,b,I);if(k===null)Pp(d,m,I,mp,b),Js(d,I);else if(hT(k,d,m,b,I))I.stopPropagation();else if(Js(d,I),m&4&&-1<cT.indexOf(d)){for(;k!==null;){var F=Za(k);if(F!==null&&dd(F),F=uo(d,m,b,I),F===null&&Pp(d,m,I,mp,b),F===k)break;k=F}k!==null&&I.stopPropagation()}else Pp(d,m,I,null,b)}}var mp=null;function uo(d,m,b,I){if(mp=null,d=sn(I),d=Vl(d),d!==null)if(m=Va(d),m===null)d=null;else if(b=m.tag,b===13){if(d=ap(m),d!==null)return d;d=null}else if(b===3){if(m.stateNode.current.memoizedState.isDehydrated)return m.tag===3?m.stateNode.containerInfo:null;d=null}else m!==d&&(d=null);return mp=d,null}function Pv(d){switch(d){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(rn()){case en:return 1;case nn:return 4;case ts:case Cr:return 16;case ns:return 536870912;default:return 16}default:return 16}}var Ho=null,Jg=null,Si=null;function gd(){if(Si)return Si;var d,m=Jg,b=m.length,I,k="value"in Ho?Ho.value:Ho.textContent,F=k.length;for(d=0;d<b&&m[d]===k[d];d++);var j=b-d;for(I=1;I<=j&&m[b-I]===k[F-I];I++);return Si=k.slice(d,1<I?1-I:void 0)}function bu(d){var m=d.keyCode;return"charCode"in d?(d=d.charCode,d===0&&m===13&&(d=13)):d=m,d===10&&(d=13),32<=d||d===13?d:0}function Ga(){return!0}function gp(){return!1}function si(d){function m(b,I,k,F,j){this._reactName=b,this._targetInst=k,this.type=I,this.nativeEvent=F,this.target=j,this.currentTarget=null;for(var le in d)d.hasOwnProperty(le)&&(b=d[le],this[le]=b?b(F):F[le]);return this.isDefaultPrevented=(F.defaultPrevented!=null?F.defaultPrevented:F.returnValue===!1)?Ga:gp,this.isPropagationStopped=gp,this}return B(m.prototype,{preventDefault:function(){this.defaultPrevented=!0;var b=this.nativeEvent;b&&(b.preventDefault?b.preventDefault():typeof b.returnValue!="unknown"&&(b.returnValue=!1),this.isDefaultPrevented=Ga)},stopPropagation:function(){var b=this.nativeEvent;b&&(b.stopPropagation?b.stopPropagation():typeof b.cancelBubble!="unknown"&&(b.cancelBubble=!0),this.isPropagationStopped=Ga)},persist:function(){},isPersistent:Ga}),m}var _u={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(d){return d.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},yd=si(_u),Tu=B({},_u,{view:0,detail:0}),Mc=si(Tu),bi,co,ho,kc=B({},Tu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Fl,button:0,buttons:0,relatedTarget:function(d){return d.relatedTarget===void 0?d.fromElement===d.srcElement?d.toElement:d.fromElement:d.relatedTarget},movementX:function(d){return"movementX"in d?d.movementX:(d!==ho&&(ho&&d.type==="mousemove"?(bi=d.screenX-ho.screenX,co=d.screenY-ho.screenY):co=bi=0,ho=d),bi)},movementY:function(d){return"movementY"in d?d.movementY:co}}),Qg=si(kc),Ha=B({},kc,{dataTransfer:0}),Ol=si(Ha),yp=B({},Tu,{relatedTarget:0}),xp=si(yp),vp=B({},_u,{animationName:0,elapsedTime:0,pseudoElement:0}),Lv=si(vp),Ov=B({},_u,{clipboardData:function(d){return"clipboardData"in d?d.clipboardData:window.clipboardData}}),ey=si(Ov),wp=B({},_u,{data:0}),ty=si(wp),Fv={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},$v={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},ny={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Rc(d){var m=this.nativeEvent;return m.getModifierState?m.getModifierState(d):(d=ny[d])?!!m[d]:!1}function Fl(){return Rc}var Sp=B({},Tu,{key:function(d){if(d.key){var m=Fv[d.key]||d.key;if(m!=="Unidentified")return m}return d.type==="keypress"?(d=bu(d),d===13?"Enter":String.fromCharCode(d)):d.type==="keydown"||d.type==="keyup"?$v[d.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Fl,charCode:function(d){return d.type==="keypress"?bu(d):0},keyCode:function(d){return d.type==="keydown"||d.type==="keyup"?d.keyCode:0},which:function(d){return d.type==="keypress"?bu(d):d.type==="keydown"||d.type==="keyup"?d.keyCode:0}}),bp=si(Sp),fo=B({},kc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Vi=si(fo),Cu=B({},Tu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Fl}),ja=si(Cu),Xa=B({},_u,{propertyName:0,elapsedTime:0,pseudoElement:0}),Eu=si(Xa),zv=B({},kc,{deltaX:function(d){return"deltaX"in d?d.deltaX:"wheelDeltaX"in d?-d.wheelDeltaX:0},deltaY:function(d){return"deltaY"in d?d.deltaY:"wheelDeltaY"in d?-d.wheelDeltaY:"wheelDelta"in d?-d.wheelDelta:0},deltaZ:0,deltaMode:0}),sy=si(zv),ry=[9,13,27,32],ri=a&&"CompositionEvent"in window,Ir=null;a&&"documentMode"in document&&(Ir=document.documentMode);var fs=a&&"TextEvent"in window&&!Ir,Dc=a&&(!ri||Ir&&8<Ir&&11>=Ir),po=" ",iy=!1;function oy(d,m){switch(d){case"keyup":return ry.indexOf(m.keyCode)!==-1;case"keydown":return m.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function _p(d){return d=d.detail,typeof d=="object"&&"data"in d?d.data:null}var $l=!1;function Uv(d,m){switch(d){case"compositionend":return _p(m);case"keypress":return m.which!==32?null:(iy=!0,po);case"textInput":return d=m.data,d===po&&iy?null:d;default:return null}}function xd(d,m){if($l)return d==="compositionend"||!ri&&oy(d,m)?(d=gd(),Si=Jg=Ho=null,$l=!1,d):null;switch(d){case"paste":return null;case"keypress":if(!(m.ctrlKey||m.altKey||m.metaKey)||m.ctrlKey&&m.altKey){if(m.char&&1<m.char.length)return m.char;if(m.which)return String.fromCharCode(m.which)}return null;case"compositionend":return Dc&&m.locale!=="ko"?null:m.data;default:return null}}var Pc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Tp(d){var m=d&&d.nodeName&&d.nodeName.toLowerCase();return m==="input"?!!Pc[d.type]:m==="textarea"}function Lc(d,m,b,I){Kt(I),m=Lp(m,"onChange"),0<m.length&&(b=new yd("onChange","change",null,b,I),d.push({event:b,listeners:m}))}var zl=null,Oc=null;function Bv(d){Uc(d,0)}function qa(d){var m=Ps(d);if(ae(m))return d}function Vv(d,m){if(d==="change")return m}var Fc=!1;if(a){var _i;if(a){var Iu="oninput"in document;if(!Iu){var Nu=document.createElement("div");Nu.setAttribute("oninput","return;"),Iu=typeof Nu.oninput=="function"}_i=Iu}else _i=!1;Fc=_i&&(!document.documentMode||9<document.documentMode)}function jo(){zl&&(zl.detachEvent("onpropertychange",Cp),Oc=zl=null)}function Cp(d){if(d.propertyName==="value"&&qa(Oc)){var m=[];Lc(m,Oc,d,sn(d)),Ys(Bv,m)}}function $c(d,m,b){d==="focusin"?(jo(),zl=m,Oc=b,zl.attachEvent("onpropertychange",Cp)):d==="focusout"&&jo()}function Wv(d){if(d==="selectionchange"||d==="keyup"||d==="keydown")return qa(Oc)}function ay(d,m){if(d==="click")return qa(m)}function vs(d,m){if(d==="input"||d==="change")return qa(m)}function Ep(d,m){return d===m&&(d!==0||1/d===1/m)||d!==d&&m!==m}var Wi=typeof Object.is=="function"?Object.is:Ep;function Au(d,m){if(Wi(d,m))return!0;if(typeof d!="object"||d===null||typeof m!="object"||m===null)return!1;var b=Object.keys(d),I=Object.keys(m);if(b.length!==I.length)return!1;for(I=0;I<b.length;I++){var k=b[I];if(!l.call(m,k)||!Wi(d[k],m[k]))return!1}return!0}function vd(d){for(;d&&d.firstChild;)d=d.firstChild;return d}function Gi(d,m){var b=vd(d);d=0;for(var I;b;){if(b.nodeType===3){if(I=d+b.textContent.length,d<=m&&I>=m)return{node:b,offset:m-d};d=I}e:{for(;b;){if(b.nextSibling){b=b.nextSibling;break e}b=b.parentNode}b=void 0}b=vd(b)}}function Mu(d,m){return d&&m?d===m?!0:d&&d.nodeType===3?!1:m&&m.nodeType===3?Mu(d,m.parentNode):"contains"in d?d.contains(m):d.compareDocumentPosition?!!(d.compareDocumentPosition(m)&16):!1:!1}function ws(){for(var d=window,m=Be();m instanceof d.HTMLIFrameElement;){try{var b=typeof m.contentWindow.location.href=="string"}catch{b=!1}if(b)d=m.contentWindow;else break;m=Be(d.document)}return m}function or(d){var m=d&&d.nodeName&&d.nodeName.toLowerCase();return m&&(m==="input"&&(d.type==="text"||d.type==="search"||d.type==="tel"||d.type==="url"||d.type==="password")||m==="textarea"||d.contentEditable==="true")}function ar(d){var m=ws(),b=d.focusedElem,I=d.selectionRange;if(m!==b&&b&&b.ownerDocument&&Mu(b.ownerDocument.documentElement,b)){if(I!==null&&or(b)){if(m=I.start,d=I.end,d===void 0&&(d=m),"selectionStart"in b)b.selectionStart=m,b.selectionEnd=Math.min(d,b.value.length);else if(d=(m=b.ownerDocument||document)&&m.defaultView||window,d.getSelection){d=d.getSelection();var k=b.textContent.length,F=Math.min(I.start,k);I=I.end===void 0?F:Math.min(I.end,k),!d.extend&&F>I&&(k=I,I=F,F=k),k=Gi(b,F);var j=Gi(b,I);k&&j&&(d.rangeCount!==1||d.anchorNode!==k.node||d.anchorOffset!==k.offset||d.focusNode!==j.node||d.focusOffset!==j.offset)&&(m=m.createRange(),m.setStart(k.node,k.offset),d.removeAllRanges(),F>I?(d.addRange(m),d.extend(j.node,j.offset)):(m.setEnd(j.node,j.offset),d.addRange(m)))}}for(m=[],d=b;d=d.parentNode;)d.nodeType===1&&m.push({element:d,left:d.scrollLeft,top:d.scrollTop});for(typeof b.focus=="function"&&b.focus(),b=0;b<m.length;b++)d=m[b],d.element.scrollLeft=d.left,d.element.scrollTop=d.top}}var Ip=a&&"documentMode"in document&&11>=document.documentMode,pa=null,ku=null,wd=null,lr=!1;function Np(d,m,b){var I=b.window===b?b.document:b.nodeType===9?b:b.ownerDocument;lr||pa==null||pa!==Be(I)||(I=pa,"selectionStart"in I&&or(I)?I={start:I.selectionStart,end:I.selectionEnd}:(I=(I.ownerDocument&&I.ownerDocument.defaultView||window).getSelection(),I={anchorNode:I.anchorNode,anchorOffset:I.anchorOffset,focusNode:I.focusNode,focusOffset:I.focusOffset}),wd&&Au(wd,I)||(wd=I,I=Lp(ku,"onSelect"),0<I.length&&(m=new yd("onSelect","select",null,m,b),d.push({event:m,listeners:I}),m.target=pa)))}function zc(d,m){var b={};return b[d.toLowerCase()]=m.toLowerCase(),b["Webkit"+d]="webkit"+m,b["Moz"+d]="moz"+m,b}var Ul={animationend:zc("Animation","AnimationEnd"),animationiteration:zc("Animation","AnimationIteration"),animationstart:zc("Animation","AnimationStart"),transitionend:zc("Transition","TransitionEnd")},Xo={},qo={};a&&(qo=document.createElement("div").style,"AnimationEvent"in window||(delete Ul.animationend.animation,delete Ul.animationiteration.animation,delete Ul.animationstart.animation),"TransitionEvent"in window||delete Ul.transitionend.transition);function ma(d){if(Xo[d])return Xo[d];if(!Ul[d])return d;var m=Ul[d],b;for(b in m)if(m.hasOwnProperty(b)&&b in qo)return Xo[d]=m[b];return d}var Sd=ma("animationend"),bd=ma("animationiteration"),ly=ma("animationstart"),uy=ma("transitionend"),cy=new Map,hy="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ka(d,m){cy.set(d,m),i(m,[d])}for(var Ap=0;Ap<hy.length;Ap++){var _d=hy[Ap],Td=_d.toLowerCase(),Gv=_d[0].toUpperCase()+_d.slice(1);Ka(Td,"on"+Gv)}Ka(Sd,"onAnimationEnd"),Ka(bd,"onAnimationIteration"),Ka(ly,"onAnimationStart"),Ka("dblclick","onDoubleClick"),Ka("focusin","onFocus"),Ka("focusout","onBlur"),Ka(uy,"onTransitionEnd"),o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),i("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),i("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),i("onBeforeInput",["compositionend","keypress","textInput","paste"]),i("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Bl="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Mp=new Set("cancel close invalid load scroll toggle".split(" ").concat(Bl));function kp(d,m,b){var I=d.type||"unknown-event";d.currentTarget=b,Kg(I,m,void 0,d),d.currentTarget=null}function Uc(d,m){m=(m&4)!==0;for(var b=0;b<d.length;b++){var I=d[b],k=I.event;I=I.listeners;e:{var F=void 0;if(m)for(var j=I.length-1;0<=j;j--){var le=I[j],me=le.instance,Le=le.currentTarget;if(le=le.listener,me!==F&&k.isPropagationStopped())break e;kp(k,le,Le),F=me}else for(j=0;j<I.length;j++){if(le=I[j],me=le.instance,Le=le.currentTarget,le=le.listener,me!==F&&k.isPropagationStopped())break e;kp(k,le,Le),F=me}}}if(Go)throw d=Dl,Go=!1,Dl=null,d}function ss(d,m){var b=m[Pu];b===void 0&&(b=m[Pu]=new Set);var I=d+"__bubble";b.has(I)||(Dp(m,d,2,!1),b.add(I))}function Rp(d,m,b){var I=0;m&&(I|=4),Dp(b,d,I,m)}var Cd="_reactListening"+Math.random().toString(36).slice(2);function Bc(d){if(!d[Cd]){d[Cd]=!0,s.forEach(function(b){b!=="selectionchange"&&(Mp.has(b)||Rp(b,!1,d),Rp(b,!0,d))});var m=d.nodeType===9?d:d.ownerDocument;m===null||m[Cd]||(m[Cd]=!0,Rp("selectionchange",!1,m))}}function Dp(d,m,b,I){switch(Pv(m)){case 1:var k=fp;break;case 4:k=Zg;break;default:k=pp}b=k.bind(null,m,b,d),k=void 0,!Zs||m!=="touchstart"&&m!=="touchmove"&&m!=="wheel"||(k=!0),I?k!==void 0?d.addEventListener(m,b,{capture:!0,passive:k}):d.addEventListener(m,b,!0):k!==void 0?d.addEventListener(m,b,{passive:k}):d.addEventListener(m,b,!1)}function Pp(d,m,b,I,k){var F=I;if((m&1)===0&&(m&2)===0&&I!==null)e:for(;;){if(I===null)return;var j=I.tag;if(j===3||j===4){var le=I.stateNode.containerInfo;if(le===k||le.nodeType===8&&le.parentNode===k)break;if(j===4)for(j=I.return;j!==null;){var me=j.tag;if((me===3||me===4)&&(me=j.stateNode.containerInfo,me===k||me.nodeType===8&&me.parentNode===k))return;j=j.return}for(;le!==null;){if(j=Vl(le),j===null)return;if(me=j.tag,me===5||me===6){I=F=j;continue e}le=le.parentNode}}I=I.return}Ys(function(){var Le=F,st=sn(b),rt=[];e:{var nt=cy.get(d);if(nt!==void 0){var Et=yd,Pt=d;switch(d){case"keypress":if(bu(b)===0)break e;case"keydown":case"keyup":Et=bp;break;case"focusin":Pt="focus",Et=xp;break;case"focusout":Pt="blur",Et=xp;break;case"beforeblur":case"afterblur":Et=xp;break;case"click":if(b.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Et=Qg;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Et=Ol;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Et=ja;break;case Sd:case bd:case ly:Et=Lv;break;case uy:Et=Eu;break;case"scroll":Et=Mc;break;case"wheel":Et=sy;break;case"copy":case"cut":case"paste":Et=ey;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Et=Vi}var Ft=(m&4)!==0,tr=!Ft&&d==="scroll",Ne=Ft?nt!==null?nt+"Capture":null:nt;Ft=[];for(var xe=Le,Me;xe!==null;){Me=xe;var lt=Me.stateNode;if(Me.tag===5&&lt!==null&&(Me=lt,Ne!==null&&(lt=Fn(xe,Ne),lt!=null&&Ft.push(Vc(xe,lt,Me)))),tr)break;xe=xe.return}0<Ft.length&&(nt=new Et(nt,Pt,null,b,st),rt.push({event:nt,listeners:Ft}))}}if((m&7)===0){e:{if(nt=d==="mouseover"||d==="pointerover",Et=d==="mouseout"||d==="pointerout",nt&&b!==jn&&(Pt=b.relatedTarget||b.fromElement)&&(Vl(Pt)||Pt[Hi]))break e;if((Et||nt)&&(nt=st.window===st?st:(nt=st.ownerDocument)?nt.defaultView||nt.parentWindow:window,Et?(Pt=b.relatedTarget||b.toElement,Et=Le,Pt=Pt?Vl(Pt):null,Pt!==null&&(tr=Va(Pt),Pt!==tr||Pt.tag!==5&&Pt.tag!==6)&&(Pt=null)):(Et=null,Pt=Le),Et!==Pt)){if(Ft=Qg,lt="onMouseLeave",Ne="onMouseEnter",xe="mouse",(d==="pointerout"||d==="pointerover")&&(Ft=Vi,lt="onPointerLeave",Ne="onPointerEnter",xe="pointer"),tr=Et==null?nt:Ps(Et),Me=Pt==null?nt:Ps(Pt),nt=new Ft(lt,xe+"leave",Et,b,st),nt.target=tr,nt.relatedTarget=Me,lt=null,Vl(st)===Le&&(Ft=new Ft(Ne,xe+"enter",Pt,b,st),Ft.target=Me,Ft.relatedTarget=tr,lt=Ft),tr=lt,Et&&Pt)t:{for(Ft=Et,Ne=Pt,xe=0,Me=Ft;Me;Me=Ru(Me))xe++;for(Me=0,lt=Ne;lt;lt=Ru(lt))Me++;for(;0<xe-Me;)Ft=Ru(Ft),xe--;for(;0<Me-xe;)Ne=Ru(Ne),Me--;for(;xe--;){if(Ft===Ne||Ne!==null&&Ft===Ne.alternate)break t;Ft=Ru(Ft),Ne=Ru(Ne)}Ft=null}else Ft=null;Et!==null&&Hv(rt,nt,Et,Ft,!1),Pt!==null&&tr!==null&&Hv(rt,tr,Pt,Ft,!0)}}e:{if(nt=Le?Ps(Le):window,Et=nt.nodeName&&nt.nodeName.toLowerCase(),Et==="select"||Et==="input"&&nt.type==="file")var Ut=Vv;else if(Tp(nt))if(Fc)Ut=vs;else{Ut=Wv;var Jt=$c}else(Et=nt.nodeName)&&Et.toLowerCase()==="input"&&(nt.type==="checkbox"||nt.type==="radio")&&(Ut=ay);if(Ut&&(Ut=Ut(d,Le))){Lc(rt,Ut,b,st);break e}Jt&&Jt(d,nt,Le),d==="focusout"&&(Jt=nt._wrapperState)&&Jt.controlled&&nt.type==="number"&&ee(nt,"number",nt.value)}switch(Jt=Le?Ps(Le):window,d){case"focusin":(Tp(Jt)||Jt.contentEditable==="true")&&(pa=Jt,ku=Le,wd=null);break;case"focusout":wd=ku=pa=null;break;case"mousedown":lr=!0;break;case"contextmenu":case"mouseup":case"dragend":lr=!1,Np(rt,b,st);break;case"selectionchange":if(Ip)break;case"keydown":case"keyup":Np(rt,b,st)}var Qt;if(ri)e:{switch(d){case"compositionstart":var an="onCompositionStart";break e;case"compositionend":an="onCompositionEnd";break e;case"compositionupdate":an="onCompositionUpdate";break e}an=void 0}else $l?oy(d,b)&&(an="onCompositionEnd"):d==="keydown"&&b.keyCode===229&&(an="onCompositionStart");an&&(Dc&&b.locale!=="ko"&&($l||an!=="onCompositionStart"?an==="onCompositionEnd"&&$l&&(Qt=gd()):(Ho=st,Jg="value"in Ho?Ho.value:Ho.textContent,$l=!0)),Jt=Lp(Le,an),0<Jt.length&&(an=new ty(an,d,null,b,st),rt.push({event:an,listeners:Jt}),Qt?an.data=Qt:(Qt=_p(b),Qt!==null&&(an.data=Qt)))),(Qt=fs?Uv(d,b):xd(d,b))&&(Le=Lp(Le,"onBeforeInput"),0<Le.length&&(st=new ty("onBeforeInput","beforeinput",null,b,st),rt.push({event:st,listeners:Le}),st.data=Qt))}Uc(rt,m)})}function Vc(d,m,b){return{instance:d,listener:m,currentTarget:b}}function Lp(d,m){for(var b=m+"Capture",I=[];d!==null;){var k=d,F=k.stateNode;k.tag===5&&F!==null&&(k=F,F=Fn(d,b),F!=null&&I.unshift(Vc(d,F,k)),F=Fn(d,m),F!=null&&I.push(Vc(d,F,k))),d=d.return}return I}function Ru(d){if(d===null)return null;do d=d.return;while(d&&d.tag!==5);return d||null}function Hv(d,m,b,I,k){for(var F=m._reactName,j=[];b!==null&&b!==I;){var le=b,me=le.alternate,Le=le.stateNode;if(me!==null&&me===I)break;le.tag===5&&Le!==null&&(le=Le,k?(me=Fn(b,F),me!=null&&j.unshift(Vc(b,me,le))):k||(me=Fn(b,F),me!=null&&j.push(Vc(b,me,le)))),b=b.return}j.length!==0&&d.push({event:m,listeners:j})}var dT=/\r\n?/g,jv=/\u0000|\uFFFD/g;function dy(d){return(typeof d=="string"?d:""+d).replace(dT,`
`).replace(jv,"")}function Ed(d,m,b){if(m=dy(m),dy(d)!==m&&b)throw Error(t(425))}function Id(){}var Wc=null,fy=null;function py(d,m){return d==="textarea"||d==="noscript"||typeof m.children=="string"||typeof m.children=="number"||typeof m.dangerouslySetInnerHTML=="object"&&m.dangerouslySetInnerHTML!==null&&m.dangerouslySetInnerHTML.__html!=null}var my=typeof setTimeout=="function"?setTimeout:void 0,gy=typeof clearTimeout=="function"?clearTimeout:void 0,Op=typeof Promise=="function"?Promise:void 0,fT=typeof queueMicrotask=="function"?queueMicrotask:typeof Op<"u"?function(d){return Op.resolve(null).then(d).catch(Xv)}:my;function Xv(d){setTimeout(function(){throw d})}function Fp(d,m){var b=m,I=0;do{var k=b.nextSibling;if(d.removeChild(b),k&&k.nodeType===8)if(b=k.data,b==="/$"){if(I===0){d.removeChild(k),md(m);return}I--}else b!=="$"&&b!=="$?"&&b!=="$!"||I++;b=k}while(b);md(m)}function Ya(d){for(;d!=null;d=d.nextSibling){var m=d.nodeType;if(m===1||m===3)break;if(m===8){if(m=d.data,m==="$"||m==="$!"||m==="$?")break;if(m==="/$")return null}}return d}function yy(d){d=d.previousSibling;for(var m=0;d;){if(d.nodeType===8){var b=d.data;if(b==="$"||b==="$!"||b==="$?"){if(m===0)return d;m--}else b==="/$"&&m++}d=d.previousSibling}return null}var Du=Math.random().toString(36).slice(2),Qs="__reactFiber$"+Du,Gc="__reactProps$"+Du,Hi="__reactContainer$"+Du,Pu="__reactEvents$"+Du,$p="__reactListeners$"+Du,zp="__reactHandles$"+Du;function Vl(d){var m=d[Qs];if(m)return m;for(var b=d.parentNode;b;){if(m=b[Hi]||b[Qs]){if(b=m.alternate,m.child!==null||b!==null&&b.child!==null)for(d=yy(d);d!==null;){if(b=d[Qs])return b;d=yy(d)}return m}d=b,b=d.parentNode}return null}function Za(d){return d=d[Qs]||d[Hi],!d||d.tag!==5&&d.tag!==6&&d.tag!==13&&d.tag!==3?null:d}function Ps(d){if(d.tag===5||d.tag===6)return d.stateNode;throw Error(t(33))}function Up(d){return d[Gc]||null}var xy=[],ur=-1;function Is(d){return{current:d}}function rs(d){0>ur||(d.current=xy[ur],xy[ur]=null,ur--)}function Kn(d,m){ur++,xy[ur]=d.current,d.current=m}var Ja={},Nr=Is(Ja),ii=Is(!1),Qa=Ja;function Lu(d,m){var b=d.type.contextTypes;if(!b)return Ja;var I=d.stateNode;if(I&&I.__reactInternalMemoizedUnmaskedChildContext===m)return I.__reactInternalMemoizedMaskedChildContext;var k={},F;for(F in b)k[F]=m[F];return I&&(d=d.stateNode,d.__reactInternalMemoizedUnmaskedChildContext=m,d.__reactInternalMemoizedMaskedChildContext=k),k}function Br(d){return d=d.childContextTypes,d!=null}function Nd(){rs(ii),rs(Nr)}function vy(d,m,b){if(Nr.current!==Ja)throw Error(t(168));Kn(Nr,m),Kn(ii,b)}function Ad(d,m,b){var I=d.stateNode;if(m=m.childContextTypes,typeof I.getChildContext!="function")return b;I=I.getChildContext();for(var k in I)if(!(k in m))throw Error(t(108,Ie(d)||"Unknown",k));return B({},b,I)}function Ou(d){return d=(d=d.stateNode)&&d.__reactInternalMemoizedMergedChildContext||Ja,Qa=Nr.current,Kn(Nr,d),Kn(ii,ii.current),!0}function wy(d,m,b){var I=d.stateNode;if(!I)throw Error(t(169));b?(d=Ad(d,m,Qa),I.__reactInternalMemoizedMergedChildContext=d,rs(ii),rs(Nr),Kn(Nr,d)):rs(ii),Kn(ii,b)}var Ko=null,Md=!1,Bp=!1;function kd(d){Ko===null?Ko=[d]:Ko.push(d)}function qv(d){Md=!0,kd(d)}function ga(){if(!Bp&&Ko!==null){Bp=!0;var d=0,m=$n;try{var b=Ko;for($n=1;d<b.length;d++){var I=b[d];do I=I(!0);while(I!==null)}Ko=null,Md=!1}catch(k){throw Ko!==null&&(Ko=Ko.slice(d+1)),Pe(en,ga),k}finally{$n=m,Bp=!1}}return null}var Fu=[],Ti=0,Vp=null,Wp=0,oi=[],cr=0,$u=null,ht=1,mo="";function el(d,m){Fu[Ti++]=Wp,Fu[Ti++]=Vp,Vp=d,Wp=m}function Sy(d,m,b){oi[cr++]=ht,oi[cr++]=mo,oi[cr++]=$u,$u=d;var I=ht;d=mo;var k=32-Cs(I)-1;I&=~(1<<k),b+=1;var F=32-Cs(m)+k;if(30<F){var j=k-k%5;F=(I&(1<<j)-1).toString(32),I>>=j,k-=j,ht=1<<32-Cs(m)+k|b<<k|I,mo=F+d}else ht=1<<F|b<<k|I,mo=d}function by(d){d.return!==null&&(el(d,1),Sy(d,1,0))}function tl(d){for(;d===Vp;)Vp=Fu[--Ti],Fu[Ti]=null,Wp=Fu[--Ti],Fu[Ti]=null;for(;d===$u;)$u=oi[--cr],oi[cr]=null,mo=oi[--cr],oi[cr]=null,ht=oi[--cr],oi[cr]=null}var Ar=null,ai=null,us=!1,go=null;function _y(d,m){var b=ba(5,null,null,0);b.elementType="DELETED",b.stateNode=m,b.return=d,m=d.deletions,m===null?(d.deletions=[b],d.flags|=16):m.push(b)}function Ty(d,m){switch(d.tag){case 5:var b=d.type;return m=m.nodeType!==1||b.toLowerCase()!==m.nodeName.toLowerCase()?null:m,m!==null?(d.stateNode=m,Ar=d,ai=Ya(m.firstChild),!0):!1;case 6:return m=d.pendingProps===""||m.nodeType!==3?null:m,m!==null?(d.stateNode=m,Ar=d,ai=null,!0):!1;case 13:return m=m.nodeType!==8?null:m,m!==null?(b=$u!==null?{id:ht,overflow:mo}:null,d.memoizedState={dehydrated:m,treeContext:b,retryLane:1073741824},b=ba(18,null,null,0),b.stateNode=m,b.return=d,d.child=b,Ar=d,ai=null,!0):!1;default:return!1}}function Gp(d){return(d.mode&1)!==0&&(d.flags&128)===0}function Hp(d){if(us){var m=ai;if(m){var b=m;if(!Ty(d,m)){if(Gp(d))throw Error(t(418));m=Ya(b.nextSibling);var I=Ar;m&&Ty(d,m)?_y(I,b):(d.flags=d.flags&-4097|2,us=!1,Ar=d)}}else{if(Gp(d))throw Error(t(418));d.flags=d.flags&-4097|2,us=!1,Ar=d}}}function jp(d){for(d=d.return;d!==null&&d.tag!==5&&d.tag!==3&&d.tag!==13;)d=d.return;Ar=d}function Hc(d){if(d!==Ar)return!1;if(!us)return jp(d),us=!0,!1;var m;if((m=d.tag!==3)&&!(m=d.tag!==5)&&(m=d.type,m=m!=="head"&&m!=="body"&&!py(d.type,d.memoizedProps)),m&&(m=ai)){if(Gp(d))throw Cy(),Error(t(418));for(;m;)_y(d,m),m=Ya(m.nextSibling)}if(jp(d),d.tag===13){if(d=d.memoizedState,d=d!==null?d.dehydrated:null,!d)throw Error(t(317));e:{for(d=d.nextSibling,m=0;d;){if(d.nodeType===8){var b=d.data;if(b==="/$"){if(m===0){ai=Ya(d.nextSibling);break e}m--}else b!=="$"&&b!=="$!"&&b!=="$?"||m++}d=d.nextSibling}ai=null}}else ai=Ar?Ya(d.stateNode.nextSibling):null;return!0}function Cy(){for(var d=ai;d;)d=Ya(d.nextSibling)}function Wl(){ai=Ar=null,us=!1}function jc(d){go===null?go=[d]:go.push(d)}var pT=C.ReactCurrentBatchConfig;function Yo(d,m){if(d&&d.defaultProps){m=B({},m),d=d.defaultProps;for(var b in d)m[b]===void 0&&(m[b]=d[b]);return m}return m}var Rd=Is(null),Dd=null,zu=null,Xp=null;function Xc(){Xp=zu=Dd=null}function qc(d){var m=Rd.current;rs(Rd),d._currentValue=m}function Kc(d,m,b){for(;d!==null;){var I=d.alternate;if((d.childLanes&m)!==m?(d.childLanes|=m,I!==null&&(I.childLanes|=m)):I!==null&&(I.childLanes&m)!==m&&(I.childLanes|=m),d===b)break;d=d.return}}function nl(d,m){Dd=d,Xp=zu=null,d=d.dependencies,d!==null&&d.firstContext!==null&&((d.lanes&m)!==0&&(_t=!0),d.firstContext=null)}function li(d){var m=d._currentValue;if(Xp!==d)if(d={context:d,memoizedValue:m,next:null},zu===null){if(Dd===null)throw Error(t(308));zu=d,Dd.dependencies={lanes:0,firstContext:d}}else zu=zu.next=d;return m}var Zo=null;function Pd(d){Zo===null?Zo=[d]:Zo.push(d)}function qp(d,m,b,I){var k=m.interleaved;return k===null?(b.next=b,Pd(m)):(b.next=k.next,k.next=b),m.interleaved=b,Jo(d,I)}function Jo(d,m){d.lanes|=m;var b=d.alternate;for(b!==null&&(b.lanes|=m),b=d,d=d.return;d!==null;)d.childLanes|=m,b=d.alternate,b!==null&&(b.childLanes|=m),b=d,d=d.return;return b.tag===3?b.stateNode:null}var sl=!1;function Ld(d){d.updateQueue={baseState:d.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Kv(d,m){d=d.updateQueue,m.updateQueue===d&&(m.updateQueue={baseState:d.baseState,firstBaseUpdate:d.firstBaseUpdate,lastBaseUpdate:d.lastBaseUpdate,shared:d.shared,effects:d.effects})}function yo(d,m){return{eventTime:d,lane:m,tag:0,payload:null,callback:null,next:null}}function ya(d,m,b){var I=d.updateQueue;if(I===null)return null;if(I=I.shared,(Vn&2)!==0){var k=I.pending;return k===null?m.next=m:(m.next=k.next,k.next=m),I.pending=m,Jo(d,b)}return k=I.interleaved,k===null?(m.next=m,Pd(I)):(m.next=k.next,k.next=m),I.interleaved=m,Jo(d,b)}function ps(d,m,b){if(m=m.updateQueue,m!==null&&(m=m.shared,(b&4194240)!==0)){var I=m.lanes;I&=d.pendingLanes,b|=I,m.lanes=b,Ic(d,b)}}function pn(d,m){var b=d.updateQueue,I=d.alternate;if(I!==null&&(I=I.updateQueue,b===I)){var k=null,F=null;if(b=b.firstBaseUpdate,b!==null){do{var j={eventTime:b.eventTime,lane:b.lane,tag:b.tag,payload:b.payload,callback:b.callback,next:null};F===null?k=F=j:F=F.next=j,b=b.next}while(b!==null);F===null?k=F=m:F=F.next=m}else k=F=m;b={baseState:I.baseState,firstBaseUpdate:k,lastBaseUpdate:F,shared:I.shared,effects:I.effects},d.updateQueue=b;return}d=b.lastBaseUpdate,d===null?b.firstBaseUpdate=m:d.next=m,b.lastBaseUpdate=m}function Ss(d,m,b,I){var k=d.updateQueue;sl=!1;var F=k.firstBaseUpdate,j=k.lastBaseUpdate,le=k.shared.pending;if(le!==null){k.shared.pending=null;var me=le,Le=me.next;me.next=null,j===null?F=Le:j.next=Le,j=me;var st=d.alternate;st!==null&&(st=st.updateQueue,le=st.lastBaseUpdate,le!==j&&(le===null?st.firstBaseUpdate=Le:le.next=Le,st.lastBaseUpdate=me))}if(F!==null){var rt=k.baseState;j=0,st=Le=me=null,le=F;do{var nt=le.lane,Et=le.eventTime;if((I&nt)===nt){st!==null&&(st=st.next={eventTime:Et,lane:0,tag:le.tag,payload:le.payload,callback:le.callback,next:null});e:{var Pt=d,Ft=le;switch(nt=m,Et=b,Ft.tag){case 1:if(Pt=Ft.payload,typeof Pt=="function"){rt=Pt.call(Et,rt,nt);break e}rt=Pt;break e;case 3:Pt.flags=Pt.flags&-65537|128;case 0:if(Pt=Ft.payload,nt=typeof Pt=="function"?Pt.call(Et,rt,nt):Pt,nt==null)break e;rt=B({},rt,nt);break e;case 2:sl=!0}}le.callback!==null&&le.lane!==0&&(d.flags|=64,nt=k.effects,nt===null?k.effects=[le]:nt.push(le))}else Et={eventTime:Et,lane:nt,tag:le.tag,payload:le.payload,callback:le.callback,next:null},st===null?(Le=st=Et,me=rt):st=st.next=Et,j|=nt;if(le=le.next,le===null){if(le=k.shared.pending,le===null)break;nt=le,le=nt.next,nt.next=null,k.lastBaseUpdate=nt,k.shared.pending=null}}while(!0);if(st===null&&(me=rt),k.baseState=me,k.firstBaseUpdate=Le,k.lastBaseUpdate=st,m=k.shared.interleaved,m!==null){k=m;do j|=k.lane,k=k.next;while(k!==m)}else F===null&&(k.shared.lanes=0);Vd|=j,d.lanes=j,d.memoizedState=rt}}function Ls(d,m,b){if(d=m.effects,m.effects=null,d!==null)for(m=0;m<d.length;m++){var I=d[m],k=I.callback;if(k!==null){if(I.callback=null,I=b,typeof k!="function")throw Error(t(191,k));k.call(I)}}}var hr=new n.Component().refs;function ui(d,m,b,I){m=d.memoizedState,b=b(I,m),b=b==null?m:B({},m,b),d.memoizedState=b,d.lanes===0&&(d.updateQueue.baseState=b)}var rl={isMounted:function(d){return(d=d._reactInternals)?Va(d)===d:!1},enqueueSetState:function(d,m,b){d=d._reactInternals;var I=Ki(),k=oh(d),F=yo(I,k);F.payload=m,b!=null&&(F.callback=b),m=ya(d,F,k),m!==null&&(ll(m,d,k,I),ps(m,d,k))},enqueueReplaceState:function(d,m,b){d=d._reactInternals;var I=Ki(),k=oh(d),F=yo(I,k);F.tag=1,F.payload=m,b!=null&&(F.callback=b),m=ya(d,F,k),m!==null&&(ll(m,d,k,I),ps(m,d,k))},enqueueForceUpdate:function(d,m){d=d._reactInternals;var b=Ki(),I=oh(d),k=yo(b,I);k.tag=2,m!=null&&(k.callback=m),m=ya(d,k,I),m!==null&&(ll(m,d,I,b),ps(m,d,I))}};function Us(d,m,b,I,k,F,j){return d=d.stateNode,typeof d.shouldComponentUpdate=="function"?d.shouldComponentUpdate(I,F,j):m.prototype&&m.prototype.isPureReactComponent?!Au(b,I)||!Au(k,F):!0}function Yc(d,m,b){var I=!1,k=Ja,F=m.contextType;return typeof F=="object"&&F!==null?F=li(F):(k=Br(m)?Qa:Nr.current,I=m.contextTypes,F=(I=I!=null)?Lu(d,k):Ja),m=new m(b,F),d.memoizedState=m.state!==null&&m.state!==void 0?m.state:null,m.updater=rl,d.stateNode=m,m._reactInternals=d,I&&(d=d.stateNode,d.__reactInternalMemoizedUnmaskedChildContext=k,d.__reactInternalMemoizedMaskedChildContext=F),m}function Uu(d,m,b,I){d=m.state,typeof m.componentWillReceiveProps=="function"&&m.componentWillReceiveProps(b,I),typeof m.UNSAFE_componentWillReceiveProps=="function"&&m.UNSAFE_componentWillReceiveProps(b,I),m.state!==d&&rl.enqueueReplaceState(m,m.state,null)}function Zc(d,m,b,I){var k=d.stateNode;k.props=b,k.state=d.memoizedState,k.refs=hr,Ld(d);var F=m.contextType;typeof F=="object"&&F!==null?k.context=li(F):(F=Br(m)?Qa:Nr.current,k.context=Lu(d,F)),k.state=d.memoizedState,F=m.getDerivedStateFromProps,typeof F=="function"&&(ui(d,m,F,b),k.state=d.memoizedState),typeof m.getDerivedStateFromProps=="function"||typeof k.getSnapshotBeforeUpdate=="function"||typeof k.UNSAFE_componentWillMount!="function"&&typeof k.componentWillMount!="function"||(m=k.state,typeof k.componentWillMount=="function"&&k.componentWillMount(),typeof k.UNSAFE_componentWillMount=="function"&&k.UNSAFE_componentWillMount(),m!==k.state&&rl.enqueueReplaceState(k,k.state,null),Ss(d,b,k,I),k.state=d.memoizedState),typeof k.componentDidMount=="function"&&(d.flags|=4194308)}function Bu(d,m,b){if(d=b.ref,d!==null&&typeof d!="function"&&typeof d!="object"){if(b._owner){if(b=b._owner,b){if(b.tag!==1)throw Error(t(309));var I=b.stateNode}if(!I)throw Error(t(147,d));var k=I,F=""+d;return m!==null&&m.ref!==null&&typeof m.ref=="function"&&m.ref._stringRef===F?m.ref:(m=function(j){var le=k.refs;le===hr&&(le=k.refs={}),j===null?delete le[F]:le[F]=j},m._stringRef=F,m)}if(typeof d!="string")throw Error(t(284));if(!b._owner)throw Error(t(290,d))}return d}function Gl(d,m){throw d=Object.prototype.toString.call(m),Error(t(31,d==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":d))}function ci(d){var m=d._init;return m(d._payload)}function Kp(d){function m(Ne,xe){if(d){var Me=Ne.deletions;Me===null?(Ne.deletions=[xe],Ne.flags|=16):Me.push(xe)}}function b(Ne,xe){if(!d)return null;for(;xe!==null;)m(Ne,xe),xe=xe.sibling;return null}function I(Ne,xe){for(Ne=new Map;xe!==null;)xe.key!==null?Ne.set(xe.key,xe):Ne.set(xe.index,xe),xe=xe.sibling;return Ne}function k(Ne,xe){return Ne=lh(Ne,xe),Ne.index=0,Ne.sibling=null,Ne}function F(Ne,xe,Me){return Ne.index=Me,d?(Me=Ne.alternate,Me!==null?(Me=Me.index,Me<xe?(Ne.flags|=2,xe):Me):(Ne.flags|=2,xe)):(Ne.flags|=1048576,xe)}function j(Ne){return d&&Ne.alternate===null&&(Ne.flags|=2),Ne}function le(Ne,xe,Me,lt){return xe===null||xe.tag!==6?(xe=DT(Me,Ne.mode,lt),xe.return=Ne,xe):(xe=k(xe,Me),xe.return=Ne,xe)}function me(Ne,xe,Me,lt){var Ut=Me.type;return Ut===P?st(Ne,xe,Me.props.children,lt,Me.key):xe!==null&&(xe.elementType===Ut||typeof Ut=="object"&&Ut!==null&&Ut.$$typeof===J&&ci(Ut)===xe.type)?(lt=k(xe,Me.props),lt.ref=Bu(Ne,xe,Me),lt.return=Ne,lt):(lt=v1(Me.type,Me.key,Me.props,null,Ne.mode,lt),lt.ref=Bu(Ne,xe,Me),lt.return=Ne,lt)}function Le(Ne,xe,Me,lt){return xe===null||xe.tag!==4||xe.stateNode.containerInfo!==Me.containerInfo||xe.stateNode.implementation!==Me.implementation?(xe=PT(Me,Ne.mode,lt),xe.return=Ne,xe):(xe=k(xe,Me.children||[]),xe.return=Ne,xe)}function st(Ne,xe,Me,lt,Ut){return xe===null||xe.tag!==7?(xe=jd(Me,Ne.mode,lt,Ut),xe.return=Ne,xe):(xe=k(xe,Me),xe.return=Ne,xe)}function rt(Ne,xe,Me){if(typeof xe=="string"&&xe!==""||typeof xe=="number")return xe=DT(""+xe,Ne.mode,Me),xe.return=Ne,xe;if(typeof xe=="object"&&xe!==null){switch(xe.$$typeof){case N:return Me=v1(xe.type,xe.key,xe.props,null,Ne.mode,Me),Me.ref=Bu(Ne,null,xe),Me.return=Ne,Me;case M:return xe=PT(xe,Ne.mode,Me),xe.return=Ne,xe;case J:var lt=xe._init;return rt(Ne,lt(xe._payload),Me)}if(X(xe)||Y(xe))return xe=jd(xe,Ne.mode,Me,null),xe.return=Ne,xe;Gl(Ne,xe)}return null}function nt(Ne,xe,Me,lt){var Ut=xe!==null?xe.key:null;if(typeof Me=="string"&&Me!==""||typeof Me=="number")return Ut!==null?null:le(Ne,xe,""+Me,lt);if(typeof Me=="object"&&Me!==null){switch(Me.$$typeof){case N:return Me.key===Ut?me(Ne,xe,Me,lt):null;case M:return Me.key===Ut?Le(Ne,xe,Me,lt):null;case J:return Ut=Me._init,nt(Ne,xe,Ut(Me._payload),lt)}if(X(Me)||Y(Me))return Ut!==null?null:st(Ne,xe,Me,lt,null);Gl(Ne,Me)}return null}function Et(Ne,xe,Me,lt,Ut){if(typeof lt=="string"&&lt!==""||typeof lt=="number")return Ne=Ne.get(Me)||null,le(xe,Ne,""+lt,Ut);if(typeof lt=="object"&&lt!==null){switch(lt.$$typeof){case N:return Ne=Ne.get(lt.key===null?Me:lt.key)||null,me(xe,Ne,lt,Ut);case M:return Ne=Ne.get(lt.key===null?Me:lt.key)||null,Le(xe,Ne,lt,Ut);case J:var Jt=lt._init;return Et(Ne,xe,Me,Jt(lt._payload),Ut)}if(X(lt)||Y(lt))return Ne=Ne.get(Me)||null,st(xe,Ne,lt,Ut,null);Gl(xe,lt)}return null}function Pt(Ne,xe,Me,lt){for(var Ut=null,Jt=null,Qt=xe,an=xe=0,Gr=null;Qt!==null&&an<Me.length;an++){Qt.index>an?(Gr=Qt,Qt=null):Gr=Qt.sibling;var Hn=nt(Ne,Qt,Me[an],lt);if(Hn===null){Qt===null&&(Qt=Gr);break}d&&Qt&&Hn.alternate===null&&m(Ne,Qt),xe=F(Hn,xe,an),Jt===null?Ut=Hn:Jt.sibling=Hn,Jt=Hn,Qt=Gr}if(an===Me.length)return b(Ne,Qt),us&&el(Ne,an),Ut;if(Qt===null){for(;an<Me.length;an++)Qt=rt(Ne,Me[an],lt),Qt!==null&&(xe=F(Qt,xe,an),Jt===null?Ut=Qt:Jt.sibling=Qt,Jt=Qt);return us&&el(Ne,an),Ut}for(Qt=I(Ne,Qt);an<Me.length;an++)Gr=Et(Qt,Ne,an,Me[an],lt),Gr!==null&&(d&&Gr.alternate!==null&&Qt.delete(Gr.key===null?an:Gr.key),xe=F(Gr,xe,an),Jt===null?Ut=Gr:Jt.sibling=Gr,Jt=Gr);return d&&Qt.forEach(function(uh){return m(Ne,uh)}),us&&el(Ne,an),Ut}function Ft(Ne,xe,Me,lt){var Ut=Y(Me);if(typeof Ut!="function")throw Error(t(150));if(Me=Ut.call(Me),Me==null)throw Error(t(151));for(var Jt=Ut=null,Qt=xe,an=xe=0,Gr=null,Hn=Me.next();Qt!==null&&!Hn.done;an++,Hn=Me.next()){Qt.index>an?(Gr=Qt,Qt=null):Gr=Qt.sibling;var uh=nt(Ne,Qt,Hn.value,lt);if(uh===null){Qt===null&&(Qt=Gr);break}d&&Qt&&uh.alternate===null&&m(Ne,Qt),xe=F(uh,xe,an),Jt===null?Ut=uh:Jt.sibling=uh,Jt=uh,Qt=Gr}if(Hn.done)return b(Ne,Qt),us&&el(Ne,an),Ut;if(Qt===null){for(;!Hn.done;an++,Hn=Me.next())Hn=rt(Ne,Hn.value,lt),Hn!==null&&(xe=F(Hn,xe,an),Jt===null?Ut=Hn:Jt.sibling=Hn,Jt=Hn);return us&&el(Ne,an),Ut}for(Qt=I(Ne,Qt);!Hn.done;an++,Hn=Me.next())Hn=Et(Qt,Ne,an,Hn.value,lt),Hn!==null&&(d&&Hn.alternate!==null&&Qt.delete(Hn.key===null?an:Hn.key),xe=F(Hn,xe,an),Jt===null?Ut=Hn:Jt.sibling=Hn,Jt=Hn);return d&&Qt.forEach(function(qW){return m(Ne,qW)}),us&&el(Ne,an),Ut}function tr(Ne,xe,Me,lt){if(typeof Me=="object"&&Me!==null&&Me.type===P&&Me.key===null&&(Me=Me.props.children),typeof Me=="object"&&Me!==null){switch(Me.$$typeof){case N:e:{for(var Ut=Me.key,Jt=xe;Jt!==null;){if(Jt.key===Ut){if(Ut=Me.type,Ut===P){if(Jt.tag===7){b(Ne,Jt.sibling),xe=k(Jt,Me.props.children),xe.return=Ne,Ne=xe;break e}}else if(Jt.elementType===Ut||typeof Ut=="object"&&Ut!==null&&Ut.$$typeof===J&&ci(Ut)===Jt.type){b(Ne,Jt.sibling),xe=k(Jt,Me.props),xe.ref=Bu(Ne,Jt,Me),xe.return=Ne,Ne=xe;break e}b(Ne,Jt);break}else m(Ne,Jt);Jt=Jt.sibling}Me.type===P?(xe=jd(Me.props.children,Ne.mode,lt,Me.key),xe.return=Ne,Ne=xe):(lt=v1(Me.type,Me.key,Me.props,null,Ne.mode,lt),lt.ref=Bu(Ne,xe,Me),lt.return=Ne,Ne=lt)}return j(Ne);case M:e:{for(Jt=Me.key;xe!==null;){if(xe.key===Jt)if(xe.tag===4&&xe.stateNode.containerInfo===Me.containerInfo&&xe.stateNode.implementation===Me.implementation){b(Ne,xe.sibling),xe=k(xe,Me.children||[]),xe.return=Ne,Ne=xe;break e}else{b(Ne,xe);break}else m(Ne,xe);xe=xe.sibling}xe=PT(Me,Ne.mode,lt),xe.return=Ne,Ne=xe}return j(Ne);case J:return Jt=Me._init,tr(Ne,xe,Jt(Me._payload),lt)}if(X(Me))return Pt(Ne,xe,Me,lt);if(Y(Me))return Ft(Ne,xe,Me,lt);Gl(Ne,Me)}return typeof Me=="string"&&Me!==""||typeof Me=="number"?(Me=""+Me,xe!==null&&xe.tag===6?(b(Ne,xe.sibling),xe=k(xe,Me),xe.return=Ne,Ne=xe):(b(Ne,xe),xe=DT(Me,Ne.mode,lt),xe.return=Ne,Ne=xe),j(Ne)):b(Ne,xe)}return tr}var Hl=Kp(!0),Vu=Kp(!1),jl={},xo=Is(jl),vo=Is(jl),Xl=Is(jl);function Ci(d){if(d===jl)throw Error(t(174));return d}function Jc(d,m){switch(Kn(Xl,m),Kn(vo,d),Kn(xo,jl),d=m.nodeType,d){case 9:case 11:m=(m=m.documentElement)?m.namespaceURI:dt(null,"");break;default:d=d===8?m.parentNode:m,m=d.namespaceURI||null,d=d.tagName,m=dt(m,d)}rs(xo),Kn(xo,m)}function xa(){rs(xo),rs(vo),rs(Xl)}function Yp(d){Ci(Xl.current);var m=Ci(xo.current),b=dt(m,d.type);m!==b&&(Kn(vo,d),Kn(xo,b))}function Qc(d){vo.current===d&&(rs(xo),rs(vo))}var is=Is(0);function dr(d){for(var m=d;m!==null;){if(m.tag===13){var b=m.memoizedState;if(b!==null&&(b=b.dehydrated,b===null||b.data==="$?"||b.data==="$!"))return m}else if(m.tag===19&&m.memoizedProps.revealOrder!==void 0){if((m.flags&128)!==0)return m}else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===d)break;for(;m.sibling===null;){if(m.return===null||m.return===d)return null;m=m.return}m.sibling.return=m.return,m=m.sibling}return null}var va=[];function Ei(){for(var d=0;d<va.length;d++)va[d]._workInProgressVersionPrimary=null;va.length=0}var Wu=C.ReactCurrentDispatcher,Vr=C.ReactCurrentBatchConfig,ql=0,cs=null,Os=null,fr=null,Qo=!1,eh=!1,th=0,Ey=0;function Ns(){throw Error(t(321))}function Zp(d,m){if(m===null)return!1;for(var b=0;b<m.length&&b<d.length;b++)if(!Wi(d[b],m[b]))return!1;return!0}function Jp(d,m,b,I,k,F){if(ql=F,cs=m,m.memoizedState=null,m.updateQueue=null,m.lanes=0,Wu.current=d===null||d.memoizedState===null?v:E,d=b(I,k),eh){F=0;do{if(eh=!1,th=0,25<=F)throw Error(t(301));F+=1,fr=Os=null,m.updateQueue=null,Wu.current=A,d=b(I,k)}while(eh)}if(Wu.current=y,m=Os!==null&&Os.next!==null,ql=0,fr=Os=cs=null,Qo=!1,m)throw Error(t(300));return d}function Od(){var d=th!==0;return th=0,d}function ji(){var d={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return fr===null?cs.memoizedState=fr=d:fr=fr.next=d,fr}function wo(){if(Os===null){var d=cs.alternate;d=d!==null?d.memoizedState:null}else d=Os.next;var m=fr===null?cs.memoizedState:fr.next;if(m!==null)fr=m,Os=d;else{if(d===null)throw Error(t(310));Os=d,d={memoizedState:Os.memoizedState,baseState:Os.baseState,baseQueue:Os.baseQueue,queue:Os.queue,next:null},fr===null?cs.memoizedState=fr=d:fr=fr.next=d}return fr}function Fd(d,m){return typeof m=="function"?m(d):m}function Qp(d){var m=wo(),b=m.queue;if(b===null)throw Error(t(311));b.lastRenderedReducer=d;var I=Os,k=I.baseQueue,F=b.pending;if(F!==null){if(k!==null){var j=k.next;k.next=F.next,F.next=j}I.baseQueue=k=F,b.pending=null}if(k!==null){F=k.next,I=I.baseState;var le=j=null,me=null,Le=F;do{var st=Le.lane;if((ql&st)===st)me!==null&&(me=me.next={lane:0,action:Le.action,hasEagerState:Le.hasEagerState,eagerState:Le.eagerState,next:null}),I=Le.hasEagerState?Le.eagerState:d(I,Le.action);else{var rt={lane:st,action:Le.action,hasEagerState:Le.hasEagerState,eagerState:Le.eagerState,next:null};me===null?(le=me=rt,j=I):me=me.next=rt,cs.lanes|=st,Vd|=st}Le=Le.next}while(Le!==null&&Le!==F);me===null?j=I:me.next=le,Wi(I,m.memoizedState)||(_t=!0),m.memoizedState=I,m.baseState=j,m.baseQueue=me,b.lastRenderedState=I}if(d=b.interleaved,d!==null){k=d;do F=k.lane,cs.lanes|=F,Vd|=F,k=k.next;while(k!==d)}else k===null&&(b.lanes=0);return[m.memoizedState,b.dispatch]}function em(d){var m=wo(),b=m.queue;if(b===null)throw Error(t(311));b.lastRenderedReducer=d;var I=b.dispatch,k=b.pending,F=m.memoizedState;if(k!==null){b.pending=null;var j=k=k.next;do F=d(F,j.action),j=j.next;while(j!==k);Wi(F,m.memoizedState)||(_t=!0),m.memoizedState=F,m.baseQueue===null&&(m.baseState=F),b.lastRenderedState=F}return[F,I]}function Kl(){}function Yv(d,m){var b=cs,I=wo(),k=m(),F=!Wi(I.memoizedState,k);if(F&&(I.memoizedState=k,_t=!0),I=I.queue,Ud(hi.bind(null,b,I,d),[d]),I.getSnapshot!==m||F||fr!==null&&fr.memoizedState.tag&1){if(b.flags|=2048,$d(9,Iy.bind(null,b,I,k,m),void 0,null),Wr===null)throw Error(t(349));(ql&30)!==0||Yl(b,m,k)}return k}function Yl(d,m,b){d.flags|=16384,d={getSnapshot:m,value:b},m=cs.updateQueue,m===null?(m={lastEffect:null,stores:null},cs.updateQueue=m,m.stores=[d]):(b=m.stores,b===null?m.stores=[d]:b.push(d))}function Iy(d,m,b,I){m.value=b,m.getSnapshot=I,Zv(m)&&Ny(d)}function hi(d,m,b){return b(function(){Zv(m)&&Ny(d)})}function Zv(d){var m=d.getSnapshot;d=d.value;try{var b=m();return!Wi(d,b)}catch{return!0}}function Ny(d){var m=Jo(d,1);m!==null&&ll(m,d,1,-1)}function Jv(d){var m=ji();return typeof d=="function"&&(d=d()),m.memoizedState=m.baseState=d,d={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Fd,lastRenderedState:d},m.queue=d,d=d.dispatch=s1.bind(null,cs,d),[m.memoizedState,d]}function $d(d,m,b,I){return d={tag:d,create:m,destroy:b,deps:I,next:null},m=cs.updateQueue,m===null?(m={lastEffect:null,stores:null},cs.updateQueue=m,m.lastEffect=d.next=d):(b=m.lastEffect,b===null?m.lastEffect=d.next=d:(I=b.next,b.next=d,d.next=I,m.lastEffect=d)),d}function Ay(){return wo().memoizedState}function zd(d,m,b,I){var k=ji();cs.flags|=d,k.memoizedState=$d(1|m,b,void 0,I===void 0?null:I)}function tm(d,m,b,I){var k=wo();I=I===void 0?null:I;var F=void 0;if(Os!==null){var j=Os.memoizedState;if(F=j.destroy,I!==null&&Zp(I,j.deps)){k.memoizedState=$d(m,b,F,I);return}}cs.flags|=d,k.memoizedState=$d(1|m,b,F,I)}function Xi(d,m){return zd(8390656,8,d,m)}function Ud(d,m){return tm(2048,8,d,m)}function Qv(d,m){return tm(4,2,d,m)}function il(d,m){return tm(4,4,d,m)}function Bd(d,m){if(typeof m=="function")return d=d(),m(d),function(){m(null)};if(m!=null)return d=d(),m.current=d,function(){m.current=null}}function Zl(d,m,b){return b=b!=null?b.concat([d]):null,tm(4,4,Bd.bind(null,m,d),b)}function nh(){}function nm(d,m){var b=wo();m=m===void 0?null:m;var I=b.memoizedState;return I!==null&&m!==null&&Zp(m,I[1])?I[0]:(b.memoizedState=[d,m],d)}function sm(d,m){var b=wo();m=m===void 0?null:m;var I=b.memoizedState;return I!==null&&m!==null&&Zp(m,I[1])?I[0]:(d=d(),b.memoizedState=[d,m],d)}function e1(d,m,b){return(ql&21)===0?(d.baseState&&(d.baseState=!1,_t=!0),d.memoizedState=b):(Wi(b,m)||(b=wi(),cs.lanes|=b,Vd|=b,d.baseState=!0),m)}function t1(d,m){var b=$n;$n=b!==0&&4>b?b:4,d(!0);var I=Vr.transition;Vr.transition={};try{d(!1),m()}finally{$n=b,Vr.transition=I}}function My(){return wo().memoizedState}function n1(d,m,b){var I=oh(d);if(b={lane:I,action:b,hasEagerState:!1,eagerState:null,next:null},rm(d))r1(m,b);else if(b=qp(d,m,b,I),b!==null){var k=Ki();ll(b,d,I,k),i1(b,m,I)}}function s1(d,m,b){var I=oh(d),k={lane:I,action:b,hasEagerState:!1,eagerState:null,next:null};if(rm(d))r1(m,k);else{var F=d.alternate;if(d.lanes===0&&(F===null||F.lanes===0)&&(F=m.lastRenderedReducer,F!==null))try{var j=m.lastRenderedState,le=F(j,b);if(k.hasEagerState=!0,k.eagerState=le,Wi(le,j)){var me=m.interleaved;me===null?(k.next=k,Pd(m)):(k.next=me.next,me.next=k),m.interleaved=k;return}}catch{}finally{}b=qp(d,m,k,I),b!==null&&(k=Ki(),ll(b,d,I,k),i1(b,m,I))}}function rm(d){var m=d.alternate;return d===cs||m!==null&&m===cs}function r1(d,m){eh=Qo=!0;var b=d.pending;b===null?m.next=m:(m.next=b.next,b.next=m),d.pending=m}function i1(d,m,b){if((b&4194240)!==0){var I=m.lanes;I&=d.pendingLanes,b|=I,m.lanes=b,Ic(d,b)}}var y={readContext:li,useCallback:Ns,useContext:Ns,useEffect:Ns,useImperativeHandle:Ns,useInsertionEffect:Ns,useLayoutEffect:Ns,useMemo:Ns,useReducer:Ns,useRef:Ns,useState:Ns,useDebugValue:Ns,useDeferredValue:Ns,useTransition:Ns,useMutableSource:Ns,useSyncExternalStore:Ns,useId:Ns,unstable_isNewReconciler:!1},v={readContext:li,useCallback:function(d,m){return ji().memoizedState=[d,m===void 0?null:m],d},useContext:li,useEffect:Xi,useImperativeHandle:function(d,m,b){return b=b!=null?b.concat([d]):null,zd(4194308,4,Bd.bind(null,m,d),b)},useLayoutEffect:function(d,m){return zd(4194308,4,d,m)},useInsertionEffect:function(d,m){return zd(4,2,d,m)},useMemo:function(d,m){var b=ji();return m=m===void 0?null:m,d=d(),b.memoizedState=[d,m],d},useReducer:function(d,m,b){var I=ji();return m=b!==void 0?b(m):m,I.memoizedState=I.baseState=m,d={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:d,lastRenderedState:m},I.queue=d,d=d.dispatch=n1.bind(null,cs,d),[I.memoizedState,d]},useRef:function(d){var m=ji();return d={current:d},m.memoizedState=d},useState:Jv,useDebugValue:nh,useDeferredValue:function(d){return ji().memoizedState=d},useTransition:function(){var d=Jv(!1),m=d[0];return d=t1.bind(null,d[1]),ji().memoizedState=d,[m,d]},useMutableSource:function(){},useSyncExternalStore:function(d,m,b){var I=cs,k=ji();if(us){if(b===void 0)throw Error(t(407));b=b()}else{if(b=m(),Wr===null)throw Error(t(349));(ql&30)!==0||Yl(I,m,b)}k.memoizedState=b;var F={value:b,getSnapshot:m};return k.queue=F,Xi(hi.bind(null,I,F,d),[d]),I.flags|=2048,$d(9,Iy.bind(null,I,F,b,m),void 0,null),b},useId:function(){var d=ji(),m=Wr.identifierPrefix;if(us){var b=mo,I=ht;b=(I&~(1<<32-Cs(I)-1)).toString(32)+b,m=":"+m+"R"+b,b=th++,0<b&&(m+="H"+b.toString(32)),m+=":"}else b=Ey++,m=":"+m+"r"+b.toString(32)+":";return d.memoizedState=m},unstable_isNewReconciler:!1},E={readContext:li,useCallback:nm,useContext:li,useEffect:Ud,useImperativeHandle:Zl,useInsertionEffect:Qv,useLayoutEffect:il,useMemo:sm,useReducer:Qp,useRef:Ay,useState:function(){return Qp(Fd)},useDebugValue:nh,useDeferredValue:function(d){var m=wo();return e1(m,Os.memoizedState,d)},useTransition:function(){var d=Qp(Fd)[0],m=wo().memoizedState;return[d,m]},useMutableSource:Kl,useSyncExternalStore:Yv,useId:My,unstable_isNewReconciler:!1},A={readContext:li,useCallback:nm,useContext:li,useEffect:Ud,useImperativeHandle:Zl,useInsertionEffect:Qv,useLayoutEffect:il,useMemo:sm,useReducer:em,useRef:Ay,useState:function(){return em(Fd)},useDebugValue:nh,useDeferredValue:function(d){var m=wo();return Os===null?m.memoizedState=d:e1(m,Os.memoizedState,d)},useTransition:function(){var d=em(Fd)[0],m=wo().memoizedState;return[d,m]},useMutableSource:Kl,useSyncExternalStore:Yv,useId:My,unstable_isNewReconciler:!1};function O(d,m){try{var b="",I=m;do b+=fe(I),I=I.return;while(I);var k=b}catch(F){k=`
Error generating stack: `+F.message+`
`+F.stack}return{value:d,source:m,stack:k,digest:null}}function U(d,m,b){return{value:d,source:null,stack:b??null,digest:m??null}}function oe(d,m){try{console.error(m.value)}catch(b){setTimeout(function(){throw b})}}var ve=typeof WeakMap=="function"?WeakMap:Map;function Ge(d,m,b){b=yo(-1,b),b.tag=3,b.payload={element:null};var I=m.value;return b.callback=function(){f1||(f1=!0,CT=I),oe(d,m)},b}function ot(d,m,b){b=yo(-1,b),b.tag=3;var I=d.type.getDerivedStateFromError;if(typeof I=="function"){var k=m.value;b.payload=function(){return I(k)},b.callback=function(){oe(d,m)}}var F=d.stateNode;return F!==null&&typeof F.componentDidCatch=="function"&&(b.callback=function(){oe(d,m),typeof I!="function"&&(rh===null?rh=new Set([this]):rh.add(this));var j=m.stack;this.componentDidCatch(m.value,{componentStack:j!==null?j:""})}),b}function Nt(d,m,b){var I=d.pingCache;if(I===null){I=d.pingCache=new ve;var k=new Set;I.set(m,k)}else k=I.get(m),k===void 0&&(k=new Set,I.set(m,k));k.has(b)||(k.add(b),d=FW.bind(null,d,m,b),m.then(d,d))}function cn(d){do{var m;if((m=d.tag===13)&&(m=d.memoizedState,m=m!==null?m.dehydrated!==null:!0),m)return d;d=d.return}while(d!==null);return null}function Xt(d,m,b,I,k){return(d.mode&1)===0?(d===m?d.flags|=65536:(d.flags|=128,b.flags|=131072,b.flags&=-52805,b.tag===1&&(b.alternate===null?b.tag=17:(m=yo(-1,1),m.tag=2,ya(b,m,1))),b.lanes|=1),d):(d.flags|=65536,d.lanes=k,d)}var Yn=C.ReactCurrentOwner,_t=!1;function Gn(d,m,b,I){m.child=d===null?Vu(m,null,b,I):Hl(m,d.child,b,I)}function qi(d,m,b,I,k){b=b.render;var F=m.ref;return nl(m,k),I=Jp(d,m,b,I,F,k),b=Od(),d!==null&&!_t?(m.updateQueue=d.updateQueue,m.flags&=-2053,d.lanes&=~k,Gu(d,m,k)):(us&&b&&by(m),m.flags|=1,Gn(d,m,I,k),m.child)}function ke(d,m,b,I,k){if(d===null){var F=b.type;return typeof F=="function"&&!RT(F)&&F.defaultProps===void 0&&b.compare===null&&b.defaultProps===void 0?(m.tag=15,m.type=F,we(d,m,F,I,k)):(d=v1(b.type,null,I,m,m.mode,k),d.ref=m.ref,d.return=m,m.child=d)}if(F=d.child,(d.lanes&k)===0){var j=F.memoizedProps;if(b=b.compare,b=b!==null?b:Au,b(j,I)&&d.ref===m.ref)return Gu(d,m,k)}return m.flags|=1,d=lh(F,I),d.ref=m.ref,d.return=m,m.child=d}function we(d,m,b,I,k){if(d!==null){var F=d.memoizedProps;if(Au(F,I)&&d.ref===m.ref)if(_t=!1,m.pendingProps=I=F,(d.lanes&k)!==0)(d.flags&131072)!==0&&(_t=!0);else return m.lanes=d.lanes,Gu(d,m,k)}return Ot(d,m,b,I,k)}function ze(d,m,b){var I=m.pendingProps,k=I.children,F=d!==null?d.memoizedState:null;if(I.mode==="hidden")if((m.mode&1)===0)m.memoizedState={baseLanes:0,cachePool:null,transitions:null},Kn(om,ea),ea|=b;else{if((b&1073741824)===0)return d=F!==null?F.baseLanes|b:b,m.lanes=m.childLanes=1073741824,m.memoizedState={baseLanes:d,cachePool:null,transitions:null},m.updateQueue=null,Kn(om,ea),ea|=d,null;m.memoizedState={baseLanes:0,cachePool:null,transitions:null},I=F!==null?F.baseLanes:b,Kn(om,ea),ea|=I}else F!==null?(I=F.baseLanes|b,m.memoizedState=null):I=b,Kn(om,ea),ea|=I;return Gn(d,m,k,b),m.child}function wt(d,m){var b=m.ref;(d===null&&b!==null||d!==null&&d.ref!==b)&&(m.flags|=512,m.flags|=2097152)}function Ot(d,m,b,I,k){var F=Br(b)?Qa:Nr.current;return F=Lu(m,F),nl(m,k),b=Jp(d,m,b,I,F,k),I=Od(),d!==null&&!_t?(m.updateQueue=d.updateQueue,m.flags&=-2053,d.lanes&=~k,Gu(d,m,k)):(us&&I&&by(m),m.flags|=1,Gn(d,m,b,k),m.child)}function fn(d,m,b,I,k){if(Br(b)){var F=!0;Ou(m)}else F=!1;if(nl(m,k),m.stateNode===null)l1(d,m),Yc(m,b,I),Zc(m,b,I,k),I=!0;else if(d===null){var j=m.stateNode,le=m.memoizedProps;j.props=le;var me=j.context,Le=b.contextType;typeof Le=="object"&&Le!==null?Le=li(Le):(Le=Br(b)?Qa:Nr.current,Le=Lu(m,Le));var st=b.getDerivedStateFromProps,rt=typeof st=="function"||typeof j.getSnapshotBeforeUpdate=="function";rt||typeof j.UNSAFE_componentWillReceiveProps!="function"&&typeof j.componentWillReceiveProps!="function"||(le!==I||me!==Le)&&Uu(m,j,I,Le),sl=!1;var nt=m.memoizedState;j.state=nt,Ss(m,I,j,k),me=m.memoizedState,le!==I||nt!==me||ii.current||sl?(typeof st=="function"&&(ui(m,b,st,I),me=m.memoizedState),(le=sl||Us(m,b,le,I,nt,me,Le))?(rt||typeof j.UNSAFE_componentWillMount!="function"&&typeof j.componentWillMount!="function"||(typeof j.componentWillMount=="function"&&j.componentWillMount(),typeof j.UNSAFE_componentWillMount=="function"&&j.UNSAFE_componentWillMount()),typeof j.componentDidMount=="function"&&(m.flags|=4194308)):(typeof j.componentDidMount=="function"&&(m.flags|=4194308),m.memoizedProps=I,m.memoizedState=me),j.props=I,j.state=me,j.context=Le,I=le):(typeof j.componentDidMount=="function"&&(m.flags|=4194308),I=!1)}else{j=m.stateNode,Kv(d,m),le=m.memoizedProps,Le=m.type===m.elementType?le:Yo(m.type,le),j.props=Le,rt=m.pendingProps,nt=j.context,me=b.contextType,typeof me=="object"&&me!==null?me=li(me):(me=Br(b)?Qa:Nr.current,me=Lu(m,me));var Et=b.getDerivedStateFromProps;(st=typeof Et=="function"||typeof j.getSnapshotBeforeUpdate=="function")||typeof j.UNSAFE_componentWillReceiveProps!="function"&&typeof j.componentWillReceiveProps!="function"||(le!==rt||nt!==me)&&Uu(m,j,I,me),sl=!1,nt=m.memoizedState,j.state=nt,Ss(m,I,j,k);var Pt=m.memoizedState;le!==rt||nt!==Pt||ii.current||sl?(typeof Et=="function"&&(ui(m,b,Et,I),Pt=m.memoizedState),(Le=sl||Us(m,b,Le,I,nt,Pt,me)||!1)?(st||typeof j.UNSAFE_componentWillUpdate!="function"&&typeof j.componentWillUpdate!="function"||(typeof j.componentWillUpdate=="function"&&j.componentWillUpdate(I,Pt,me),typeof j.UNSAFE_componentWillUpdate=="function"&&j.UNSAFE_componentWillUpdate(I,Pt,me)),typeof j.componentDidUpdate=="function"&&(m.flags|=4),typeof j.getSnapshotBeforeUpdate=="function"&&(m.flags|=1024)):(typeof j.componentDidUpdate!="function"||le===d.memoizedProps&&nt===d.memoizedState||(m.flags|=4),typeof j.getSnapshotBeforeUpdate!="function"||le===d.memoizedProps&&nt===d.memoizedState||(m.flags|=1024),m.memoizedProps=I,m.memoizedState=Pt),j.props=I,j.state=Pt,j.context=me,I=Le):(typeof j.componentDidUpdate!="function"||le===d.memoizedProps&&nt===d.memoizedState||(m.flags|=4),typeof j.getSnapshotBeforeUpdate!="function"||le===d.memoizedProps&&nt===d.memoizedState||(m.flags|=1024),I=!1)}return on(d,m,b,I,F,k)}function on(d,m,b,I,k,F){wt(d,m);var j=(m.flags&128)!==0;if(!I&&!j)return k&&wy(m,b,!1),Gu(d,m,F);I=m.stateNode,Yn.current=m;var le=j&&typeof b.getDerivedStateFromError!="function"?null:I.render();return m.flags|=1,d!==null&&j?(m.child=Hl(m,d.child,null,F),m.child=Hl(m,null,le,F)):Gn(d,m,le,F),m.memoizedState=I.state,k&&wy(m,b,!0),m.child}function Ln(d){var m=d.stateNode;m.pendingContext?vy(d,m.pendingContext,m.pendingContext!==m.context):m.context&&vy(d,m.context,!1),Jc(d,m.containerInfo)}function er(d,m,b,I,k){return Wl(),jc(k),m.flags|=256,Gn(d,m,b,I),m.child}var Rn={dehydrated:null,treeContext:null,retryLane:0};function wa(d){return{baseLanes:d,cachePool:null,transitions:null}}function o1(d,m,b){var I=m.pendingProps,k=is.current,F=!1,j=(m.flags&128)!==0,le;if((le=j)||(le=d!==null&&d.memoizedState===null?!1:(k&2)!==0),le?(F=!0,m.flags&=-129):(d===null||d.memoizedState!==null)&&(k|=1),Kn(is,k&1),d===null)return Hp(m),d=m.memoizedState,d!==null&&(d=d.dehydrated,d!==null)?((m.mode&1)===0?m.lanes=1:d.data==="$!"?m.lanes=8:m.lanes=1073741824,null):(j=I.children,d=I.fallback,F?(I=m.mode,F=m.child,j={mode:"hidden",children:j},(I&1)===0&&F!==null?(F.childLanes=0,F.pendingProps=j):F=w1(j,I,0,null),d=jd(d,I,b,null),F.return=m,d.return=m,F.sibling=d,m.child=F,m.child.memoizedState=wa(b),m.memoizedState=Rn,d):mT(m,j));if(k=d.memoizedState,k!==null&&(le=k.dehydrated,le!==null))return CW(d,m,j,I,le,k,b);if(F){F=I.fallback,j=m.mode,k=d.child,le=k.sibling;var me={mode:"hidden",children:I.children};return(j&1)===0&&m.child!==k?(I=m.child,I.childLanes=0,I.pendingProps=me,m.deletions=null):(I=lh(k,me),I.subtreeFlags=k.subtreeFlags&14680064),le!==null?F=lh(le,F):(F=jd(F,j,b,null),F.flags|=2),F.return=m,I.return=m,I.sibling=F,m.child=I,I=F,F=m.child,j=d.child.memoizedState,j=j===null?wa(b):{baseLanes:j.baseLanes|b,cachePool:null,transitions:j.transitions},F.memoizedState=j,F.childLanes=d.childLanes&~b,m.memoizedState=Rn,I}return F=d.child,d=F.sibling,I=lh(F,{mode:"visible",children:I.children}),(m.mode&1)===0&&(I.lanes=b),I.return=m,I.sibling=null,d!==null&&(b=m.deletions,b===null?(m.deletions=[d],m.flags|=16):b.push(d)),m.child=I,m.memoizedState=null,I}function mT(d,m){return m=w1({mode:"visible",children:m},d.mode,0,null),m.return=d,d.child=m}function a1(d,m,b,I){return I!==null&&jc(I),Hl(m,d.child,null,b),d=mT(m,m.pendingProps.children),d.flags|=2,m.memoizedState=null,d}function CW(d,m,b,I,k,F,j){if(b)return m.flags&256?(m.flags&=-257,I=U(Error(t(422))),a1(d,m,j,I)):m.memoizedState!==null?(m.child=d.child,m.flags|=128,null):(F=I.fallback,k=m.mode,I=w1({mode:"visible",children:I.children},k,0,null),F=jd(F,k,j,null),F.flags|=2,I.return=m,F.return=m,I.sibling=F,m.child=I,(m.mode&1)!==0&&Hl(m,d.child,null,j),m.child.memoizedState=wa(j),m.memoizedState=Rn,F);if((m.mode&1)===0)return a1(d,m,j,null);if(k.data==="$!"){if(I=k.nextSibling&&k.nextSibling.dataset,I)var le=I.dgst;return I=le,F=Error(t(419)),I=U(F,I,void 0),a1(d,m,j,I)}if(le=(j&d.childLanes)!==0,_t||le){if(I=Wr,I!==null){switch(j&-j){case 4:k=2;break;case 16:k=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:k=32;break;case 536870912:k=268435456;break;default:k=0}k=(k&(I.suspendedLanes|j))!==0?0:k,k!==0&&k!==F.retryLane&&(F.retryLane=k,Jo(d,k),ll(I,d,k,-1))}return kT(),I=U(Error(t(421))),a1(d,m,j,I)}return k.data==="$?"?(m.flags|=128,m.child=d.child,m=$W.bind(null,d),k._reactRetry=m,null):(d=F.treeContext,ai=Ya(k.nextSibling),Ar=m,us=!0,go=null,d!==null&&(oi[cr++]=ht,oi[cr++]=mo,oi[cr++]=$u,ht=d.id,mo=d.overflow,$u=m),m=mT(m,I.children),m.flags|=4096,m)}function QM(d,m,b){d.lanes|=m;var I=d.alternate;I!==null&&(I.lanes|=m),Kc(d.return,m,b)}function gT(d,m,b,I,k){var F=d.memoizedState;F===null?d.memoizedState={isBackwards:m,rendering:null,renderingStartTime:0,last:I,tail:b,tailMode:k}:(F.isBackwards=m,F.rendering=null,F.renderingStartTime=0,F.last=I,F.tail=b,F.tailMode=k)}function ek(d,m,b){var I=m.pendingProps,k=I.revealOrder,F=I.tail;if(Gn(d,m,I.children,b),I=is.current,(I&2)!==0)I=I&1|2,m.flags|=128;else{if(d!==null&&(d.flags&128)!==0)e:for(d=m.child;d!==null;){if(d.tag===13)d.memoizedState!==null&&QM(d,b,m);else if(d.tag===19)QM(d,b,m);else if(d.child!==null){d.child.return=d,d=d.child;continue}if(d===m)break e;for(;d.sibling===null;){if(d.return===null||d.return===m)break e;d=d.return}d.sibling.return=d.return,d=d.sibling}I&=1}if(Kn(is,I),(m.mode&1)===0)m.memoizedState=null;else switch(k){case"forwards":for(b=m.child,k=null;b!==null;)d=b.alternate,d!==null&&dr(d)===null&&(k=b),b=b.sibling;b=k,b===null?(k=m.child,m.child=null):(k=b.sibling,b.sibling=null),gT(m,!1,k,b,F);break;case"backwards":for(b=null,k=m.child,m.child=null;k!==null;){if(d=k.alternate,d!==null&&dr(d)===null){m.child=k;break}d=k.sibling,k.sibling=b,b=k,k=d}gT(m,!0,b,null,F);break;case"together":gT(m,!1,null,null,void 0);break;default:m.memoizedState=null}return m.child}function l1(d,m){(m.mode&1)===0&&d!==null&&(d.alternate=null,m.alternate=null,m.flags|=2)}function Gu(d,m,b){if(d!==null&&(m.dependencies=d.dependencies),Vd|=m.lanes,(b&m.childLanes)===0)return null;if(d!==null&&m.child!==d.child)throw Error(t(153));if(m.child!==null){for(d=m.child,b=lh(d,d.pendingProps),m.child=b,b.return=m;d.sibling!==null;)d=d.sibling,b=b.sibling=lh(d,d.pendingProps),b.return=m;b.sibling=null}return m.child}function EW(d,m,b){switch(m.tag){case 3:Ln(m),Wl();break;case 5:Yp(m);break;case 1:Br(m.type)&&Ou(m);break;case 4:Jc(m,m.stateNode.containerInfo);break;case 10:var I=m.type._context,k=m.memoizedProps.value;Kn(Rd,I._currentValue),I._currentValue=k;break;case 13:if(I=m.memoizedState,I!==null)return I.dehydrated!==null?(Kn(is,is.current&1),m.flags|=128,null):(b&m.child.childLanes)!==0?o1(d,m,b):(Kn(is,is.current&1),d=Gu(d,m,b),d!==null?d.sibling:null);Kn(is,is.current&1);break;case 19:if(I=(b&m.childLanes)!==0,(d.flags&128)!==0){if(I)return ek(d,m,b);m.flags|=128}if(k=m.memoizedState,k!==null&&(k.rendering=null,k.tail=null,k.lastEffect=null),Kn(is,is.current),I)break;return null;case 22:case 23:return m.lanes=0,ze(d,m,b)}return Gu(d,m,b)}var tk,yT,nk,sk;tk=function(d,m){for(var b=m.child;b!==null;){if(b.tag===5||b.tag===6)d.appendChild(b.stateNode);else if(b.tag!==4&&b.child!==null){b.child.return=b,b=b.child;continue}if(b===m)break;for(;b.sibling===null;){if(b.return===null||b.return===m)return;b=b.return}b.sibling.return=b.return,b=b.sibling}},yT=function(){},nk=function(d,m,b,I){var k=d.memoizedProps;if(k!==I){d=m.stateNode,Ci(xo.current);var F=null;switch(b){case"input":k=De(d,k),I=De(d,I),F=[];break;case"select":k=B({},k,{value:void 0}),I=B({},I,{value:void 0}),F=[];break;case"textarea":k=We(d,k),I=We(d,I),F=[];break;default:typeof k.onClick!="function"&&typeof I.onClick=="function"&&(d.onclick=Id)}jt(b,I);var j;b=null;for(Le in k)if(!I.hasOwnProperty(Le)&&k.hasOwnProperty(Le)&&k[Le]!=null)if(Le==="style"){var le=k[Le];for(j in le)le.hasOwnProperty(j)&&(b||(b={}),b[j]="")}else Le!=="dangerouslySetInnerHTML"&&Le!=="children"&&Le!=="suppressContentEditableWarning"&&Le!=="suppressHydrationWarning"&&Le!=="autoFocus"&&(r.hasOwnProperty(Le)?F||(F=[]):(F=F||[]).push(Le,null));for(Le in I){var me=I[Le];if(le=k!=null?k[Le]:void 0,I.hasOwnProperty(Le)&&me!==le&&(me!=null||le!=null))if(Le==="style")if(le){for(j in le)!le.hasOwnProperty(j)||me&&me.hasOwnProperty(j)||(b||(b={}),b[j]="");for(j in me)me.hasOwnProperty(j)&&le[j]!==me[j]&&(b||(b={}),b[j]=me[j])}else b||(F||(F=[]),F.push(Le,b)),b=me;else Le==="dangerouslySetInnerHTML"?(me=me?me.__html:void 0,le=le?le.__html:void 0,me!=null&&le!==me&&(F=F||[]).push(Le,me)):Le==="children"?typeof me!="string"&&typeof me!="number"||(F=F||[]).push(Le,""+me):Le!=="suppressContentEditableWarning"&&Le!=="suppressHydrationWarning"&&(r.hasOwnProperty(Le)?(me!=null&&Le==="onScroll"&&ss("scroll",d),F||le===me||(F=[])):(F=F||[]).push(Le,me))}b&&(F=F||[]).push("style",b);var Le=F;(m.updateQueue=Le)&&(m.flags|=4)}},sk=function(d,m,b,I){b!==I&&(m.flags|=4)};function ky(d,m){if(!us)switch(d.tailMode){case"hidden":m=d.tail;for(var b=null;m!==null;)m.alternate!==null&&(b=m),m=m.sibling;b===null?d.tail=null:b.sibling=null;break;case"collapsed":b=d.tail;for(var I=null;b!==null;)b.alternate!==null&&(I=b),b=b.sibling;I===null?m||d.tail===null?d.tail=null:d.tail.sibling=null:I.sibling=null}}function Ii(d){var m=d.alternate!==null&&d.alternate.child===d.child,b=0,I=0;if(m)for(var k=d.child;k!==null;)b|=k.lanes|k.childLanes,I|=k.subtreeFlags&14680064,I|=k.flags&14680064,k.return=d,k=k.sibling;else for(k=d.child;k!==null;)b|=k.lanes|k.childLanes,I|=k.subtreeFlags,I|=k.flags,k.return=d,k=k.sibling;return d.subtreeFlags|=I,d.childLanes=b,m}function IW(d,m,b){var I=m.pendingProps;switch(tl(m),m.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ii(m),null;case 1:return Br(m.type)&&Nd(),Ii(m),null;case 3:return I=m.stateNode,xa(),rs(ii),rs(Nr),Ei(),I.pendingContext&&(I.context=I.pendingContext,I.pendingContext=null),(d===null||d.child===null)&&(Hc(m)?m.flags|=4:d===null||d.memoizedState.isDehydrated&&(m.flags&256)===0||(m.flags|=1024,go!==null&&(NT(go),go=null))),yT(d,m),Ii(m),null;case 5:Qc(m);var k=Ci(Xl.current);if(b=m.type,d!==null&&m.stateNode!=null)nk(d,m,b,I,k),d.ref!==m.ref&&(m.flags|=512,m.flags|=2097152);else{if(!I){if(m.stateNode===null)throw Error(t(166));return Ii(m),null}if(d=Ci(xo.current),Hc(m)){I=m.stateNode,b=m.type;var F=m.memoizedProps;switch(I[Qs]=m,I[Gc]=F,d=(m.mode&1)!==0,b){case"dialog":ss("cancel",I),ss("close",I);break;case"iframe":case"object":case"embed":ss("load",I);break;case"video":case"audio":for(k=0;k<Bl.length;k++)ss(Bl[k],I);break;case"source":ss("error",I);break;case"img":case"image":case"link":ss("error",I),ss("load",I);break;case"details":ss("toggle",I);break;case"input":He(I,F),ss("invalid",I);break;case"select":I._wrapperState={wasMultiple:!!F.multiple},ss("invalid",I);break;case"textarea":Xe(I,F),ss("invalid",I)}jt(b,F),k=null;for(var j in F)if(F.hasOwnProperty(j)){var le=F[j];j==="children"?typeof le=="string"?I.textContent!==le&&(F.suppressHydrationWarning!==!0&&Ed(I.textContent,le,d),k=["children",le]):typeof le=="number"&&I.textContent!==""+le&&(F.suppressHydrationWarning!==!0&&Ed(I.textContent,le,d),k=["children",""+le]):r.hasOwnProperty(j)&&le!=null&&j==="onScroll"&&ss("scroll",I)}switch(b){case"input":et(I),Qe(I,F,!0);break;case"textarea":et(I),xt(I);break;case"select":case"option":break;default:typeof F.onClick=="function"&&(I.onclick=Id)}I=k,m.updateQueue=I,I!==null&&(m.flags|=4)}else{j=k.nodeType===9?k:k.ownerDocument,d==="http://www.w3.org/1999/xhtml"&&(d=it(b)),d==="http://www.w3.org/1999/xhtml"?b==="script"?(d=j.createElement("div"),d.innerHTML="<script><\/script>",d=d.removeChild(d.firstChild)):typeof I.is=="string"?d=j.createElement(b,{is:I.is}):(d=j.createElement(b),b==="select"&&(j=d,I.multiple?j.multiple=!0:I.size&&(j.size=I.size))):d=j.createElementNS(d,b),d[Qs]=m,d[Gc]=I,tk(d,m,!1,!1),m.stateNode=d;e:{switch(j=Nn(b,I),b){case"dialog":ss("cancel",d),ss("close",d),k=I;break;case"iframe":case"object":case"embed":ss("load",d),k=I;break;case"video":case"audio":for(k=0;k<Bl.length;k++)ss(Bl[k],d);k=I;break;case"source":ss("error",d),k=I;break;case"img":case"image":case"link":ss("error",d),ss("load",d),k=I;break;case"details":ss("toggle",d),k=I;break;case"input":He(d,I),k=De(d,I),ss("invalid",d);break;case"option":k=I;break;case"select":d._wrapperState={wasMultiple:!!I.multiple},k=B({},I,{value:void 0}),ss("invalid",d);break;case"textarea":Xe(d,I),k=We(d,I),ss("invalid",d);break;default:k=I}jt(b,k),le=k;for(F in le)if(le.hasOwnProperty(F)){var me=le[F];F==="style"?Bt(d,me):F==="dangerouslySetInnerHTML"?(me=me?me.__html:void 0,me!=null&&Yt(d,me)):F==="children"?typeof me=="string"?(b!=="textarea"||me!=="")&&Ke(d,me):typeof me=="number"&&Ke(d,""+me):F!=="suppressContentEditableWarning"&&F!=="suppressHydrationWarning"&&F!=="autoFocus"&&(r.hasOwnProperty(F)?me!=null&&F==="onScroll"&&ss("scroll",d):me!=null&&T(d,F,me,j))}switch(b){case"input":et(d),Qe(d,I,!1);break;case"textarea":et(d),xt(d);break;case"option":I.value!=null&&d.setAttribute("value",""+Ve(I.value));break;case"select":d.multiple=!!I.multiple,F=I.value,F!=null?Se(d,!!I.multiple,F,!1):I.defaultValue!=null&&Se(d,!!I.multiple,I.defaultValue,!0);break;default:typeof k.onClick=="function"&&(d.onclick=Id)}switch(b){case"button":case"input":case"select":case"textarea":I=!!I.autoFocus;break e;case"img":I=!0;break e;default:I=!1}}I&&(m.flags|=4)}m.ref!==null&&(m.flags|=512,m.flags|=2097152)}return Ii(m),null;case 6:if(d&&m.stateNode!=null)sk(d,m,d.memoizedProps,I);else{if(typeof I!="string"&&m.stateNode===null)throw Error(t(166));if(b=Ci(Xl.current),Ci(xo.current),Hc(m)){if(I=m.stateNode,b=m.memoizedProps,I[Qs]=m,(F=I.nodeValue!==b)&&(d=Ar,d!==null))switch(d.tag){case 3:Ed(I.nodeValue,b,(d.mode&1)!==0);break;case 5:d.memoizedProps.suppressHydrationWarning!==!0&&Ed(I.nodeValue,b,(d.mode&1)!==0)}F&&(m.flags|=4)}else I=(b.nodeType===9?b:b.ownerDocument).createTextNode(I),I[Qs]=m,m.stateNode=I}return Ii(m),null;case 13:if(rs(is),I=m.memoizedState,d===null||d.memoizedState!==null&&d.memoizedState.dehydrated!==null){if(us&&ai!==null&&(m.mode&1)!==0&&(m.flags&128)===0)Cy(),Wl(),m.flags|=98560,F=!1;else if(F=Hc(m),I!==null&&I.dehydrated!==null){if(d===null){if(!F)throw Error(t(318));if(F=m.memoizedState,F=F!==null?F.dehydrated:null,!F)throw Error(t(317));F[Qs]=m}else Wl(),(m.flags&128)===0&&(m.memoizedState=null),m.flags|=4;Ii(m),F=!1}else go!==null&&(NT(go),go=null),F=!0;if(!F)return m.flags&65536?m:null}return(m.flags&128)!==0?(m.lanes=b,m):(I=I!==null,I!==(d!==null&&d.memoizedState!==null)&&I&&(m.child.flags|=8192,(m.mode&1)!==0&&(d===null||(is.current&1)!==0?Mr===0&&(Mr=3):kT())),m.updateQueue!==null&&(m.flags|=4),Ii(m),null);case 4:return xa(),yT(d,m),d===null&&Bc(m.stateNode.containerInfo),Ii(m),null;case 10:return qc(m.type._context),Ii(m),null;case 17:return Br(m.type)&&Nd(),Ii(m),null;case 19:if(rs(is),F=m.memoizedState,F===null)return Ii(m),null;if(I=(m.flags&128)!==0,j=F.rendering,j===null)if(I)ky(F,!1);else{if(Mr!==0||d!==null&&(d.flags&128)!==0)for(d=m.child;d!==null;){if(j=dr(d),j!==null){for(m.flags|=128,ky(F,!1),I=j.updateQueue,I!==null&&(m.updateQueue=I,m.flags|=4),m.subtreeFlags=0,I=b,b=m.child;b!==null;)F=b,d=I,F.flags&=14680066,j=F.alternate,j===null?(F.childLanes=0,F.lanes=d,F.child=null,F.subtreeFlags=0,F.memoizedProps=null,F.memoizedState=null,F.updateQueue=null,F.dependencies=null,F.stateNode=null):(F.childLanes=j.childLanes,F.lanes=j.lanes,F.child=j.child,F.subtreeFlags=0,F.deletions=null,F.memoizedProps=j.memoizedProps,F.memoizedState=j.memoizedState,F.updateQueue=j.updateQueue,F.type=j.type,d=j.dependencies,F.dependencies=d===null?null:{lanes:d.lanes,firstContext:d.firstContext}),b=b.sibling;return Kn(is,is.current&1|2),m.child}d=d.sibling}F.tail!==null&&Ct()>am&&(m.flags|=128,I=!0,ky(F,!1),m.lanes=4194304)}else{if(!I)if(d=dr(j),d!==null){if(m.flags|=128,I=!0,b=d.updateQueue,b!==null&&(m.updateQueue=b,m.flags|=4),ky(F,!0),F.tail===null&&F.tailMode==="hidden"&&!j.alternate&&!us)return Ii(m),null}else 2*Ct()-F.renderingStartTime>am&&b!==1073741824&&(m.flags|=128,I=!0,ky(F,!1),m.lanes=4194304);F.isBackwards?(j.sibling=m.child,m.child=j):(b=F.last,b!==null?b.sibling=j:m.child=j,F.last=j)}return F.tail!==null?(m=F.tail,F.rendering=m,F.tail=m.sibling,F.renderingStartTime=Ct(),m.sibling=null,b=is.current,Kn(is,I?b&1|2:b&1),m):(Ii(m),null);case 22:case 23:return MT(),I=m.memoizedState!==null,d!==null&&d.memoizedState!==null!==I&&(m.flags|=8192),I&&(m.mode&1)!==0?(ea&1073741824)!==0&&(Ii(m),m.subtreeFlags&6&&(m.flags|=8192)):Ii(m),null;case 24:return null;case 25:return null}throw Error(t(156,m.tag))}function NW(d,m){switch(tl(m),m.tag){case 1:return Br(m.type)&&Nd(),d=m.flags,d&65536?(m.flags=d&-65537|128,m):null;case 3:return xa(),rs(ii),rs(Nr),Ei(),d=m.flags,(d&65536)!==0&&(d&128)===0?(m.flags=d&-65537|128,m):null;case 5:return Qc(m),null;case 13:if(rs(is),d=m.memoizedState,d!==null&&d.dehydrated!==null){if(m.alternate===null)throw Error(t(340));Wl()}return d=m.flags,d&65536?(m.flags=d&-65537|128,m):null;case 19:return rs(is),null;case 4:return xa(),null;case 10:return qc(m.type._context),null;case 22:case 23:return MT(),null;case 24:return null;default:return null}}var u1=!1,Ni=!1,AW=typeof WeakSet=="function"?WeakSet:Set,Mt=null;function im(d,m){var b=d.ref;if(b!==null)if(typeof b=="function")try{b(null)}catch(I){Bs(d,m,I)}else b.current=null}function xT(d,m,b){try{b()}catch(I){Bs(d,m,I)}}var rk=!1;function MW(d,m){if(Wc=lo,d=ws(),or(d)){if("selectionStart"in d)var b={start:d.selectionStart,end:d.selectionEnd};else e:{b=(b=d.ownerDocument)&&b.defaultView||window;var I=b.getSelection&&b.getSelection();if(I&&I.rangeCount!==0){b=I.anchorNode;var k=I.anchorOffset,F=I.focusNode;I=I.focusOffset;try{b.nodeType,F.nodeType}catch{b=null;break e}var j=0,le=-1,me=-1,Le=0,st=0,rt=d,nt=null;t:for(;;){for(var Et;rt!==b||k!==0&&rt.nodeType!==3||(le=j+k),rt!==F||I!==0&&rt.nodeType!==3||(me=j+I),rt.nodeType===3&&(j+=rt.nodeValue.length),(Et=rt.firstChild)!==null;)nt=rt,rt=Et;for(;;){if(rt===d)break t;if(nt===b&&++Le===k&&(le=j),nt===F&&++st===I&&(me=j),(Et=rt.nextSibling)!==null)break;rt=nt,nt=rt.parentNode}rt=Et}b=le===-1||me===-1?null:{start:le,end:me}}else b=null}b=b||{start:0,end:0}}else b=null;for(fy={focusedElem:d,selectionRange:b},lo=!1,Mt=m;Mt!==null;)if(m=Mt,d=m.child,(m.subtreeFlags&1028)!==0&&d!==null)d.return=m,Mt=d;else for(;Mt!==null;){m=Mt;try{var Pt=m.alternate;if((m.flags&1024)!==0)switch(m.tag){case 0:case 11:case 15:break;case 1:if(Pt!==null){var Ft=Pt.memoizedProps,tr=Pt.memoizedState,Ne=m.stateNode,xe=Ne.getSnapshotBeforeUpdate(m.elementType===m.type?Ft:Yo(m.type,Ft),tr);Ne.__reactInternalSnapshotBeforeUpdate=xe}break;case 3:var Me=m.stateNode.containerInfo;Me.nodeType===1?Me.textContent="":Me.nodeType===9&&Me.documentElement&&Me.removeChild(Me.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(lt){Bs(m,m.return,lt)}if(d=m.sibling,d!==null){d.return=m.return,Mt=d;break}Mt=m.return}return Pt=rk,rk=!1,Pt}function Ry(d,m,b){var I=m.updateQueue;if(I=I!==null?I.lastEffect:null,I!==null){var k=I=I.next;do{if((k.tag&d)===d){var F=k.destroy;k.destroy=void 0,F!==void 0&&xT(m,b,F)}k=k.next}while(k!==I)}}function c1(d,m){if(m=m.updateQueue,m=m!==null?m.lastEffect:null,m!==null){var b=m=m.next;do{if((b.tag&d)===d){var I=b.create;b.destroy=I()}b=b.next}while(b!==m)}}function vT(d){var m=d.ref;if(m!==null){var b=d.stateNode;switch(d.tag){case 5:d=b;break;default:d=b}typeof m=="function"?m(d):m.current=d}}function ik(d){var m=d.alternate;m!==null&&(d.alternate=null,ik(m)),d.child=null,d.deletions=null,d.sibling=null,d.tag===5&&(m=d.stateNode,m!==null&&(delete m[Qs],delete m[Gc],delete m[Pu],delete m[$p],delete m[zp])),d.stateNode=null,d.return=null,d.dependencies=null,d.memoizedProps=null,d.memoizedState=null,d.pendingProps=null,d.stateNode=null,d.updateQueue=null}function ok(d){return d.tag===5||d.tag===3||d.tag===4}function ak(d){e:for(;;){for(;d.sibling===null;){if(d.return===null||ok(d.return))return null;d=d.return}for(d.sibling.return=d.return,d=d.sibling;d.tag!==5&&d.tag!==6&&d.tag!==18;){if(d.flags&2||d.child===null||d.tag===4)continue e;d.child.return=d,d=d.child}if(!(d.flags&2))return d.stateNode}}function wT(d,m,b){var I=d.tag;if(I===5||I===6)d=d.stateNode,m?b.nodeType===8?b.parentNode.insertBefore(d,m):b.insertBefore(d,m):(b.nodeType===8?(m=b.parentNode,m.insertBefore(d,b)):(m=b,m.appendChild(d)),b=b._reactRootContainer,b!=null||m.onclick!==null||(m.onclick=Id));else if(I!==4&&(d=d.child,d!==null))for(wT(d,m,b),d=d.sibling;d!==null;)wT(d,m,b),d=d.sibling}function ST(d,m,b){var I=d.tag;if(I===5||I===6)d=d.stateNode,m?b.insertBefore(d,m):b.appendChild(d);else if(I!==4&&(d=d.child,d!==null))for(ST(d,m,b),d=d.sibling;d!==null;)ST(d,m,b),d=d.sibling}var di=null,ol=!1;function sh(d,m,b){for(b=b.child;b!==null;)lk(d,m,b),b=b.sibling}function lk(d,m,b){if(zt&&typeof zt.onCommitFiberUnmount=="function")try{zt.onCommitFiberUnmount(Rs,b)}catch{}switch(b.tag){case 5:Ni||im(b,m);case 6:var I=di,k=ol;di=null,sh(d,m,b),di=I,ol=k,di!==null&&(ol?(d=di,b=b.stateNode,d.nodeType===8?d.parentNode.removeChild(b):d.removeChild(b)):di.removeChild(b.stateNode));break;case 18:di!==null&&(ol?(d=di,b=b.stateNode,d.nodeType===8?Fp(d.parentNode,b):d.nodeType===1&&Fp(d,b),md(d)):Fp(di,b.stateNode));break;case 4:I=di,k=ol,di=b.stateNode.containerInfo,ol=!0,sh(d,m,b),di=I,ol=k;break;case 0:case 11:case 14:case 15:if(!Ni&&(I=b.updateQueue,I!==null&&(I=I.lastEffect,I!==null))){k=I=I.next;do{var F=k,j=F.destroy;F=F.tag,j!==void 0&&((F&2)!==0||(F&4)!==0)&&xT(b,m,j),k=k.next}while(k!==I)}sh(d,m,b);break;case 1:if(!Ni&&(im(b,m),I=b.stateNode,typeof I.componentWillUnmount=="function"))try{I.props=b.memoizedProps,I.state=b.memoizedState,I.componentWillUnmount()}catch(le){Bs(b,m,le)}sh(d,m,b);break;case 21:sh(d,m,b);break;case 22:b.mode&1?(Ni=(I=Ni)||b.memoizedState!==null,sh(d,m,b),Ni=I):sh(d,m,b);break;default:sh(d,m,b)}}function uk(d){var m=d.updateQueue;if(m!==null){d.updateQueue=null;var b=d.stateNode;b===null&&(b=d.stateNode=new AW),m.forEach(function(I){var k=zW.bind(null,d,I);b.has(I)||(b.add(I),I.then(k,k))})}}function al(d,m){var b=m.deletions;if(b!==null)for(var I=0;I<b.length;I++){var k=b[I];try{var F=d,j=m,le=j;e:for(;le!==null;){switch(le.tag){case 5:di=le.stateNode,ol=!1;break e;case 3:di=le.stateNode.containerInfo,ol=!0;break e;case 4:di=le.stateNode.containerInfo,ol=!0;break e}le=le.return}if(di===null)throw Error(t(160));lk(F,j,k),di=null,ol=!1;var me=k.alternate;me!==null&&(me.return=null),k.return=null}catch(Le){Bs(k,m,Le)}}if(m.subtreeFlags&12854)for(m=m.child;m!==null;)ck(m,d),m=m.sibling}function ck(d,m){var b=d.alternate,I=d.flags;switch(d.tag){case 0:case 11:case 14:case 15:if(al(m,d),Jl(d),I&4){try{Ry(3,d,d.return),c1(3,d)}catch(Ft){Bs(d,d.return,Ft)}try{Ry(5,d,d.return)}catch(Ft){Bs(d,d.return,Ft)}}break;case 1:al(m,d),Jl(d),I&512&&b!==null&&im(b,b.return);break;case 5:if(al(m,d),Jl(d),I&512&&b!==null&&im(b,b.return),d.flags&32){var k=d.stateNode;try{Ke(k,"")}catch(Ft){Bs(d,d.return,Ft)}}if(I&4&&(k=d.stateNode,k!=null)){var F=d.memoizedProps,j=b!==null?b.memoizedProps:F,le=d.type,me=d.updateQueue;if(d.updateQueue=null,me!==null)try{le==="input"&&F.type==="radio"&&F.name!=null&&Re(k,F),Nn(le,j);var Le=Nn(le,F);for(j=0;j<me.length;j+=2){var st=me[j],rt=me[j+1];st==="style"?Bt(k,rt):st==="dangerouslySetInnerHTML"?Yt(k,rt):st==="children"?Ke(k,rt):T(k,st,rt,Le)}switch(le){case"input":at(k,F);break;case"textarea":je(k,F);break;case"select":var nt=k._wrapperState.wasMultiple;k._wrapperState.wasMultiple=!!F.multiple;var Et=F.value;Et!=null?Se(k,!!F.multiple,Et,!1):nt!==!!F.multiple&&(F.defaultValue!=null?Se(k,!!F.multiple,F.defaultValue,!0):Se(k,!!F.multiple,F.multiple?[]:"",!1))}k[Gc]=F}catch(Ft){Bs(d,d.return,Ft)}}break;case 6:if(al(m,d),Jl(d),I&4){if(d.stateNode===null)throw Error(t(162));k=d.stateNode,F=d.memoizedProps;try{k.nodeValue=F}catch(Ft){Bs(d,d.return,Ft)}}break;case 3:if(al(m,d),Jl(d),I&4&&b!==null&&b.memoizedState.isDehydrated)try{md(m.containerInfo)}catch(Ft){Bs(d,d.return,Ft)}break;case 4:al(m,d),Jl(d);break;case 13:al(m,d),Jl(d),k=d.child,k.flags&8192&&(F=k.memoizedState!==null,k.stateNode.isHidden=F,!F||k.alternate!==null&&k.alternate.memoizedState!==null||(TT=Ct())),I&4&&uk(d);break;case 22:if(st=b!==null&&b.memoizedState!==null,d.mode&1?(Ni=(Le=Ni)||st,al(m,d),Ni=Le):al(m,d),Jl(d),I&8192){if(Le=d.memoizedState!==null,(d.stateNode.isHidden=Le)&&!st&&(d.mode&1)!==0)for(Mt=d,st=d.child;st!==null;){for(rt=Mt=st;Mt!==null;){switch(nt=Mt,Et=nt.child,nt.tag){case 0:case 11:case 14:case 15:Ry(4,nt,nt.return);break;case 1:im(nt,nt.return);var Pt=nt.stateNode;if(typeof Pt.componentWillUnmount=="function"){I=nt,b=nt.return;try{m=I,Pt.props=m.memoizedProps,Pt.state=m.memoizedState,Pt.componentWillUnmount()}catch(Ft){Bs(I,b,Ft)}}break;case 5:im(nt,nt.return);break;case 22:if(nt.memoizedState!==null){fk(rt);continue}}Et!==null?(Et.return=nt,Mt=Et):fk(rt)}st=st.sibling}e:for(st=null,rt=d;;){if(rt.tag===5){if(st===null){st=rt;try{k=rt.stateNode,Le?(F=k.style,typeof F.setProperty=="function"?F.setProperty("display","none","important"):F.display="none"):(le=rt.stateNode,me=rt.memoizedProps.style,j=me!=null&&me.hasOwnProperty("display")?me.display:null,le.style.display=qt("display",j))}catch(Ft){Bs(d,d.return,Ft)}}}else if(rt.tag===6){if(st===null)try{rt.stateNode.nodeValue=Le?"":rt.memoizedProps}catch(Ft){Bs(d,d.return,Ft)}}else if((rt.tag!==22&&rt.tag!==23||rt.memoizedState===null||rt===d)&&rt.child!==null){rt.child.return=rt,rt=rt.child;continue}if(rt===d)break e;for(;rt.sibling===null;){if(rt.return===null||rt.return===d)break e;st===rt&&(st=null),rt=rt.return}st===rt&&(st=null),rt.sibling.return=rt.return,rt=rt.sibling}}break;case 19:al(m,d),Jl(d),I&4&&uk(d);break;case 21:break;default:al(m,d),Jl(d)}}function Jl(d){var m=d.flags;if(m&2){try{e:{for(var b=d.return;b!==null;){if(ok(b)){var I=b;break e}b=b.return}throw Error(t(160))}switch(I.tag){case 5:var k=I.stateNode;I.flags&32&&(Ke(k,""),I.flags&=-33);var F=ak(d);ST(d,F,k);break;case 3:case 4:var j=I.stateNode.containerInfo,le=ak(d);wT(d,le,j);break;default:throw Error(t(161))}}catch(me){Bs(d,d.return,me)}d.flags&=-3}m&4096&&(d.flags&=-4097)}function kW(d,m,b){Mt=d,hk(d)}function hk(d,m,b){for(var I=(d.mode&1)!==0;Mt!==null;){var k=Mt,F=k.child;if(k.tag===22&&I){var j=k.memoizedState!==null||u1;if(!j){var le=k.alternate,me=le!==null&&le.memoizedState!==null||Ni;le=u1;var Le=Ni;if(u1=j,(Ni=me)&&!Le)for(Mt=k;Mt!==null;)j=Mt,me=j.child,j.tag===22&&j.memoizedState!==null?pk(k):me!==null?(me.return=j,Mt=me):pk(k);for(;F!==null;)Mt=F,hk(F),F=F.sibling;Mt=k,u1=le,Ni=Le}dk(d)}else(k.subtreeFlags&8772)!==0&&F!==null?(F.return=k,Mt=F):dk(d)}}function dk(d){for(;Mt!==null;){var m=Mt;if((m.flags&8772)!==0){var b=m.alternate;try{if((m.flags&8772)!==0)switch(m.tag){case 0:case 11:case 15:Ni||c1(5,m);break;case 1:var I=m.stateNode;if(m.flags&4&&!Ni)if(b===null)I.componentDidMount();else{var k=m.elementType===m.type?b.memoizedProps:Yo(m.type,b.memoizedProps);I.componentDidUpdate(k,b.memoizedState,I.__reactInternalSnapshotBeforeUpdate)}var F=m.updateQueue;F!==null&&Ls(m,F,I);break;case 3:var j=m.updateQueue;if(j!==null){if(b=null,m.child!==null)switch(m.child.tag){case 5:b=m.child.stateNode;break;case 1:b=m.child.stateNode}Ls(m,j,b)}break;case 5:var le=m.stateNode;if(b===null&&m.flags&4){b=le;var me=m.memoizedProps;switch(m.type){case"button":case"input":case"select":case"textarea":me.autoFocus&&b.focus();break;case"img":me.src&&(b.src=me.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(m.memoizedState===null){var Le=m.alternate;if(Le!==null){var st=Le.memoizedState;if(st!==null){var rt=st.dehydrated;rt!==null&&md(rt)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}Ni||m.flags&512&&vT(m)}catch(nt){Bs(m,m.return,nt)}}if(m===d){Mt=null;break}if(b=m.sibling,b!==null){b.return=m.return,Mt=b;break}Mt=m.return}}function fk(d){for(;Mt!==null;){var m=Mt;if(m===d){Mt=null;break}var b=m.sibling;if(b!==null){b.return=m.return,Mt=b;break}Mt=m.return}}function pk(d){for(;Mt!==null;){var m=Mt;try{switch(m.tag){case 0:case 11:case 15:var b=m.return;try{c1(4,m)}catch(me){Bs(m,b,me)}break;case 1:var I=m.stateNode;if(typeof I.componentDidMount=="function"){var k=m.return;try{I.componentDidMount()}catch(me){Bs(m,k,me)}}var F=m.return;try{vT(m)}catch(me){Bs(m,F,me)}break;case 5:var j=m.return;try{vT(m)}catch(me){Bs(m,j,me)}}}catch(me){Bs(m,m.return,me)}if(m===d){Mt=null;break}var le=m.sibling;if(le!==null){le.return=m.return,Mt=le;break}Mt=m.return}}var RW=Math.ceil,h1=C.ReactCurrentDispatcher,bT=C.ReactCurrentOwner,Sa=C.ReactCurrentBatchConfig,Vn=0,Wr=null,pr=null,fi=0,ea=0,om=Is(0),Mr=0,Dy=null,Vd=0,d1=0,_T=0,Py=null,So=null,TT=0,am=1/0,Hu=null,f1=!1,CT=null,rh=null,p1=!1,ih=null,m1=0,Ly=0,ET=null,g1=-1,y1=0;function Ki(){return(Vn&6)!==0?Ct():g1!==-1?g1:g1=Ct()}function oh(d){return(d.mode&1)===0?1:(Vn&2)!==0&&fi!==0?fi&-fi:pT.transition!==null?(y1===0&&(y1=wi()),y1):(d=$n,d!==0||(d=window.event,d=d===void 0?16:Pv(d.type)),d)}function ll(d,m,b,I){if(50<Ly)throw Ly=0,ET=null,Error(t(185));hd(d,b,I),((Vn&2)===0||d!==Wr)&&(d===Wr&&((Vn&2)===0&&(d1|=b),Mr===4&&ah(d,fi)),bo(d,I),b===1&&Vn===0&&(m.mode&1)===0&&(am=Ct()+500,Md&&ga()))}function bo(d,m){var b=d.callbackNode;Er(d,m);var I=Bi(d,d===Wr?fi:0);if(I===0)b!==null&&bt(b),d.callbackNode=null,d.callbackPriority=0;else if(m=I&-I,d.callbackPriority!==m){if(b!=null&&bt(b),m===1)d.tag===0?qv(gk.bind(null,d)):kd(gk.bind(null,d)),fT(function(){(Vn&6)===0&&ga()}),b=null;else{switch(Nc(I)){case 1:b=en;break;case 4:b=nn;break;case 16:b=ts;break;case 536870912:b=ns;break;default:b=ts}b=Tk(b,mk.bind(null,d))}d.callbackPriority=m,d.callbackNode=b}}function mk(d,m){if(g1=-1,y1=0,(Vn&6)!==0)throw Error(t(327));var b=d.callbackNode;if(lm()&&d.callbackNode!==b)return null;var I=Bi(d,d===Wr?fi:0);if(I===0)return null;if((I&30)!==0||(I&d.expiredLanes)!==0||m)m=x1(d,I);else{m=I;var k=Vn;Vn|=2;var F=xk();(Wr!==d||fi!==m)&&(Hu=null,am=Ct()+500,Gd(d,m));do try{LW();break}catch(le){yk(d,le)}while(!0);Xc(),h1.current=F,Vn=k,pr!==null?m=0:(Wr=null,fi=0,m=Mr)}if(m!==0){if(m===2&&(k=Pl(d),k!==0&&(I=k,m=IT(d,k))),m===1)throw b=Dy,Gd(d,0),ah(d,I),bo(d,Ct()),b;if(m===6)ah(d,I);else{if(k=d.current.alternate,(I&30)===0&&!DW(k)&&(m=x1(d,I),m===2&&(F=Pl(d),F!==0&&(I=F,m=IT(d,F))),m===1))throw b=Dy,Gd(d,0),ah(d,I),bo(d,Ct()),b;switch(d.finishedWork=k,d.finishedLanes=I,m){case 0:case 1:throw Error(t(345));case 2:Hd(d,So,Hu);break;case 3:if(ah(d,I),(I&130023424)===I&&(m=TT+500-Ct(),10<m)){if(Bi(d,0)!==0)break;if(k=d.suspendedLanes,(k&I)!==I){Ki(),d.pingedLanes|=d.suspendedLanes&k;break}d.timeoutHandle=my(Hd.bind(null,d,So,Hu),m);break}Hd(d,So,Hu);break;case 4:if(ah(d,I),(I&4194240)===I)break;for(m=d.eventTimes,k=-1;0<I;){var j=31-Cs(I);F=1<<j,j=m[j],j>k&&(k=j),I&=~F}if(I=k,I=Ct()-I,I=(120>I?120:480>I?480:1080>I?1080:1920>I?1920:3e3>I?3e3:4320>I?4320:1960*RW(I/1960))-I,10<I){d.timeoutHandle=my(Hd.bind(null,d,So,Hu),I);break}Hd(d,So,Hu);break;case 5:Hd(d,So,Hu);break;default:throw Error(t(329))}}}return bo(d,Ct()),d.callbackNode===b?mk.bind(null,d):null}function IT(d,m){var b=Py;return d.current.memoizedState.isDehydrated&&(Gd(d,m).flags|=256),d=x1(d,m),d!==2&&(m=So,So=b,m!==null&&NT(m)),d}function NT(d){So===null?So=d:So.push.apply(So,d)}function DW(d){for(var m=d;;){if(m.flags&16384){var b=m.updateQueue;if(b!==null&&(b=b.stores,b!==null))for(var I=0;I<b.length;I++){var k=b[I],F=k.getSnapshot;k=k.value;try{if(!Wi(F(),k))return!1}catch{return!1}}}if(b=m.child,m.subtreeFlags&16384&&b!==null)b.return=m,m=b;else{if(m===d)break;for(;m.sibling===null;){if(m.return===null||m.return===d)return!0;m=m.return}m.sibling.return=m.return,m=m.sibling}}return!0}function ah(d,m){for(m&=~_T,m&=~d1,d.suspendedLanes|=m,d.pingedLanes&=~m,d=d.expirationTimes;0<m;){var b=31-Cs(m),I=1<<b;d[b]=-1,m&=~I}}function gk(d){if((Vn&6)!==0)throw Error(t(327));lm();var m=Bi(d,0);if((m&1)===0)return bo(d,Ct()),null;var b=x1(d,m);if(d.tag!==0&&b===2){var I=Pl(d);I!==0&&(m=I,b=IT(d,I))}if(b===1)throw b=Dy,Gd(d,0),ah(d,m),bo(d,Ct()),b;if(b===6)throw Error(t(345));return d.finishedWork=d.current.alternate,d.finishedLanes=m,Hd(d,So,Hu),bo(d,Ct()),null}function AT(d,m){var b=Vn;Vn|=1;try{return d(m)}finally{Vn=b,Vn===0&&(am=Ct()+500,Md&&ga())}}function Wd(d){ih!==null&&ih.tag===0&&(Vn&6)===0&&lm();var m=Vn;Vn|=1;var b=Sa.transition,I=$n;try{if(Sa.transition=null,$n=1,d)return d()}finally{$n=I,Sa.transition=b,Vn=m,(Vn&6)===0&&ga()}}function MT(){ea=om.current,rs(om)}function Gd(d,m){d.finishedWork=null,d.finishedLanes=0;var b=d.timeoutHandle;if(b!==-1&&(d.timeoutHandle=-1,gy(b)),pr!==null)for(b=pr.return;b!==null;){var I=b;switch(tl(I),I.tag){case 1:I=I.type.childContextTypes,I!=null&&Nd();break;case 3:xa(),rs(ii),rs(Nr),Ei();break;case 5:Qc(I);break;case 4:xa();break;case 13:rs(is);break;case 19:rs(is);break;case 10:qc(I.type._context);break;case 22:case 23:MT()}b=b.return}if(Wr=d,pr=d=lh(d.current,null),fi=ea=m,Mr=0,Dy=null,_T=d1=Vd=0,So=Py=null,Zo!==null){for(m=0;m<Zo.length;m++)if(b=Zo[m],I=b.interleaved,I!==null){b.interleaved=null;var k=I.next,F=b.pending;if(F!==null){var j=F.next;F.next=k,I.next=j}b.pending=I}Zo=null}return d}function yk(d,m){do{var b=pr;try{if(Xc(),Wu.current=y,Qo){for(var I=cs.memoizedState;I!==null;){var k=I.queue;k!==null&&(k.pending=null),I=I.next}Qo=!1}if(ql=0,fr=Os=cs=null,eh=!1,th=0,bT.current=null,b===null||b.return===null){Mr=1,Dy=m,pr=null;break}e:{var F=d,j=b.return,le=b,me=m;if(m=fi,le.flags|=32768,me!==null&&typeof me=="object"&&typeof me.then=="function"){var Le=me,st=le,rt=st.tag;if((st.mode&1)===0&&(rt===0||rt===11||rt===15)){var nt=st.alternate;nt?(st.updateQueue=nt.updateQueue,st.memoizedState=nt.memoizedState,st.lanes=nt.lanes):(st.updateQueue=null,st.memoizedState=null)}var Et=cn(j);if(Et!==null){Et.flags&=-257,Xt(Et,j,le,F,m),Et.mode&1&&Nt(F,Le,m),m=Et,me=Le;var Pt=m.updateQueue;if(Pt===null){var Ft=new Set;Ft.add(me),m.updateQueue=Ft}else Pt.add(me);break e}else{if((m&1)===0){Nt(F,Le,m),kT();break e}me=Error(t(426))}}else if(us&&le.mode&1){var tr=cn(j);if(tr!==null){(tr.flags&65536)===0&&(tr.flags|=256),Xt(tr,j,le,F,m),jc(O(me,le));break e}}F=me=O(me,le),Mr!==4&&(Mr=2),Py===null?Py=[F]:Py.push(F),F=j;do{switch(F.tag){case 3:F.flags|=65536,m&=-m,F.lanes|=m;var Ne=Ge(F,me,m);pn(F,Ne);break e;case 1:le=me;var xe=F.type,Me=F.stateNode;if((F.flags&128)===0&&(typeof xe.getDerivedStateFromError=="function"||Me!==null&&typeof Me.componentDidCatch=="function"&&(rh===null||!rh.has(Me)))){F.flags|=65536,m&=-m,F.lanes|=m;var lt=ot(F,le,m);pn(F,lt);break e}}F=F.return}while(F!==null)}wk(b)}catch(Ut){m=Ut,pr===b&&b!==null&&(pr=b=b.return);continue}break}while(!0)}function xk(){var d=h1.current;return h1.current=y,d===null?y:d}function kT(){(Mr===0||Mr===3||Mr===2)&&(Mr=4),Wr===null||(Vd&268435455)===0&&(d1&268435455)===0||ah(Wr,fi)}function x1(d,m){var b=Vn;Vn|=2;var I=xk();(Wr!==d||fi!==m)&&(Hu=null,Gd(d,m));do try{PW();break}catch(k){yk(d,k)}while(!0);if(Xc(),Vn=b,h1.current=I,pr!==null)throw Error(t(261));return Wr=null,fi=0,Mr}function PW(){for(;pr!==null;)vk(pr)}function LW(){for(;pr!==null&&!Vt();)vk(pr)}function vk(d){var m=_k(d.alternate,d,ea);d.memoizedProps=d.pendingProps,m===null?wk(d):pr=m,bT.current=null}function wk(d){var m=d;do{var b=m.alternate;if(d=m.return,(m.flags&32768)===0){if(b=IW(b,m,ea),b!==null){pr=b;return}}else{if(b=NW(b,m),b!==null){b.flags&=32767,pr=b;return}if(d!==null)d.flags|=32768,d.subtreeFlags=0,d.deletions=null;else{Mr=6,pr=null;return}}if(m=m.sibling,m!==null){pr=m;return}pr=m=d}while(m!==null);Mr===0&&(Mr=5)}function Hd(d,m,b){var I=$n,k=Sa.transition;try{Sa.transition=null,$n=1,OW(d,m,b,I)}finally{Sa.transition=k,$n=I}return null}function OW(d,m,b,I){do lm();while(ih!==null);if((Vn&6)!==0)throw Error(t(327));b=d.finishedWork;var k=d.finishedLanes;if(b===null)return null;if(d.finishedWork=null,d.finishedLanes=0,b===d.current)throw Error(t(177));d.callbackNode=null,d.callbackPriority=0;var F=b.lanes|b.childLanes;if(uT(d,F),d===Wr&&(pr=Wr=null,fi=0),(b.subtreeFlags&2064)===0&&(b.flags&2064)===0||p1||(p1=!0,Tk(ts,function(){return lm(),null})),F=(b.flags&15990)!==0,(b.subtreeFlags&15990)!==0||F){F=Sa.transition,Sa.transition=null;var j=$n;$n=1;var le=Vn;Vn|=4,bT.current=null,MW(d,b),ck(b,d),ar(fy),lo=!!Wc,fy=Wc=null,d.current=b,kW(b),Zt(),Vn=le,$n=j,Sa.transition=F}else d.current=b;if(p1&&(p1=!1,ih=d,m1=k),F=d.pendingLanes,F===0&&(rh=null),At(b.stateNode),bo(d,Ct()),m!==null)for(I=d.onRecoverableError,b=0;b<m.length;b++)k=m[b],I(k.value,{componentStack:k.stack,digest:k.digest});if(f1)throw f1=!1,d=CT,CT=null,d;return(m1&1)!==0&&d.tag!==0&&lm(),F=d.pendingLanes,(F&1)!==0?d===ET?Ly++:(Ly=0,ET=d):Ly=0,ga(),null}function lm(){if(ih!==null){var d=Nc(m1),m=Sa.transition,b=$n;try{if(Sa.transition=null,$n=16>d?16:d,ih===null)var I=!1;else{if(d=ih,ih=null,m1=0,(Vn&6)!==0)throw Error(t(331));var k=Vn;for(Vn|=4,Mt=d.current;Mt!==null;){var F=Mt,j=F.child;if((Mt.flags&16)!==0){var le=F.deletions;if(le!==null){for(var me=0;me<le.length;me++){var Le=le[me];for(Mt=Le;Mt!==null;){var st=Mt;switch(st.tag){case 0:case 11:case 15:Ry(8,st,F)}var rt=st.child;if(rt!==null)rt.return=st,Mt=rt;else for(;Mt!==null;){st=Mt;var nt=st.sibling,Et=st.return;if(ik(st),st===Le){Mt=null;break}if(nt!==null){nt.return=Et,Mt=nt;break}Mt=Et}}}var Pt=F.alternate;if(Pt!==null){var Ft=Pt.child;if(Ft!==null){Pt.child=null;do{var tr=Ft.sibling;Ft.sibling=null,Ft=tr}while(Ft!==null)}}Mt=F}}if((F.subtreeFlags&2064)!==0&&j!==null)j.return=F,Mt=j;else e:for(;Mt!==null;){if(F=Mt,(F.flags&2048)!==0)switch(F.tag){case 0:case 11:case 15:Ry(9,F,F.return)}var Ne=F.sibling;if(Ne!==null){Ne.return=F.return,Mt=Ne;break e}Mt=F.return}}var xe=d.current;for(Mt=xe;Mt!==null;){j=Mt;var Me=j.child;if((j.subtreeFlags&2064)!==0&&Me!==null)Me.return=j,Mt=Me;else e:for(j=xe;Mt!==null;){if(le=Mt,(le.flags&2048)!==0)try{switch(le.tag){case 0:case 11:case 15:c1(9,le)}}catch(Ut){Bs(le,le.return,Ut)}if(le===j){Mt=null;break e}var lt=le.sibling;if(lt!==null){lt.return=le.return,Mt=lt;break e}Mt=le.return}}if(Vn=k,ga(),zt&&typeof zt.onPostCommitFiberRoot=="function")try{zt.onPostCommitFiberRoot(Rs,d)}catch{}I=!0}return I}finally{$n=b,Sa.transition=m}}return!1}function Sk(d,m,b){m=O(b,m),m=Ge(d,m,1),d=ya(d,m,1),m=Ki(),d!==null&&(hd(d,1,m),bo(d,m))}function Bs(d,m,b){if(d.tag===3)Sk(d,d,b);else for(;m!==null;){if(m.tag===3){Sk(m,d,b);break}else if(m.tag===1){var I=m.stateNode;if(typeof m.type.getDerivedStateFromError=="function"||typeof I.componentDidCatch=="function"&&(rh===null||!rh.has(I))){d=O(b,d),d=ot(m,d,1),m=ya(m,d,1),d=Ki(),m!==null&&(hd(m,1,d),bo(m,d));break}}m=m.return}}function FW(d,m,b){var I=d.pingCache;I!==null&&I.delete(m),m=Ki(),d.pingedLanes|=d.suspendedLanes&b,Wr===d&&(fi&b)===b&&(Mr===4||Mr===3&&(fi&130023424)===fi&&500>Ct()-TT?Gd(d,0):_T|=b),bo(d,m)}function bk(d,m){m===0&&((d.mode&1)===0?m=1:(m=Ds,Ds<<=1,(Ds&130023424)===0&&(Ds=4194304)));var b=Ki();d=Jo(d,m),d!==null&&(hd(d,m,b),bo(d,b))}function $W(d){var m=d.memoizedState,b=0;m!==null&&(b=m.retryLane),bk(d,b)}function zW(d,m){var b=0;switch(d.tag){case 13:var I=d.stateNode,k=d.memoizedState;k!==null&&(b=k.retryLane);break;case 19:I=d.stateNode;break;default:throw Error(t(314))}I!==null&&I.delete(m),bk(d,b)}var _k;_k=function(d,m,b){if(d!==null)if(d.memoizedProps!==m.pendingProps||ii.current)_t=!0;else{if((d.lanes&b)===0&&(m.flags&128)===0)return _t=!1,EW(d,m,b);_t=(d.flags&131072)!==0}else _t=!1,us&&(m.flags&1048576)!==0&&Sy(m,Wp,m.index);switch(m.lanes=0,m.tag){case 2:var I=m.type;l1(d,m),d=m.pendingProps;var k=Lu(m,Nr.current);nl(m,b),k=Jp(null,m,I,d,k,b);var F=Od();return m.flags|=1,typeof k=="object"&&k!==null&&typeof k.render=="function"&&k.$$typeof===void 0?(m.tag=1,m.memoizedState=null,m.updateQueue=null,Br(I)?(F=!0,Ou(m)):F=!1,m.memoizedState=k.state!==null&&k.state!==void 0?k.state:null,Ld(m),k.updater=rl,m.stateNode=k,k._reactInternals=m,Zc(m,I,d,b),m=on(null,m,I,!0,F,b)):(m.tag=0,us&&F&&by(m),Gn(null,m,k,b),m=m.child),m;case 16:I=m.elementType;e:{switch(l1(d,m),d=m.pendingProps,k=I._init,I=k(I._payload),m.type=I,k=m.tag=BW(I),d=Yo(I,d),k){case 0:m=Ot(null,m,I,d,b);break e;case 1:m=fn(null,m,I,d,b);break e;case 11:m=qi(null,m,I,d,b);break e;case 14:m=ke(null,m,I,Yo(I.type,d),b);break e}throw Error(t(306,I,""))}return m;case 0:return I=m.type,k=m.pendingProps,k=m.elementType===I?k:Yo(I,k),Ot(d,m,I,k,b);case 1:return I=m.type,k=m.pendingProps,k=m.elementType===I?k:Yo(I,k),fn(d,m,I,k,b);case 3:e:{if(Ln(m),d===null)throw Error(t(387));I=m.pendingProps,F=m.memoizedState,k=F.element,Kv(d,m),Ss(m,I,null,b);var j=m.memoizedState;if(I=j.element,F.isDehydrated)if(F={element:I,isDehydrated:!1,cache:j.cache,pendingSuspenseBoundaries:j.pendingSuspenseBoundaries,transitions:j.transitions},m.updateQueue.baseState=F,m.memoizedState=F,m.flags&256){k=O(Error(t(423)),m),m=er(d,m,I,b,k);break e}else if(I!==k){k=O(Error(t(424)),m),m=er(d,m,I,b,k);break e}else for(ai=Ya(m.stateNode.containerInfo.firstChild),Ar=m,us=!0,go=null,b=Vu(m,null,I,b),m.child=b;b;)b.flags=b.flags&-3|4096,b=b.sibling;else{if(Wl(),I===k){m=Gu(d,m,b);break e}Gn(d,m,I,b)}m=m.child}return m;case 5:return Yp(m),d===null&&Hp(m),I=m.type,k=m.pendingProps,F=d!==null?d.memoizedProps:null,j=k.children,py(I,k)?j=null:F!==null&&py(I,F)&&(m.flags|=32),wt(d,m),Gn(d,m,j,b),m.child;case 6:return d===null&&Hp(m),null;case 13:return o1(d,m,b);case 4:return Jc(m,m.stateNode.containerInfo),I=m.pendingProps,d===null?m.child=Hl(m,null,I,b):Gn(d,m,I,b),m.child;case 11:return I=m.type,k=m.pendingProps,k=m.elementType===I?k:Yo(I,k),qi(d,m,I,k,b);case 7:return Gn(d,m,m.pendingProps,b),m.child;case 8:return Gn(d,m,m.pendingProps.children,b),m.child;case 12:return Gn(d,m,m.pendingProps.children,b),m.child;case 10:e:{if(I=m.type._context,k=m.pendingProps,F=m.memoizedProps,j=k.value,Kn(Rd,I._currentValue),I._currentValue=j,F!==null)if(Wi(F.value,j)){if(F.children===k.children&&!ii.current){m=Gu(d,m,b);break e}}else for(F=m.child,F!==null&&(F.return=m);F!==null;){var le=F.dependencies;if(le!==null){j=F.child;for(var me=le.firstContext;me!==null;){if(me.context===I){if(F.tag===1){me=yo(-1,b&-b),me.tag=2;var Le=F.updateQueue;if(Le!==null){Le=Le.shared;var st=Le.pending;st===null?me.next=me:(me.next=st.next,st.next=me),Le.pending=me}}F.lanes|=b,me=F.alternate,me!==null&&(me.lanes|=b),Kc(F.return,b,m),le.lanes|=b;break}me=me.next}}else if(F.tag===10)j=F.type===m.type?null:F.child;else if(F.tag===18){if(j=F.return,j===null)throw Error(t(341));j.lanes|=b,le=j.alternate,le!==null&&(le.lanes|=b),Kc(j,b,m),j=F.sibling}else j=F.child;if(j!==null)j.return=F;else for(j=F;j!==null;){if(j===m){j=null;break}if(F=j.sibling,F!==null){F.return=j.return,j=F;break}j=j.return}F=j}Gn(d,m,k.children,b),m=m.child}return m;case 9:return k=m.type,I=m.pendingProps.children,nl(m,b),k=li(k),I=I(k),m.flags|=1,Gn(d,m,I,b),m.child;case 14:return I=m.type,k=Yo(I,m.pendingProps),k=Yo(I.type,k),ke(d,m,I,k,b);case 15:return we(d,m,m.type,m.pendingProps,b);case 17:return I=m.type,k=m.pendingProps,k=m.elementType===I?k:Yo(I,k),l1(d,m),m.tag=1,Br(I)?(d=!0,Ou(m)):d=!1,nl(m,b),Yc(m,I,k),Zc(m,I,k,b),on(null,m,I,!0,d,b);case 19:return ek(d,m,b);case 22:return ze(d,m,b)}throw Error(t(156,m.tag))};function Tk(d,m){return Pe(d,m)}function UW(d,m,b,I){this.tag=d,this.key=b,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=m,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=I,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ba(d,m,b,I){return new UW(d,m,b,I)}function RT(d){return d=d.prototype,!(!d||!d.isReactComponent)}function BW(d){if(typeof d=="function")return RT(d)?1:0;if(d!=null){if(d=d.$$typeof,d===G)return 11;if(d===H)return 14}return 2}function lh(d,m){var b=d.alternate;return b===null?(b=ba(d.tag,m,d.key,d.mode),b.elementType=d.elementType,b.type=d.type,b.stateNode=d.stateNode,b.alternate=d,d.alternate=b):(b.pendingProps=m,b.type=d.type,b.flags=0,b.subtreeFlags=0,b.deletions=null),b.flags=d.flags&14680064,b.childLanes=d.childLanes,b.lanes=d.lanes,b.child=d.child,b.memoizedProps=d.memoizedProps,b.memoizedState=d.memoizedState,b.updateQueue=d.updateQueue,m=d.dependencies,b.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext},b.sibling=d.sibling,b.index=d.index,b.ref=d.ref,b}function v1(d,m,b,I,k,F){var j=2;if(I=d,typeof d=="function")RT(d)&&(j=1);else if(typeof d=="string")j=5;else e:switch(d){case P:return jd(b.children,k,F,m);case $:j=8,k|=8;break;case R:return d=ba(12,b,m,k|2),d.elementType=R,d.lanes=F,d;case Q:return d=ba(13,b,m,k),d.elementType=Q,d.lanes=F,d;case W:return d=ba(19,b,m,k),d.elementType=W,d.lanes=F,d;case ie:return w1(b,k,F,m);default:if(typeof d=="object"&&d!==null)switch(d.$$typeof){case D:j=10;break e;case L:j=9;break e;case G:j=11;break e;case H:j=14;break e;case J:j=16,I=null;break e}throw Error(t(130,d==null?d:typeof d,""))}return m=ba(j,b,m,k),m.elementType=d,m.type=I,m.lanes=F,m}function jd(d,m,b,I){return d=ba(7,d,I,m),d.lanes=b,d}function w1(d,m,b,I){return d=ba(22,d,I,m),d.elementType=ie,d.lanes=b,d.stateNode={isHidden:!1},d}function DT(d,m,b){return d=ba(6,d,null,m),d.lanes=b,d}function PT(d,m,b){return m=ba(4,d.children!==null?d.children:[],d.key,m),m.lanes=b,m.stateNode={containerInfo:d.containerInfo,pendingChildren:null,implementation:d.implementation},m}function VW(d,m,b,I,k){this.tag=m,this.containerInfo=d,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Ec(0),this.expirationTimes=Ec(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ec(0),this.identifierPrefix=I,this.onRecoverableError=k,this.mutableSourceEagerHydrationData=null}function LT(d,m,b,I,k,F,j,le,me){return d=new VW(d,m,b,le,me),m===1?(m=1,F===!0&&(m|=8)):m=0,F=ba(3,null,null,m),d.current=F,F.stateNode=d,F.memoizedState={element:I,isDehydrated:b,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ld(F),d}function WW(d,m,b){var I=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:M,key:I==null?null:""+I,children:d,containerInfo:m,implementation:b}}function Ck(d){if(!d)return Ja;d=d._reactInternals;e:{if(Va(d)!==d||d.tag!==1)throw Error(t(170));var m=d;do{switch(m.tag){case 3:m=m.stateNode.context;break e;case 1:if(Br(m.type)){m=m.stateNode.__reactInternalMemoizedMergedChildContext;break e}}m=m.return}while(m!==null);throw Error(t(171))}if(d.tag===1){var b=d.type;if(Br(b))return Ad(d,b,m)}return m}function Ek(d,m,b,I,k,F,j,le,me){return d=LT(b,I,!0,d,k,F,j,le,me),d.context=Ck(null),b=d.current,I=Ki(),k=oh(b),F=yo(I,k),F.callback=m??null,ya(b,F,k),d.current.lanes=k,hd(d,k,I),bo(d,I),d}function S1(d,m,b,I){var k=m.current,F=Ki(),j=oh(k);return b=Ck(b),m.context===null?m.context=b:m.pendingContext=b,m=yo(F,j),m.payload={element:d},I=I===void 0?null:I,I!==null&&(m.callback=I),d=ya(k,m,j),d!==null&&(ll(d,k,j,F),ps(d,k,j)),j}function b1(d){if(d=d.current,!d.child)return null;switch(d.child.tag){case 5:return d.child.stateNode;default:return d.child.stateNode}}function Ik(d,m){if(d=d.memoizedState,d!==null&&d.dehydrated!==null){var b=d.retryLane;d.retryLane=b!==0&&b<m?b:m}}function OT(d,m){Ik(d,m),(d=d.alternate)&&Ik(d,m)}function GW(){return null}var Nk=typeof reportError=="function"?reportError:function(d){console.error(d)};function FT(d){this._internalRoot=d}_1.prototype.render=FT.prototype.render=function(d){var m=this._internalRoot;if(m===null)throw Error(t(409));S1(d,m,null,null)},_1.prototype.unmount=FT.prototype.unmount=function(){var d=this._internalRoot;if(d!==null){this._internalRoot=null;var m=d.containerInfo;Wd(function(){S1(null,d,null,null)}),m[Hi]=null}};function _1(d){this._internalRoot=d}_1.prototype.unstable_scheduleHydration=function(d){if(d){var m=lp();d={blockedOn:null,target:d,priority:m};for(var b=0;b<Ll.length&&m!==0&&m<Ll[b].priority;b++);Ll.splice(b,0,d),b===0&&hp(d)}};function $T(d){return!(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)}function T1(d){return!(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11&&(d.nodeType!==8||d.nodeValue!==" react-mount-point-unstable "))}function Ak(){}function HW(d,m,b,I,k){if(k){if(typeof I=="function"){var F=I;I=function(){var Le=b1(j);F.call(Le)}}var j=Ek(m,I,d,0,null,!1,!1,"",Ak);return d._reactRootContainer=j,d[Hi]=j.current,Bc(d.nodeType===8?d.parentNode:d),Wd(),j}for(;k=d.lastChild;)d.removeChild(k);if(typeof I=="function"){var le=I;I=function(){var Le=b1(me);le.call(Le)}}var me=LT(d,0,!1,null,null,!1,!1,"",Ak);return d._reactRootContainer=me,d[Hi]=me.current,Bc(d.nodeType===8?d.parentNode:d),Wd(function(){S1(m,me,b,I)}),me}function C1(d,m,b,I,k){var F=b._reactRootContainer;if(F){var j=F;if(typeof k=="function"){var le=k;k=function(){var me=b1(j);le.call(me)}}S1(m,j,d,k)}else j=HW(b,m,d,k,I);return b1(j)}dd=function(d){switch(d.tag){case 3:var m=d.stateNode;if(m.current.memoizedState.isDehydrated){var b=ls(m.pendingLanes);b!==0&&(Ic(m,b|1),bo(m,Ct()),(Vn&6)===0&&(am=Ct()+500,ga()))}break;case 13:Wd(function(){var I=Jo(d,1);if(I!==null){var k=Ki();ll(I,d,1,k)}}),OT(d,1)}},Yg=function(d){if(d.tag===13){var m=Jo(d,134217728);if(m!==null){var b=Ki();ll(m,d,134217728,b)}OT(d,134217728)}},Dv=function(d){if(d.tag===13){var m=oh(d),b=Jo(d,m);if(b!==null){var I=Ki();ll(b,d,m,I)}OT(d,m)}},lp=function(){return $n},up=function(d,m){var b=$n;try{return $n=d,m()}finally{$n=b}},ut=function(d,m,b){switch(m){case"input":if(at(d,b),m=b.name,b.type==="radio"&&m!=null){for(b=d;b.parentNode;)b=b.parentNode;for(b=b.querySelectorAll("input[name="+JSON.stringify(""+m)+'][type="radio"]'),m=0;m<b.length;m++){var I=b[m];if(I!==d&&I.form===d.form){var k=Up(I);if(!k)throw Error(t(90));ae(I),at(I,k)}}}break;case"textarea":je(d,b);break;case"select":m=b.value,m!=null&&Se(d,!!b.multiple,m,!1)}},Bn=AT,kn=Wd;var jW={usingClientEntryPoint:!1,Events:[Za,Ps,Up,Kt,Gt,AT]},Oy={findFiberByHostInstance:Vl,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},XW={bundleType:Oy.bundleType,version:Oy.version,rendererPackageName:Oy.rendererPackageName,rendererConfig:Oy.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:C.ReactCurrentDispatcher,findHostInstanceByFiber:function(d){return d=Fe(d),d===null?null:d.stateNode},findFiberByHostInstance:Oy.findFiberByHostInstance||GW,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var E1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!E1.isDisabled&&E1.supportsFiber)try{Rs=E1.inject(XW),zt=E1}catch{}}return _o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=jW,_o.createPortal=function(d,m){var b=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!$T(m))throw Error(t(200));return WW(d,m,null,b)},_o.createRoot=function(d,m){if(!$T(d))throw Error(t(299));var b=!1,I="",k=Nk;return m!=null&&(m.unstable_strictMode===!0&&(b=!0),m.identifierPrefix!==void 0&&(I=m.identifierPrefix),m.onRecoverableError!==void 0&&(k=m.onRecoverableError)),m=LT(d,1,!1,null,null,b,!1,I,k),d[Hi]=m.current,Bc(d.nodeType===8?d.parentNode:d),new FT(m)},_o.findDOMNode=function(d){if(d==null)return null;if(d.nodeType===1)return d;var m=d._reactInternals;if(m===void 0)throw typeof d.render=="function"?Error(t(188)):(d=Object.keys(d).join(","),Error(t(268,d)));return d=Fe(m),d=d===null?null:d.stateNode,d},_o.flushSync=function(d){return Wd(d)},_o.hydrate=function(d,m,b){if(!T1(m))throw Error(t(200));return C1(null,d,m,!0,b)},_o.hydrateRoot=function(d,m,b){if(!$T(d))throw Error(t(405));var I=b!=null&&b.hydratedSources||null,k=!1,F="",j=Nk;if(b!=null&&(b.unstable_strictMode===!0&&(k=!0),b.identifierPrefix!==void 0&&(F=b.identifierPrefix),b.onRecoverableError!==void 0&&(j=b.onRecoverableError)),m=Ek(m,null,d,1,b??null,k,!1,F,j),d[Hi]=m.current,Bc(d),I)for(d=0;d<I.length;d++)b=I[d],k=b._getVersion,k=k(b._source),m.mutableSourceEagerHydrationData==null?m.mutableSourceEagerHydrationData=[b,k]:m.mutableSourceEagerHydrationData.push(b,k);return new _1(m)},_o.render=function(d,m,b){if(!T1(m))throw Error(t(200));return C1(null,d,m,!1,b)},_o.unmountComponentAtNode=function(d){if(!T1(d))throw Error(t(40));return d._reactRootContainer?(Wd(function(){C1(null,null,d,!1,function(){d._reactRootContainer=null,d[Hi]=null})}),!0):!1},_o.unstable_batchedUpdates=AT,_o.unstable_renderSubtreeIntoContainer=function(d,m,b,I){if(!T1(b))throw Error(t(200));if(d==null||d._reactInternals===void 0)throw Error(t(38));return C1(d,m,b,!1,I)},_o.version="18.2.0-next-9e3b772b8-20220608",_o}var Fk;function sG(){if(Fk)return BT.exports;Fk=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),BT.exports=nG(),BT.exports}var $k;function rG(){if($k)return I1;$k=1;var n=sG();return I1.createRoot=n.createRoot,I1.hydrateRoot=n.hydrateRoot,I1}var iG=rG();const oG=Z0(iG);/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Q0="160",aG={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},lG={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},zL=0,lE=1,UL=2,uG=3,BL=0,WS=1,l0=2,pl=3,hc=0,no=1,su=2,cG=2,ac=0,_f=1,sS=2,uE=3,cE=4,VL=5,wh=100,WL=101,GL=102,hE=103,dE=104,HL=200,jL=201,XL=202,qL=203,rS=204,iS=205,KL=206,YL=207,ZL=208,JL=209,QL=210,e3=211,t3=212,n3=213,s3=214,r3=0,i3=1,o3=2,m0=3,a3=4,l3=5,u3=6,c3=7,ex=0,h3=1,d3=2,iu=0,f3=1,p3=2,m3=3,GS=4,g3=5,y3=6,fE="attached",x3="detached",HS=300,dc=301,kh=302,g0=303,y0=304,_g=306,Af=1e3,Pi=1001,x0=1002,sr=1003,oS=1004,hG=1004,u0=1005,dG=1005,rr=1006,Z2=1007,fG=1007,Rh=1008,pG=1008,ou=1009,v3=1010,w3=1011,jS=1012,J2=1013,ic=1014,xl=1015,rg=1016,Q2=1017,eI=1018,Th=1020,S3=1021,eo=1023,b3=1024,_3=1025,Ch=1026,Mf=1027,T3=1028,tI=1029,C3=1030,nI=1031,sI=1033,Fw=33776,$w=33777,zw=33778,Uw=33779,pE=35840,mE=35841,gE=35842,yE=35843,rI=36196,xE=37492,vE=37496,wE=37808,SE=37809,bE=37810,_E=37811,TE=37812,CE=37813,EE=37814,IE=37815,NE=37816,AE=37817,ME=37818,kE=37819,RE=37820,DE=37821,Bw=36492,PE=36494,LE=36495,E3=36283,OE=36284,FE=36285,$E=36286,I3=2200,N3=2201,A3=2202,v0=2300,w0=2301,Vw=2302,mf=2400,gf=2401,S0=2402,XS=2500,iI=2501,mG=0,gG=1,yG=2,oI=3e3,Eh=3001,M3=3200,k3=3201,Xh=0,R3=1,sa="",kr="srgb",du="srgb-linear",qS="display-p3",tx="display-p3-linear",b0="linear",ms="srgb",_0="rec709",T0="p3",xG=0,af=7680,vG=7681,wG=7682,SG=7683,bG=34055,_G=34056,TG=5386,CG=512,EG=513,IG=514,NG=515,AG=516,MG=517,kG=518,zE=519,D3=512,P3=513,L3=514,aI=515,O3=516,F3=517,$3=518,z3=519,C0=35044,RG=35048,DG=35040,PG=35045,LG=35049,OG=35041,FG=35046,$G=35050,zG=35042,UG="100",UE="300 es",aS=1035,vl=2e3,ig=2001;class xc{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const i=r.indexOf(t);i!==-1&&r.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const r=s.slice(0);for(let i=0,o=r.length;i<o;i++)r[i].call(this,e);e.target=null}}}const Ai=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let zk=1234567;const Tf=Math.PI/180,og=180/Math.PI;function oa(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(Ai[n&255]+Ai[n>>8&255]+Ai[n>>16&255]+Ai[n>>24&255]+"-"+Ai[e&255]+Ai[e>>8&255]+"-"+Ai[e>>16&15|64]+Ai[e>>24&255]+"-"+Ai[t&63|128]+Ai[t>>8&255]+"-"+Ai[t>>16&255]+Ai[t>>24&255]+Ai[s&255]+Ai[s>>8&255]+Ai[s>>16&255]+Ai[s>>24&255]).toLowerCase()}function Ws(n,e,t){return Math.max(e,Math.min(t,n))}function lI(n,e){return(n%e+e)%e}function BG(n,e,t,s,r){return s+(n-e)*(r-s)/(t-e)}function VG(n,e,t){return n!==e?(t-n)/(e-n):0}function c0(n,e,t){return(1-t)*n+t*e}function WG(n,e,t,s){return c0(n,e,1-Math.exp(-t*s))}function GG(n,e=1){return e-Math.abs(lI(n,e*2)-e)}function HG(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function jG(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function XG(n,e){return n+Math.floor(Math.random()*(e-n+1))}function qG(n,e){return n+Math.random()*(e-n)}function KG(n){return n*(.5-Math.random())}function YG(n){n!==void 0&&(zk=n);let e=zk+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function ZG(n){return n*Tf}function JG(n){return n*og}function BE(n){return(n&n-1)===0&&n!==0}function QG(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function lS(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function eH(n,e,t,s,r){const i=Math.cos,o=Math.sin,a=i(t/2),l=o(t/2),u=i((e+s)/2),c=o((e+s)/2),h=i((e-s)/2),f=o((e-s)/2),p=i((s-e)/2),g=o((s-e)/2);switch(r){case"XYX":n.set(a*c,l*h,l*f,a*u);break;case"YZY":n.set(l*f,a*c,l*h,a*u);break;case"ZXZ":n.set(l*h,l*f,a*c,a*u);break;case"XZX":n.set(a*c,l*g,l*p,a*u);break;case"YXY":n.set(l*p,a*c,l*g,a*u);break;case"ZYZ":n.set(l*g,l*p,a*c,a*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function Ao(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Sn(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const Qu={DEG2RAD:Tf,RAD2DEG:og,generateUUID:oa,clamp:Ws,euclideanModulo:lI,mapLinear:BG,inverseLerp:VG,lerp:c0,damp:WG,pingpong:GG,smoothstep:HG,smootherstep:jG,randInt:XG,randFloat:qG,randFloatSpread:KG,seededRandom:YG,degToRad:ZG,radToDeg:JG,isPowerOfTwo:BE,ceilPowerOfTwo:QG,floorPowerOfTwo:lS,setQuaternionFromProperEuler:eH,normalize:Sn,denormalize:Ao};class Je{constructor(e=0,t=0){Je.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6],this.y=r[1]*t+r[4]*s+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Ws(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),r=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*s-o*r+e.x,this.y=i*r+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class _n{constructor(e,t,s,r,i,o,a,l,u){_n.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,r,i,o,a,l,u)}set(e,t,s,r,i,o,a,l,u){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=i,c[5]=l,c[6]=s,c[7]=o,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,i=this.elements,o=s[0],a=s[3],l=s[6],u=s[1],c=s[4],h=s[7],f=s[2],p=s[5],g=s[8],S=r[0],x=r[3],w=r[6],_=r[1],T=r[4],C=r[7],N=r[2],M=r[5],P=r[8];return i[0]=o*S+a*_+l*N,i[3]=o*x+a*T+l*M,i[6]=o*w+a*C+l*P,i[1]=u*S+c*_+h*N,i[4]=u*x+c*T+h*M,i[7]=u*w+c*C+h*P,i[2]=f*S+p*_+g*N,i[5]=f*x+p*T+g*M,i[8]=f*w+p*C+g*P,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8];return t*o*c-t*a*u-s*i*c+s*a*l+r*i*u-r*o*l}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=c*o-a*u,f=a*l-c*i,p=u*i-o*l,g=t*h+s*f+r*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const S=1/g;return e[0]=h*S,e[1]=(r*u-c*s)*S,e[2]=(a*s-r*o)*S,e[3]=f*S,e[4]=(c*t-r*l)*S,e[5]=(r*i-a*t)*S,e[6]=p*S,e[7]=(s*l-u*t)*S,e[8]=(o*t-s*i)*S,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,r,i,o,a){const l=Math.cos(i),u=Math.sin(i);return this.set(s*l,s*u,-s*(l*o+u*a)+o+e,-r*u,r*l,-r*(-u*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(GT.makeScale(e,t)),this}rotate(e){return this.premultiply(GT.makeRotation(-e)),this}translate(e,t){return this.premultiply(GT.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<9;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const GT=new _n;function U3(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const tH={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Wm(n,e){return new tH[n](e)}function E0(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function B3(){const n=E0("canvas");return n.style.display="block",n}const Uk={};function h0(n){n in Uk||(Uk[n]=!0,console.warn(n))}const Bk=new _n().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),Vk=new _n().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),N1={[du]:{transfer:b0,primaries:_0,toReference:n=>n,fromReference:n=>n},[kr]:{transfer:ms,primaries:_0,toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[tx]:{transfer:b0,primaries:T0,toReference:n=>n.applyMatrix3(Vk),fromReference:n=>n.applyMatrix3(Bk)},[qS]:{transfer:ms,primaries:T0,toReference:n=>n.convertSRGBToLinear().applyMatrix3(Vk),fromReference:n=>n.applyMatrix3(Bk).convertLinearToSRGB()}},nH=new Set([du,tx]),Zn={enabled:!0,_workingColorSpace:du,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!nH.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const s=N1[e].toReference,r=N1[t].fromReference;return r(s(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return N1[n].primaries},getTransfer:function(n){return n===sa?b0:N1[n].transfer}};function Km(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function HT(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let um;class uI{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{um===void 0&&(um=E0("canvas")),um.width=e.width,um.height=e.height;const s=um.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),t=um}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=E0("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const r=s.getImageData(0,0,e.width,e.height),i=r.data;for(let o=0;o<i.length;o++)i[o]=Km(i[o]/255)*255;return s.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(Km(t[s]/255)*255):t[s]=Km(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let sH=0;class yf{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:sH++}),this.uuid=oa(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},r=this.data;if(r!==null){let i;if(Array.isArray(r)){i=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?i.push(jT(r[o].image)):i.push(jT(r[o]))}else i=jT(r);s.url=i}return t||(e.images[this.uuid]=s),s}}function jT(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?uI.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let rH=0;class Hs extends xc{constructor(e=Hs.DEFAULT_IMAGE,t=Hs.DEFAULT_MAPPING,s=Pi,r=Pi,i=rr,o=Rh,a=eo,l=ou,u=Hs.DEFAULT_ANISOTROPY,c=sa){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:rH++}),this.uuid=oa(),this.name="",this.source=new yf(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=r,this.magFilter=i,this.minFilter=o,this.anisotropy=u,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Je(0,0),this.repeat=new Je(1,1),this.center=new Je(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new _n,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof c=="string"?this.colorSpace=c:(h0("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=c===Eh?kr:sa),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==HS)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Af:e.x=e.x-Math.floor(e.x);break;case Pi:e.x=e.x<0?0:1;break;case x0:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Af:e.y=e.y-Math.floor(e.y);break;case Pi:e.y=e.y<0?0:1;break;case x0:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return h0("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===kr?Eh:oI}set encoding(e){h0("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===Eh?kr:sa}}Hs.DEFAULT_IMAGE=null;Hs.DEFAULT_MAPPING=HS;Hs.DEFAULT_ANISOTROPY=1;class Jn{constructor(e=0,t=0,s=0,r=1){Jn.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,r){return this.x=e,this.y=t,this.z=s,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*r+o[12]*i,this.y=o[1]*t+o[5]*s+o[9]*r+o[13]*i,this.z=o[2]*t+o[6]*s+o[10]*r+o[14]*i,this.w=o[3]*t+o[7]*s+o[11]*r+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,r,i;const l=e.elements,u=l[0],c=l[4],h=l[8],f=l[1],p=l[5],g=l[9],S=l[2],x=l[6],w=l[10];if(Math.abs(c-f)<.01&&Math.abs(h-S)<.01&&Math.abs(g-x)<.01){if(Math.abs(c+f)<.1&&Math.abs(h+S)<.1&&Math.abs(g+x)<.1&&Math.abs(u+p+w-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const T=(u+1)/2,C=(p+1)/2,N=(w+1)/2,M=(c+f)/4,P=(h+S)/4,$=(g+x)/4;return T>C&&T>N?T<.01?(s=0,r=.707106781,i=.707106781):(s=Math.sqrt(T),r=M/s,i=P/s):C>N?C<.01?(s=.707106781,r=0,i=.707106781):(r=Math.sqrt(C),s=M/r,i=$/r):N<.01?(s=.707106781,r=.707106781,i=0):(i=Math.sqrt(N),s=P/i,r=$/i),this.set(s,r,i,t),this}let _=Math.sqrt((x-g)*(x-g)+(h-S)*(h-S)+(f-c)*(f-c));return Math.abs(_)<.001&&(_=1),this.x=(x-g)/_,this.y=(h-S)/_,this.z=(f-c)/_,this.w=Math.acos((u+p+w-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class V3 extends xc{constructor(e=1,t=1,s={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Jn(0,0,e,t),this.scissorTest=!1,this.viewport=new Jn(0,0,e,t);const r={width:e,height:t,depth:1};s.encoding!==void 0&&(h0("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),s.colorSpace=s.encoding===Eh?kr:sa),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:rr,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},s),this.texture=new Hs(r,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=s.generateMipmaps,this.texture.internalFormat=s.internalFormat,this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.depthTexture=s.depthTexture,this.samples=s.samples}setSize(e,t,s=1){(this.width!==e||this.height!==t||this.depth!==s)&&(this.width=e,this.height=t,this.depth=s,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=s,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new yf(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class _l extends V3{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class KS extends Hs{constructor(e=null,t=1,s=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:r},this.magFilter=sr,this.minFilter=sr,this.wrapR=Pi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class iH extends _l{constructor(e=1,t=1,s=1,r={}){super(e,t,r),this.isWebGLArrayRenderTarget=!0,this.depth=s,this.texture=new KS(null,e,t,s),this.texture.isRenderTargetTexture=!0}}class cI extends Hs{constructor(e=null,t=1,s=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:r},this.magFilter=sr,this.minFilter=sr,this.wrapR=Pi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class oH extends _l{constructor(e=1,t=1,s=1,r={}){super(e,t,r),this.isWebGL3DRenderTarget=!0,this.depth=s,this.texture=new cI(null,e,t,s),this.texture.isRenderTargetTexture=!0}}class aH extends _l{constructor(e=1,t=1,s=1,r={}){super(e,t,r),this.isWebGLMultipleRenderTargets=!0;const i=this.texture;this.texture=[];for(let o=0;o<s;o++)this.texture[o]=i.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let r=0,i=this.texture.length;r<i;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=s;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,s=e.texture.length;t<s;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class Do{constructor(e=0,t=0,s=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=r}static slerpFlat(e,t,s,r,i,o,a){let l=s[r+0],u=s[r+1],c=s[r+2],h=s[r+3];const f=i[o+0],p=i[o+1],g=i[o+2],S=i[o+3];if(a===0){e[t+0]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h;return}if(a===1){e[t+0]=f,e[t+1]=p,e[t+2]=g,e[t+3]=S;return}if(h!==S||l!==f||u!==p||c!==g){let x=1-a;const w=l*f+u*p+c*g+h*S,_=w>=0?1:-1,T=1-w*w;if(T>Number.EPSILON){const N=Math.sqrt(T),M=Math.atan2(N,w*_);x=Math.sin(x*M)/N,a=Math.sin(a*M)/N}const C=a*_;if(l=l*x+f*C,u=u*x+p*C,c=c*x+g*C,h=h*x+S*C,x===1-a){const N=1/Math.sqrt(l*l+u*u+c*c+h*h);l*=N,u*=N,c*=N,h*=N}}e[t]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,s,r,i,o){const a=s[r],l=s[r+1],u=s[r+2],c=s[r+3],h=i[o],f=i[o+1],p=i[o+2],g=i[o+3];return e[t]=a*g+c*h+l*p-u*f,e[t+1]=l*g+c*f+u*h-a*p,e[t+2]=u*g+c*p+a*f-l*h,e[t+3]=c*g-a*h-l*f-u*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,r){return this._x=e,this._y=t,this._z=s,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const s=e._x,r=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,u=a(s/2),c=a(r/2),h=a(i/2),f=l(s/2),p=l(r/2),g=l(i/2);switch(o){case"XYZ":this._x=f*c*h+u*p*g,this._y=u*p*h-f*c*g,this._z=u*c*g+f*p*h,this._w=u*c*h-f*p*g;break;case"YXZ":this._x=f*c*h+u*p*g,this._y=u*p*h-f*c*g,this._z=u*c*g-f*p*h,this._w=u*c*h+f*p*g;break;case"ZXY":this._x=f*c*h-u*p*g,this._y=u*p*h+f*c*g,this._z=u*c*g+f*p*h,this._w=u*c*h-f*p*g;break;case"ZYX":this._x=f*c*h-u*p*g,this._y=u*p*h+f*c*g,this._z=u*c*g-f*p*h,this._w=u*c*h+f*p*g;break;case"YZX":this._x=f*c*h+u*p*g,this._y=u*p*h+f*c*g,this._z=u*c*g-f*p*h,this._w=u*c*h-f*p*g;break;case"XZY":this._x=f*c*h-u*p*g,this._y=u*p*h-f*c*g,this._z=u*c*g+f*p*h,this._w=u*c*h+f*p*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,r=Math.sin(s);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],r=t[4],i=t[8],o=t[1],a=t[5],l=t[9],u=t[2],c=t[6],h=t[10],f=s+a+h;if(f>0){const p=.5/Math.sqrt(f+1);this._w=.25/p,this._x=(c-l)*p,this._y=(i-u)*p,this._z=(o-r)*p}else if(s>a&&s>h){const p=2*Math.sqrt(1+s-a-h);this._w=(c-l)/p,this._x=.25*p,this._y=(r+o)/p,this._z=(i+u)/p}else if(a>h){const p=2*Math.sqrt(1+a-s-h);this._w=(i-u)/p,this._x=(r+o)/p,this._y=.25*p,this._z=(l+c)/p}else{const p=2*Math.sqrt(1+h-s-a);this._w=(o-r)/p,this._x=(i+u)/p,this._y=(l+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ws(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const r=Math.min(1,t/s);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,r=e._y,i=e._z,o=e._w,a=t._x,l=t._y,u=t._z,c=t._w;return this._x=s*c+o*a+r*u-i*l,this._y=r*c+o*l+i*a-s*u,this._z=i*c+o*u+s*l-r*a,this._w=o*c-s*a-r*l-i*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,r=this._y,i=this._z,o=this._w;let a=o*e._w+s*e._x+r*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=r,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*s+t*this._x,this._y=p*r+t*this._y,this._z=p*i+t*this._z,this.normalize(),this}const u=Math.sqrt(l),c=Math.atan2(u,a),h=Math.sin((1-t)*c)/u,f=Math.sin(t*c)/u;return this._w=o*h+this._w*f,this._x=s*h+this._x*f,this._y=r*h+this._y*f,this._z=i*h+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=Math.random(),t=Math.sqrt(1-e),s=Math.sqrt(e),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(r),s*Math.sin(i),s*Math.cos(i),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class re{constructor(e=0,t=0,s=0){re.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Wk.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Wk.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6]*r,this.y=i[1]*t+i[4]*s+i[7]*r,this.z=i[2]*t+i[5]*s+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,i=e.elements,o=1/(i[3]*t+i[7]*s+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*s+i[8]*r+i[12])*o,this.y=(i[1]*t+i[5]*s+i[9]*r+i[13])*o,this.z=(i[2]*t+i[6]*s+i[10]*r+i[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,r=this.z,i=e.x,o=e.y,a=e.z,l=e.w,u=2*(o*r-a*s),c=2*(a*t-i*r),h=2*(i*s-o*t);return this.x=t+l*u+o*h-a*c,this.y=s+l*c+a*u-i*h,this.z=r+l*h+i*c-o*u,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*s+i[8]*r,this.y=i[1]*t+i[5]*s+i[9]*r,this.z=i[2]*t+i[6]*s+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,r=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-i*a,this.y=i*o-s*l,this.z=s*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return XT.copy(this).projectOnVector(e),this.sub(XT)}reflect(e){return this.sub(XT.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Ws(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,r=this.z-e.z;return t*t+s*s+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const r=Math.sin(t)*e;return this.x=r*Math.sin(s),this.y=Math.cos(t)*e,this.z=r*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,s=Math.sqrt(1-e**2);return this.x=s*Math.cos(t),this.y=s*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const XT=new re,Wk=new Do;class so{constructor(e=new re(1/0,1/0,1/0),t=new re(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(ul.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(ul.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=ul.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const i=s.getAttribute("position");if(t===!0&&i!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=i.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,ul):ul.fromBufferAttribute(i,o),ul.applyMatrix4(e.matrixWorld),this.expandByPoint(ul);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),A1.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),A1.copy(s.boundingBox)),A1.applyMatrix4(e.matrixWorld),this.union(A1)}const r=e.children;for(let i=0,o=r.length;i<o;i++)this.expandByObject(r[i],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,ul),ul.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter($y),M1.subVectors(this.max,$y),cm.subVectors(e.a,$y),hm.subVectors(e.b,$y),dm.subVectors(e.c,$y),ch.subVectors(hm,cm),hh.subVectors(dm,hm),Xd.subVectors(cm,dm);let t=[0,-ch.z,ch.y,0,-hh.z,hh.y,0,-Xd.z,Xd.y,ch.z,0,-ch.x,hh.z,0,-hh.x,Xd.z,0,-Xd.x,-ch.y,ch.x,0,-hh.y,hh.x,0,-Xd.y,Xd.x,0];return!qT(t,cm,hm,dm,M1)||(t=[1,0,0,0,1,0,0,0,1],!qT(t,cm,hm,dm,M1))?!1:(k1.crossVectors(ch,hh),t=[k1.x,k1.y,k1.z],qT(t,cm,hm,dm,M1))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,ul).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(ul).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(ju[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),ju[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),ju[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),ju[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),ju[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),ju[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),ju[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),ju[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(ju),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const ju=[new re,new re,new re,new re,new re,new re,new re,new re],ul=new re,A1=new so,cm=new re,hm=new re,dm=new re,ch=new re,hh=new re,Xd=new re,$y=new re,M1=new re,k1=new re,qd=new re;function qT(n,e,t,s,r){for(let i=0,o=n.length-3;i<=o;i+=3){qd.fromArray(n,i);const a=r.x*Math.abs(qd.x)+r.y*Math.abs(qd.y)+r.z*Math.abs(qd.z),l=e.dot(qd),u=t.dot(qd),c=s.dot(qd);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>a)return!1}return!0}const lH=new so,zy=new re,KT=new re;class Fi{constructor(e=new re,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):lH.setFromPoints(e).getCenter(s);let r=0;for(let i=0,o=e.length;i<o;i++)r=Math.max(r,s.distanceToSquared(e[i]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;zy.subVectors(e,this.center);const t=zy.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),r=(s-this.radius)*.5;this.center.addScaledVector(zy,r/s),this.radius+=r}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(KT.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(zy.copy(e.center).add(KT)),this.expandByPoint(zy.copy(e.center).sub(KT))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Xu=new re,YT=new re,R1=new re,dh=new re,ZT=new re,D1=new re,JT=new re;class Tg{constructor(e=new re,t=new re(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Xu)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Xu.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Xu.copy(this.origin).addScaledVector(this.direction,t),Xu.distanceToSquared(e))}distanceSqToSegment(e,t,s,r){YT.copy(e).add(t).multiplyScalar(.5),R1.copy(t).sub(e).normalize(),dh.copy(this.origin).sub(YT);const i=e.distanceTo(t)*.5,o=-this.direction.dot(R1),a=dh.dot(this.direction),l=-dh.dot(R1),u=dh.lengthSq(),c=Math.abs(1-o*o);let h,f,p,g;if(c>0)if(h=o*l-a,f=o*a-l,g=i*c,h>=0)if(f>=-g)if(f<=g){const S=1/c;h*=S,f*=S,p=h*(h+o*f+2*a)+f*(o*h+f+2*l)+u}else f=i,h=Math.max(0,-(o*f+a)),p=-h*h+f*(f+2*l)+u;else f=-i,h=Math.max(0,-(o*f+a)),p=-h*h+f*(f+2*l)+u;else f<=-g?(h=Math.max(0,-(-o*i+a)),f=h>0?-i:Math.min(Math.max(-i,-l),i),p=-h*h+f*(f+2*l)+u):f<=g?(h=0,f=Math.min(Math.max(-i,-l),i),p=f*(f+2*l)+u):(h=Math.max(0,-(o*i+a)),f=h>0?i:Math.min(Math.max(-i,-l),i),p=-h*h+f*(f+2*l)+u);else f=o>0?-i:i,h=Math.max(0,-(o*f+a)),p=-h*h+f*(f+2*l)+u;return s&&s.copy(this.origin).addScaledVector(this.direction,h),r&&r.copy(YT).addScaledVector(R1,f),p}intersectSphere(e,t){Xu.subVectors(e.center,this.origin);const s=Xu.dot(this.direction),r=Xu.dot(Xu)-s*s,i=e.radius*e.radius;if(r>i)return null;const o=Math.sqrt(i-r),a=s-o,l=s+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,r,i,o,a,l;const u=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,f=this.origin;return u>=0?(s=(e.min.x-f.x)*u,r=(e.max.x-f.x)*u):(s=(e.max.x-f.x)*u,r=(e.min.x-f.x)*u),c>=0?(i=(e.min.y-f.y)*c,o=(e.max.y-f.y)*c):(i=(e.max.y-f.y)*c,o=(e.min.y-f.y)*c),s>o||i>r||((i>s||isNaN(s))&&(s=i),(o<r||isNaN(r))&&(r=o),h>=0?(a=(e.min.z-f.z)*h,l=(e.max.z-f.z)*h):(a=(e.max.z-f.z)*h,l=(e.min.z-f.z)*h),s>l||a>r)||((a>s||s!==s)&&(s=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(s>=0?s:r,t)}intersectsBox(e){return this.intersectBox(e,Xu)!==null}intersectTriangle(e,t,s,r,i){ZT.subVectors(t,e),D1.subVectors(s,e),JT.crossVectors(ZT,D1);let o=this.direction.dot(JT),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;dh.subVectors(this.origin,e);const l=a*this.direction.dot(D1.crossVectors(dh,D1));if(l<0)return null;const u=a*this.direction.dot(ZT.cross(dh));if(u<0||l+u>o)return null;const c=-a*dh.dot(JT);return c<0?null:this.at(c/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ln{constructor(e,t,s,r,i,o,a,l,u,c,h,f,p,g,S,x){ln.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,r,i,o,a,l,u,c,h,f,p,g,S,x)}set(e,t,s,r,i,o,a,l,u,c,h,f,p,g,S,x){const w=this.elements;return w[0]=e,w[4]=t,w[8]=s,w[12]=r,w[1]=i,w[5]=o,w[9]=a,w[13]=l,w[2]=u,w[6]=c,w[10]=h,w[14]=f,w[3]=p,w[7]=g,w[11]=S,w[15]=x,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ln().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,r=1/fm.setFromMatrixColumn(e,0).length(),i=1/fm.setFromMatrixColumn(e,1).length(),o=1/fm.setFromMatrixColumn(e,2).length();return t[0]=s[0]*r,t[1]=s[1]*r,t[2]=s[2]*r,t[3]=0,t[4]=s[4]*i,t[5]=s[5]*i,t[6]=s[6]*i,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,r=e.y,i=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(r),u=Math.sin(r),c=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const f=o*c,p=o*h,g=a*c,S=a*h;t[0]=l*c,t[4]=-l*h,t[8]=u,t[1]=p+g*u,t[5]=f-S*u,t[9]=-a*l,t[2]=S-f*u,t[6]=g+p*u,t[10]=o*l}else if(e.order==="YXZ"){const f=l*c,p=l*h,g=u*c,S=u*h;t[0]=f+S*a,t[4]=g*a-p,t[8]=o*u,t[1]=o*h,t[5]=o*c,t[9]=-a,t[2]=p*a-g,t[6]=S+f*a,t[10]=o*l}else if(e.order==="ZXY"){const f=l*c,p=l*h,g=u*c,S=u*h;t[0]=f-S*a,t[4]=-o*h,t[8]=g+p*a,t[1]=p+g*a,t[5]=o*c,t[9]=S-f*a,t[2]=-o*u,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const f=o*c,p=o*h,g=a*c,S=a*h;t[0]=l*c,t[4]=g*u-p,t[8]=f*u+S,t[1]=l*h,t[5]=S*u+f,t[9]=p*u-g,t[2]=-u,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const f=o*l,p=o*u,g=a*l,S=a*u;t[0]=l*c,t[4]=S-f*h,t[8]=g*h+p,t[1]=h,t[5]=o*c,t[9]=-a*c,t[2]=-u*c,t[6]=p*h+g,t[10]=f-S*h}else if(e.order==="XZY"){const f=o*l,p=o*u,g=a*l,S=a*u;t[0]=l*c,t[4]=-h,t[8]=u*c,t[1]=f*h+S,t[5]=o*c,t[9]=p*h-g,t[2]=g*h-p,t[6]=a*c,t[10]=S*h+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(uH,e,cH)}lookAt(e,t,s){const r=this.elements;return ta.subVectors(e,t),ta.lengthSq()===0&&(ta.z=1),ta.normalize(),fh.crossVectors(s,ta),fh.lengthSq()===0&&(Math.abs(s.z)===1?ta.x+=1e-4:ta.z+=1e-4,ta.normalize(),fh.crossVectors(s,ta)),fh.normalize(),P1.crossVectors(ta,fh),r[0]=fh.x,r[4]=P1.x,r[8]=ta.x,r[1]=fh.y,r[5]=P1.y,r[9]=ta.y,r[2]=fh.z,r[6]=P1.z,r[10]=ta.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,i=this.elements,o=s[0],a=s[4],l=s[8],u=s[12],c=s[1],h=s[5],f=s[9],p=s[13],g=s[2],S=s[6],x=s[10],w=s[14],_=s[3],T=s[7],C=s[11],N=s[15],M=r[0],P=r[4],$=r[8],R=r[12],D=r[1],L=r[5],G=r[9],Q=r[13],W=r[2],H=r[6],J=r[10],ie=r[14],V=r[3],Y=r[7],B=r[11],K=r[15];return i[0]=o*M+a*D+l*W+u*V,i[4]=o*P+a*L+l*H+u*Y,i[8]=o*$+a*G+l*J+u*B,i[12]=o*R+a*Q+l*ie+u*K,i[1]=c*M+h*D+f*W+p*V,i[5]=c*P+h*L+f*H+p*Y,i[9]=c*$+h*G+f*J+p*B,i[13]=c*R+h*Q+f*ie+p*K,i[2]=g*M+S*D+x*W+w*V,i[6]=g*P+S*L+x*H+w*Y,i[10]=g*$+S*G+x*J+w*B,i[14]=g*R+S*Q+x*ie+w*K,i[3]=_*M+T*D+C*W+N*V,i[7]=_*P+T*L+C*H+N*Y,i[11]=_*$+T*G+C*J+N*B,i[15]=_*R+T*Q+C*ie+N*K,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],r=e[8],i=e[12],o=e[1],a=e[5],l=e[9],u=e[13],c=e[2],h=e[6],f=e[10],p=e[14],g=e[3],S=e[7],x=e[11],w=e[15];return g*(+i*l*h-r*u*h-i*a*f+s*u*f+r*a*p-s*l*p)+S*(+t*l*p-t*u*f+i*o*f-r*o*p+r*u*c-i*l*c)+x*(+t*u*h-t*a*p-i*o*h+s*o*p+i*a*c-s*u*c)+w*(-r*a*c-t*l*h+t*a*f+r*o*h-s*o*f+s*l*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=e[9],f=e[10],p=e[11],g=e[12],S=e[13],x=e[14],w=e[15],_=h*x*u-S*f*u+S*l*p-a*x*p-h*l*w+a*f*w,T=g*f*u-c*x*u-g*l*p+o*x*p+c*l*w-o*f*w,C=c*S*u-g*h*u+g*a*p-o*S*p-c*a*w+o*h*w,N=g*h*l-c*S*l-g*a*f+o*S*f+c*a*x-o*h*x,M=t*_+s*T+r*C+i*N;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const P=1/M;return e[0]=_*P,e[1]=(S*f*i-h*x*i-S*r*p+s*x*p+h*r*w-s*f*w)*P,e[2]=(a*x*i-S*l*i+S*r*u-s*x*u-a*r*w+s*l*w)*P,e[3]=(h*l*i-a*f*i-h*r*u+s*f*u+a*r*p-s*l*p)*P,e[4]=T*P,e[5]=(c*x*i-g*f*i+g*r*p-t*x*p-c*r*w+t*f*w)*P,e[6]=(g*l*i-o*x*i-g*r*u+t*x*u+o*r*w-t*l*w)*P,e[7]=(o*f*i-c*l*i+c*r*u-t*f*u-o*r*p+t*l*p)*P,e[8]=C*P,e[9]=(g*h*i-c*S*i-g*s*p+t*S*p+c*s*w-t*h*w)*P,e[10]=(o*S*i-g*a*i+g*s*u-t*S*u-o*s*w+t*a*w)*P,e[11]=(c*a*i-o*h*i-c*s*u+t*h*u+o*s*p-t*a*p)*P,e[12]=N*P,e[13]=(c*S*r-g*h*r+g*s*f-t*S*f-c*s*x+t*h*x)*P,e[14]=(g*a*r-o*S*r-g*s*l+t*S*l+o*s*x-t*a*x)*P,e[15]=(o*h*r-c*a*r+c*s*l-t*h*l-o*s*f+t*a*f)*P,this}scale(e){const t=this.elements,s=e.x,r=e.y,i=e.z;return t[0]*=s,t[4]*=r,t[8]*=i,t[1]*=s,t[5]*=r,t[9]*=i,t[2]*=s,t[6]*=r,t[10]*=i,t[3]*=s,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,r))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),r=Math.sin(t),i=1-s,o=e.x,a=e.y,l=e.z,u=i*o,c=i*a;return this.set(u*o+s,u*a-r*l,u*l+r*a,0,u*a+r*l,c*a+s,c*l-r*o,0,u*l-r*a,c*l+r*o,i*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,r,i,o){return this.set(1,s,i,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,s){const r=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,u=i+i,c=o+o,h=a+a,f=i*u,p=i*c,g=i*h,S=o*c,x=o*h,w=a*h,_=l*u,T=l*c,C=l*h,N=s.x,M=s.y,P=s.z;return r[0]=(1-(S+w))*N,r[1]=(p+C)*N,r[2]=(g-T)*N,r[3]=0,r[4]=(p-C)*M,r[5]=(1-(f+w))*M,r[6]=(x+_)*M,r[7]=0,r[8]=(g+T)*P,r[9]=(x-_)*P,r[10]=(1-(f+S))*P,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,s){const r=this.elements;let i=fm.set(r[0],r[1],r[2]).length();const o=fm.set(r[4],r[5],r[6]).length(),a=fm.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],cl.copy(this);const u=1/i,c=1/o,h=1/a;return cl.elements[0]*=u,cl.elements[1]*=u,cl.elements[2]*=u,cl.elements[4]*=c,cl.elements[5]*=c,cl.elements[6]*=c,cl.elements[8]*=h,cl.elements[9]*=h,cl.elements[10]*=h,t.setFromRotationMatrix(cl),s.x=i,s.y=o,s.z=a,this}makePerspective(e,t,s,r,i,o,a=vl){const l=this.elements,u=2*i/(t-e),c=2*i/(s-r),h=(t+e)/(t-e),f=(s+r)/(s-r);let p,g;if(a===vl)p=-(o+i)/(o-i),g=-2*o*i/(o-i);else if(a===ig)p=-o/(o-i),g=-o*i/(o-i);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=u,l[4]=0,l[8]=h,l[12]=0,l[1]=0,l[5]=c,l[9]=f,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,s,r,i,o,a=vl){const l=this.elements,u=1/(t-e),c=1/(s-r),h=1/(o-i),f=(t+e)*u,p=(s+r)*c;let g,S;if(a===vl)g=(o+i)*h,S=-2*h;else if(a===ig)g=i*h,S=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-f,l[1]=0,l[5]=2*c,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=S,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<16;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const fm=new re,cl=new ln,uH=new re(0,0,0),cH=new re(1,1,1),fh=new re,P1=new re,ta=new re,Gk=new ln,Hk=new Do;class Cg{constructor(e=0,t=0,s=0,r=Cg.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,r=this._order){return this._x=e,this._y=t,this._z=s,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const r=e.elements,i=r[0],o=r[4],a=r[8],l=r[1],u=r[5],c=r[9],h=r[2],f=r[6],p=r[10];switch(t){case"XYZ":this._y=Math.asin(Ws(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-o,i)):(this._x=Math.atan2(f,u),this._z=0);break;case"YXZ":this._x=Math.asin(-Ws(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(Ws(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,u)):(this._y=0,this._z=Math.atan2(l,i));break;case"ZYX":this._y=Math.asin(-Ws(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(f,p),this._z=Math.atan2(l,i)):(this._x=0,this._z=Math.atan2(-o,u));break;case"YZX":this._z=Math.asin(Ws(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Ws(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,u),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return Gk.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Gk,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Hk.setFromEuler(this),this.setFromQuaternion(Hk,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Cg.DEFAULT_ORDER="XYZ";class Cf{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let hH=0;const jk=new re,pm=new Do,qu=new ln,L1=new re,Uy=new re,dH=new re,fH=new Do,Xk=new re(1,0,0),qk=new re(0,1,0),Kk=new re(0,0,1),pH={type:"added"},mH={type:"removed"};class zn extends xc{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:hH++}),this.uuid=oa(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=zn.DEFAULT_UP.clone();const e=new re,t=new Cg,s=new Do,r=new re(1,1,1);function i(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(i),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new ln},normalMatrix:{value:new _n}}),this.matrix=new ln,this.matrixWorld=new ln,this.matrixAutoUpdate=zn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=zn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Cf,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return pm.setFromAxisAngle(e,t),this.quaternion.multiply(pm),this}rotateOnWorldAxis(e,t){return pm.setFromAxisAngle(e,t),this.quaternion.premultiply(pm),this}rotateX(e){return this.rotateOnAxis(Xk,e)}rotateY(e){return this.rotateOnAxis(qk,e)}rotateZ(e){return this.rotateOnAxis(Kk,e)}translateOnAxis(e,t){return jk.copy(e).applyQuaternion(this.quaternion),this.position.add(jk.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Xk,e)}translateY(e){return this.translateOnAxis(qk,e)}translateZ(e){return this.translateOnAxis(Kk,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(qu.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?L1.copy(e):L1.set(e,t,s);const r=this.parent;this.updateWorldMatrix(!0,!1),Uy.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qu.lookAt(Uy,L1,this.up):qu.lookAt(L1,Uy,this.up),this.quaternion.setFromRotationMatrix(qu),r&&(qu.extractRotation(r.matrixWorld),pm.setFromRotationMatrix(qu),this.quaternion.premultiply(pm.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(pH)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(mH)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),qu.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),qu.multiply(e.parent.matrixWorld)),e.applyMatrix4(qu),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,r=this.children.length;s<r;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,s=[]){this[e]===t&&s.push(this);const r=this.children;for(let i=0,o=r.length;i<o;i++)r[i].getObjectsByProperty(e,t,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Uy,e,dH),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Uy,fH,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,r=t.length;s<r;s++){const i=t[s];(i.matrixWorldAutoUpdate===!0||e===!0)&&i.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let i=0,o=r.length;i<o;i++){const a=r[i];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),r.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(r.type="BatchedMesh",r.perObjectFrustumCulled=this.perObjectFrustumCulled,r.sortObjects=this.sortObjects,r.drawRanges=this._drawRanges,r.reservedRanges=this._reservedRanges,r.visibility=this._visibility,r.active=this._active,r.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),r.maxGeometryCount=this._maxGeometryCount,r.maxVertexCount=this._maxVertexCount,r.maxIndexCount=this._maxIndexCount,r.geometryInitialized=this._geometryInitialized,r.geometryCount=this._geometryCount,r.matricesTexture=this._matricesTexture.toJSON(e),this.boundingSphere!==null&&(r.boundingSphere={center:r.boundingSphere.center.toArray(),radius:r.boundingSphere.radius}),this.boundingBox!==null&&(r.boundingBox={min:r.boundingBox.min.toArray(),max:r.boundingBox.max.toArray()}));function i(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const h=l[u];i(e.shapes,h)}else i(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,u=this.material.length;l<u;l++)a.push(i(e.materials,this.material[l]));r.material=a}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(i(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),u=o(e.textures),c=o(e.images),h=o(e.shapes),f=o(e.skeletons),p=o(e.animations),g=o(e.nodes);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),u.length>0&&(s.textures=u),c.length>0&&(s.images=c),h.length>0&&(s.shapes=h),f.length>0&&(s.skeletons=f),p.length>0&&(s.animations=p),g.length>0&&(s.nodes=g)}return s.object=r,s;function o(a){const l=[];for(const u in a){const c=a[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const r=e.children[s];this.add(r.clone())}return this}}zn.DEFAULT_UP=new re(0,1,0);zn.DEFAULT_MATRIX_AUTO_UPDATE=!0;zn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const hl=new re,Ku=new re,QT=new re,Yu=new re,mm=new re,gm=new re,Yk=new re,eC=new re,tC=new re,nC=new re;let O1=!1;class No{constructor(e=new re,t=new re,s=new re){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,r){r.subVectors(s,t),hl.subVectors(e,t),r.cross(hl);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,s,r,i){hl.subVectors(r,t),Ku.subVectors(s,t),QT.subVectors(e,t);const o=hl.dot(hl),a=hl.dot(Ku),l=hl.dot(QT),u=Ku.dot(Ku),c=Ku.dot(QT),h=o*u-a*a;if(h===0)return i.set(0,0,0),null;const f=1/h,p=(u*l-a*c)*f,g=(o*c-a*l)*f;return i.set(1-p-g,g,p)}static containsPoint(e,t,s,r){return this.getBarycoord(e,t,s,r,Yu)===null?!1:Yu.x>=0&&Yu.y>=0&&Yu.x+Yu.y<=1}static getUV(e,t,s,r,i,o,a,l){return O1===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),O1=!0),this.getInterpolation(e,t,s,r,i,o,a,l)}static getInterpolation(e,t,s,r,i,o,a,l){return this.getBarycoord(e,t,s,r,Yu)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(i,Yu.x),l.addScaledVector(o,Yu.y),l.addScaledVector(a,Yu.z),l)}static isFrontFacing(e,t,s,r){return hl.subVectors(s,t),Ku.subVectors(e,t),hl.cross(Ku).dot(r)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,r){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,s,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return hl.subVectors(this.c,this.b),Ku.subVectors(this.a,this.b),hl.cross(Ku).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return No.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return No.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,s,r,i){return O1===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),O1=!0),No.getInterpolation(e,this.a,this.b,this.c,t,s,r,i)}getInterpolation(e,t,s,r,i){return No.getInterpolation(e,this.a,this.b,this.c,t,s,r,i)}containsPoint(e){return No.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return No.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,r=this.b,i=this.c;let o,a;mm.subVectors(r,s),gm.subVectors(i,s),eC.subVectors(e,s);const l=mm.dot(eC),u=gm.dot(eC);if(l<=0&&u<=0)return t.copy(s);tC.subVectors(e,r);const c=mm.dot(tC),h=gm.dot(tC);if(c>=0&&h<=c)return t.copy(r);const f=l*h-c*u;if(f<=0&&l>=0&&c<=0)return o=l/(l-c),t.copy(s).addScaledVector(mm,o);nC.subVectors(e,i);const p=mm.dot(nC),g=gm.dot(nC);if(g>=0&&p<=g)return t.copy(i);const S=p*u-l*g;if(S<=0&&u>=0&&g<=0)return a=u/(u-g),t.copy(s).addScaledVector(gm,a);const x=c*g-p*h;if(x<=0&&h-c>=0&&p-g>=0)return Yk.subVectors(i,r),a=(h-c)/(h-c+(p-g)),t.copy(r).addScaledVector(Yk,a);const w=1/(x+S+f);return o=S*w,a=f*w,t.copy(s).addScaledVector(mm,o).addScaledVector(gm,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const W3={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ph={h:0,s:0,l:0},F1={h:0,s:0,l:0};function sC(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class vt{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const r=e;r&&r.isColor?this.copy(r):typeof r=="number"?this.setHex(r):typeof r=="string"&&this.setStyle(r)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=kr){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Zn.toWorkingColorSpace(this,t),this}setRGB(e,t,s,r=Zn.workingColorSpace){return this.r=e,this.g=t,this.b=s,Zn.toWorkingColorSpace(this,r),this}setHSL(e,t,s,r=Zn.workingColorSpace){if(e=lI(e,1),t=Ws(t,0,1),s=Ws(s,0,1),t===0)this.r=this.g=this.b=s;else{const i=s<=.5?s*(1+t):s+t-s*t,o=2*s-i;this.r=sC(o,i,e+1/3),this.g=sC(o,i,e),this.b=sC(o,i,e-1/3)}return Zn.toWorkingColorSpace(this,r),this}setStyle(e,t=kr){function s(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^(\w+)\(([^\)]*)\)/.exec(e)){let i;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,t);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,t);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=r[1],o=i.length;if(o===3)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(i,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=kr){const s=W3[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Km(e.r),this.g=Km(e.g),this.b=Km(e.b),this}copyLinearToSRGB(e){return this.r=HT(e.r),this.g=HT(e.g),this.b=HT(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=kr){return Zn.fromWorkingColorSpace(Mi.copy(this),e),Math.round(Ws(Mi.r*255,0,255))*65536+Math.round(Ws(Mi.g*255,0,255))*256+Math.round(Ws(Mi.b*255,0,255))}getHexString(e=kr){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Zn.workingColorSpace){Zn.fromWorkingColorSpace(Mi.copy(this),t);const s=Mi.r,r=Mi.g,i=Mi.b,o=Math.max(s,r,i),a=Math.min(s,r,i);let l,u;const c=(a+o)/2;if(a===o)l=0,u=0;else{const h=o-a;switch(u=c<=.5?h/(o+a):h/(2-o-a),o){case s:l=(r-i)/h+(r<i?6:0);break;case r:l=(i-s)/h+2;break;case i:l=(s-r)/h+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,t=Zn.workingColorSpace){return Zn.fromWorkingColorSpace(Mi.copy(this),t),e.r=Mi.r,e.g=Mi.g,e.b=Mi.b,e}getStyle(e=kr){Zn.fromWorkingColorSpace(Mi.copy(this),e);const t=Mi.r,s=Mi.g,r=Mi.b;return e!==kr?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${r.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(r*255)})`}offsetHSL(e,t,s){return this.getHSL(ph),this.setHSL(ph.h+e,ph.s+t,ph.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(ph),e.getHSL(F1);const s=c0(ph.h,F1.h,t),r=c0(ph.s,F1.s,t),i=c0(ph.l,F1.l,t);return this.setHSL(s,r,i),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,r=this.b,i=e.elements;return this.r=i[0]*t+i[3]*s+i[6]*r,this.g=i[1]*t+i[4]*s+i[7]*r,this.b=i[2]*t+i[5]*s+i[8]*r,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Mi=new vt;vt.NAMES=W3;let gH=0;class xi extends xc{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:gH++}),this.uuid=oa(),this.name="",this.type="Material",this.blending=_f,this.side=hc,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=rS,this.blendDst=iS,this.blendEquation=wh,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new vt(0,0,0),this.blendAlpha=0,this.depthFunc=m0,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=zE,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=af,this.stencilZFail=af,this.stencilZPass=af,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const r=this[t];if(r===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}r&&r.isColor?r.set(s):r&&r.isVector3&&s&&s.isVector3?r.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==_f&&(s.blending=this.blending),this.side!==hc&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==rS&&(s.blendSrc=this.blendSrc),this.blendDst!==iS&&(s.blendDst=this.blendDst),this.blendEquation!==wh&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==m0&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==zE&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==af&&(s.stencilFail=this.stencilFail),this.stencilZFail!==af&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==af&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function r(i){const o=[];for(const a in i){const l=i[a];delete l.metadata,o.push(l)}return o}if(t){const i=r(e.textures),o=r(e.images);i.length>0&&(s.textures=i),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const r=t.length;s=new Array(r);for(let i=0;i!==r;++i)s[i]=t[i].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class qh extends xi{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new vt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ex,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const sc=yH();function yH(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),s=new Uint32Array(512),r=new Uint32Array(512);for(let l=0;l<256;++l){const u=l-127;u<-27?(s[l]=0,s[l|256]=32768,r[l]=24,r[l|256]=24):u<-14?(s[l]=1024>>-u-14,s[l|256]=1024>>-u-14|32768,r[l]=-u-1,r[l|256]=-u-1):u<=15?(s[l]=u+15<<10,s[l|256]=u+15<<10|32768,r[l]=13,r[l|256]=13):u<128?(s[l]=31744,s[l|256]=64512,r[l]=24,r[l|256]=24):(s[l]=31744,s[l|256]=64512,r[l]=13,r[l|256]=13)}const i=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let u=l<<13,c=0;for(;(u&8388608)===0;)u<<=1,c-=8388608;u&=-8388609,c+=947912704,i[l]=u|c}for(let l=1024;l<2048;++l)i[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:s,shiftTable:r,mantissaTable:i,exponentTable:o,offsetTable:a}}function Co(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Ws(n,-65504,65504),sc.floatView[0]=n;const e=sc.uint32View[0],t=e>>23&511;return sc.baseTable[t]+((e&8388607)>>sc.shiftTable[t])}function t0(n){const e=n>>10;return sc.uint32View[0]=sc.mantissaTable[sc.offsetTable[e]+(n&1023)]+sc.exponentTable[e],sc.floatView[0]}const xH={toHalfFloat:Co,fromHalfFloat:t0},mr=new re,$1=new Je;class Qn{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=C0,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=xl,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[s+r];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)$1.fromBufferAttribute(this,t),$1.applyMatrix3(e),this.setXY(t,$1.x,$1.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.applyMatrix3(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.applyMatrix4(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.applyNormalMatrix(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)mr.fromBufferAttribute(this,t),mr.transformDirection(e),this.setXYZ(t,mr.x,mr.y,mr.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=Ao(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Sn(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Ao(t,this.array)),t}setX(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Ao(t,this.array)),t}setY(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Ao(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Ao(t,this.array)),t}setW(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,r){return e*=this.itemSize,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array),r=Sn(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this}setXYZW(e,t,s,r,i){return e*=this.itemSize,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array),r=Sn(r,this.array),i=Sn(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==C0&&(e.usage=this.usage),e}}class vH extends Qn{constructor(e,t,s){super(new Int8Array(e),t,s)}}class wH extends Qn{constructor(e,t,s){super(new Uint8Array(e),t,s)}}class SH extends Qn{constructor(e,t,s){super(new Uint8ClampedArray(e),t,s)}}class bH extends Qn{constructor(e,t,s){super(new Int16Array(e),t,s)}}class hI extends Qn{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class _H extends Qn{constructor(e,t,s){super(new Int32Array(e),t,s)}}class dI extends Qn{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class TH extends Qn{constructor(e,t,s){super(new Uint16Array(e),t,s),this.isFloat16BufferAttribute=!0}getX(e){let t=t0(this.array[e*this.itemSize]);return this.normalized&&(t=Ao(t,this.array)),t}setX(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize]=Co(t),this}getY(e){let t=t0(this.array[e*this.itemSize+1]);return this.normalized&&(t=Ao(t,this.array)),t}setY(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize+1]=Co(t),this}getZ(e){let t=t0(this.array[e*this.itemSize+2]);return this.normalized&&(t=Ao(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize+2]=Co(t),this}getW(e){let t=t0(this.array[e*this.itemSize+3]);return this.normalized&&(t=Ao(t,this.array)),t}setW(e,t){return this.normalized&&(t=Sn(t,this.array)),this.array[e*this.itemSize+3]=Co(t),this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array)),this.array[e+0]=Co(t),this.array[e+1]=Co(s),this}setXYZ(e,t,s,r){return e*=this.itemSize,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array),r=Sn(r,this.array)),this.array[e+0]=Co(t),this.array[e+1]=Co(s),this.array[e+2]=Co(r),this}setXYZW(e,t,s,r,i){return e*=this.itemSize,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array),r=Sn(r,this.array),i=Sn(i,this.array)),this.array[e+0]=Co(t),this.array[e+1]=Co(s),this.array[e+2]=Co(r),this.array[e+3]=Co(i),this}}class $t extends Qn{constructor(e,t,s){super(new Float32Array(e),t,s)}}class CH extends Qn{constructor(e,t,s){super(new Float64Array(e),t,s)}}let EH=0;const _a=new ln,rC=new zn,ym=new re,na=new so,By=new so,Hr=new re;class bn extends xc{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:EH++}),this.uuid=oa(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(U3(e)?dI:hI)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const i=new _n().getNormalMatrix(e);s.applyNormalMatrix(i),s.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return _a.makeRotationFromQuaternion(e),this.applyMatrix4(_a),this}rotateX(e){return _a.makeRotationX(e),this.applyMatrix4(_a),this}rotateY(e){return _a.makeRotationY(e),this.applyMatrix4(_a),this}rotateZ(e){return _a.makeRotationZ(e),this.applyMatrix4(_a),this}translate(e,t,s){return _a.makeTranslation(e,t,s),this.applyMatrix4(_a),this}scale(e,t,s){return _a.makeScale(e,t,s),this.applyMatrix4(_a),this}lookAt(e){return rC.lookAt(e),rC.updateMatrix(),this.applyMatrix4(rC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ym).negate(),this.translate(ym.x,ym.y,ym.z),this}setFromPoints(e){const t=[];for(let s=0,r=e.length;s<r;s++){const i=e[s];t.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new $t(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new so);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new re(-1/0,-1/0,-1/0),new re(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,r=t.length;s<r;s++){const i=t[s];na.setFromBufferAttribute(i),this.morphTargetsRelative?(Hr.addVectors(this.boundingBox.min,na.min),this.boundingBox.expandByPoint(Hr),Hr.addVectors(this.boundingBox.max,na.max),this.boundingBox.expandByPoint(Hr)):(this.boundingBox.expandByPoint(na.min),this.boundingBox.expandByPoint(na.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Fi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new re,1/0);return}if(e){const s=this.boundingSphere.center;if(na.setFromBufferAttribute(e),t)for(let i=0,o=t.length;i<o;i++){const a=t[i];By.setFromBufferAttribute(a),this.morphTargetsRelative?(Hr.addVectors(na.min,By.min),na.expandByPoint(Hr),Hr.addVectors(na.max,By.max),na.expandByPoint(Hr)):(na.expandByPoint(By.min),na.expandByPoint(By.max))}na.getCenter(s);let r=0;for(let i=0,o=e.count;i<o;i++)Hr.fromBufferAttribute(e,i),r=Math.max(r,s.distanceToSquared(Hr));if(t)for(let i=0,o=t.length;i<o;i++){const a=t[i],l=this.morphTargetsRelative;for(let u=0,c=a.count;u<c;u++)Hr.fromBufferAttribute(a,u),l&&(ym.fromBufferAttribute(e,u),Hr.add(ym)),r=Math.max(r,s.distanceToSquared(Hr))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.array,r=t.position.array,i=t.normal.array,o=t.uv.array,a=r.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Qn(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,u=[],c=[];for(let D=0;D<a;D++)u[D]=new re,c[D]=new re;const h=new re,f=new re,p=new re,g=new Je,S=new Je,x=new Je,w=new re,_=new re;function T(D,L,G){h.fromArray(r,D*3),f.fromArray(r,L*3),p.fromArray(r,G*3),g.fromArray(o,D*2),S.fromArray(o,L*2),x.fromArray(o,G*2),f.sub(h),p.sub(h),S.sub(g),x.sub(g);const Q=1/(S.x*x.y-x.x*S.y);isFinite(Q)&&(w.copy(f).multiplyScalar(x.y).addScaledVector(p,-S.y).multiplyScalar(Q),_.copy(p).multiplyScalar(S.x).addScaledVector(f,-x.x).multiplyScalar(Q),u[D].add(w),u[L].add(w),u[G].add(w),c[D].add(_),c[L].add(_),c[G].add(_))}let C=this.groups;C.length===0&&(C=[{start:0,count:s.length}]);for(let D=0,L=C.length;D<L;++D){const G=C[D],Q=G.start,W=G.count;for(let H=Q,J=Q+W;H<J;H+=3)T(s[H+0],s[H+1],s[H+2])}const N=new re,M=new re,P=new re,$=new re;function R(D){P.fromArray(i,D*3),$.copy(P);const L=u[D];N.copy(L),N.sub(P.multiplyScalar(P.dot(L))).normalize(),M.crossVectors($,L);const Q=M.dot(c[D])<0?-1:1;l[D*4]=N.x,l[D*4+1]=N.y,l[D*4+2]=N.z,l[D*4+3]=Q}for(let D=0,L=C.length;D<L;++D){const G=C[D],Q=G.start,W=G.count;for(let H=Q,J=Q+W;H<J;H+=3)R(s[H+0]),R(s[H+1]),R(s[H+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Qn(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let f=0,p=s.count;f<p;f++)s.setXYZ(f,0,0,0);const r=new re,i=new re,o=new re,a=new re,l=new re,u=new re,c=new re,h=new re;if(e)for(let f=0,p=e.count;f<p;f+=3){const g=e.getX(f+0),S=e.getX(f+1),x=e.getX(f+2);r.fromBufferAttribute(t,g),i.fromBufferAttribute(t,S),o.fromBufferAttribute(t,x),c.subVectors(o,i),h.subVectors(r,i),c.cross(h),a.fromBufferAttribute(s,g),l.fromBufferAttribute(s,S),u.fromBufferAttribute(s,x),a.add(c),l.add(c),u.add(c),s.setXYZ(g,a.x,a.y,a.z),s.setXYZ(S,l.x,l.y,l.z),s.setXYZ(x,u.x,u.y,u.z)}else for(let f=0,p=t.count;f<p;f+=3)r.fromBufferAttribute(t,f+0),i.fromBufferAttribute(t,f+1),o.fromBufferAttribute(t,f+2),c.subVectors(o,i),h.subVectors(r,i),c.cross(h),s.setXYZ(f+0,c.x,c.y,c.z),s.setXYZ(f+1,c.x,c.y,c.z),s.setXYZ(f+2,c.x,c.y,c.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)Hr.fromBufferAttribute(e,t),Hr.normalize(),e.setXYZ(t,Hr.x,Hr.y,Hr.z)}toNonIndexed(){function e(a,l){const u=a.array,c=a.itemSize,h=a.normalized,f=new u.constructor(l.length*c);let p=0,g=0;for(let S=0,x=l.length;S<x;S++){a.isInterleavedBufferAttribute?p=l[S]*a.data.stride+a.offset:p=l[S]*c;for(let w=0;w<c;w++)f[g++]=u[p++]}return new Qn(f,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new bn,s=this.index.array,r=this.attributes;for(const a in r){const l=r[a],u=e(l,s);t.setAttribute(a,u)}const i=this.morphAttributes;for(const a in i){const l=[],u=i[a];for(let c=0,h=u.length;c<h;c++){const f=u[c],p=e(f,s);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const u=o[a];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const u=s[l];e.data.attributes[l]=u.toJSON(e.data)}const r={};let i=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let h=0,f=u.length;h<f;h++){const p=u[h];c.push(p.toJSON(e.data))}c.length>0&&(r[l]=c,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(t));const r=e.attributes;for(const u in r){const c=r[u];this.setAttribute(u,c.clone(t))}const i=e.morphAttributes;for(const u in i){const c=[],h=i[u];for(let f=0,p=h.length;f<p;f++)c.push(h[f].clone(t));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let u=0,c=o.length;u<c;u++){const h=o[u];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Zk=new ln,Kd=new Tg,z1=new Fi,Jk=new re,xm=new re,vm=new re,wm=new re,iC=new re,U1=new re,B1=new Je,V1=new Je,W1=new Je,Qk=new re,eR=new re,tR=new re,G1=new re,H1=new re;class Dr extends zn{constructor(e=new bn,t=new qh){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}getVertexPosition(e,t){const s=this.geometry,r=s.attributes.position,i=s.morphAttributes.position,o=s.morphTargetsRelative;t.fromBufferAttribute(r,e);const a=this.morphTargetInfluences;if(i&&a){U1.set(0,0,0);for(let l=0,u=i.length;l<u;l++){const c=a[l],h=i[l];c!==0&&(iC.fromBufferAttribute(h,e),o?U1.addScaledVector(iC,c):U1.addScaledVector(iC.sub(t),c))}t.add(U1)}return t}raycast(e,t){const s=this.geometry,r=this.material,i=this.matrixWorld;r!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),z1.copy(s.boundingSphere),z1.applyMatrix4(i),Kd.copy(e.ray).recast(e.near),!(z1.containsPoint(Kd.origin)===!1&&(Kd.intersectSphere(z1,Jk)===null||Kd.origin.distanceToSquared(Jk)>(e.far-e.near)**2))&&(Zk.copy(i).invert(),Kd.copy(e.ray).applyMatrix4(Zk),!(s.boundingBox!==null&&Kd.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,Kd)))}_computeIntersections(e,t,s){let r;const i=this.geometry,o=this.material,a=i.index,l=i.attributes.position,u=i.attributes.uv,c=i.attributes.uv1,h=i.attributes.normal,f=i.groups,p=i.drawRange;if(a!==null)if(Array.isArray(o))for(let g=0,S=f.length;g<S;g++){const x=f[g],w=o[x.materialIndex],_=Math.max(x.start,p.start),T=Math.min(a.count,Math.min(x.start+x.count,p.start+p.count));for(let C=_,N=T;C<N;C+=3){const M=a.getX(C),P=a.getX(C+1),$=a.getX(C+2);r=j1(this,w,e,s,u,c,h,M,P,$),r&&(r.faceIndex=Math.floor(C/3),r.face.materialIndex=x.materialIndex,t.push(r))}}else{const g=Math.max(0,p.start),S=Math.min(a.count,p.start+p.count);for(let x=g,w=S;x<w;x+=3){const _=a.getX(x),T=a.getX(x+1),C=a.getX(x+2);r=j1(this,o,e,s,u,c,h,_,T,C),r&&(r.faceIndex=Math.floor(x/3),t.push(r))}}else if(l!==void 0)if(Array.isArray(o))for(let g=0,S=f.length;g<S;g++){const x=f[g],w=o[x.materialIndex],_=Math.max(x.start,p.start),T=Math.min(l.count,Math.min(x.start+x.count,p.start+p.count));for(let C=_,N=T;C<N;C+=3){const M=C,P=C+1,$=C+2;r=j1(this,w,e,s,u,c,h,M,P,$),r&&(r.faceIndex=Math.floor(C/3),r.face.materialIndex=x.materialIndex,t.push(r))}}else{const g=Math.max(0,p.start),S=Math.min(l.count,p.start+p.count);for(let x=g,w=S;x<w;x+=3){const _=x,T=x+1,C=x+2;r=j1(this,o,e,s,u,c,h,_,T,C),r&&(r.faceIndex=Math.floor(x/3),t.push(r))}}}}function IH(n,e,t,s,r,i,o,a){let l;if(e.side===no?l=s.intersectTriangle(o,i,r,!0,a):l=s.intersectTriangle(r,i,o,e.side===hc,a),l===null)return null;H1.copy(a),H1.applyMatrix4(n.matrixWorld);const u=t.ray.origin.distanceTo(H1);return u<t.near||u>t.far?null:{distance:u,point:H1.clone(),object:n}}function j1(n,e,t,s,r,i,o,a,l,u){n.getVertexPosition(a,xm),n.getVertexPosition(l,vm),n.getVertexPosition(u,wm);const c=IH(n,e,t,s,xm,vm,wm,G1);if(c){r&&(B1.fromBufferAttribute(r,a),V1.fromBufferAttribute(r,l),W1.fromBufferAttribute(r,u),c.uv=No.getInterpolation(G1,xm,vm,wm,B1,V1,W1,new Je)),i&&(B1.fromBufferAttribute(i,a),V1.fromBufferAttribute(i,l),W1.fromBufferAttribute(i,u),c.uv1=No.getInterpolation(G1,xm,vm,wm,B1,V1,W1,new Je),c.uv2=c.uv1),o&&(Qk.fromBufferAttribute(o,a),eR.fromBufferAttribute(o,l),tR.fromBufferAttribute(o,u),c.normal=No.getInterpolation(G1,xm,vm,wm,Qk,eR,tR,new re),c.normal.dot(s.direction)>0&&c.normal.multiplyScalar(-1));const h={a,b:l,c:u,normal:new re,materialIndex:0};No.getNormal(xm,vm,wm,h.normal),c.face=h}return c}class Kh extends bn{constructor(e=1,t=1,s=1,r=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:r,heightSegments:i,depthSegments:o};const a=this;r=Math.floor(r),i=Math.floor(i),o=Math.floor(o);const l=[],u=[],c=[],h=[];let f=0,p=0;g("z","y","x",-1,-1,s,t,e,o,i,0),g("z","y","x",1,-1,s,t,-e,o,i,1),g("x","z","y",1,1,e,s,t,r,o,2),g("x","z","y",1,-1,e,s,-t,r,o,3),g("x","y","z",1,-1,e,t,s,r,i,4),g("x","y","z",-1,-1,e,t,-s,r,i,5),this.setIndex(l),this.setAttribute("position",new $t(u,3)),this.setAttribute("normal",new $t(c,3)),this.setAttribute("uv",new $t(h,2));function g(S,x,w,_,T,C,N,M,P,$,R){const D=C/P,L=N/$,G=C/2,Q=N/2,W=M/2,H=P+1,J=$+1;let ie=0,V=0;const Y=new re;for(let B=0;B<J;B++){const K=B*L-Q;for(let se=0;se<H;se++){const te=se*D-G;Y[S]=te*_,Y[x]=K*T,Y[w]=W,u.push(Y.x,Y.y,Y.z),Y[S]=0,Y[x]=0,Y[w]=M>0?1:-1,c.push(Y.x,Y.y,Y.z),h.push(se/P),h.push(1-B/$),ie+=1}}for(let B=0;B<$;B++)for(let K=0;K<P;K++){const se=f+K+H*B,te=f+K+H*(B+1),ue=f+(K+1)+H*(B+1),fe=f+(K+1)+H*B;l.push(se,te,fe),l.push(te,ue,fe),V+=6}a.addGroup(p,V,R),p+=V,f+=ie}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Kh(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function ag(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const r=n[t][s];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=r.clone():Array.isArray(r)?e[t][s]=r.slice():e[t][s]=r}}return e}function Zi(n){const e={};for(let t=0;t<n.length;t++){const s=ag(n[t]);for(const r in s)e[r]=s[r]}return e}function NH(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function G3(n){return n.getRenderTarget()===null?n.outputColorSpace:Zn.workingColorSpace}const H3={clone:ag,merge:Zi};var AH=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,MH=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Tl extends xi{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=AH,this.fragmentShader=MH,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ag(e.uniforms),this.uniformsGroups=NH(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const r in this.extensions)this.extensions[r]===!0&&(s[r]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class nx extends zn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ln,this.projectionMatrix=new ln,this.projectionMatrixInverse=new ln,this.coordinateSystem=vl}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class jr extends nx{constructor(e=50,t=1,s=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=og*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Tf*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return og*2*Math.atan(Math.tan(Tf*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,s,r,i,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Tf*.5*this.fov)/this.zoom,s=2*t,r=this.aspect*s,i=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,u=o.fullHeight;i+=o.offsetX*r/l,t-=o.offsetY*s/u,r*=o.width/l,s*=o.height/u}const a=this.filmOffset;a!==0&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Sm=-90,bm=1;class j3 extends zn{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const r=new jr(Sm,bm,e,t);r.layers=this.layers,this.add(r);const i=new jr(Sm,bm,e,t);i.layers=this.layers,this.add(i);const o=new jr(Sm,bm,e,t);o.layers=this.layers,this.add(o);const a=new jr(Sm,bm,e,t);a.layers=this.layers,this.add(a);const l=new jr(Sm,bm,e,t);l.layers=this.layers,this.add(l);const u=new jr(Sm,bm,e,t);u.layers=this.layers,this.add(u)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,r,i,o,a,l]=t;for(const u of t)this.remove(u);if(e===vl)s.up.set(0,1,0),s.lookAt(1,0,0),r.up.set(0,1,0),r.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===ig)s.up.set(0,-1,0),s.lookAt(-1,0,0),r.up.set(0,-1,0),r.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const u of t)this.add(u),u.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:r}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[i,o,a,l,u,c]=this.children,h=e.getRenderTarget(),f=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),g=e.xr.enabled;e.xr.enabled=!1;const S=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,r),e.render(t,i),e.setRenderTarget(s,1,r),e.render(t,o),e.setRenderTarget(s,2,r),e.render(t,a),e.setRenderTarget(s,3,r),e.render(t,l),e.setRenderTarget(s,4,r),e.render(t,u),s.texture.generateMipmaps=S,e.setRenderTarget(s,5,r),e.render(t,c),e.setRenderTarget(h,f,p),e.xr.enabled=g,s.texture.needsPMREMUpdate=!0}}class sx extends Hs{constructor(e,t,s,r,i,o,a,l,u,c){e=e!==void 0?e:[],t=t!==void 0?t:dc,super(e,t,s,r,i,o,a,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class X3 extends _l{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},r=[s,s,s,s,s,s];t.encoding!==void 0&&(h0("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===Eh?kr:sa),this.texture=new sx(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:rr}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Kh(5,5,5),i=new Tl({name:"CubemapFromEquirect",uniforms:ag(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:no,blending:ac});i.uniforms.tEquirect.value=t;const o=new Dr(r,i),a=t.minFilter;return t.minFilter===Rh&&(t.minFilter=rr),new j3(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,s,r){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,r);e.setRenderTarget(i)}}const oC=new re,kH=new re,RH=new _n;class xh{constructor(e=new re(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,r){return this.normal.set(e,t,s),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const r=oC.subVectors(s,t).cross(kH.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(oC),r=this.normal.dot(s);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(e.start).addScaledVector(s,i)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||RH.getNormalMatrix(e),r=this.coplanarPoint(oC).applyMatrix4(e),i=this.normal.applyMatrix3(s).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Yd=new Fi,X1=new re;class rx{constructor(e=new xh,t=new xh,s=new xh,r=new xh,i=new xh,o=new xh){this.planes=[e,t,s,r,i,o]}set(e,t,s,r,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(r),a[4].copy(i),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=vl){const s=this.planes,r=e.elements,i=r[0],o=r[1],a=r[2],l=r[3],u=r[4],c=r[5],h=r[6],f=r[7],p=r[8],g=r[9],S=r[10],x=r[11],w=r[12],_=r[13],T=r[14],C=r[15];if(s[0].setComponents(l-i,f-u,x-p,C-w).normalize(),s[1].setComponents(l+i,f+u,x+p,C+w).normalize(),s[2].setComponents(l+o,f+c,x+g,C+_).normalize(),s[3].setComponents(l-o,f-c,x-g,C-_).normalize(),s[4].setComponents(l-a,f-h,x-S,C-T).normalize(),t===vl)s[5].setComponents(l+a,f+h,x+S,C+T).normalize();else if(t===ig)s[5].setComponents(a,h,S,T).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Yd.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Yd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Yd)}intersectsSprite(e){return Yd.center.set(0,0,0),Yd.radius=.7071067811865476,Yd.applyMatrix4(e.matrixWorld),this.intersectsSphere(Yd)}intersectsSphere(e){const t=this.planes,s=e.center,r=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(s)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const r=t[s];if(X1.x=r.normal.x>0?e.max.x:e.min.x,X1.y=r.normal.y>0?e.max.y:e.min.y,X1.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(X1)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function q3(){let n=null,e=!1,t=null,s=null;function r(i,o){t(i,o),s=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function DH(n,e){const t=e.isWebGL2,s=new WeakMap;function r(u,c){const h=u.array,f=u.usage,p=h.byteLength,g=n.createBuffer();n.bindBuffer(c,g),n.bufferData(c,h,f),u.onUploadCallback();let S;if(h instanceof Float32Array)S=n.FLOAT;else if(h instanceof Uint16Array)if(u.isFloat16BufferAttribute)if(t)S=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else S=n.UNSIGNED_SHORT;else if(h instanceof Int16Array)S=n.SHORT;else if(h instanceof Uint32Array)S=n.UNSIGNED_INT;else if(h instanceof Int32Array)S=n.INT;else if(h instanceof Int8Array)S=n.BYTE;else if(h instanceof Uint8Array)S=n.UNSIGNED_BYTE;else if(h instanceof Uint8ClampedArray)S=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:g,type:S,bytesPerElement:h.BYTES_PER_ELEMENT,version:u.version,size:p}}function i(u,c,h){const f=c.array,p=c._updateRange,g=c.updateRanges;if(n.bindBuffer(h,u),p.count===-1&&g.length===0&&n.bufferSubData(h,0,f),g.length!==0){for(let S=0,x=g.length;S<x;S++){const w=g[S];t?n.bufferSubData(h,w.start*f.BYTES_PER_ELEMENT,f,w.start,w.count):n.bufferSubData(h,w.start*f.BYTES_PER_ELEMENT,f.subarray(w.start,w.start+w.count))}c.clearUpdateRanges()}p.count!==-1&&(t?n.bufferSubData(h,p.offset*f.BYTES_PER_ELEMENT,f,p.offset,p.count):n.bufferSubData(h,p.offset*f.BYTES_PER_ELEMENT,f.subarray(p.offset,p.offset+p.count)),p.count=-1),c.onUploadCallback()}function o(u){return u.isInterleavedBufferAttribute&&(u=u.data),s.get(u)}function a(u){u.isInterleavedBufferAttribute&&(u=u.data);const c=s.get(u);c&&(n.deleteBuffer(c.buffer),s.delete(u))}function l(u,c){if(u.isGLBufferAttribute){const f=s.get(u);(!f||f.version<u.version)&&s.set(u,{buffer:u.buffer,type:u.type,bytesPerElement:u.elementSize,version:u.version});return}u.isInterleavedBufferAttribute&&(u=u.data);const h=s.get(u);if(h===void 0)s.set(u,r(u,c));else if(h.version<u.version){if(h.size!==u.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");i(h.buffer,u,c),h.version=u.version}}return{get:o,remove:a,update:l}}class ix extends bn{constructor(e=1,t=1,s=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:r};const i=e/2,o=t/2,a=Math.floor(s),l=Math.floor(r),u=a+1,c=l+1,h=e/a,f=t/l,p=[],g=[],S=[],x=[];for(let w=0;w<c;w++){const _=w*f-o;for(let T=0;T<u;T++){const C=T*h-i;g.push(C,-_,0),S.push(0,0,1),x.push(T/a),x.push(1-w/l)}}for(let w=0;w<l;w++)for(let _=0;_<a;_++){const T=_+u*w,C=_+u*(w+1),N=_+1+u*(w+1),M=_+1+u*w;p.push(T,C,M),p.push(C,N,M)}this.setIndex(p),this.setAttribute("position",new $t(g,3)),this.setAttribute("normal",new $t(S,3)),this.setAttribute("uv",new $t(x,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ix(e.width,e.height,e.widthSegments,e.heightSegments)}}var PH=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,LH=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,OH=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,FH=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,$H=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,zH=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,UH=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,BH=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,VH=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,WH=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,GH=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,HH=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,jH=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,XH=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,qH=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,KH=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,YH=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,ZH=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,JH=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,QH=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,e5=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,t5=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,n5=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,s5=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,r5=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,i5=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,o5=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,a5=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,l5=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,u5=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,c5="gl_FragColor = linearToOutputTexel( gl_FragColor );",h5=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,d5=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,f5=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,p5=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,m5=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,g5=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,y5=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,x5=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,v5=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,w5=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,S5=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,b5=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,_5=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,T5=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,C5=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,E5=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,I5=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,N5=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,A5=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,M5=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,k5=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,R5=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,D5=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,P5=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,L5=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,O5=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,F5=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,$5=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,z5=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,U5=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,B5=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,V5=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,W5=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,G5=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,H5=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,j5=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,X5=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,q5=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,K5=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,Y5=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,Z5=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,J5=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Q5=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,e6=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,t6=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,n6=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,s6=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,r6=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,i6=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,o6=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,a6=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,l6=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,u6=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,c6=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,h6=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,d6=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,f6=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,p6=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,m6=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,g6=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,y6=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,x6=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,v6=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,w6=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,S6=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,b6=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,_6=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,T6=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,C6=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,E6=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,I6=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,N6=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,A6=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,M6=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,k6=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,R6=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const D6=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,P6=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,L6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,O6=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,F6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,$6=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,z6=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,U6=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,B6=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,V6=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,W6=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,G6=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,H6=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,j6=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,X6=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,q6=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,K6=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Y6=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Z6=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,J6=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Q6=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,e8=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,t8=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,n8=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,s8=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,r8=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,i8=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,o8=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,a8=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,l8=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,u8=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,c8=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,h8=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,d8=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,wn={alphahash_fragment:PH,alphahash_pars_fragment:LH,alphamap_fragment:OH,alphamap_pars_fragment:FH,alphatest_fragment:$H,alphatest_pars_fragment:zH,aomap_fragment:UH,aomap_pars_fragment:BH,batching_pars_vertex:VH,batching_vertex:WH,begin_vertex:GH,beginnormal_vertex:HH,bsdfs:jH,iridescence_fragment:XH,bumpmap_pars_fragment:qH,clipping_planes_fragment:KH,clipping_planes_pars_fragment:YH,clipping_planes_pars_vertex:ZH,clipping_planes_vertex:JH,color_fragment:QH,color_pars_fragment:e5,color_pars_vertex:t5,color_vertex:n5,common:s5,cube_uv_reflection_fragment:r5,defaultnormal_vertex:i5,displacementmap_pars_vertex:o5,displacementmap_vertex:a5,emissivemap_fragment:l5,emissivemap_pars_fragment:u5,colorspace_fragment:c5,colorspace_pars_fragment:h5,envmap_fragment:d5,envmap_common_pars_fragment:f5,envmap_pars_fragment:p5,envmap_pars_vertex:m5,envmap_physical_pars_fragment:I5,envmap_vertex:g5,fog_vertex:y5,fog_pars_vertex:x5,fog_fragment:v5,fog_pars_fragment:w5,gradientmap_pars_fragment:S5,lightmap_fragment:b5,lightmap_pars_fragment:_5,lights_lambert_fragment:T5,lights_lambert_pars_fragment:C5,lights_pars_begin:E5,lights_toon_fragment:N5,lights_toon_pars_fragment:A5,lights_phong_fragment:M5,lights_phong_pars_fragment:k5,lights_physical_fragment:R5,lights_physical_pars_fragment:D5,lights_fragment_begin:P5,lights_fragment_maps:L5,lights_fragment_end:O5,logdepthbuf_fragment:F5,logdepthbuf_pars_fragment:$5,logdepthbuf_pars_vertex:z5,logdepthbuf_vertex:U5,map_fragment:B5,map_pars_fragment:V5,map_particle_fragment:W5,map_particle_pars_fragment:G5,metalnessmap_fragment:H5,metalnessmap_pars_fragment:j5,morphcolor_vertex:X5,morphnormal_vertex:q5,morphtarget_pars_vertex:K5,morphtarget_vertex:Y5,normal_fragment_begin:Z5,normal_fragment_maps:J5,normal_pars_fragment:Q5,normal_pars_vertex:e6,normal_vertex:t6,normalmap_pars_fragment:n6,clearcoat_normal_fragment_begin:s6,clearcoat_normal_fragment_maps:r6,clearcoat_pars_fragment:i6,iridescence_pars_fragment:o6,opaque_fragment:a6,packing:l6,premultiplied_alpha_fragment:u6,project_vertex:c6,dithering_fragment:h6,dithering_pars_fragment:d6,roughnessmap_fragment:f6,roughnessmap_pars_fragment:p6,shadowmap_pars_fragment:m6,shadowmap_pars_vertex:g6,shadowmap_vertex:y6,shadowmask_pars_fragment:x6,skinbase_vertex:v6,skinning_pars_vertex:w6,skinning_vertex:S6,skinnormal_vertex:b6,specularmap_fragment:_6,specularmap_pars_fragment:T6,tonemapping_fragment:C6,tonemapping_pars_fragment:E6,transmission_fragment:I6,transmission_pars_fragment:N6,uv_pars_fragment:A6,uv_pars_vertex:M6,uv_vertex:k6,worldpos_vertex:R6,background_vert:D6,background_frag:P6,backgroundCube_vert:L6,backgroundCube_frag:O6,cube_vert:F6,cube_frag:$6,depth_vert:z6,depth_frag:U6,distanceRGBA_vert:B6,distanceRGBA_frag:V6,equirect_vert:W6,equirect_frag:G6,linedashed_vert:H6,linedashed_frag:j6,meshbasic_vert:X6,meshbasic_frag:q6,meshlambert_vert:K6,meshlambert_frag:Y6,meshmatcap_vert:Z6,meshmatcap_frag:J6,meshnormal_vert:Q6,meshnormal_frag:e8,meshphong_vert:t8,meshphong_frag:n8,meshphysical_vert:s8,meshphysical_frag:r8,meshtoon_vert:i8,meshtoon_frag:o8,points_vert:a8,points_frag:l8,shadow_vert:u8,shadow_frag:c8,sprite_vert:h8,sprite_frag:d8},mt={common:{diffuse:{value:new vt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new _n},alphaMap:{value:null},alphaMapTransform:{value:new _n},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new _n}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new _n}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new _n}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new _n},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new _n},normalScale:{value:new Je(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new _n},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new _n}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new _n}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new _n}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new vt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new vt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new _n},alphaTest:{value:0},uvTransform:{value:new _n}},sprite:{diffuse:{value:new vt(16777215)},opacity:{value:1},center:{value:new Je(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new _n},alphaMap:{value:null},alphaMapTransform:{value:new _n},alphaTest:{value:0}}},ml={basic:{uniforms:Zi([mt.common,mt.specularmap,mt.envmap,mt.aomap,mt.lightmap,mt.fog]),vertexShader:wn.meshbasic_vert,fragmentShader:wn.meshbasic_frag},lambert:{uniforms:Zi([mt.common,mt.specularmap,mt.envmap,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.fog,mt.lights,{emissive:{value:new vt(0)}}]),vertexShader:wn.meshlambert_vert,fragmentShader:wn.meshlambert_frag},phong:{uniforms:Zi([mt.common,mt.specularmap,mt.envmap,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.fog,mt.lights,{emissive:{value:new vt(0)},specular:{value:new vt(1118481)},shininess:{value:30}}]),vertexShader:wn.meshphong_vert,fragmentShader:wn.meshphong_frag},standard:{uniforms:Zi([mt.common,mt.envmap,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.roughnessmap,mt.metalnessmap,mt.fog,mt.lights,{emissive:{value:new vt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:wn.meshphysical_vert,fragmentShader:wn.meshphysical_frag},toon:{uniforms:Zi([mt.common,mt.aomap,mt.lightmap,mt.emissivemap,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.gradientmap,mt.fog,mt.lights,{emissive:{value:new vt(0)}}]),vertexShader:wn.meshtoon_vert,fragmentShader:wn.meshtoon_frag},matcap:{uniforms:Zi([mt.common,mt.bumpmap,mt.normalmap,mt.displacementmap,mt.fog,{matcap:{value:null}}]),vertexShader:wn.meshmatcap_vert,fragmentShader:wn.meshmatcap_frag},points:{uniforms:Zi([mt.points,mt.fog]),vertexShader:wn.points_vert,fragmentShader:wn.points_frag},dashed:{uniforms:Zi([mt.common,mt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:wn.linedashed_vert,fragmentShader:wn.linedashed_frag},depth:{uniforms:Zi([mt.common,mt.displacementmap]),vertexShader:wn.depth_vert,fragmentShader:wn.depth_frag},normal:{uniforms:Zi([mt.common,mt.bumpmap,mt.normalmap,mt.displacementmap,{opacity:{value:1}}]),vertexShader:wn.meshnormal_vert,fragmentShader:wn.meshnormal_frag},sprite:{uniforms:Zi([mt.sprite,mt.fog]),vertexShader:wn.sprite_vert,fragmentShader:wn.sprite_frag},background:{uniforms:{uvTransform:{value:new _n},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:wn.background_vert,fragmentShader:wn.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:wn.backgroundCube_vert,fragmentShader:wn.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:wn.cube_vert,fragmentShader:wn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:wn.equirect_vert,fragmentShader:wn.equirect_frag},distanceRGBA:{uniforms:Zi([mt.common,mt.displacementmap,{referencePosition:{value:new re},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:wn.distanceRGBA_vert,fragmentShader:wn.distanceRGBA_frag},shadow:{uniforms:Zi([mt.lights,mt.fog,{color:{value:new vt(0)},opacity:{value:1}}]),vertexShader:wn.shadow_vert,fragmentShader:wn.shadow_frag}};ml.physical={uniforms:Zi([ml.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new _n},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new _n},clearcoatNormalScale:{value:new Je(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new _n},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new _n},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new _n},sheen:{value:0},sheenColor:{value:new vt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new _n},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new _n},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new _n},transmissionSamplerSize:{value:new Je},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new _n},attenuationDistance:{value:0},attenuationColor:{value:new vt(0)},specularColor:{value:new vt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new _n},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new _n},anisotropyVector:{value:new Je},anisotropyMap:{value:null},anisotropyMapTransform:{value:new _n}}]),vertexShader:wn.meshphysical_vert,fragmentShader:wn.meshphysical_frag};const q1={r:0,b:0,g:0};function f8(n,e,t,s,r,i,o){const a=new vt(0);let l=i===!0?0:1,u,c,h=null,f=0,p=null;function g(x,w){let _=!1,T=w.isScene===!0?w.background:null;T&&T.isTexture&&(T=(w.backgroundBlurriness>0?t:e).get(T)),T===null?S(a,l):T&&T.isColor&&(S(T,1),_=!0);const C=n.xr.getEnvironmentBlendMode();C==="additive"?s.buffers.color.setClear(0,0,0,1,o):C==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,o),(n.autoClear||_)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),T&&(T.isCubeTexture||T.mapping===_g)?(c===void 0&&(c=new Dr(new Kh(1,1,1),new Tl({name:"BackgroundCubeMaterial",uniforms:ag(ml.backgroundCube.uniforms),vertexShader:ml.backgroundCube.vertexShader,fragmentShader:ml.backgroundCube.fragmentShader,side:no,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(N,M,P){this.matrixWorld.copyPosition(P.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=T,c.material.uniforms.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=w.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=w.backgroundIntensity,c.material.toneMapped=Zn.getTransfer(T.colorSpace)!==ms,(h!==T||f!==T.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,h=T,f=T.version,p=n.toneMapping),c.layers.enableAll(),x.unshift(c,c.geometry,c.material,0,0,null)):T&&T.isTexture&&(u===void 0&&(u=new Dr(new ix(2,2),new Tl({name:"BackgroundMaterial",uniforms:ag(ml.background.uniforms),vertexShader:ml.background.vertexShader,fragmentShader:ml.background.fragmentShader,side:hc,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(u)),u.material.uniforms.t2D.value=T,u.material.uniforms.backgroundIntensity.value=w.backgroundIntensity,u.material.toneMapped=Zn.getTransfer(T.colorSpace)!==ms,T.matrixAutoUpdate===!0&&T.updateMatrix(),u.material.uniforms.uvTransform.value.copy(T.matrix),(h!==T||f!==T.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,h=T,f=T.version,p=n.toneMapping),u.layers.enableAll(),x.unshift(u,u.geometry,u.material,0,0,null))}function S(x,w){x.getRGB(q1,G3(n)),s.buffers.color.setClear(q1.r,q1.g,q1.b,w,o)}return{getClearColor:function(){return a},setClearColor:function(x,w=1){a.set(x),l=w,S(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(x){l=x,S(a,l)},render:g}}function p8(n,e,t,s){const r=n.getParameter(n.MAX_VERTEX_ATTRIBS),i=s.isWebGL2?null:e.get("OES_vertex_array_object"),o=s.isWebGL2||i!==null,a={},l=x(null);let u=l,c=!1;function h(W,H,J,ie,V){let Y=!1;if(o){const B=S(ie,J,H);u!==B&&(u=B,p(u.object)),Y=w(W,ie,J,V),Y&&_(W,ie,J,V)}else{const B=H.wireframe===!0;(u.geometry!==ie.id||u.program!==J.id||u.wireframe!==B)&&(u.geometry=ie.id,u.program=J.id,u.wireframe=B,Y=!0)}V!==null&&t.update(V,n.ELEMENT_ARRAY_BUFFER),(Y||c)&&(c=!1,$(W,H,J,ie),V!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(V).buffer))}function f(){return s.isWebGL2?n.createVertexArray():i.createVertexArrayOES()}function p(W){return s.isWebGL2?n.bindVertexArray(W):i.bindVertexArrayOES(W)}function g(W){return s.isWebGL2?n.deleteVertexArray(W):i.deleteVertexArrayOES(W)}function S(W,H,J){const ie=J.wireframe===!0;let V=a[W.id];V===void 0&&(V={},a[W.id]=V);let Y=V[H.id];Y===void 0&&(Y={},V[H.id]=Y);let B=Y[ie];return B===void 0&&(B=x(f()),Y[ie]=B),B}function x(W){const H=[],J=[],ie=[];for(let V=0;V<r;V++)H[V]=0,J[V]=0,ie[V]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:H,enabledAttributes:J,attributeDivisors:ie,object:W,attributes:{},index:null}}function w(W,H,J,ie){const V=u.attributes,Y=H.attributes;let B=0;const K=J.getAttributes();for(const se in K)if(K[se].location>=0){const ue=V[se];let fe=Y[se];if(fe===void 0&&(se==="instanceMatrix"&&W.instanceMatrix&&(fe=W.instanceMatrix),se==="instanceColor"&&W.instanceColor&&(fe=W.instanceColor)),ue===void 0||ue.attribute!==fe||fe&&ue.data!==fe.data)return!0;B++}return u.attributesNum!==B||u.index!==ie}function _(W,H,J,ie){const V={},Y=H.attributes;let B=0;const K=J.getAttributes();for(const se in K)if(K[se].location>=0){let ue=Y[se];ue===void 0&&(se==="instanceMatrix"&&W.instanceMatrix&&(ue=W.instanceMatrix),se==="instanceColor"&&W.instanceColor&&(ue=W.instanceColor));const fe={};fe.attribute=ue,ue&&ue.data&&(fe.data=ue.data),V[se]=fe,B++}u.attributes=V,u.attributesNum=B,u.index=ie}function T(){const W=u.newAttributes;for(let H=0,J=W.length;H<J;H++)W[H]=0}function C(W){N(W,0)}function N(W,H){const J=u.newAttributes,ie=u.enabledAttributes,V=u.attributeDivisors;J[W]=1,ie[W]===0&&(n.enableVertexAttribArray(W),ie[W]=1),V[W]!==H&&((s.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](W,H),V[W]=H)}function M(){const W=u.newAttributes,H=u.enabledAttributes;for(let J=0,ie=H.length;J<ie;J++)H[J]!==W[J]&&(n.disableVertexAttribArray(J),H[J]=0)}function P(W,H,J,ie,V,Y,B){B===!0?n.vertexAttribIPointer(W,H,J,V,Y):n.vertexAttribPointer(W,H,J,ie,V,Y)}function $(W,H,J,ie){if(s.isWebGL2===!1&&(W.isInstancedMesh||ie.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;T();const V=ie.attributes,Y=J.getAttributes(),B=H.defaultAttributeValues;for(const K in Y){const se=Y[K];if(se.location>=0){let te=V[K];if(te===void 0&&(K==="instanceMatrix"&&W.instanceMatrix&&(te=W.instanceMatrix),K==="instanceColor"&&W.instanceColor&&(te=W.instanceColor)),te!==void 0){const ue=te.normalized,fe=te.itemSize,_e=t.get(te);if(_e===void 0)continue;const Ie=_e.buffer,Ve=_e.type,qe=_e.bytesPerElement,Ye=s.isWebGL2===!0&&(Ve===n.INT||Ve===n.UNSIGNED_INT||te.gpuType===J2);if(te.isInterleavedBufferAttribute){const et=te.data,ae=et.stride,Be=te.offset;if(et.isInstancedInterleavedBuffer){for(let De=0;De<se.locationSize;De++)N(se.location+De,et.meshPerAttribute);W.isInstancedMesh!==!0&&ie._maxInstanceCount===void 0&&(ie._maxInstanceCount=et.meshPerAttribute*et.count)}else for(let De=0;De<se.locationSize;De++)C(se.location+De);n.bindBuffer(n.ARRAY_BUFFER,Ie);for(let De=0;De<se.locationSize;De++)P(se.location+De,fe/se.locationSize,Ve,ue,ae*qe,(Be+fe/se.locationSize*De)*qe,Ye)}else{if(te.isInstancedBufferAttribute){for(let et=0;et<se.locationSize;et++)N(se.location+et,te.meshPerAttribute);W.isInstancedMesh!==!0&&ie._maxInstanceCount===void 0&&(ie._maxInstanceCount=te.meshPerAttribute*te.count)}else for(let et=0;et<se.locationSize;et++)C(se.location+et);n.bindBuffer(n.ARRAY_BUFFER,Ie);for(let et=0;et<se.locationSize;et++)P(se.location+et,fe/se.locationSize,Ve,ue,fe*qe,fe/se.locationSize*et*qe,Ye)}}else if(B!==void 0){const ue=B[K];if(ue!==void 0)switch(ue.length){case 2:n.vertexAttrib2fv(se.location,ue);break;case 3:n.vertexAttrib3fv(se.location,ue);break;case 4:n.vertexAttrib4fv(se.location,ue);break;default:n.vertexAttrib1fv(se.location,ue)}}}}M()}function R(){G();for(const W in a){const H=a[W];for(const J in H){const ie=H[J];for(const V in ie)g(ie[V].object),delete ie[V];delete H[J]}delete a[W]}}function D(W){if(a[W.id]===void 0)return;const H=a[W.id];for(const J in H){const ie=H[J];for(const V in ie)g(ie[V].object),delete ie[V];delete H[J]}delete a[W.id]}function L(W){for(const H in a){const J=a[H];if(J[W.id]===void 0)continue;const ie=J[W.id];for(const V in ie)g(ie[V].object),delete ie[V];delete J[W.id]}}function G(){Q(),c=!0,u!==l&&(u=l,p(u.object))}function Q(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:G,resetDefaultState:Q,dispose:R,releaseStatesOfGeometry:D,releaseStatesOfProgram:L,initAttributes:T,enableAttribute:C,disableUnusedAttributes:M}}function m8(n,e,t,s){const r=s.isWebGL2;let i;function o(c){i=c}function a(c,h){n.drawArrays(i,c,h),t.update(h,i,1)}function l(c,h,f){if(f===0)return;let p,g;if(r)p=n,g="drawArraysInstanced";else if(p=e.get("ANGLE_instanced_arrays"),g="drawArraysInstancedANGLE",p===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[g](i,c,h,f),t.update(h,i,f)}function u(c,h,f){if(f===0)return;const p=e.get("WEBGL_multi_draw");if(p===null)for(let g=0;g<f;g++)this.render(c[g],h[g]);else{p.multiDrawArraysWEBGL(i,c,0,h,0,f);let g=0;for(let S=0;S<f;S++)g+=h[S];t.update(g,i,1)}}this.setMode=o,this.render=a,this.renderInstances=l,this.renderMultiDraw=u}function g8(n,e,t){let s;function r(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const P=e.get("EXT_texture_filter_anisotropic");s=n.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function i(P){if(P==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";P="mediump"}return P==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const u=o||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,h=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),f=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),g=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),S=n.getParameter(n.MAX_VERTEX_ATTRIBS),x=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),w=n.getParameter(n.MAX_VARYING_VECTORS),_=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),T=f>0,C=o||e.has("OES_texture_float"),N=T&&C,M=o?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:u,getMaxAnisotropy:r,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:f,maxTextureSize:p,maxCubemapSize:g,maxAttributes:S,maxVertexUniforms:x,maxVaryings:w,maxFragmentUniforms:_,vertexTextures:T,floatFragmentTextures:C,floatVertexTextures:N,maxSamples:M}}function y8(n){const e=this;let t=null,s=0,r=!1,i=!1;const o=new xh,a=new _n,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,f){const p=h.length!==0||f||s!==0||r;return r=f,s=h.length,p},this.beginShadows=function(){i=!0,c(null)},this.endShadows=function(){i=!1},this.setGlobalState=function(h,f){t=c(h,f,0)},this.setState=function(h,f,p){const g=h.clippingPlanes,S=h.clipIntersection,x=h.clipShadows,w=n.get(h);if(!r||g===null||g.length===0||i&&!x)i?c(null):u();else{const _=i?0:s,T=_*4;let C=w.clippingState||null;l.value=C,C=c(g,f,T,p);for(let N=0;N!==T;++N)C[N]=t[N];w.clippingState=C,this.numIntersection=S?this.numPlanes:0,this.numPlanes+=_}};function u(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function c(h,f,p,g){const S=h!==null?h.length:0;let x=null;if(S!==0){if(x=l.value,g!==!0||x===null){const w=p+S*4,_=f.matrixWorldInverse;a.getNormalMatrix(_),(x===null||x.length<w)&&(x=new Float32Array(w));for(let T=0,C=p;T!==S;++T,C+=4)o.copy(h[T]).applyMatrix4(_,a),o.normal.toArray(x,C),x[C+3]=o.constant}l.value=x,l.needsUpdate=!0}return e.numPlanes=S,e.numIntersection=0,x}}function x8(n){let e=new WeakMap;function t(o,a){return a===g0?o.mapping=dc:a===y0&&(o.mapping=kh),o}function s(o){if(o&&o.isTexture){const a=o.mapping;if(a===g0||a===y0)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const u=new X3(l.height/2);return u.fromEquirectangularTexture(n,o),e.set(o,u),o.addEventListener("dispose",r),t(u.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:s,dispose:i}}class ox extends nx{constructor(e=-1,t=1,s=1,r=-1,i=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=r,this.near=i,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,r,i,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=s-e,o=s+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=u*this.view.offsetX,o=i+u*this.view.width,a-=c*this.view.offsetY,l=a-c*this.view.height}this.projectionMatrix.makeOrthographic(i,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Gm=4,nR=[.125,.215,.35,.446,.526,.582],cf=20,aC=new ox,sR=new vt;let lC=null,uC=0,cC=0;const lf=(1+Math.sqrt(5))/2,_m=1/lf,rR=[new re(1,1,1),new re(-1,1,1),new re(1,1,-1),new re(-1,1,-1),new re(0,lf,_m),new re(0,lf,-_m),new re(_m,0,lf),new re(-_m,0,lf),new re(lf,_m,0),new re(-lf,_m,0)];class VE{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,r=100){lC=this._renderer.getRenderTarget(),uC=this._renderer.getActiveCubeFace(),cC=this._renderer.getActiveMipmapLevel(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(e,s,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=aR(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=oR(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(lC,uC,cC),e.scissorTest=!1,K1(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===dc||e.mapping===kh?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),lC=this._renderer.getRenderTarget(),uC=this._renderer.getActiveCubeFace(),cC=this._renderer.getActiveMipmapLevel();const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:rr,minFilter:rr,generateMipmaps:!1,type:rg,format:eo,colorSpace:du,depthBuffer:!1},r=iR(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=iR(e,t,s);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=v8(i)),this._blurMaterial=w8(i,e,t)}return r}_compileMaterial(e){const t=new Dr(this._lodPlanes[0],e);this._renderer.compile(t,aC)}_sceneToCubeUV(e,t,s,r){const a=new jr(90,1,t,s),l=[1,-1,1,1,1,1],u=[1,1,1,-1,-1,-1],c=this._renderer,h=c.autoClear,f=c.toneMapping;c.getClearColor(sR),c.toneMapping=iu,c.autoClear=!1;const p=new qh({name:"PMREM.Background",side:no,depthWrite:!1,depthTest:!1}),g=new Dr(new Kh,p);let S=!1;const x=e.background;x?x.isColor&&(p.color.copy(x),e.background=null,S=!0):(p.color.copy(sR),S=!0);for(let w=0;w<6;w++){const _=w%3;_===0?(a.up.set(0,l[w],0),a.lookAt(u[w],0,0)):_===1?(a.up.set(0,0,l[w]),a.lookAt(0,u[w],0)):(a.up.set(0,l[w],0),a.lookAt(0,0,u[w]));const T=this._cubeSize;K1(r,_*T,w>2?T:0,T,T),c.setRenderTarget(r),S&&c.render(g,a),c.render(e,a)}g.geometry.dispose(),g.material.dispose(),c.toneMapping=f,c.autoClear=h,e.background=x}_textureToCubeUV(e,t){const s=this._renderer,r=e.mapping===dc||e.mapping===kh;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=aR()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=oR());const i=r?this._cubemapMaterial:this._equirectMaterial,o=new Dr(this._lodPlanes[0],i),a=i.uniforms;a.envMap.value=e;const l=this._cubeSize;K1(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(o,aC)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){const i=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),o=rR[(r-1)%rR.length];this._blur(e,r-1,r,i,o)}t.autoClear=s}_blur(e,t,s,r,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,r,"latitudinal",i),this._halfBlur(o,e,s,s,r,"longitudinal",i)}_halfBlur(e,t,s,r,i,o,a){const l=this._renderer,u=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,h=new Dr(this._lodPlanes[r],u),f=u.uniforms,p=this._sizeLods[s]-1,g=isFinite(i)?Math.PI/(2*p):2*Math.PI/(2*cf-1),S=i/g,x=isFinite(i)?1+Math.floor(c*S):cf;x>cf&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${cf}`);const w=[];let _=0;for(let P=0;P<cf;++P){const $=P/S,R=Math.exp(-$*$/2);w.push(R),P===0?_+=R:P<x&&(_+=2*R)}for(let P=0;P<w.length;P++)w[P]=w[P]/_;f.envMap.value=e.texture,f.samples.value=x,f.weights.value=w,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a);const{_lodMax:T}=this;f.dTheta.value=g,f.mipInt.value=T-s;const C=this._sizeLods[r],N=3*C*(r>T-Gm?r-T+Gm:0),M=4*(this._cubeSize-C);K1(t,N,M,3*C,2*C),l.setRenderTarget(t),l.render(h,aC)}}function v8(n){const e=[],t=[],s=[];let r=n;const i=n-Gm+1+nR.length;for(let o=0;o<i;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-Gm?l=nR[o-n+Gm-1]:o===0&&(l=0),s.push(l);const u=1/(a-2),c=-u,h=1+u,f=[c,c,h,c,h,h,c,c,h,h,c,h],p=6,g=6,S=3,x=2,w=1,_=new Float32Array(S*g*p),T=new Float32Array(x*g*p),C=new Float32Array(w*g*p);for(let M=0;M<p;M++){const P=M%3*2/3-1,$=M>2?0:-1,R=[P,$,0,P+2/3,$,0,P+2/3,$+1,0,P,$,0,P+2/3,$+1,0,P,$+1,0];_.set(R,S*g*M),T.set(f,x*g*M);const D=[M,M,M,M,M,M];C.set(D,w*g*M)}const N=new bn;N.setAttribute("position",new Qn(_,S)),N.setAttribute("uv",new Qn(T,x)),N.setAttribute("faceIndex",new Qn(C,w)),e.push(N),r>Gm&&r--}return{lodPlanes:e,sizeLods:t,sigmas:s}}function iR(n,e,t){const s=new _l(n,e,t);return s.texture.mapping=_g,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function K1(n,e,t,s,r){n.viewport.set(e,t,s,r),n.scissor.set(e,t,s,r)}function w8(n,e,t){const s=new Float32Array(cf),r=new re(0,1,0);return new Tl({name:"SphericalGaussianBlur",defines:{n:cf,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:fI(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ac,depthTest:!1,depthWrite:!1})}function oR(){return new Tl({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:fI(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ac,depthTest:!1,depthWrite:!1})}function aR(){return new Tl({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:fI(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ac,depthTest:!1,depthWrite:!1})}function fI(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function S8(n){let e=new WeakMap,t=null;function s(a){if(a&&a.isTexture){const l=a.mapping,u=l===g0||l===y0,c=l===dc||l===kh;if(u||c)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new VE(n)),h=u?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(u&&h&&h.height>0||c&&h&&r(h)){t===null&&(t=new VE(n));const f=u?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,f),a.addEventListener("dispose",i),f.texture}else return null}}}return a}function r(a){let l=0;const u=6;for(let c=0;c<u;c++)a[c]!==void 0&&l++;return l===u}function i(a){const l=a.target;l.removeEventListener("dispose",i);const u=e.get(l);u!==void 0&&(e.delete(l),u.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:o}}function b8(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let r;switch(s){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(s)}return e[s]=r,r}return{has:function(s){return t(s)!==null},init:function(s){s.isWebGL2?(t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance")):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(s){const r=t(s);return r===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),r}}}function _8(n,e,t,s){const r={},i=new WeakMap;function o(h){const f=h.target;f.index!==null&&e.remove(f.index);for(const g in f.attributes)e.remove(f.attributes[g]);for(const g in f.morphAttributes){const S=f.morphAttributes[g];for(let x=0,w=S.length;x<w;x++)e.remove(S[x])}f.removeEventListener("dispose",o),delete r[f.id];const p=i.get(f);p&&(e.remove(p),i.delete(f)),s.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(h,f){return r[f.id]===!0||(f.addEventListener("dispose",o),r[f.id]=!0,t.memory.geometries++),f}function l(h){const f=h.attributes;for(const g in f)e.update(f[g],n.ARRAY_BUFFER);const p=h.morphAttributes;for(const g in p){const S=p[g];for(let x=0,w=S.length;x<w;x++)e.update(S[x],n.ARRAY_BUFFER)}}function u(h){const f=[],p=h.index,g=h.attributes.position;let S=0;if(p!==null){const _=p.array;S=p.version;for(let T=0,C=_.length;T<C;T+=3){const N=_[T+0],M=_[T+1],P=_[T+2];f.push(N,M,M,P,P,N)}}else if(g!==void 0){const _=g.array;S=g.version;for(let T=0,C=_.length/3-1;T<C;T+=3){const N=T+0,M=T+1,P=T+2;f.push(N,M,M,P,P,N)}}else return;const x=new(U3(f)?dI:hI)(f,1);x.version=S;const w=i.get(h);w&&e.remove(w),i.set(h,x)}function c(h){const f=i.get(h);if(f){const p=h.index;p!==null&&f.version<p.version&&u(h)}else u(h);return i.get(h)}return{get:a,update:l,getWireframeAttribute:c}}function T8(n,e,t,s){const r=s.isWebGL2;let i;function o(p){i=p}let a,l;function u(p){a=p.type,l=p.bytesPerElement}function c(p,g){n.drawElements(i,g,a,p*l),t.update(g,i,1)}function h(p,g,S){if(S===0)return;let x,w;if(r)x=n,w="drawElementsInstanced";else if(x=e.get("ANGLE_instanced_arrays"),w="drawElementsInstancedANGLE",x===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}x[w](i,g,a,p*l,S),t.update(g,i,S)}function f(p,g,S){if(S===0)return;const x=e.get("WEBGL_multi_draw");if(x===null)for(let w=0;w<S;w++)this.render(p[w]/l,g[w]);else{x.multiDrawElementsWEBGL(i,g,0,a,p,0,S);let w=0;for(let _=0;_<S;_++)w+=g[_];t.update(w,i,1)}}this.setMode=o,this.setIndex=u,this.render=c,this.renderInstances=h,this.renderMultiDraw=f}function C8(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(i,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(i/3);break;case n.LINES:t.lines+=a*(i/2);break;case n.LINE_STRIP:t.lines+=a*(i-1);break;case n.LINE_LOOP:t.lines+=a*i;break;case n.POINTS:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:s}}function E8(n,e){return n[0]-e[0]}function I8(n,e){return Math.abs(e[1])-Math.abs(n[1])}function N8(n,e,t){const s={},r=new Float32Array(8),i=new WeakMap,o=new Jn,a=[];for(let u=0;u<8;u++)a[u]=[u,0];function l(u,c,h){const f=u.morphTargetInfluences;if(e.isWebGL2===!0){const g=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,S=g!==void 0?g.length:0;let x=i.get(c);if(x===void 0||x.count!==S){let H=function(){Q.dispose(),i.delete(c),c.removeEventListener("dispose",H)};var p=H;x!==void 0&&x.texture.dispose();const T=c.morphAttributes.position!==void 0,C=c.morphAttributes.normal!==void 0,N=c.morphAttributes.color!==void 0,M=c.morphAttributes.position||[],P=c.morphAttributes.normal||[],$=c.morphAttributes.color||[];let R=0;T===!0&&(R=1),C===!0&&(R=2),N===!0&&(R=3);let D=c.attributes.position.count*R,L=1;D>e.maxTextureSize&&(L=Math.ceil(D/e.maxTextureSize),D=e.maxTextureSize);const G=new Float32Array(D*L*4*S),Q=new KS(G,D,L,S);Q.type=xl,Q.needsUpdate=!0;const W=R*4;for(let J=0;J<S;J++){const ie=M[J],V=P[J],Y=$[J],B=D*L*4*J;for(let K=0;K<ie.count;K++){const se=K*W;T===!0&&(o.fromBufferAttribute(ie,K),G[B+se+0]=o.x,G[B+se+1]=o.y,G[B+se+2]=o.z,G[B+se+3]=0),C===!0&&(o.fromBufferAttribute(V,K),G[B+se+4]=o.x,G[B+se+5]=o.y,G[B+se+6]=o.z,G[B+se+7]=0),N===!0&&(o.fromBufferAttribute(Y,K),G[B+se+8]=o.x,G[B+se+9]=o.y,G[B+se+10]=o.z,G[B+se+11]=Y.itemSize===4?o.w:1)}}x={count:S,texture:Q,size:new Je(D,L)},i.set(c,x),c.addEventListener("dispose",H)}let w=0;for(let T=0;T<f.length;T++)w+=f[T];const _=c.morphTargetsRelative?1:1-w;h.getUniforms().setValue(n,"morphTargetBaseInfluence",_),h.getUniforms().setValue(n,"morphTargetInfluences",f),h.getUniforms().setValue(n,"morphTargetsTexture",x.texture,t),h.getUniforms().setValue(n,"morphTargetsTextureSize",x.size)}else{const g=f===void 0?0:f.length;let S=s[c.id];if(S===void 0||S.length!==g){S=[];for(let C=0;C<g;C++)S[C]=[C,0];s[c.id]=S}for(let C=0;C<g;C++){const N=S[C];N[0]=C,N[1]=f[C]}S.sort(I8);for(let C=0;C<8;C++)C<g&&S[C][1]?(a[C][0]=S[C][0],a[C][1]=S[C][1]):(a[C][0]=Number.MAX_SAFE_INTEGER,a[C][1]=0);a.sort(E8);const x=c.morphAttributes.position,w=c.morphAttributes.normal;let _=0;for(let C=0;C<8;C++){const N=a[C],M=N[0],P=N[1];M!==Number.MAX_SAFE_INTEGER&&P?(x&&c.getAttribute("morphTarget"+C)!==x[M]&&c.setAttribute("morphTarget"+C,x[M]),w&&c.getAttribute("morphNormal"+C)!==w[M]&&c.setAttribute("morphNormal"+C,w[M]),r[C]=P,_+=P):(x&&c.hasAttribute("morphTarget"+C)===!0&&c.deleteAttribute("morphTarget"+C),w&&c.hasAttribute("morphNormal"+C)===!0&&c.deleteAttribute("morphNormal"+C),r[C]=0)}const T=c.morphTargetsRelative?1:1-_;h.getUniforms().setValue(n,"morphTargetBaseInfluence",T),h.getUniforms().setValue(n,"morphTargetInfluences",r)}}return{update:l}}function A8(n,e,t,s){let r=new WeakMap;function i(l){const u=s.render.frame,c=l.geometry,h=e.get(l,c);if(r.get(h)!==u&&(e.update(h),r.set(h,u)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),r.get(l)!==u&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),r.set(l,u))),l.isSkinnedMesh){const f=l.skeleton;r.get(f)!==u&&(f.update(),r.set(f,u))}return h}function o(){r=new WeakMap}function a(l){const u=l.target;u.removeEventListener("dispose",a),t.remove(u.instanceMatrix),u.instanceColor!==null&&t.remove(u.instanceColor)}return{update:i,dispose:o}}class pI extends Hs{constructor(e,t,s,r,i,o,a,l,u,c){if(c=c!==void 0?c:Ch,c!==Ch&&c!==Mf)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&c===Ch&&(s=ic),s===void 0&&c===Mf&&(s=Th),super(null,r,i,o,a,l,c,s,u),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:sr,this.minFilter=l!==void 0?l:sr,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}const K3=new Hs,Y3=new pI(1,1);Y3.compareFunction=aI;const Z3=new KS,J3=new cI,Q3=new sx,lR=[],uR=[],cR=new Float32Array(16),hR=new Float32Array(9),dR=new Float32Array(4);function Eg(n,e,t){const s=n[0];if(s<=0||s>0)return n;const r=e*t;let i=lR[r];if(i===void 0&&(i=new Float32Array(r),lR[r]=i),e!==0){s.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function Or(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function Fr(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function YS(n,e){let t=uR[e];t===void 0&&(t=new Int32Array(e),uR[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function M8(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function k8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Or(t,e))return;n.uniform2fv(this.addr,e),Fr(t,e)}}function R8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Or(t,e))return;n.uniform3fv(this.addr,e),Fr(t,e)}}function D8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Or(t,e))return;n.uniform4fv(this.addr,e),Fr(t,e)}}function P8(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Or(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Fr(t,e)}else{if(Or(t,s))return;dR.set(s),n.uniformMatrix2fv(this.addr,!1,dR),Fr(t,s)}}function L8(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Or(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Fr(t,e)}else{if(Or(t,s))return;hR.set(s),n.uniformMatrix3fv(this.addr,!1,hR),Fr(t,s)}}function O8(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Or(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Fr(t,e)}else{if(Or(t,s))return;cR.set(s),n.uniformMatrix4fv(this.addr,!1,cR),Fr(t,s)}}function F8(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function $8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Or(t,e))return;n.uniform2iv(this.addr,e),Fr(t,e)}}function z8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Or(t,e))return;n.uniform3iv(this.addr,e),Fr(t,e)}}function U8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Or(t,e))return;n.uniform4iv(this.addr,e),Fr(t,e)}}function B8(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function V8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Or(t,e))return;n.uniform2uiv(this.addr,e),Fr(t,e)}}function W8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Or(t,e))return;n.uniform3uiv(this.addr,e),Fr(t,e)}}function G8(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Or(t,e))return;n.uniform4uiv(this.addr,e),Fr(t,e)}}function H8(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r);const i=this.type===n.SAMPLER_2D_SHADOW?Y3:K3;t.setTexture2D(e||i,r)}function j8(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTexture3D(e||J3,r)}function X8(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTextureCube(e||Q3,r)}function q8(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTexture2DArray(e||Z3,r)}function K8(n){switch(n){case 5126:return M8;case 35664:return k8;case 35665:return R8;case 35666:return D8;case 35674:return P8;case 35675:return L8;case 35676:return O8;case 5124:case 35670:return F8;case 35667:case 35671:return $8;case 35668:case 35672:return z8;case 35669:case 35673:return U8;case 5125:return B8;case 36294:return V8;case 36295:return W8;case 36296:return G8;case 35678:case 36198:case 36298:case 36306:case 35682:return H8;case 35679:case 36299:case 36307:return j8;case 35680:case 36300:case 36308:case 36293:return X8;case 36289:case 36303:case 36311:case 36292:return q8}}function Y8(n,e){n.uniform1fv(this.addr,e)}function Z8(n,e){const t=Eg(e,this.size,2);n.uniform2fv(this.addr,t)}function J8(n,e){const t=Eg(e,this.size,3);n.uniform3fv(this.addr,t)}function Q8(n,e){const t=Eg(e,this.size,4);n.uniform4fv(this.addr,t)}function ej(n,e){const t=Eg(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function tj(n,e){const t=Eg(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function nj(n,e){const t=Eg(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function sj(n,e){n.uniform1iv(this.addr,e)}function rj(n,e){n.uniform2iv(this.addr,e)}function ij(n,e){n.uniform3iv(this.addr,e)}function oj(n,e){n.uniform4iv(this.addr,e)}function aj(n,e){n.uniform1uiv(this.addr,e)}function lj(n,e){n.uniform2uiv(this.addr,e)}function uj(n,e){n.uniform3uiv(this.addr,e)}function cj(n,e){n.uniform4uiv(this.addr,e)}function hj(n,e,t){const s=this.cache,r=e.length,i=YS(t,r);Or(s,i)||(n.uniform1iv(this.addr,i),Fr(s,i));for(let o=0;o!==r;++o)t.setTexture2D(e[o]||K3,i[o])}function dj(n,e,t){const s=this.cache,r=e.length,i=YS(t,r);Or(s,i)||(n.uniform1iv(this.addr,i),Fr(s,i));for(let o=0;o!==r;++o)t.setTexture3D(e[o]||J3,i[o])}function fj(n,e,t){const s=this.cache,r=e.length,i=YS(t,r);Or(s,i)||(n.uniform1iv(this.addr,i),Fr(s,i));for(let o=0;o!==r;++o)t.setTextureCube(e[o]||Q3,i[o])}function pj(n,e,t){const s=this.cache,r=e.length,i=YS(t,r);Or(s,i)||(n.uniform1iv(this.addr,i),Fr(s,i));for(let o=0;o!==r;++o)t.setTexture2DArray(e[o]||Z3,i[o])}function mj(n){switch(n){case 5126:return Y8;case 35664:return Z8;case 35665:return J8;case 35666:return Q8;case 35674:return ej;case 35675:return tj;case 35676:return nj;case 5124:case 35670:return sj;case 35667:case 35671:return rj;case 35668:case 35672:return ij;case 35669:case 35673:return oj;case 5125:return aj;case 36294:return lj;case 36295:return uj;case 36296:return cj;case 35678:case 36198:case 36298:case 36306:case 35682:return hj;case 35679:case 36299:case 36307:return dj;case 35680:case 36300:case 36308:case 36293:return fj;case 36289:case 36303:case 36311:case 36292:return pj}}class gj{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.setValue=K8(t.type)}}class yj{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=mj(t.type)}}class xj{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const r=this.seq;for(let i=0,o=r.length;i!==o;++i){const a=r[i];a.setValue(e,t[a.id],s)}}}const hC=/(\w+)(\])?(\[|\.)?/g;function fR(n,e){n.seq.push(e),n.map[e.id]=e}function vj(n,e,t){const s=n.name,r=s.length;for(hC.lastIndex=0;;){const i=hC.exec(s),o=hC.lastIndex;let a=i[1];const l=i[2]==="]",u=i[3];if(l&&(a=a|0),u===void 0||u==="["&&o+2===r){fR(t,u===void 0?new gj(a,n,e):new yj(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new xj(a),fR(t,h)),t=h}}}class Ww{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<s;++r){const i=e.getActiveUniform(t,r),o=e.getUniformLocation(t,i.name);vj(i,o,this)}}setValue(e,t,s,r){const i=this.map[t];i!==void 0&&i.setValue(e,s,r)}setOptional(e,t,s){const r=t[s];r!==void 0&&this.setValue(e,s,r)}static upload(e,t,s,r){for(let i=0,o=t.length;i!==o;++i){const a=t[i],l=s[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,r)}}static seqWithValue(e,t){const s=[];for(let r=0,i=e.length;r!==i;++r){const o=e[r];o.id in t&&s.push(o)}return s}}function pR(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}const wj=37297;let Sj=0;function bj(n,e){const t=n.split(`
`),s=[],r=Math.max(e-6,0),i=Math.min(e+6,t.length);for(let o=r;o<i;o++){const a=o+1;s.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return s.join(`
`)}function _j(n){const e=Zn.getPrimaries(Zn.workingColorSpace),t=Zn.getPrimaries(n);let s;switch(e===t?s="":e===T0&&t===_0?s="LinearDisplayP3ToLinearSRGB":e===_0&&t===T0&&(s="LinearSRGBToLinearDisplayP3"),n){case du:case tx:return[s,"LinearTransferOETF"];case kr:case qS:return[s,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[s,"LinearTransferOETF"]}}function mR(n,e,t){const s=n.getShaderParameter(e,n.COMPILE_STATUS),r=n.getShaderInfoLog(e).trim();if(s&&r==="")return"";const i=/ERROR: 0:(\d+)/.exec(r);if(i){const o=parseInt(i[1]);return t.toUpperCase()+`

`+r+`

`+bj(n.getShaderSource(e),o)}else return r}function Tj(n,e){const t=_j(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function Cj(n,e){let t;switch(e){case f3:t="Linear";break;case p3:t="Reinhard";break;case m3:t="OptimizedCineon";break;case GS:t="ACESFilmic";break;case y3:t="AgX";break;case g3:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Ej(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Hm).join(`
`)}function Ij(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":""].filter(Hm).join(`
`)}function Nj(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function Aj(n,e){const t={},s=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let r=0;r<s;r++){const i=n.getActiveAttrib(e,r),o=i.name;let a=1;i.type===n.FLOAT_MAT2&&(a=2),i.type===n.FLOAT_MAT3&&(a=3),i.type===n.FLOAT_MAT4&&(a=4),t[o]={type:i.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Hm(n){return n!==""}function gR(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function yR(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Mj=/^[ \t]*#include +<([\w\d./]+)>/gm;function WE(n){return n.replace(Mj,Rj)}const kj=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function Rj(n,e){let t=wn[e];if(t===void 0){const s=kj.get(e);if(s!==void 0)t=wn[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return WE(t)}const Dj=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function xR(n){return n.replace(Dj,Pj)}function Pj(n,e,t,s){let r="";for(let i=parseInt(e);i<parseInt(t);i++)r+=s.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return r}function vR(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Lj(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===WS?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===l0?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===pl&&(e="SHADOWMAP_TYPE_VSM"),e}function Oj(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case dc:case kh:e="ENVMAP_TYPE_CUBE";break;case _g:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Fj(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case kh:e="ENVMAP_MODE_REFRACTION";break}return e}function $j(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case ex:e="ENVMAP_BLENDING_MULTIPLY";break;case h3:e="ENVMAP_BLENDING_MIX";break;case d3:e="ENVMAP_BLENDING_ADD";break}return e}function zj(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:s,maxMip:t}}function Uj(n,e,t,s){const r=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=Lj(t),u=Oj(t),c=Fj(t),h=$j(t),f=zj(t),p=t.isWebGL2?"":Ej(t),g=Ij(t),S=Nj(i),x=r.createProgram();let w,_,T=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(w=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S].filter(Hm).join(`
`),w.length>0&&(w+=`
`),_=[p,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S].filter(Hm).join(`
`),_.length>0&&(_+=`
`)):(w=[vR(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Hm).join(`
`),_=[p,vR(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,S,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",f?"#define CUBEUV_TEXEL_WIDTH "+f.texelWidth:"",f?"#define CUBEUV_TEXEL_HEIGHT "+f.texelHeight:"",f?"#define CUBEUV_MAX_MIP "+f.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==iu?"#define TONE_MAPPING":"",t.toneMapping!==iu?wn.tonemapping_pars_fragment:"",t.toneMapping!==iu?Cj("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",wn.colorspace_pars_fragment,Tj("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Hm).join(`
`)),o=WE(o),o=gR(o,t),o=yR(o,t),a=WE(a),a=gR(a,t),a=yR(a,t),o=xR(o),a=xR(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,w=[g,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+w,_=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===UE?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===UE?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const C=T+w+o,N=T+_+a,M=pR(r,r.VERTEX_SHADER,C),P=pR(r,r.FRAGMENT_SHADER,N);r.attachShader(x,M),r.attachShader(x,P),t.index0AttributeName!==void 0?r.bindAttribLocation(x,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(x,0,"position"),r.linkProgram(x);function $(G){if(n.debug.checkShaderErrors){const Q=r.getProgramInfoLog(x).trim(),W=r.getShaderInfoLog(M).trim(),H=r.getShaderInfoLog(P).trim();let J=!0,ie=!0;if(r.getProgramParameter(x,r.LINK_STATUS)===!1)if(J=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(r,x,M,P);else{const V=mR(r,M,"vertex"),Y=mR(r,P,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(x,r.VALIDATE_STATUS)+`

Program Info Log: `+Q+`
`+V+`
`+Y)}else Q!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Q):(W===""||H==="")&&(ie=!1);ie&&(G.diagnostics={runnable:J,programLog:Q,vertexShader:{log:W,prefix:w},fragmentShader:{log:H,prefix:_}})}r.deleteShader(M),r.deleteShader(P),R=new Ww(r,x),D=Aj(r,x)}let R;this.getUniforms=function(){return R===void 0&&$(this),R};let D;this.getAttributes=function(){return D===void 0&&$(this),D};let L=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return L===!1&&(L=r.getProgramParameter(x,wj)),L},this.destroy=function(){s.releaseStatesOfProgram(this),r.deleteProgram(x),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=Sj++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=M,this.fragmentShader=P,this}let Bj=0;class Vj{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(s),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(i)===!1&&(o.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new Wj(e),t.set(e,s)),s}}class Wj{constructor(e){this.id=Bj++,this.code=e,this.usedTimes=0}}function Gj(n,e,t,s,r,i,o){const a=new Cf,l=new Vj,u=[],c=r.isWebGL2,h=r.logarithmicDepthBuffer,f=r.vertexTextures;let p=r.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function S(R){return R===0?"uv":`uv${R}`}function x(R,D,L,G,Q){const W=G.fog,H=Q.geometry,J=R.isMeshStandardMaterial?G.environment:null,ie=(R.isMeshStandardMaterial?t:e).get(R.envMap||J),V=ie&&ie.mapping===_g?ie.image.height:null,Y=g[R.type];R.precision!==null&&(p=r.getMaxPrecision(R.precision),p!==R.precision&&console.warn("THREE.WebGLProgram.getParameters:",R.precision,"not supported, using",p,"instead."));const B=H.morphAttributes.position||H.morphAttributes.normal||H.morphAttributes.color,K=B!==void 0?B.length:0;let se=0;H.morphAttributes.position!==void 0&&(se=1),H.morphAttributes.normal!==void 0&&(se=2),H.morphAttributes.color!==void 0&&(se=3);let te,ue,fe,_e;if(Y){const Ys=ml[Y];te=Ys.vertexShader,ue=Ys.fragmentShader}else te=R.vertexShader,ue=R.fragmentShader,l.update(R),fe=l.getVertexShaderID(R),_e=l.getFragmentShaderID(R);const Ie=n.getRenderTarget(),Ve=Q.isInstancedMesh===!0,qe=Q.isBatchedMesh===!0,Ye=!!R.map,et=!!R.matcap,ae=!!ie,Be=!!R.aoMap,De=!!R.lightMap,He=!!R.bumpMap,Re=!!R.normalMap,at=!!R.displacementMap,Qe=!!R.emissiveMap,ee=!!R.metalnessMap,X=!!R.roughnessMap,Se=R.anisotropy>0,We=R.clearcoat>0,Xe=R.iridescence>0,je=R.sheen>0,xt=R.transmission>0,it=Se&&!!R.anisotropyMap,dt=We&&!!R.clearcoatMap,It=We&&!!R.clearcoatNormalMap,Yt=We&&!!R.clearcoatRoughnessMap,Ke=Xe&&!!R.iridescenceMap,hn=Xe&&!!R.iridescenceThicknessMap,un=je&&!!R.sheenColorMap,qt=je&&!!R.sheenRoughnessMap,Bt=!!R.specularMap,yt=!!R.specularColorMap,jt=!!R.specularIntensityMap,Nn=xt&&!!R.transmissionMap,jn=xt&&!!R.thicknessMap,sn=!!R.gradientMap,ut=!!R.alphaMap,ge=R.alphaTest>0,ct=!!R.alphaHash,pt=!!R.extensions,Kt=!!H.attributes.uv1,Gt=!!H.attributes.uv2,Bn=!!H.attributes.uv3;let kn=iu;return R.toneMapped&&(Ie===null||Ie.isXRRenderTarget===!0)&&(kn=n.toneMapping),{isWebGL2:c,shaderID:Y,shaderType:R.type,shaderName:R.name,vertexShader:te,fragmentShader:ue,defines:R.defines,customVertexShaderID:fe,customFragmentShaderID:_e,isRawShaderMaterial:R.isRawShaderMaterial===!0,glslVersion:R.glslVersion,precision:p,batching:qe,instancing:Ve,instancingColor:Ve&&Q.instanceColor!==null,supportsVertexTextures:f,outputColorSpace:Ie===null?n.outputColorSpace:Ie.isXRRenderTarget===!0?Ie.texture.colorSpace:du,map:Ye,matcap:et,envMap:ae,envMapMode:ae&&ie.mapping,envMapCubeUVHeight:V,aoMap:Be,lightMap:De,bumpMap:He,normalMap:Re,displacementMap:f&&at,emissiveMap:Qe,normalMapObjectSpace:Re&&R.normalMapType===R3,normalMapTangentSpace:Re&&R.normalMapType===Xh,metalnessMap:ee,roughnessMap:X,anisotropy:Se,anisotropyMap:it,clearcoat:We,clearcoatMap:dt,clearcoatNormalMap:It,clearcoatRoughnessMap:Yt,iridescence:Xe,iridescenceMap:Ke,iridescenceThicknessMap:hn,sheen:je,sheenColorMap:un,sheenRoughnessMap:qt,specularMap:Bt,specularColorMap:yt,specularIntensityMap:jt,transmission:xt,transmissionMap:Nn,thicknessMap:jn,gradientMap:sn,opaque:R.transparent===!1&&R.blending===_f,alphaMap:ut,alphaTest:ge,alphaHash:ct,combine:R.combine,mapUv:Ye&&S(R.map.channel),aoMapUv:Be&&S(R.aoMap.channel),lightMapUv:De&&S(R.lightMap.channel),bumpMapUv:He&&S(R.bumpMap.channel),normalMapUv:Re&&S(R.normalMap.channel),displacementMapUv:at&&S(R.displacementMap.channel),emissiveMapUv:Qe&&S(R.emissiveMap.channel),metalnessMapUv:ee&&S(R.metalnessMap.channel),roughnessMapUv:X&&S(R.roughnessMap.channel),anisotropyMapUv:it&&S(R.anisotropyMap.channel),clearcoatMapUv:dt&&S(R.clearcoatMap.channel),clearcoatNormalMapUv:It&&S(R.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Yt&&S(R.clearcoatRoughnessMap.channel),iridescenceMapUv:Ke&&S(R.iridescenceMap.channel),iridescenceThicknessMapUv:hn&&S(R.iridescenceThicknessMap.channel),sheenColorMapUv:un&&S(R.sheenColorMap.channel),sheenRoughnessMapUv:qt&&S(R.sheenRoughnessMap.channel),specularMapUv:Bt&&S(R.specularMap.channel),specularColorMapUv:yt&&S(R.specularColorMap.channel),specularIntensityMapUv:jt&&S(R.specularIntensityMap.channel),transmissionMapUv:Nn&&S(R.transmissionMap.channel),thicknessMapUv:jn&&S(R.thicknessMap.channel),alphaMapUv:ut&&S(R.alphaMap.channel),vertexTangents:!!H.attributes.tangent&&(Re||Se),vertexColors:R.vertexColors,vertexAlphas:R.vertexColors===!0&&!!H.attributes.color&&H.attributes.color.itemSize===4,vertexUv1s:Kt,vertexUv2s:Gt,vertexUv3s:Bn,pointsUvs:Q.isPoints===!0&&!!H.attributes.uv&&(Ye||ut),fog:!!W,useFog:R.fog===!0,fogExp2:W&&W.isFogExp2,flatShading:R.flatShading===!0,sizeAttenuation:R.sizeAttenuation===!0,logarithmicDepthBuffer:h,skinning:Q.isSkinnedMesh===!0,morphTargets:H.morphAttributes.position!==void 0,morphNormals:H.morphAttributes.normal!==void 0,morphColors:H.morphAttributes.color!==void 0,morphTargetsCount:K,morphTextureStride:se,numDirLights:D.directional.length,numPointLights:D.point.length,numSpotLights:D.spot.length,numSpotLightMaps:D.spotLightMap.length,numRectAreaLights:D.rectArea.length,numHemiLights:D.hemi.length,numDirLightShadows:D.directionalShadowMap.length,numPointLightShadows:D.pointShadowMap.length,numSpotLightShadows:D.spotShadowMap.length,numSpotLightShadowsWithMaps:D.numSpotLightShadowsWithMaps,numLightProbes:D.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:R.dithering,shadowMapEnabled:n.shadowMap.enabled&&L.length>0,shadowMapType:n.shadowMap.type,toneMapping:kn,useLegacyLights:n._useLegacyLights,decodeVideoTexture:Ye&&R.map.isVideoTexture===!0&&Zn.getTransfer(R.map.colorSpace)===ms,premultipliedAlpha:R.premultipliedAlpha,doubleSided:R.side===su,flipSided:R.side===no,useDepthPacking:R.depthPacking>=0,depthPacking:R.depthPacking||0,index0AttributeName:R.index0AttributeName,extensionDerivatives:pt&&R.extensions.derivatives===!0,extensionFragDepth:pt&&R.extensions.fragDepth===!0,extensionDrawBuffers:pt&&R.extensions.drawBuffers===!0,extensionShaderTextureLOD:pt&&R.extensions.shaderTextureLOD===!0,extensionClipCullDistance:pt&&R.extensions.clipCullDistance&&s.has("WEBGL_clip_cull_distance"),rendererExtensionFragDepth:c||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||s.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:R.customProgramCacheKey()}}function w(R){const D=[];if(R.shaderID?D.push(R.shaderID):(D.push(R.customVertexShaderID),D.push(R.customFragmentShaderID)),R.defines!==void 0)for(const L in R.defines)D.push(L),D.push(R.defines[L]);return R.isRawShaderMaterial===!1&&(_(D,R),T(D,R),D.push(n.outputColorSpace)),D.push(R.customProgramCacheKey),D.join()}function _(R,D){R.push(D.precision),R.push(D.outputColorSpace),R.push(D.envMapMode),R.push(D.envMapCubeUVHeight),R.push(D.mapUv),R.push(D.alphaMapUv),R.push(D.lightMapUv),R.push(D.aoMapUv),R.push(D.bumpMapUv),R.push(D.normalMapUv),R.push(D.displacementMapUv),R.push(D.emissiveMapUv),R.push(D.metalnessMapUv),R.push(D.roughnessMapUv),R.push(D.anisotropyMapUv),R.push(D.clearcoatMapUv),R.push(D.clearcoatNormalMapUv),R.push(D.clearcoatRoughnessMapUv),R.push(D.iridescenceMapUv),R.push(D.iridescenceThicknessMapUv),R.push(D.sheenColorMapUv),R.push(D.sheenRoughnessMapUv),R.push(D.specularMapUv),R.push(D.specularColorMapUv),R.push(D.specularIntensityMapUv),R.push(D.transmissionMapUv),R.push(D.thicknessMapUv),R.push(D.combine),R.push(D.fogExp2),R.push(D.sizeAttenuation),R.push(D.morphTargetsCount),R.push(D.morphAttributeCount),R.push(D.numDirLights),R.push(D.numPointLights),R.push(D.numSpotLights),R.push(D.numSpotLightMaps),R.push(D.numHemiLights),R.push(D.numRectAreaLights),R.push(D.numDirLightShadows),R.push(D.numPointLightShadows),R.push(D.numSpotLightShadows),R.push(D.numSpotLightShadowsWithMaps),R.push(D.numLightProbes),R.push(D.shadowMapType),R.push(D.toneMapping),R.push(D.numClippingPlanes),R.push(D.numClipIntersection),R.push(D.depthPacking)}function T(R,D){a.disableAll(),D.isWebGL2&&a.enable(0),D.supportsVertexTextures&&a.enable(1),D.instancing&&a.enable(2),D.instancingColor&&a.enable(3),D.matcap&&a.enable(4),D.envMap&&a.enable(5),D.normalMapObjectSpace&&a.enable(6),D.normalMapTangentSpace&&a.enable(7),D.clearcoat&&a.enable(8),D.iridescence&&a.enable(9),D.alphaTest&&a.enable(10),D.vertexColors&&a.enable(11),D.vertexAlphas&&a.enable(12),D.vertexUv1s&&a.enable(13),D.vertexUv2s&&a.enable(14),D.vertexUv3s&&a.enable(15),D.vertexTangents&&a.enable(16),D.anisotropy&&a.enable(17),D.alphaHash&&a.enable(18),D.batching&&a.enable(19),R.push(a.mask),a.disableAll(),D.fog&&a.enable(0),D.useFog&&a.enable(1),D.flatShading&&a.enable(2),D.logarithmicDepthBuffer&&a.enable(3),D.skinning&&a.enable(4),D.morphTargets&&a.enable(5),D.morphNormals&&a.enable(6),D.morphColors&&a.enable(7),D.premultipliedAlpha&&a.enable(8),D.shadowMapEnabled&&a.enable(9),D.useLegacyLights&&a.enable(10),D.doubleSided&&a.enable(11),D.flipSided&&a.enable(12),D.useDepthPacking&&a.enable(13),D.dithering&&a.enable(14),D.transmission&&a.enable(15),D.sheen&&a.enable(16),D.opaque&&a.enable(17),D.pointsUvs&&a.enable(18),D.decodeVideoTexture&&a.enable(19),R.push(a.mask)}function C(R){const D=g[R.type];let L;if(D){const G=ml[D];L=H3.clone(G.uniforms)}else L=R.uniforms;return L}function N(R,D){let L;for(let G=0,Q=u.length;G<Q;G++){const W=u[G];if(W.cacheKey===D){L=W,++L.usedTimes;break}}return L===void 0&&(L=new Uj(n,D,R,i),u.push(L)),L}function M(R){if(--R.usedTimes===0){const D=u.indexOf(R);u[D]=u[u.length-1],u.pop(),R.destroy()}}function P(R){l.remove(R)}function $(){l.dispose()}return{getParameters:x,getProgramCacheKey:w,getUniforms:C,acquireProgram:N,releaseProgram:M,releaseShaderCache:P,programs:u,dispose:$}}function Hj(){let n=new WeakMap;function e(i){let o=n.get(i);return o===void 0&&(o={},n.set(i,o)),o}function t(i){n.delete(i)}function s(i,o,a){n.get(i)[o]=a}function r(){n=new WeakMap}return{get:e,remove:t,update:s,dispose:r}}function jj(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function wR(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function SR(){const n=[];let e=0;const t=[],s=[],r=[];function i(){e=0,t.length=0,s.length=0,r.length=0}function o(h,f,p,g,S,x){let w=n[e];return w===void 0?(w={id:h.id,object:h,geometry:f,material:p,groupOrder:g,renderOrder:h.renderOrder,z:S,group:x},n[e]=w):(w.id=h.id,w.object=h,w.geometry=f,w.material=p,w.groupOrder=g,w.renderOrder=h.renderOrder,w.z=S,w.group=x),e++,w}function a(h,f,p,g,S,x){const w=o(h,f,p,g,S,x);p.transmission>0?s.push(w):p.transparent===!0?r.push(w):t.push(w)}function l(h,f,p,g,S,x){const w=o(h,f,p,g,S,x);p.transmission>0?s.unshift(w):p.transparent===!0?r.unshift(w):t.unshift(w)}function u(h,f){t.length>1&&t.sort(h||jj),s.length>1&&s.sort(f||wR),r.length>1&&r.sort(f||wR)}function c(){for(let h=e,f=n.length;h<f;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:s,transparent:r,init:i,push:a,unshift:l,finish:c,sort:u}}function Xj(){let n=new WeakMap;function e(s,r){const i=n.get(s);let o;return i===void 0?(o=new SR,n.set(s,[o])):r>=i.length?(o=new SR,i.push(o)):o=i[r],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function qj(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new re,color:new vt};break;case"SpotLight":t={position:new re,direction:new re,color:new vt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new re,color:new vt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new re,skyColor:new vt,groundColor:new vt};break;case"RectAreaLight":t={color:new vt,position:new re,halfWidth:new re,halfHeight:new re};break}return n[e.id]=t,t}}}function Kj(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Je};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Je};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Je,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let Yj=0;function Zj(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function Jj(n,e){const t=new qj,s=Kj(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)r.probe.push(new re);const i=new re,o=new ln,a=new ln;function l(c,h){let f=0,p=0,g=0;for(let G=0;G<9;G++)r.probe[G].set(0,0,0);let S=0,x=0,w=0,_=0,T=0,C=0,N=0,M=0,P=0,$=0,R=0;c.sort(Zj);const D=h===!0?Math.PI:1;for(let G=0,Q=c.length;G<Q;G++){const W=c[G],H=W.color,J=W.intensity,ie=W.distance,V=W.shadow&&W.shadow.map?W.shadow.map.texture:null;if(W.isAmbientLight)f+=H.r*J*D,p+=H.g*J*D,g+=H.b*J*D;else if(W.isLightProbe){for(let Y=0;Y<9;Y++)r.probe[Y].addScaledVector(W.sh.coefficients[Y],J);R++}else if(W.isDirectionalLight){const Y=t.get(W);if(Y.color.copy(W.color).multiplyScalar(W.intensity*D),W.castShadow){const B=W.shadow,K=s.get(W);K.shadowBias=B.bias,K.shadowNormalBias=B.normalBias,K.shadowRadius=B.radius,K.shadowMapSize=B.mapSize,r.directionalShadow[S]=K,r.directionalShadowMap[S]=V,r.directionalShadowMatrix[S]=W.shadow.matrix,C++}r.directional[S]=Y,S++}else if(W.isSpotLight){const Y=t.get(W);Y.position.setFromMatrixPosition(W.matrixWorld),Y.color.copy(H).multiplyScalar(J*D),Y.distance=ie,Y.coneCos=Math.cos(W.angle),Y.penumbraCos=Math.cos(W.angle*(1-W.penumbra)),Y.decay=W.decay,r.spot[w]=Y;const B=W.shadow;if(W.map&&(r.spotLightMap[P]=W.map,P++,B.updateMatrices(W),W.castShadow&&$++),r.spotLightMatrix[w]=B.matrix,W.castShadow){const K=s.get(W);K.shadowBias=B.bias,K.shadowNormalBias=B.normalBias,K.shadowRadius=B.radius,K.shadowMapSize=B.mapSize,r.spotShadow[w]=K,r.spotShadowMap[w]=V,M++}w++}else if(W.isRectAreaLight){const Y=t.get(W);Y.color.copy(H).multiplyScalar(J),Y.halfWidth.set(W.width*.5,0,0),Y.halfHeight.set(0,W.height*.5,0),r.rectArea[_]=Y,_++}else if(W.isPointLight){const Y=t.get(W);if(Y.color.copy(W.color).multiplyScalar(W.intensity*D),Y.distance=W.distance,Y.decay=W.decay,W.castShadow){const B=W.shadow,K=s.get(W);K.shadowBias=B.bias,K.shadowNormalBias=B.normalBias,K.shadowRadius=B.radius,K.shadowMapSize=B.mapSize,K.shadowCameraNear=B.camera.near,K.shadowCameraFar=B.camera.far,r.pointShadow[x]=K,r.pointShadowMap[x]=V,r.pointShadowMatrix[x]=W.shadow.matrix,N++}r.point[x]=Y,x++}else if(W.isHemisphereLight){const Y=t.get(W);Y.skyColor.copy(W.color).multiplyScalar(J*D),Y.groundColor.copy(W.groundColor).multiplyScalar(J*D),r.hemi[T]=Y,T++}}_>0&&(e.isWebGL2?n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=mt.LTC_FLOAT_1,r.rectAreaLTC2=mt.LTC_FLOAT_2):(r.rectAreaLTC1=mt.LTC_HALF_1,r.rectAreaLTC2=mt.LTC_HALF_2):n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=mt.LTC_FLOAT_1,r.rectAreaLTC2=mt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=mt.LTC_HALF_1,r.rectAreaLTC2=mt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=f,r.ambient[1]=p,r.ambient[2]=g;const L=r.hash;(L.directionalLength!==S||L.pointLength!==x||L.spotLength!==w||L.rectAreaLength!==_||L.hemiLength!==T||L.numDirectionalShadows!==C||L.numPointShadows!==N||L.numSpotShadows!==M||L.numSpotMaps!==P||L.numLightProbes!==R)&&(r.directional.length=S,r.spot.length=w,r.rectArea.length=_,r.point.length=x,r.hemi.length=T,r.directionalShadow.length=C,r.directionalShadowMap.length=C,r.pointShadow.length=N,r.pointShadowMap.length=N,r.spotShadow.length=M,r.spotShadowMap.length=M,r.directionalShadowMatrix.length=C,r.pointShadowMatrix.length=N,r.spotLightMatrix.length=M+P-$,r.spotLightMap.length=P,r.numSpotLightShadowsWithMaps=$,r.numLightProbes=R,L.directionalLength=S,L.pointLength=x,L.spotLength=w,L.rectAreaLength=_,L.hemiLength=T,L.numDirectionalShadows=C,L.numPointShadows=N,L.numSpotShadows=M,L.numSpotMaps=P,L.numLightProbes=R,r.version=Yj++)}function u(c,h){let f=0,p=0,g=0,S=0,x=0;const w=h.matrixWorldInverse;for(let _=0,T=c.length;_<T;_++){const C=c[_];if(C.isDirectionalLight){const N=r.directional[f];N.direction.setFromMatrixPosition(C.matrixWorld),i.setFromMatrixPosition(C.target.matrixWorld),N.direction.sub(i),N.direction.transformDirection(w),f++}else if(C.isSpotLight){const N=r.spot[g];N.position.setFromMatrixPosition(C.matrixWorld),N.position.applyMatrix4(w),N.direction.setFromMatrixPosition(C.matrixWorld),i.setFromMatrixPosition(C.target.matrixWorld),N.direction.sub(i),N.direction.transformDirection(w),g++}else if(C.isRectAreaLight){const N=r.rectArea[S];N.position.setFromMatrixPosition(C.matrixWorld),N.position.applyMatrix4(w),a.identity(),o.copy(C.matrixWorld),o.premultiply(w),a.extractRotation(o),N.halfWidth.set(C.width*.5,0,0),N.halfHeight.set(0,C.height*.5,0),N.halfWidth.applyMatrix4(a),N.halfHeight.applyMatrix4(a),S++}else if(C.isPointLight){const N=r.point[p];N.position.setFromMatrixPosition(C.matrixWorld),N.position.applyMatrix4(w),p++}else if(C.isHemisphereLight){const N=r.hemi[x];N.direction.setFromMatrixPosition(C.matrixWorld),N.direction.transformDirection(w),x++}}}return{setup:l,setupView:u,state:r}}function bR(n,e){const t=new Jj(n,e),s=[],r=[];function i(){s.length=0,r.length=0}function o(h){s.push(h)}function a(h){r.push(h)}function l(h){t.setup(s,h)}function u(h){t.setupView(s,h)}return{init:i,state:{lightsArray:s,shadowsArray:r,lights:t},setupLights:l,setupLightsView:u,pushLight:o,pushShadow:a}}function Qj(n,e){let t=new WeakMap;function s(i,o=0){const a=t.get(i);let l;return a===void 0?(l=new bR(n,e),t.set(i,[l])):o>=a.length?(l=new bR(n,e),a.push(l)):l=a[o],l}function r(){t=new WeakMap}return{get:s,dispose:r}}class mI extends xi{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=M3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class gI extends xi{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const eX=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,tX=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function nX(n,e,t){let s=new rx;const r=new Je,i=new Je,o=new Jn,a=new mI({depthPacking:k3}),l=new gI,u={},c=t.maxTextureSize,h={[hc]:no,[no]:hc,[su]:su},f=new Tl({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Je},radius:{value:4}},vertexShader:eX,fragmentShader:tX}),p=f.clone();p.defines.HORIZONTAL_PASS=1;const g=new bn;g.setAttribute("position",new Qn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const S=new Dr(g,f),x=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=WS;let w=this.type;this.render=function(M,P,$){if(x.enabled===!1||x.autoUpdate===!1&&x.needsUpdate===!1||M.length===0)return;const R=n.getRenderTarget(),D=n.getActiveCubeFace(),L=n.getActiveMipmapLevel(),G=n.state;G.setBlending(ac),G.buffers.color.setClear(1,1,1,1),G.buffers.depth.setTest(!0),G.setScissorTest(!1);const Q=w!==pl&&this.type===pl,W=w===pl&&this.type!==pl;for(let H=0,J=M.length;H<J;H++){const ie=M[H],V=ie.shadow;if(V===void 0){console.warn("THREE.WebGLShadowMap:",ie,"has no shadow.");continue}if(V.autoUpdate===!1&&V.needsUpdate===!1)continue;r.copy(V.mapSize);const Y=V.getFrameExtents();if(r.multiply(Y),i.copy(V.mapSize),(r.x>c||r.y>c)&&(r.x>c&&(i.x=Math.floor(c/Y.x),r.x=i.x*Y.x,V.mapSize.x=i.x),r.y>c&&(i.y=Math.floor(c/Y.y),r.y=i.y*Y.y,V.mapSize.y=i.y)),V.map===null||Q===!0||W===!0){const K=this.type!==pl?{minFilter:sr,magFilter:sr}:{};V.map!==null&&V.map.dispose(),V.map=new _l(r.x,r.y,K),V.map.texture.name=ie.name+".shadowMap",V.camera.updateProjectionMatrix()}n.setRenderTarget(V.map),n.clear();const B=V.getViewportCount();for(let K=0;K<B;K++){const se=V.getViewport(K);o.set(i.x*se.x,i.y*se.y,i.x*se.z,i.y*se.w),G.viewport(o),V.updateMatrices(ie,K),s=V.getFrustum(),C(P,$,V.camera,ie,this.type)}V.isPointLightShadow!==!0&&this.type===pl&&_(V,$),V.needsUpdate=!1}w=this.type,x.needsUpdate=!1,n.setRenderTarget(R,D,L)};function _(M,P){const $=e.update(S);f.defines.VSM_SAMPLES!==M.blurSamples&&(f.defines.VSM_SAMPLES=M.blurSamples,p.defines.VSM_SAMPLES=M.blurSamples,f.needsUpdate=!0,p.needsUpdate=!0),M.mapPass===null&&(M.mapPass=new _l(r.x,r.y)),f.uniforms.shadow_pass.value=M.map.texture,f.uniforms.resolution.value=M.mapSize,f.uniforms.radius.value=M.radius,n.setRenderTarget(M.mapPass),n.clear(),n.renderBufferDirect(P,null,$,f,S,null),p.uniforms.shadow_pass.value=M.mapPass.texture,p.uniforms.resolution.value=M.mapSize,p.uniforms.radius.value=M.radius,n.setRenderTarget(M.map),n.clear(),n.renderBufferDirect(P,null,$,p,S,null)}function T(M,P,$,R){let D=null;const L=$.isPointLight===!0?M.customDistanceMaterial:M.customDepthMaterial;if(L!==void 0)D=L;else if(D=$.isPointLight===!0?l:a,n.localClippingEnabled&&P.clipShadows===!0&&Array.isArray(P.clippingPlanes)&&P.clippingPlanes.length!==0||P.displacementMap&&P.displacementScale!==0||P.alphaMap&&P.alphaTest>0||P.map&&P.alphaTest>0){const G=D.uuid,Q=P.uuid;let W=u[G];W===void 0&&(W={},u[G]=W);let H=W[Q];H===void 0&&(H=D.clone(),W[Q]=H,P.addEventListener("dispose",N)),D=H}if(D.visible=P.visible,D.wireframe=P.wireframe,R===pl?D.side=P.shadowSide!==null?P.shadowSide:P.side:D.side=P.shadowSide!==null?P.shadowSide:h[P.side],D.alphaMap=P.alphaMap,D.alphaTest=P.alphaTest,D.map=P.map,D.clipShadows=P.clipShadows,D.clippingPlanes=P.clippingPlanes,D.clipIntersection=P.clipIntersection,D.displacementMap=P.displacementMap,D.displacementScale=P.displacementScale,D.displacementBias=P.displacementBias,D.wireframeLinewidth=P.wireframeLinewidth,D.linewidth=P.linewidth,$.isPointLight===!0&&D.isMeshDistanceMaterial===!0){const G=n.properties.get(D);G.light=$}return D}function C(M,P,$,R,D){if(M.visible===!1)return;if(M.layers.test(P.layers)&&(M.isMesh||M.isLine||M.isPoints)&&(M.castShadow||M.receiveShadow&&D===pl)&&(!M.frustumCulled||s.intersectsObject(M))){M.modelViewMatrix.multiplyMatrices($.matrixWorldInverse,M.matrixWorld);const Q=e.update(M),W=M.material;if(Array.isArray(W)){const H=Q.groups;for(let J=0,ie=H.length;J<ie;J++){const V=H[J],Y=W[V.materialIndex];if(Y&&Y.visible){const B=T(M,Y,R,D);M.onBeforeShadow(n,M,P,$,Q,B,V),n.renderBufferDirect($,null,Q,B,M,V),M.onAfterShadow(n,M,P,$,Q,B,V)}}}else if(W.visible){const H=T(M,W,R,D);M.onBeforeShadow(n,M,P,$,Q,H,null),n.renderBufferDirect($,null,Q,H,M,null),M.onAfterShadow(n,M,P,$,Q,H,null)}}const G=M.children;for(let Q=0,W=G.length;Q<W;Q++)C(G[Q],P,$,R,D)}function N(M){M.target.removeEventListener("dispose",N);for(const $ in u){const R=u[$],D=M.target.uuid;D in R&&(R[D].dispose(),delete R[D])}}}function sX(n,e,t){const s=t.isWebGL2;function r(){let ge=!1;const ct=new Jn;let pt=null;const Kt=new Jn(0,0,0,0);return{setMask:function(Gt){pt!==Gt&&!ge&&(n.colorMask(Gt,Gt,Gt,Gt),pt=Gt)},setLocked:function(Gt){ge=Gt},setClear:function(Gt,Bn,kn,xs,Ys){Ys===!0&&(Gt*=xs,Bn*=xs,kn*=xs),ct.set(Gt,Bn,kn,xs),Kt.equals(ct)===!1&&(n.clearColor(Gt,Bn,kn,xs),Kt.copy(ct))},reset:function(){ge=!1,pt=null,Kt.set(-1,0,0,0)}}}function i(){let ge=!1,ct=null,pt=null,Kt=null;return{setTest:function(Gt){Gt?qe(n.DEPTH_TEST):Ye(n.DEPTH_TEST)},setMask:function(Gt){ct!==Gt&&!ge&&(n.depthMask(Gt),ct=Gt)},setFunc:function(Gt){if(pt!==Gt){switch(Gt){case r3:n.depthFunc(n.NEVER);break;case i3:n.depthFunc(n.ALWAYS);break;case o3:n.depthFunc(n.LESS);break;case m0:n.depthFunc(n.LEQUAL);break;case a3:n.depthFunc(n.EQUAL);break;case l3:n.depthFunc(n.GEQUAL);break;case u3:n.depthFunc(n.GREATER);break;case c3:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}pt=Gt}},setLocked:function(Gt){ge=Gt},setClear:function(Gt){Kt!==Gt&&(n.clearDepth(Gt),Kt=Gt)},reset:function(){ge=!1,ct=null,pt=null,Kt=null}}}function o(){let ge=!1,ct=null,pt=null,Kt=null,Gt=null,Bn=null,kn=null,xs=null,Ys=null;return{setTest:function(Fn){ge||(Fn?qe(n.STENCIL_TEST):Ye(n.STENCIL_TEST))},setMask:function(Fn){ct!==Fn&&!ge&&(n.stencilMask(Fn),ct=Fn)},setFunc:function(Fn,Zs,Ur){(pt!==Fn||Kt!==Zs||Gt!==Ur)&&(n.stencilFunc(Fn,Zs,Ur),pt=Fn,Kt=Zs,Gt=Ur)},setOp:function(Fn,Zs,Ur){(Bn!==Fn||kn!==Zs||xs!==Ur)&&(n.stencilOp(Fn,Zs,Ur),Bn=Fn,kn=Zs,xs=Ur)},setLocked:function(Fn){ge=Fn},setClear:function(Fn){Ys!==Fn&&(n.clearStencil(Fn),Ys=Fn)},reset:function(){ge=!1,ct=null,pt=null,Kt=null,Gt=null,Bn=null,kn=null,xs=null,Ys=null}}}const a=new r,l=new i,u=new o,c=new WeakMap,h=new WeakMap;let f={},p={},g=new WeakMap,S=[],x=null,w=!1,_=null,T=null,C=null,N=null,M=null,P=null,$=null,R=new vt(0,0,0),D=0,L=!1,G=null,Q=null,W=null,H=null,J=null;const ie=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let V=!1,Y=0;const B=n.getParameter(n.VERSION);B.indexOf("WebGL")!==-1?(Y=parseFloat(/^WebGL (\d)/.exec(B)[1]),V=Y>=1):B.indexOf("OpenGL ES")!==-1&&(Y=parseFloat(/^OpenGL ES (\d)/.exec(B)[1]),V=Y>=2);let K=null,se={};const te=n.getParameter(n.SCISSOR_BOX),ue=n.getParameter(n.VIEWPORT),fe=new Jn().fromArray(te),_e=new Jn().fromArray(ue);function Ie(ge,ct,pt,Kt){const Gt=new Uint8Array(4),Bn=n.createTexture();n.bindTexture(ge,Bn),n.texParameteri(ge,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(ge,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let kn=0;kn<pt;kn++)s&&(ge===n.TEXTURE_3D||ge===n.TEXTURE_2D_ARRAY)?n.texImage3D(ct,0,n.RGBA,1,1,Kt,0,n.RGBA,n.UNSIGNED_BYTE,Gt):n.texImage2D(ct+kn,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,Gt);return Bn}const Ve={};Ve[n.TEXTURE_2D]=Ie(n.TEXTURE_2D,n.TEXTURE_2D,1),Ve[n.TEXTURE_CUBE_MAP]=Ie(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),s&&(Ve[n.TEXTURE_2D_ARRAY]=Ie(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),Ve[n.TEXTURE_3D]=Ie(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),l.setClear(1),u.setClear(0),qe(n.DEPTH_TEST),l.setFunc(m0),Qe(!1),ee(lE),qe(n.CULL_FACE),Re(ac);function qe(ge){f[ge]!==!0&&(n.enable(ge),f[ge]=!0)}function Ye(ge){f[ge]!==!1&&(n.disable(ge),f[ge]=!1)}function et(ge,ct){return p[ge]!==ct?(n.bindFramebuffer(ge,ct),p[ge]=ct,s&&(ge===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=ct),ge===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=ct)),!0):!1}function ae(ge,ct){let pt=S,Kt=!1;if(ge)if(pt=g.get(ct),pt===void 0&&(pt=[],g.set(ct,pt)),ge.isWebGLMultipleRenderTargets){const Gt=ge.texture;if(pt.length!==Gt.length||pt[0]!==n.COLOR_ATTACHMENT0){for(let Bn=0,kn=Gt.length;Bn<kn;Bn++)pt[Bn]=n.COLOR_ATTACHMENT0+Bn;pt.length=Gt.length,Kt=!0}}else pt[0]!==n.COLOR_ATTACHMENT0&&(pt[0]=n.COLOR_ATTACHMENT0,Kt=!0);else pt[0]!==n.BACK&&(pt[0]=n.BACK,Kt=!0);Kt&&(t.isWebGL2?n.drawBuffers(pt):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(pt))}function Be(ge){return x!==ge?(n.useProgram(ge),x=ge,!0):!1}const De={[wh]:n.FUNC_ADD,[WL]:n.FUNC_SUBTRACT,[GL]:n.FUNC_REVERSE_SUBTRACT};if(s)De[hE]=n.MIN,De[dE]=n.MAX;else{const ge=e.get("EXT_blend_minmax");ge!==null&&(De[hE]=ge.MIN_EXT,De[dE]=ge.MAX_EXT)}const He={[HL]:n.ZERO,[jL]:n.ONE,[XL]:n.SRC_COLOR,[rS]:n.SRC_ALPHA,[QL]:n.SRC_ALPHA_SATURATE,[ZL]:n.DST_COLOR,[KL]:n.DST_ALPHA,[qL]:n.ONE_MINUS_SRC_COLOR,[iS]:n.ONE_MINUS_SRC_ALPHA,[JL]:n.ONE_MINUS_DST_COLOR,[YL]:n.ONE_MINUS_DST_ALPHA,[e3]:n.CONSTANT_COLOR,[t3]:n.ONE_MINUS_CONSTANT_COLOR,[n3]:n.CONSTANT_ALPHA,[s3]:n.ONE_MINUS_CONSTANT_ALPHA};function Re(ge,ct,pt,Kt,Gt,Bn,kn,xs,Ys,Fn){if(ge===ac){w===!0&&(Ye(n.BLEND),w=!1);return}if(w===!1&&(qe(n.BLEND),w=!0),ge!==VL){if(ge!==_||Fn!==L){if((T!==wh||M!==wh)&&(n.blendEquation(n.FUNC_ADD),T=wh,M=wh),Fn)switch(ge){case _f:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case sS:n.blendFunc(n.ONE,n.ONE);break;case uE:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case cE:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",ge);break}else switch(ge){case _f:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case sS:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case uE:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case cE:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",ge);break}C=null,N=null,P=null,$=null,R.set(0,0,0),D=0,_=ge,L=Fn}return}Gt=Gt||ct,Bn=Bn||pt,kn=kn||Kt,(ct!==T||Gt!==M)&&(n.blendEquationSeparate(De[ct],De[Gt]),T=ct,M=Gt),(pt!==C||Kt!==N||Bn!==P||kn!==$)&&(n.blendFuncSeparate(He[pt],He[Kt],He[Bn],He[kn]),C=pt,N=Kt,P=Bn,$=kn),(xs.equals(R)===!1||Ys!==D)&&(n.blendColor(xs.r,xs.g,xs.b,Ys),R.copy(xs),D=Ys),_=ge,L=!1}function at(ge,ct){ge.side===su?Ye(n.CULL_FACE):qe(n.CULL_FACE);let pt=ge.side===no;ct&&(pt=!pt),Qe(pt),ge.blending===_f&&ge.transparent===!1?Re(ac):Re(ge.blending,ge.blendEquation,ge.blendSrc,ge.blendDst,ge.blendEquationAlpha,ge.blendSrcAlpha,ge.blendDstAlpha,ge.blendColor,ge.blendAlpha,ge.premultipliedAlpha),l.setFunc(ge.depthFunc),l.setTest(ge.depthTest),l.setMask(ge.depthWrite),a.setMask(ge.colorWrite);const Kt=ge.stencilWrite;u.setTest(Kt),Kt&&(u.setMask(ge.stencilWriteMask),u.setFunc(ge.stencilFunc,ge.stencilRef,ge.stencilFuncMask),u.setOp(ge.stencilFail,ge.stencilZFail,ge.stencilZPass)),Se(ge.polygonOffset,ge.polygonOffsetFactor,ge.polygonOffsetUnits),ge.alphaToCoverage===!0?qe(n.SAMPLE_ALPHA_TO_COVERAGE):Ye(n.SAMPLE_ALPHA_TO_COVERAGE)}function Qe(ge){G!==ge&&(ge?n.frontFace(n.CW):n.frontFace(n.CCW),G=ge)}function ee(ge){ge!==zL?(qe(n.CULL_FACE),ge!==Q&&(ge===lE?n.cullFace(n.BACK):ge===UL?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):Ye(n.CULL_FACE),Q=ge}function X(ge){ge!==W&&(V&&n.lineWidth(ge),W=ge)}function Se(ge,ct,pt){ge?(qe(n.POLYGON_OFFSET_FILL),(H!==ct||J!==pt)&&(n.polygonOffset(ct,pt),H=ct,J=pt)):Ye(n.POLYGON_OFFSET_FILL)}function We(ge){ge?qe(n.SCISSOR_TEST):Ye(n.SCISSOR_TEST)}function Xe(ge){ge===void 0&&(ge=n.TEXTURE0+ie-1),K!==ge&&(n.activeTexture(ge),K=ge)}function je(ge,ct,pt){pt===void 0&&(K===null?pt=n.TEXTURE0+ie-1:pt=K);let Kt=se[pt];Kt===void 0&&(Kt={type:void 0,texture:void 0},se[pt]=Kt),(Kt.type!==ge||Kt.texture!==ct)&&(K!==pt&&(n.activeTexture(pt),K=pt),n.bindTexture(ge,ct||Ve[ge]),Kt.type=ge,Kt.texture=ct)}function xt(){const ge=se[K];ge!==void 0&&ge.type!==void 0&&(n.bindTexture(ge.type,null),ge.type=void 0,ge.texture=void 0)}function it(){try{n.compressedTexImage2D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function dt(){try{n.compressedTexImage3D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function It(){try{n.texSubImage2D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Yt(){try{n.texSubImage3D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Ke(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function hn(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function un(){try{n.texStorage2D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function qt(){try{n.texStorage3D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function Bt(){try{n.texImage2D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function yt(){try{n.texImage3D.apply(n,arguments)}catch(ge){console.error("THREE.WebGLState:",ge)}}function jt(ge){fe.equals(ge)===!1&&(n.scissor(ge.x,ge.y,ge.z,ge.w),fe.copy(ge))}function Nn(ge){_e.equals(ge)===!1&&(n.viewport(ge.x,ge.y,ge.z,ge.w),_e.copy(ge))}function jn(ge,ct){let pt=h.get(ct);pt===void 0&&(pt=new WeakMap,h.set(ct,pt));let Kt=pt.get(ge);Kt===void 0&&(Kt=n.getUniformBlockIndex(ct,ge.name),pt.set(ge,Kt))}function sn(ge,ct){const Kt=h.get(ct).get(ge);c.get(ct)!==Kt&&(n.uniformBlockBinding(ct,Kt,ge.__bindingPointIndex),c.set(ct,Kt))}function ut(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),s===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),f={},K=null,se={},p={},g=new WeakMap,S=[],x=null,w=!1,_=null,T=null,C=null,N=null,M=null,P=null,$=null,R=new vt(0,0,0),D=0,L=!1,G=null,Q=null,W=null,H=null,J=null,fe.set(0,0,n.canvas.width,n.canvas.height),_e.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),u.reset()}return{buffers:{color:a,depth:l,stencil:u},enable:qe,disable:Ye,bindFramebuffer:et,drawBuffers:ae,useProgram:Be,setBlending:Re,setMaterial:at,setFlipSided:Qe,setCullFace:ee,setLineWidth:X,setPolygonOffset:Se,setScissorTest:We,activeTexture:Xe,bindTexture:je,unbindTexture:xt,compressedTexImage2D:it,compressedTexImage3D:dt,texImage2D:Bt,texImage3D:yt,updateUBOMapping:jn,uniformBlockBinding:sn,texStorage2D:un,texStorage3D:qt,texSubImage2D:It,texSubImage3D:Yt,compressedTexSubImage2D:Ke,compressedTexSubImage3D:hn,scissor:jt,viewport:Nn,reset:ut}}function rX(n,e,t,s,r,i,o){const a=r.isWebGL2,l=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,u=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new WeakMap;let h;const f=new WeakMap;let p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(ee,X){return p?new OffscreenCanvas(ee,X):E0("canvas")}function S(ee,X,Se,We){let Xe=1;if((ee.width>We||ee.height>We)&&(Xe=We/Math.max(ee.width,ee.height)),Xe<1||X===!0)if(typeof HTMLImageElement<"u"&&ee instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ee instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ee instanceof ImageBitmap){const je=X?lS:Math.floor,xt=je(Xe*ee.width),it=je(Xe*ee.height);h===void 0&&(h=g(xt,it));const dt=Se?g(xt,it):h;return dt.width=xt,dt.height=it,dt.getContext("2d").drawImage(ee,0,0,xt,it),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ee.width+"x"+ee.height+") to ("+xt+"x"+it+")."),dt}else return"data"in ee&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ee.width+"x"+ee.height+")."),ee;return ee}function x(ee){return BE(ee.width)&&BE(ee.height)}function w(ee){return a?!1:ee.wrapS!==Pi||ee.wrapT!==Pi||ee.minFilter!==sr&&ee.minFilter!==rr}function _(ee,X){return ee.generateMipmaps&&X&&ee.minFilter!==sr&&ee.minFilter!==rr}function T(ee){n.generateMipmap(ee)}function C(ee,X,Se,We,Xe=!1){if(a===!1)return X;if(ee!==null){if(n[ee]!==void 0)return n[ee];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ee+"'")}let je=X;if(X===n.RED&&(Se===n.FLOAT&&(je=n.R32F),Se===n.HALF_FLOAT&&(je=n.R16F),Se===n.UNSIGNED_BYTE&&(je=n.R8)),X===n.RED_INTEGER&&(Se===n.UNSIGNED_BYTE&&(je=n.R8UI),Se===n.UNSIGNED_SHORT&&(je=n.R16UI),Se===n.UNSIGNED_INT&&(je=n.R32UI),Se===n.BYTE&&(je=n.R8I),Se===n.SHORT&&(je=n.R16I),Se===n.INT&&(je=n.R32I)),X===n.RG&&(Se===n.FLOAT&&(je=n.RG32F),Se===n.HALF_FLOAT&&(je=n.RG16F),Se===n.UNSIGNED_BYTE&&(je=n.RG8)),X===n.RGBA){const xt=Xe?b0:Zn.getTransfer(We);Se===n.FLOAT&&(je=n.RGBA32F),Se===n.HALF_FLOAT&&(je=n.RGBA16F),Se===n.UNSIGNED_BYTE&&(je=xt===ms?n.SRGB8_ALPHA8:n.RGBA8),Se===n.UNSIGNED_SHORT_4_4_4_4&&(je=n.RGBA4),Se===n.UNSIGNED_SHORT_5_5_5_1&&(je=n.RGB5_A1)}return(je===n.R16F||je===n.R32F||je===n.RG16F||je===n.RG32F||je===n.RGBA16F||je===n.RGBA32F)&&e.get("EXT_color_buffer_float"),je}function N(ee,X,Se){return _(ee,Se)===!0||ee.isFramebufferTexture&&ee.minFilter!==sr&&ee.minFilter!==rr?Math.log2(Math.max(X.width,X.height))+1:ee.mipmaps!==void 0&&ee.mipmaps.length>0?ee.mipmaps.length:ee.isCompressedTexture&&Array.isArray(ee.image)?X.mipmaps.length:1}function M(ee){return ee===sr||ee===oS||ee===u0?n.NEAREST:n.LINEAR}function P(ee){const X=ee.target;X.removeEventListener("dispose",P),R(X),X.isVideoTexture&&c.delete(X)}function $(ee){const X=ee.target;X.removeEventListener("dispose",$),L(X)}function R(ee){const X=s.get(ee);if(X.__webglInit===void 0)return;const Se=ee.source,We=f.get(Se);if(We){const Xe=We[X.__cacheKey];Xe.usedTimes--,Xe.usedTimes===0&&D(ee),Object.keys(We).length===0&&f.delete(Se)}s.remove(ee)}function D(ee){const X=s.get(ee);n.deleteTexture(X.__webglTexture);const Se=ee.source,We=f.get(Se);delete We[X.__cacheKey],o.memory.textures--}function L(ee){const X=ee.texture,Se=s.get(ee),We=s.get(X);if(We.__webglTexture!==void 0&&(n.deleteTexture(We.__webglTexture),o.memory.textures--),ee.depthTexture&&ee.depthTexture.dispose(),ee.isWebGLCubeRenderTarget)for(let Xe=0;Xe<6;Xe++){if(Array.isArray(Se.__webglFramebuffer[Xe]))for(let je=0;je<Se.__webglFramebuffer[Xe].length;je++)n.deleteFramebuffer(Se.__webglFramebuffer[Xe][je]);else n.deleteFramebuffer(Se.__webglFramebuffer[Xe]);Se.__webglDepthbuffer&&n.deleteRenderbuffer(Se.__webglDepthbuffer[Xe])}else{if(Array.isArray(Se.__webglFramebuffer))for(let Xe=0;Xe<Se.__webglFramebuffer.length;Xe++)n.deleteFramebuffer(Se.__webglFramebuffer[Xe]);else n.deleteFramebuffer(Se.__webglFramebuffer);if(Se.__webglDepthbuffer&&n.deleteRenderbuffer(Se.__webglDepthbuffer),Se.__webglMultisampledFramebuffer&&n.deleteFramebuffer(Se.__webglMultisampledFramebuffer),Se.__webglColorRenderbuffer)for(let Xe=0;Xe<Se.__webglColorRenderbuffer.length;Xe++)Se.__webglColorRenderbuffer[Xe]&&n.deleteRenderbuffer(Se.__webglColorRenderbuffer[Xe]);Se.__webglDepthRenderbuffer&&n.deleteRenderbuffer(Se.__webglDepthRenderbuffer)}if(ee.isWebGLMultipleRenderTargets)for(let Xe=0,je=X.length;Xe<je;Xe++){const xt=s.get(X[Xe]);xt.__webglTexture&&(n.deleteTexture(xt.__webglTexture),o.memory.textures--),s.remove(X[Xe])}s.remove(X),s.remove(ee)}let G=0;function Q(){G=0}function W(){const ee=G;return ee>=r.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+ee+" texture units while this GPU supports only "+r.maxTextures),G+=1,ee}function H(ee){const X=[];return X.push(ee.wrapS),X.push(ee.wrapT),X.push(ee.wrapR||0),X.push(ee.magFilter),X.push(ee.minFilter),X.push(ee.anisotropy),X.push(ee.internalFormat),X.push(ee.format),X.push(ee.type),X.push(ee.generateMipmaps),X.push(ee.premultiplyAlpha),X.push(ee.flipY),X.push(ee.unpackAlignment),X.push(ee.colorSpace),X.join()}function J(ee,X){const Se=s.get(ee);if(ee.isVideoTexture&&at(ee),ee.isRenderTargetTexture===!1&&ee.version>0&&Se.__version!==ee.version){const We=ee.image;if(We===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(We.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{fe(Se,ee,X);return}}t.bindTexture(n.TEXTURE_2D,Se.__webglTexture,n.TEXTURE0+X)}function ie(ee,X){const Se=s.get(ee);if(ee.version>0&&Se.__version!==ee.version){fe(Se,ee,X);return}t.bindTexture(n.TEXTURE_2D_ARRAY,Se.__webglTexture,n.TEXTURE0+X)}function V(ee,X){const Se=s.get(ee);if(ee.version>0&&Se.__version!==ee.version){fe(Se,ee,X);return}t.bindTexture(n.TEXTURE_3D,Se.__webglTexture,n.TEXTURE0+X)}function Y(ee,X){const Se=s.get(ee);if(ee.version>0&&Se.__version!==ee.version){_e(Se,ee,X);return}t.bindTexture(n.TEXTURE_CUBE_MAP,Se.__webglTexture,n.TEXTURE0+X)}const B={[Af]:n.REPEAT,[Pi]:n.CLAMP_TO_EDGE,[x0]:n.MIRRORED_REPEAT},K={[sr]:n.NEAREST,[oS]:n.NEAREST_MIPMAP_NEAREST,[u0]:n.NEAREST_MIPMAP_LINEAR,[rr]:n.LINEAR,[Z2]:n.LINEAR_MIPMAP_NEAREST,[Rh]:n.LINEAR_MIPMAP_LINEAR},se={[D3]:n.NEVER,[z3]:n.ALWAYS,[P3]:n.LESS,[aI]:n.LEQUAL,[L3]:n.EQUAL,[$3]:n.GEQUAL,[O3]:n.GREATER,[F3]:n.NOTEQUAL};function te(ee,X,Se){if(Se?(n.texParameteri(ee,n.TEXTURE_WRAP_S,B[X.wrapS]),n.texParameteri(ee,n.TEXTURE_WRAP_T,B[X.wrapT]),(ee===n.TEXTURE_3D||ee===n.TEXTURE_2D_ARRAY)&&n.texParameteri(ee,n.TEXTURE_WRAP_R,B[X.wrapR]),n.texParameteri(ee,n.TEXTURE_MAG_FILTER,K[X.magFilter]),n.texParameteri(ee,n.TEXTURE_MIN_FILTER,K[X.minFilter])):(n.texParameteri(ee,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(ee,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(ee===n.TEXTURE_3D||ee===n.TEXTURE_2D_ARRAY)&&n.texParameteri(ee,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(X.wrapS!==Pi||X.wrapT!==Pi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(ee,n.TEXTURE_MAG_FILTER,M(X.magFilter)),n.texParameteri(ee,n.TEXTURE_MIN_FILTER,M(X.minFilter)),X.minFilter!==sr&&X.minFilter!==rr&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),X.compareFunction&&(n.texParameteri(ee,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(ee,n.TEXTURE_COMPARE_FUNC,se[X.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const We=e.get("EXT_texture_filter_anisotropic");if(X.magFilter===sr||X.minFilter!==u0&&X.minFilter!==Rh||X.type===xl&&e.has("OES_texture_float_linear")===!1||a===!1&&X.type===rg&&e.has("OES_texture_half_float_linear")===!1)return;(X.anisotropy>1||s.get(X).__currentAnisotropy)&&(n.texParameterf(ee,We.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(X.anisotropy,r.getMaxAnisotropy())),s.get(X).__currentAnisotropy=X.anisotropy)}}function ue(ee,X){let Se=!1;ee.__webglInit===void 0&&(ee.__webglInit=!0,X.addEventListener("dispose",P));const We=X.source;let Xe=f.get(We);Xe===void 0&&(Xe={},f.set(We,Xe));const je=H(X);if(je!==ee.__cacheKey){Xe[je]===void 0&&(Xe[je]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,Se=!0),Xe[je].usedTimes++;const xt=Xe[ee.__cacheKey];xt!==void 0&&(Xe[ee.__cacheKey].usedTimes--,xt.usedTimes===0&&D(X)),ee.__cacheKey=je,ee.__webglTexture=Xe[je].texture}return Se}function fe(ee,X,Se){let We=n.TEXTURE_2D;(X.isDataArrayTexture||X.isCompressedArrayTexture)&&(We=n.TEXTURE_2D_ARRAY),X.isData3DTexture&&(We=n.TEXTURE_3D);const Xe=ue(ee,X),je=X.source;t.bindTexture(We,ee.__webglTexture,n.TEXTURE0+Se);const xt=s.get(je);if(je.version!==xt.__version||Xe===!0){t.activeTexture(n.TEXTURE0+Se);const it=Zn.getPrimaries(Zn.workingColorSpace),dt=X.colorSpace===sa?null:Zn.getPrimaries(X.colorSpace),It=X.colorSpace===sa||it===dt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,X.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,X.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,X.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,It);const Yt=w(X)&&x(X.image)===!1;let Ke=S(X.image,Yt,!1,r.maxTextureSize);Ke=Qe(X,Ke);const hn=x(Ke)||a,un=i.convert(X.format,X.colorSpace);let qt=i.convert(X.type),Bt=C(X.internalFormat,un,qt,X.colorSpace,X.isVideoTexture);te(We,X,hn);let yt;const jt=X.mipmaps,Nn=a&&X.isVideoTexture!==!0&&Bt!==rI,jn=xt.__version===void 0||Xe===!0,sn=N(X,Ke,hn);if(X.isDepthTexture)Bt=n.DEPTH_COMPONENT,a?X.type===xl?Bt=n.DEPTH_COMPONENT32F:X.type===ic?Bt=n.DEPTH_COMPONENT24:X.type===Th?Bt=n.DEPTH24_STENCIL8:Bt=n.DEPTH_COMPONENT16:X.type===xl&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),X.format===Ch&&Bt===n.DEPTH_COMPONENT&&X.type!==jS&&X.type!==ic&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),X.type=ic,qt=i.convert(X.type)),X.format===Mf&&Bt===n.DEPTH_COMPONENT&&(Bt=n.DEPTH_STENCIL,X.type!==Th&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),X.type=Th,qt=i.convert(X.type))),jn&&(Nn?t.texStorage2D(n.TEXTURE_2D,1,Bt,Ke.width,Ke.height):t.texImage2D(n.TEXTURE_2D,0,Bt,Ke.width,Ke.height,0,un,qt,null));else if(X.isDataTexture)if(jt.length>0&&hn){Nn&&jn&&t.texStorage2D(n.TEXTURE_2D,sn,Bt,jt[0].width,jt[0].height);for(let ut=0,ge=jt.length;ut<ge;ut++)yt=jt[ut],Nn?t.texSubImage2D(n.TEXTURE_2D,ut,0,0,yt.width,yt.height,un,qt,yt.data):t.texImage2D(n.TEXTURE_2D,ut,Bt,yt.width,yt.height,0,un,qt,yt.data);X.generateMipmaps=!1}else Nn?(jn&&t.texStorage2D(n.TEXTURE_2D,sn,Bt,Ke.width,Ke.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,Ke.width,Ke.height,un,qt,Ke.data)):t.texImage2D(n.TEXTURE_2D,0,Bt,Ke.width,Ke.height,0,un,qt,Ke.data);else if(X.isCompressedTexture)if(X.isCompressedArrayTexture){Nn&&jn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,sn,Bt,jt[0].width,jt[0].height,Ke.depth);for(let ut=0,ge=jt.length;ut<ge;ut++)yt=jt[ut],X.format!==eo?un!==null?Nn?t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,ut,0,0,0,yt.width,yt.height,Ke.depth,un,yt.data,0,0):t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,ut,Bt,yt.width,yt.height,Ke.depth,0,yt.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Nn?t.texSubImage3D(n.TEXTURE_2D_ARRAY,ut,0,0,0,yt.width,yt.height,Ke.depth,un,qt,yt.data):t.texImage3D(n.TEXTURE_2D_ARRAY,ut,Bt,yt.width,yt.height,Ke.depth,0,un,qt,yt.data)}else{Nn&&jn&&t.texStorage2D(n.TEXTURE_2D,sn,Bt,jt[0].width,jt[0].height);for(let ut=0,ge=jt.length;ut<ge;ut++)yt=jt[ut],X.format!==eo?un!==null?Nn?t.compressedTexSubImage2D(n.TEXTURE_2D,ut,0,0,yt.width,yt.height,un,yt.data):t.compressedTexImage2D(n.TEXTURE_2D,ut,Bt,yt.width,yt.height,0,yt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Nn?t.texSubImage2D(n.TEXTURE_2D,ut,0,0,yt.width,yt.height,un,qt,yt.data):t.texImage2D(n.TEXTURE_2D,ut,Bt,yt.width,yt.height,0,un,qt,yt.data)}else if(X.isDataArrayTexture)Nn?(jn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,sn,Bt,Ke.width,Ke.height,Ke.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,Ke.width,Ke.height,Ke.depth,un,qt,Ke.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,Bt,Ke.width,Ke.height,Ke.depth,0,un,qt,Ke.data);else if(X.isData3DTexture)Nn?(jn&&t.texStorage3D(n.TEXTURE_3D,sn,Bt,Ke.width,Ke.height,Ke.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,Ke.width,Ke.height,Ke.depth,un,qt,Ke.data)):t.texImage3D(n.TEXTURE_3D,0,Bt,Ke.width,Ke.height,Ke.depth,0,un,qt,Ke.data);else if(X.isFramebufferTexture){if(jn)if(Nn)t.texStorage2D(n.TEXTURE_2D,sn,Bt,Ke.width,Ke.height);else{let ut=Ke.width,ge=Ke.height;for(let ct=0;ct<sn;ct++)t.texImage2D(n.TEXTURE_2D,ct,Bt,ut,ge,0,un,qt,null),ut>>=1,ge>>=1}}else if(jt.length>0&&hn){Nn&&jn&&t.texStorage2D(n.TEXTURE_2D,sn,Bt,jt[0].width,jt[0].height);for(let ut=0,ge=jt.length;ut<ge;ut++)yt=jt[ut],Nn?t.texSubImage2D(n.TEXTURE_2D,ut,0,0,un,qt,yt):t.texImage2D(n.TEXTURE_2D,ut,Bt,un,qt,yt);X.generateMipmaps=!1}else Nn?(jn&&t.texStorage2D(n.TEXTURE_2D,sn,Bt,Ke.width,Ke.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,un,qt,Ke)):t.texImage2D(n.TEXTURE_2D,0,Bt,un,qt,Ke);_(X,hn)&&T(We),xt.__version=je.version,X.onUpdate&&X.onUpdate(X)}ee.__version=X.version}function _e(ee,X,Se){if(X.image.length!==6)return;const We=ue(ee,X),Xe=X.source;t.bindTexture(n.TEXTURE_CUBE_MAP,ee.__webglTexture,n.TEXTURE0+Se);const je=s.get(Xe);if(Xe.version!==je.__version||We===!0){t.activeTexture(n.TEXTURE0+Se);const xt=Zn.getPrimaries(Zn.workingColorSpace),it=X.colorSpace===sa?null:Zn.getPrimaries(X.colorSpace),dt=X.colorSpace===sa||xt===it?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,X.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,X.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,X.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,dt);const It=X.isCompressedTexture||X.image[0].isCompressedTexture,Yt=X.image[0]&&X.image[0].isDataTexture,Ke=[];for(let ut=0;ut<6;ut++)!It&&!Yt?Ke[ut]=S(X.image[ut],!1,!0,r.maxCubemapSize):Ke[ut]=Yt?X.image[ut].image:X.image[ut],Ke[ut]=Qe(X,Ke[ut]);const hn=Ke[0],un=x(hn)||a,qt=i.convert(X.format,X.colorSpace),Bt=i.convert(X.type),yt=C(X.internalFormat,qt,Bt,X.colorSpace),jt=a&&X.isVideoTexture!==!0,Nn=je.__version===void 0||We===!0;let jn=N(X,hn,un);te(n.TEXTURE_CUBE_MAP,X,un);let sn;if(It){jt&&Nn&&t.texStorage2D(n.TEXTURE_CUBE_MAP,jn,yt,hn.width,hn.height);for(let ut=0;ut<6;ut++){sn=Ke[ut].mipmaps;for(let ge=0;ge<sn.length;ge++){const ct=sn[ge];X.format!==eo?qt!==null?jt?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge,0,0,ct.width,ct.height,qt,ct.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge,yt,ct.width,ct.height,0,ct.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):jt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge,0,0,ct.width,ct.height,qt,Bt,ct.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge,yt,ct.width,ct.height,0,qt,Bt,ct.data)}}}else{sn=X.mipmaps,jt&&Nn&&(sn.length>0&&jn++,t.texStorage2D(n.TEXTURE_CUBE_MAP,jn,yt,Ke[0].width,Ke[0].height));for(let ut=0;ut<6;ut++)if(Yt){jt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,0,0,0,Ke[ut].width,Ke[ut].height,qt,Bt,Ke[ut].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,0,yt,Ke[ut].width,Ke[ut].height,0,qt,Bt,Ke[ut].data);for(let ge=0;ge<sn.length;ge++){const pt=sn[ge].image[ut].image;jt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge+1,0,0,pt.width,pt.height,qt,Bt,pt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge+1,yt,pt.width,pt.height,0,qt,Bt,pt.data)}}else{jt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,0,0,0,qt,Bt,Ke[ut]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,0,yt,qt,Bt,Ke[ut]);for(let ge=0;ge<sn.length;ge++){const ct=sn[ge];jt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge+1,0,0,qt,Bt,ct.image[ut]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ut,ge+1,yt,qt,Bt,ct.image[ut])}}}_(X,un)&&T(n.TEXTURE_CUBE_MAP),je.__version=Xe.version,X.onUpdate&&X.onUpdate(X)}ee.__version=X.version}function Ie(ee,X,Se,We,Xe,je){const xt=i.convert(Se.format,Se.colorSpace),it=i.convert(Se.type),dt=C(Se.internalFormat,xt,it,Se.colorSpace);if(!s.get(X).__hasExternalTextures){const Yt=Math.max(1,X.width>>je),Ke=Math.max(1,X.height>>je);Xe===n.TEXTURE_3D||Xe===n.TEXTURE_2D_ARRAY?t.texImage3D(Xe,je,dt,Yt,Ke,X.depth,0,xt,it,null):t.texImage2D(Xe,je,dt,Yt,Ke,0,xt,it,null)}t.bindFramebuffer(n.FRAMEBUFFER,ee),Re(X)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,We,Xe,s.get(Se).__webglTexture,0,He(X)):(Xe===n.TEXTURE_2D||Xe>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&Xe<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,We,Xe,s.get(Se).__webglTexture,je),t.bindFramebuffer(n.FRAMEBUFFER,null)}function Ve(ee,X,Se){if(n.bindRenderbuffer(n.RENDERBUFFER,ee),X.depthBuffer&&!X.stencilBuffer){let We=a===!0?n.DEPTH_COMPONENT24:n.DEPTH_COMPONENT16;if(Se||Re(X)){const Xe=X.depthTexture;Xe&&Xe.isDepthTexture&&(Xe.type===xl?We=n.DEPTH_COMPONENT32F:Xe.type===ic&&(We=n.DEPTH_COMPONENT24));const je=He(X);Re(X)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,je,We,X.width,X.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,je,We,X.width,X.height)}else n.renderbufferStorage(n.RENDERBUFFER,We,X.width,X.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,ee)}else if(X.depthBuffer&&X.stencilBuffer){const We=He(X);Se&&Re(X)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,We,n.DEPTH24_STENCIL8,X.width,X.height):Re(X)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,We,n.DEPTH24_STENCIL8,X.width,X.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,X.width,X.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,ee)}else{const We=X.isWebGLMultipleRenderTargets===!0?X.texture:[X.texture];for(let Xe=0;Xe<We.length;Xe++){const je=We[Xe],xt=i.convert(je.format,je.colorSpace),it=i.convert(je.type),dt=C(je.internalFormat,xt,it,je.colorSpace),It=He(X);Se&&Re(X)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,It,dt,X.width,X.height):Re(X)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,It,dt,X.width,X.height):n.renderbufferStorage(n.RENDERBUFFER,dt,X.width,X.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function qe(ee,X){if(X&&X.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,ee),!(X.depthTexture&&X.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(X.depthTexture).__webglTexture||X.depthTexture.image.width!==X.width||X.depthTexture.image.height!==X.height)&&(X.depthTexture.image.width=X.width,X.depthTexture.image.height=X.height,X.depthTexture.needsUpdate=!0),J(X.depthTexture,0);const We=s.get(X.depthTexture).__webglTexture,Xe=He(X);if(X.depthTexture.format===Ch)Re(X)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,We,0,Xe):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,We,0);else if(X.depthTexture.format===Mf)Re(X)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,We,0,Xe):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,We,0);else throw new Error("Unknown depthTexture format")}function Ye(ee){const X=s.get(ee),Se=ee.isWebGLCubeRenderTarget===!0;if(ee.depthTexture&&!X.__autoAllocateDepthBuffer){if(Se)throw new Error("target.depthTexture not supported in Cube render targets");qe(X.__webglFramebuffer,ee)}else if(Se){X.__webglDepthbuffer=[];for(let We=0;We<6;We++)t.bindFramebuffer(n.FRAMEBUFFER,X.__webglFramebuffer[We]),X.__webglDepthbuffer[We]=n.createRenderbuffer(),Ve(X.__webglDepthbuffer[We],ee,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,X.__webglFramebuffer),X.__webglDepthbuffer=n.createRenderbuffer(),Ve(X.__webglDepthbuffer,ee,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function et(ee,X,Se){const We=s.get(ee);X!==void 0&&Ie(We.__webglFramebuffer,ee,ee.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),Se!==void 0&&Ye(ee)}function ae(ee){const X=ee.texture,Se=s.get(ee),We=s.get(X);ee.addEventListener("dispose",$),ee.isWebGLMultipleRenderTargets!==!0&&(We.__webglTexture===void 0&&(We.__webglTexture=n.createTexture()),We.__version=X.version,o.memory.textures++);const Xe=ee.isWebGLCubeRenderTarget===!0,je=ee.isWebGLMultipleRenderTargets===!0,xt=x(ee)||a;if(Xe){Se.__webglFramebuffer=[];for(let it=0;it<6;it++)if(a&&X.mipmaps&&X.mipmaps.length>0){Se.__webglFramebuffer[it]=[];for(let dt=0;dt<X.mipmaps.length;dt++)Se.__webglFramebuffer[it][dt]=n.createFramebuffer()}else Se.__webglFramebuffer[it]=n.createFramebuffer()}else{if(a&&X.mipmaps&&X.mipmaps.length>0){Se.__webglFramebuffer=[];for(let it=0;it<X.mipmaps.length;it++)Se.__webglFramebuffer[it]=n.createFramebuffer()}else Se.__webglFramebuffer=n.createFramebuffer();if(je)if(r.drawBuffers){const it=ee.texture;for(let dt=0,It=it.length;dt<It;dt++){const Yt=s.get(it[dt]);Yt.__webglTexture===void 0&&(Yt.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&ee.samples>0&&Re(ee)===!1){const it=je?X:[X];Se.__webglMultisampledFramebuffer=n.createFramebuffer(),Se.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,Se.__webglMultisampledFramebuffer);for(let dt=0;dt<it.length;dt++){const It=it[dt];Se.__webglColorRenderbuffer[dt]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,Se.__webglColorRenderbuffer[dt]);const Yt=i.convert(It.format,It.colorSpace),Ke=i.convert(It.type),hn=C(It.internalFormat,Yt,Ke,It.colorSpace,ee.isXRRenderTarget===!0),un=He(ee);n.renderbufferStorageMultisample(n.RENDERBUFFER,un,hn,ee.width,ee.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+dt,n.RENDERBUFFER,Se.__webglColorRenderbuffer[dt])}n.bindRenderbuffer(n.RENDERBUFFER,null),ee.depthBuffer&&(Se.__webglDepthRenderbuffer=n.createRenderbuffer(),Ve(Se.__webglDepthRenderbuffer,ee,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(Xe){t.bindTexture(n.TEXTURE_CUBE_MAP,We.__webglTexture),te(n.TEXTURE_CUBE_MAP,X,xt);for(let it=0;it<6;it++)if(a&&X.mipmaps&&X.mipmaps.length>0)for(let dt=0;dt<X.mipmaps.length;dt++)Ie(Se.__webglFramebuffer[it][dt],ee,X,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+it,dt);else Ie(Se.__webglFramebuffer[it],ee,X,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+it,0);_(X,xt)&&T(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(je){const it=ee.texture;for(let dt=0,It=it.length;dt<It;dt++){const Yt=it[dt],Ke=s.get(Yt);t.bindTexture(n.TEXTURE_2D,Ke.__webglTexture),te(n.TEXTURE_2D,Yt,xt),Ie(Se.__webglFramebuffer,ee,Yt,n.COLOR_ATTACHMENT0+dt,n.TEXTURE_2D,0),_(Yt,xt)&&T(n.TEXTURE_2D)}t.unbindTexture()}else{let it=n.TEXTURE_2D;if((ee.isWebGL3DRenderTarget||ee.isWebGLArrayRenderTarget)&&(a?it=ee.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(it,We.__webglTexture),te(it,X,xt),a&&X.mipmaps&&X.mipmaps.length>0)for(let dt=0;dt<X.mipmaps.length;dt++)Ie(Se.__webglFramebuffer[dt],ee,X,n.COLOR_ATTACHMENT0,it,dt);else Ie(Se.__webglFramebuffer,ee,X,n.COLOR_ATTACHMENT0,it,0);_(X,xt)&&T(it),t.unbindTexture()}ee.depthBuffer&&Ye(ee)}function Be(ee){const X=x(ee)||a,Se=ee.isWebGLMultipleRenderTargets===!0?ee.texture:[ee.texture];for(let We=0,Xe=Se.length;We<Xe;We++){const je=Se[We];if(_(je,X)){const xt=ee.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,it=s.get(je).__webglTexture;t.bindTexture(xt,it),T(xt),t.unbindTexture()}}}function De(ee){if(a&&ee.samples>0&&Re(ee)===!1){const X=ee.isWebGLMultipleRenderTargets?ee.texture:[ee.texture],Se=ee.width,We=ee.height;let Xe=n.COLOR_BUFFER_BIT;const je=[],xt=ee.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,it=s.get(ee),dt=ee.isWebGLMultipleRenderTargets===!0;if(dt)for(let It=0;It<X.length;It++)t.bindFramebuffer(n.FRAMEBUFFER,it.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+It,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,it.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+It,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,it.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,it.__webglFramebuffer);for(let It=0;It<X.length;It++){je.push(n.COLOR_ATTACHMENT0+It),ee.depthBuffer&&je.push(xt);const Yt=it.__ignoreDepthValues!==void 0?it.__ignoreDepthValues:!1;if(Yt===!1&&(ee.depthBuffer&&(Xe|=n.DEPTH_BUFFER_BIT),ee.stencilBuffer&&(Xe|=n.STENCIL_BUFFER_BIT)),dt&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,it.__webglColorRenderbuffer[It]),Yt===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[xt]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[xt])),dt){const Ke=s.get(X[It]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,Ke,0)}n.blitFramebuffer(0,0,Se,We,0,0,Se,We,Xe,n.NEAREST),u&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,je)}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),dt)for(let It=0;It<X.length;It++){t.bindFramebuffer(n.FRAMEBUFFER,it.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+It,n.RENDERBUFFER,it.__webglColorRenderbuffer[It]);const Yt=s.get(X[It]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,it.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+It,n.TEXTURE_2D,Yt,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,it.__webglMultisampledFramebuffer)}}function He(ee){return Math.min(r.maxSamples,ee.samples)}function Re(ee){const X=s.get(ee);return a&&ee.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&X.__useRenderToTexture!==!1}function at(ee){const X=o.render.frame;c.get(ee)!==X&&(c.set(ee,X),ee.update())}function Qe(ee,X){const Se=ee.colorSpace,We=ee.format,Xe=ee.type;return ee.isCompressedTexture===!0||ee.isVideoTexture===!0||ee.format===aS||Se!==du&&Se!==sa&&(Zn.getTransfer(Se)===ms?a===!1?e.has("EXT_sRGB")===!0&&We===eo?(ee.format=aS,ee.minFilter=rr,ee.generateMipmaps=!1):X=uI.sRGBToLinear(X):(We!==eo||Xe!==ou)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Se)),X}this.allocateTextureUnit=W,this.resetTextureUnits=Q,this.setTexture2D=J,this.setTexture2DArray=ie,this.setTexture3D=V,this.setTextureCube=Y,this.rebindTextures=et,this.setupRenderTarget=ae,this.updateRenderTargetMipmap=Be,this.updateMultisampleRenderTarget=De,this.setupDepthRenderbuffer=Ye,this.setupFrameBufferTexture=Ie,this.useMultisampledRTT=Re}function eO(n,e,t){const s=t.isWebGL2;function r(i,o=sa){let a;const l=Zn.getTransfer(o);if(i===ou)return n.UNSIGNED_BYTE;if(i===Q2)return n.UNSIGNED_SHORT_4_4_4_4;if(i===eI)return n.UNSIGNED_SHORT_5_5_5_1;if(i===v3)return n.BYTE;if(i===w3)return n.SHORT;if(i===jS)return n.UNSIGNED_SHORT;if(i===J2)return n.INT;if(i===ic)return n.UNSIGNED_INT;if(i===xl)return n.FLOAT;if(i===rg)return s?n.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(i===S3)return n.ALPHA;if(i===eo)return n.RGBA;if(i===b3)return n.LUMINANCE;if(i===_3)return n.LUMINANCE_ALPHA;if(i===Ch)return n.DEPTH_COMPONENT;if(i===Mf)return n.DEPTH_STENCIL;if(i===aS)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(i===T3)return n.RED;if(i===tI)return n.RED_INTEGER;if(i===C3)return n.RG;if(i===nI)return n.RG_INTEGER;if(i===sI)return n.RGBA_INTEGER;if(i===Fw||i===$w||i===zw||i===Uw)if(l===ms)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(i===Fw)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===$w)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===zw)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===Uw)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(i===Fw)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===$w)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===zw)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===Uw)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===pE||i===mE||i===gE||i===yE)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(i===pE)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===mE)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===gE)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===yE)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===rI)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===xE||i===vE)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(i===xE)return l===ms?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(i===vE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===wE||i===SE||i===bE||i===_E||i===TE||i===CE||i===EE||i===IE||i===NE||i===AE||i===ME||i===kE||i===RE||i===DE)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(i===wE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===SE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===bE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===_E)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===TE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===CE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===EE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===IE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===NE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===AE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===ME)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===kE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===RE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===DE)return l===ms?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===Bw||i===PE||i===LE)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(i===Bw)return l===ms?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===PE)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===LE)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(i===E3||i===OE||i===FE||i===$E)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(i===Bw)return a.COMPRESSED_RED_RGTC1_EXT;if(i===OE)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===FE)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===$E)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return i===Th?s?n.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[i]!==void 0?n[i]:null}return{convert:r}}class tO extends jr{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class jm extends zn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const iX={type:"move"};class dC{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new jm,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new jm,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new re,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new re),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new jm,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new re,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new re),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let r=null,i=null,o=null;const a=this._targetRay,l=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(u&&e.hand){o=!0;for(const S of e.hand.values()){const x=t.getJointPose(S,s),w=this._getHandJoint(u,S);x!==null&&(w.matrix.fromArray(x.transform.matrix),w.matrix.decompose(w.position,w.rotation,w.scale),w.matrixWorldNeedsUpdate=!0,w.jointRadius=x.radius),w.visible=x!==null}const c=u.joints["index-finger-tip"],h=u.joints["thumb-tip"],f=c.position.distanceTo(h.position),p=.02,g=.005;u.inputState.pinching&&f>p+g?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&f<=p-g&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(i=t.getPose(e.gripSpace,s),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(r=t.getPose(e.targetRaySpace,s),r===null&&i!==null&&(r=i),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(iX)))}return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=i!==null),u!==null&&(u.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new jm;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class oX extends xc{constructor(e,t){super();const s=this;let r=null,i=1,o=null,a="local-floor",l=1,u=null,c=null,h=null,f=null,p=null,g=null;const S=t.getContextAttributes();let x=null,w=null;const _=[],T=[],C=new Je;let N=null;const M=new jr;M.layers.enable(1),M.viewport=new Jn;const P=new jr;P.layers.enable(2),P.viewport=new Jn;const $=[M,P],R=new tO;R.layers.enable(1),R.layers.enable(2);let D=null,L=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(te){let ue=_[te];return ue===void 0&&(ue=new dC,_[te]=ue),ue.getTargetRaySpace()},this.getControllerGrip=function(te){let ue=_[te];return ue===void 0&&(ue=new dC,_[te]=ue),ue.getGripSpace()},this.getHand=function(te){let ue=_[te];return ue===void 0&&(ue=new dC,_[te]=ue),ue.getHandSpace()};function G(te){const ue=T.indexOf(te.inputSource);if(ue===-1)return;const fe=_[ue];fe!==void 0&&(fe.update(te.inputSource,te.frame,u||o),fe.dispatchEvent({type:te.type,data:te.inputSource}))}function Q(){r.removeEventListener("select",G),r.removeEventListener("selectstart",G),r.removeEventListener("selectend",G),r.removeEventListener("squeeze",G),r.removeEventListener("squeezestart",G),r.removeEventListener("squeezeend",G),r.removeEventListener("end",Q),r.removeEventListener("inputsourceschange",W);for(let te=0;te<_.length;te++){const ue=T[te];ue!==null&&(T[te]=null,_[te].disconnect(ue))}D=null,L=null,e.setRenderTarget(x),p=null,f=null,h=null,r=null,w=null,se.stop(),s.isPresenting=!1,e.setPixelRatio(N),e.setSize(C.width,C.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(te){i=te,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(te){a=te,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u||o},this.setReferenceSpace=function(te){u=te},this.getBaseLayer=function(){return f!==null?f:p},this.getBinding=function(){return h},this.getFrame=function(){return g},this.getSession=function(){return r},this.setSession=async function(te){if(r=te,r!==null){if(x=e.getRenderTarget(),r.addEventListener("select",G),r.addEventListener("selectstart",G),r.addEventListener("selectend",G),r.addEventListener("squeeze",G),r.addEventListener("squeezestart",G),r.addEventListener("squeezeend",G),r.addEventListener("end",Q),r.addEventListener("inputsourceschange",W),S.xrCompatible!==!0&&await t.makeXRCompatible(),N=e.getPixelRatio(),e.getSize(C),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const ue={antialias:r.renderState.layers===void 0?S.antialias:!0,alpha:!0,depth:S.depth,stencil:S.stencil,framebufferScaleFactor:i};p=new XRWebGLLayer(r,t,ue),r.updateRenderState({baseLayer:p}),e.setPixelRatio(1),e.setSize(p.framebufferWidth,p.framebufferHeight,!1),w=new _l(p.framebufferWidth,p.framebufferHeight,{format:eo,type:ou,colorSpace:e.outputColorSpace,stencilBuffer:S.stencil})}else{let ue=null,fe=null,_e=null;S.depth&&(_e=S.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,ue=S.stencil?Mf:Ch,fe=S.stencil?Th:ic);const Ie={colorFormat:t.RGBA8,depthFormat:_e,scaleFactor:i};h=new XRWebGLBinding(r,t),f=h.createProjectionLayer(Ie),r.updateRenderState({layers:[f]}),e.setPixelRatio(1),e.setSize(f.textureWidth,f.textureHeight,!1),w=new _l(f.textureWidth,f.textureHeight,{format:eo,type:ou,depthTexture:new pI(f.textureWidth,f.textureHeight,fe,void 0,void 0,void 0,void 0,void 0,void 0,ue),stencilBuffer:S.stencil,colorSpace:e.outputColorSpace,samples:S.antialias?4:0});const Ve=e.properties.get(w);Ve.__ignoreDepthValues=f.ignoreDepthValues}w.isXRRenderTarget=!0,this.setFoveation(l),u=null,o=await r.requestReferenceSpace(a),se.setContext(r),se.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(r!==null)return r.environmentBlendMode};function W(te){for(let ue=0;ue<te.removed.length;ue++){const fe=te.removed[ue],_e=T.indexOf(fe);_e>=0&&(T[_e]=null,_[_e].disconnect(fe))}for(let ue=0;ue<te.added.length;ue++){const fe=te.added[ue];let _e=T.indexOf(fe);if(_e===-1){for(let Ve=0;Ve<_.length;Ve++)if(Ve>=T.length){T.push(fe),_e=Ve;break}else if(T[Ve]===null){T[Ve]=fe,_e=Ve;break}if(_e===-1)break}const Ie=_[_e];Ie&&Ie.connect(fe)}}const H=new re,J=new re;function ie(te,ue,fe){H.setFromMatrixPosition(ue.matrixWorld),J.setFromMatrixPosition(fe.matrixWorld);const _e=H.distanceTo(J),Ie=ue.projectionMatrix.elements,Ve=fe.projectionMatrix.elements,qe=Ie[14]/(Ie[10]-1),Ye=Ie[14]/(Ie[10]+1),et=(Ie[9]+1)/Ie[5],ae=(Ie[9]-1)/Ie[5],Be=(Ie[8]-1)/Ie[0],De=(Ve[8]+1)/Ve[0],He=qe*Be,Re=qe*De,at=_e/(-Be+De),Qe=at*-Be;ue.matrixWorld.decompose(te.position,te.quaternion,te.scale),te.translateX(Qe),te.translateZ(at),te.matrixWorld.compose(te.position,te.quaternion,te.scale),te.matrixWorldInverse.copy(te.matrixWorld).invert();const ee=qe+at,X=Ye+at,Se=He-Qe,We=Re+(_e-Qe),Xe=et*Ye/X*ee,je=ae*Ye/X*ee;te.projectionMatrix.makePerspective(Se,We,Xe,je,ee,X),te.projectionMatrixInverse.copy(te.projectionMatrix).invert()}function V(te,ue){ue===null?te.matrixWorld.copy(te.matrix):te.matrixWorld.multiplyMatrices(ue.matrixWorld,te.matrix),te.matrixWorldInverse.copy(te.matrixWorld).invert()}this.updateCamera=function(te){if(r===null)return;R.near=P.near=M.near=te.near,R.far=P.far=M.far=te.far,(D!==R.near||L!==R.far)&&(r.updateRenderState({depthNear:R.near,depthFar:R.far}),D=R.near,L=R.far);const ue=te.parent,fe=R.cameras;V(R,ue);for(let _e=0;_e<fe.length;_e++)V(fe[_e],ue);fe.length===2?ie(R,M,P):R.projectionMatrix.copy(M.projectionMatrix),Y(te,R,ue)};function Y(te,ue,fe){fe===null?te.matrix.copy(ue.matrixWorld):(te.matrix.copy(fe.matrixWorld),te.matrix.invert(),te.matrix.multiply(ue.matrixWorld)),te.matrix.decompose(te.position,te.quaternion,te.scale),te.updateMatrixWorld(!0),te.projectionMatrix.copy(ue.projectionMatrix),te.projectionMatrixInverse.copy(ue.projectionMatrixInverse),te.isPerspectiveCamera&&(te.fov=og*2*Math.atan(1/te.projectionMatrix.elements[5]),te.zoom=1)}this.getCamera=function(){return R},this.getFoveation=function(){if(!(f===null&&p===null))return l},this.setFoveation=function(te){l=te,f!==null&&(f.fixedFoveation=te),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=te)};let B=null;function K(te,ue){if(c=ue.getViewerPose(u||o),g=ue,c!==null){const fe=c.views;p!==null&&(e.setRenderTargetFramebuffer(w,p.framebuffer),e.setRenderTarget(w));let _e=!1;fe.length!==R.cameras.length&&(R.cameras.length=0,_e=!0);for(let Ie=0;Ie<fe.length;Ie++){const Ve=fe[Ie];let qe=null;if(p!==null)qe=p.getViewport(Ve);else{const et=h.getViewSubImage(f,Ve);qe=et.viewport,Ie===0&&(e.setRenderTargetTextures(w,et.colorTexture,f.ignoreDepthValues?void 0:et.depthStencilTexture),e.setRenderTarget(w))}let Ye=$[Ie];Ye===void 0&&(Ye=new jr,Ye.layers.enable(Ie),Ye.viewport=new Jn,$[Ie]=Ye),Ye.matrix.fromArray(Ve.transform.matrix),Ye.matrix.decompose(Ye.position,Ye.quaternion,Ye.scale),Ye.projectionMatrix.fromArray(Ve.projectionMatrix),Ye.projectionMatrixInverse.copy(Ye.projectionMatrix).invert(),Ye.viewport.set(qe.x,qe.y,qe.width,qe.height),Ie===0&&(R.matrix.copy(Ye.matrix),R.matrix.decompose(R.position,R.quaternion,R.scale)),_e===!0&&R.cameras.push(Ye)}}for(let fe=0;fe<_.length;fe++){const _e=T[fe],Ie=_[fe];_e!==null&&Ie!==void 0&&Ie.update(_e,ue,u||o)}B&&B(te,ue),ue.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:ue}),g=null}const se=new q3;se.setAnimationLoop(K),this.setAnimationLoop=function(te){B=te},this.dispose=function(){}}}function aX(n,e){function t(x,w){x.matrixAutoUpdate===!0&&x.updateMatrix(),w.value.copy(x.matrix)}function s(x,w){w.color.getRGB(x.fogColor.value,G3(n)),w.isFog?(x.fogNear.value=w.near,x.fogFar.value=w.far):w.isFogExp2&&(x.fogDensity.value=w.density)}function r(x,w,_,T,C){w.isMeshBasicMaterial||w.isMeshLambertMaterial?i(x,w):w.isMeshToonMaterial?(i(x,w),h(x,w)):w.isMeshPhongMaterial?(i(x,w),c(x,w)):w.isMeshStandardMaterial?(i(x,w),f(x,w),w.isMeshPhysicalMaterial&&p(x,w,C)):w.isMeshMatcapMaterial?(i(x,w),g(x,w)):w.isMeshDepthMaterial?i(x,w):w.isMeshDistanceMaterial?(i(x,w),S(x,w)):w.isMeshNormalMaterial?i(x,w):w.isLineBasicMaterial?(o(x,w),w.isLineDashedMaterial&&a(x,w)):w.isPointsMaterial?l(x,w,_,T):w.isSpriteMaterial?u(x,w):w.isShadowMaterial?(x.color.value.copy(w.color),x.opacity.value=w.opacity):w.isShaderMaterial&&(w.uniformsNeedUpdate=!1)}function i(x,w){x.opacity.value=w.opacity,w.color&&x.diffuse.value.copy(w.color),w.emissive&&x.emissive.value.copy(w.emissive).multiplyScalar(w.emissiveIntensity),w.map&&(x.map.value=w.map,t(w.map,x.mapTransform)),w.alphaMap&&(x.alphaMap.value=w.alphaMap,t(w.alphaMap,x.alphaMapTransform)),w.bumpMap&&(x.bumpMap.value=w.bumpMap,t(w.bumpMap,x.bumpMapTransform),x.bumpScale.value=w.bumpScale,w.side===no&&(x.bumpScale.value*=-1)),w.normalMap&&(x.normalMap.value=w.normalMap,t(w.normalMap,x.normalMapTransform),x.normalScale.value.copy(w.normalScale),w.side===no&&x.normalScale.value.negate()),w.displacementMap&&(x.displacementMap.value=w.displacementMap,t(w.displacementMap,x.displacementMapTransform),x.displacementScale.value=w.displacementScale,x.displacementBias.value=w.displacementBias),w.emissiveMap&&(x.emissiveMap.value=w.emissiveMap,t(w.emissiveMap,x.emissiveMapTransform)),w.specularMap&&(x.specularMap.value=w.specularMap,t(w.specularMap,x.specularMapTransform)),w.alphaTest>0&&(x.alphaTest.value=w.alphaTest);const _=e.get(w).envMap;if(_&&(x.envMap.value=_,x.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,x.reflectivity.value=w.reflectivity,x.ior.value=w.ior,x.refractionRatio.value=w.refractionRatio),w.lightMap){x.lightMap.value=w.lightMap;const T=n._useLegacyLights===!0?Math.PI:1;x.lightMapIntensity.value=w.lightMapIntensity*T,t(w.lightMap,x.lightMapTransform)}w.aoMap&&(x.aoMap.value=w.aoMap,x.aoMapIntensity.value=w.aoMapIntensity,t(w.aoMap,x.aoMapTransform))}function o(x,w){x.diffuse.value.copy(w.color),x.opacity.value=w.opacity,w.map&&(x.map.value=w.map,t(w.map,x.mapTransform))}function a(x,w){x.dashSize.value=w.dashSize,x.totalSize.value=w.dashSize+w.gapSize,x.scale.value=w.scale}function l(x,w,_,T){x.diffuse.value.copy(w.color),x.opacity.value=w.opacity,x.size.value=w.size*_,x.scale.value=T*.5,w.map&&(x.map.value=w.map,t(w.map,x.uvTransform)),w.alphaMap&&(x.alphaMap.value=w.alphaMap,t(w.alphaMap,x.alphaMapTransform)),w.alphaTest>0&&(x.alphaTest.value=w.alphaTest)}function u(x,w){x.diffuse.value.copy(w.color),x.opacity.value=w.opacity,x.rotation.value=w.rotation,w.map&&(x.map.value=w.map,t(w.map,x.mapTransform)),w.alphaMap&&(x.alphaMap.value=w.alphaMap,t(w.alphaMap,x.alphaMapTransform)),w.alphaTest>0&&(x.alphaTest.value=w.alphaTest)}function c(x,w){x.specular.value.copy(w.specular),x.shininess.value=Math.max(w.shininess,1e-4)}function h(x,w){w.gradientMap&&(x.gradientMap.value=w.gradientMap)}function f(x,w){x.metalness.value=w.metalness,w.metalnessMap&&(x.metalnessMap.value=w.metalnessMap,t(w.metalnessMap,x.metalnessMapTransform)),x.roughness.value=w.roughness,w.roughnessMap&&(x.roughnessMap.value=w.roughnessMap,t(w.roughnessMap,x.roughnessMapTransform)),e.get(w).envMap&&(x.envMapIntensity.value=w.envMapIntensity)}function p(x,w,_){x.ior.value=w.ior,w.sheen>0&&(x.sheenColor.value.copy(w.sheenColor).multiplyScalar(w.sheen),x.sheenRoughness.value=w.sheenRoughness,w.sheenColorMap&&(x.sheenColorMap.value=w.sheenColorMap,t(w.sheenColorMap,x.sheenColorMapTransform)),w.sheenRoughnessMap&&(x.sheenRoughnessMap.value=w.sheenRoughnessMap,t(w.sheenRoughnessMap,x.sheenRoughnessMapTransform))),w.clearcoat>0&&(x.clearcoat.value=w.clearcoat,x.clearcoatRoughness.value=w.clearcoatRoughness,w.clearcoatMap&&(x.clearcoatMap.value=w.clearcoatMap,t(w.clearcoatMap,x.clearcoatMapTransform)),w.clearcoatRoughnessMap&&(x.clearcoatRoughnessMap.value=w.clearcoatRoughnessMap,t(w.clearcoatRoughnessMap,x.clearcoatRoughnessMapTransform)),w.clearcoatNormalMap&&(x.clearcoatNormalMap.value=w.clearcoatNormalMap,t(w.clearcoatNormalMap,x.clearcoatNormalMapTransform),x.clearcoatNormalScale.value.copy(w.clearcoatNormalScale),w.side===no&&x.clearcoatNormalScale.value.negate())),w.iridescence>0&&(x.iridescence.value=w.iridescence,x.iridescenceIOR.value=w.iridescenceIOR,x.iridescenceThicknessMinimum.value=w.iridescenceThicknessRange[0],x.iridescenceThicknessMaximum.value=w.iridescenceThicknessRange[1],w.iridescenceMap&&(x.iridescenceMap.value=w.iridescenceMap,t(w.iridescenceMap,x.iridescenceMapTransform)),w.iridescenceThicknessMap&&(x.iridescenceThicknessMap.value=w.iridescenceThicknessMap,t(w.iridescenceThicknessMap,x.iridescenceThicknessMapTransform))),w.transmission>0&&(x.transmission.value=w.transmission,x.transmissionSamplerMap.value=_.texture,x.transmissionSamplerSize.value.set(_.width,_.height),w.transmissionMap&&(x.transmissionMap.value=w.transmissionMap,t(w.transmissionMap,x.transmissionMapTransform)),x.thickness.value=w.thickness,w.thicknessMap&&(x.thicknessMap.value=w.thicknessMap,t(w.thicknessMap,x.thicknessMapTransform)),x.attenuationDistance.value=w.attenuationDistance,x.attenuationColor.value.copy(w.attenuationColor)),w.anisotropy>0&&(x.anisotropyVector.value.set(w.anisotropy*Math.cos(w.anisotropyRotation),w.anisotropy*Math.sin(w.anisotropyRotation)),w.anisotropyMap&&(x.anisotropyMap.value=w.anisotropyMap,t(w.anisotropyMap,x.anisotropyMapTransform))),x.specularIntensity.value=w.specularIntensity,x.specularColor.value.copy(w.specularColor),w.specularColorMap&&(x.specularColorMap.value=w.specularColorMap,t(w.specularColorMap,x.specularColorMapTransform)),w.specularIntensityMap&&(x.specularIntensityMap.value=w.specularIntensityMap,t(w.specularIntensityMap,x.specularIntensityMapTransform))}function g(x,w){w.matcap&&(x.matcap.value=w.matcap)}function S(x,w){const _=e.get(w).light;x.referencePosition.value.setFromMatrixPosition(_.matrixWorld),x.nearDistance.value=_.shadow.camera.near,x.farDistance.value=_.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:r}}function lX(n,e,t,s){let r={},i={},o=[];const a=t.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(_,T){const C=T.program;s.uniformBlockBinding(_,C)}function u(_,T){let C=r[_.id];C===void 0&&(g(_),C=c(_),r[_.id]=C,_.addEventListener("dispose",x));const N=T.program;s.updateUBOMapping(_,N);const M=e.render.frame;i[_.id]!==M&&(f(_),i[_.id]=M)}function c(_){const T=h();_.__bindingPointIndex=T;const C=n.createBuffer(),N=_.__size,M=_.usage;return n.bindBuffer(n.UNIFORM_BUFFER,C),n.bufferData(n.UNIFORM_BUFFER,N,M),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,T,C),C}function h(){for(let _=0;_<a;_++)if(o.indexOf(_)===-1)return o.push(_),_;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function f(_){const T=r[_.id],C=_.uniforms,N=_.__cache;n.bindBuffer(n.UNIFORM_BUFFER,T);for(let M=0,P=C.length;M<P;M++){const $=Array.isArray(C[M])?C[M]:[C[M]];for(let R=0,D=$.length;R<D;R++){const L=$[R];if(p(L,M,R,N)===!0){const G=L.__offset,Q=Array.isArray(L.value)?L.value:[L.value];let W=0;for(let H=0;H<Q.length;H++){const J=Q[H],ie=S(J);typeof J=="number"||typeof J=="boolean"?(L.__data[0]=J,n.bufferSubData(n.UNIFORM_BUFFER,G+W,L.__data)):J.isMatrix3?(L.__data[0]=J.elements[0],L.__data[1]=J.elements[1],L.__data[2]=J.elements[2],L.__data[3]=0,L.__data[4]=J.elements[3],L.__data[5]=J.elements[4],L.__data[6]=J.elements[5],L.__data[7]=0,L.__data[8]=J.elements[6],L.__data[9]=J.elements[7],L.__data[10]=J.elements[8],L.__data[11]=0):(J.toArray(L.__data,W),W+=ie.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,G,L.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(_,T,C,N){const M=_.value,P=T+"_"+C;if(N[P]===void 0)return typeof M=="number"||typeof M=="boolean"?N[P]=M:N[P]=M.clone(),!0;{const $=N[P];if(typeof M=="number"||typeof M=="boolean"){if($!==M)return N[P]=M,!0}else if($.equals(M)===!1)return $.copy(M),!0}return!1}function g(_){const T=_.uniforms;let C=0;const N=16;for(let P=0,$=T.length;P<$;P++){const R=Array.isArray(T[P])?T[P]:[T[P]];for(let D=0,L=R.length;D<L;D++){const G=R[D],Q=Array.isArray(G.value)?G.value:[G.value];for(let W=0,H=Q.length;W<H;W++){const J=Q[W],ie=S(J),V=C%N;V!==0&&N-V<ie.boundary&&(C+=N-V),G.__data=new Float32Array(ie.storage/Float32Array.BYTES_PER_ELEMENT),G.__offset=C,C+=ie.storage}}}const M=C%N;return M>0&&(C+=N-M),_.__size=C,_.__cache={},this}function S(_){const T={boundary:0,storage:0};return typeof _=="number"||typeof _=="boolean"?(T.boundary=4,T.storage=4):_.isVector2?(T.boundary=8,T.storage=8):_.isVector3||_.isColor?(T.boundary=16,T.storage=12):_.isVector4?(T.boundary=16,T.storage=16):_.isMatrix3?(T.boundary=48,T.storage=48):_.isMatrix4?(T.boundary=64,T.storage=64):_.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",_),T}function x(_){const T=_.target;T.removeEventListener("dispose",x);const C=o.indexOf(T.__bindingPointIndex);o.splice(C,1),n.deleteBuffer(r[T.id]),delete r[T.id],delete i[T.id]}function w(){for(const _ in r)n.deleteBuffer(r[_]);o=[],r={},i={}}return{bind:l,update:u,dispose:w}}class yI{constructor(e={}){const{canvas:t=B3(),context:s=null,depth:r=!0,stencil:i=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:u=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:h=!1}=e;this.isWebGLRenderer=!0;let f;s!==null?f=s.getContextAttributes().alpha:f=o;const p=new Uint32Array(4),g=new Int32Array(4);let S=null,x=null;const w=[],_=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=kr,this._useLegacyLights=!1,this.toneMapping=iu,this.toneMappingExposure=1;const T=this;let C=!1,N=0,M=0,P=null,$=-1,R=null;const D=new Jn,L=new Jn;let G=null;const Q=new vt(0);let W=0,H=t.width,J=t.height,ie=1,V=null,Y=null;const B=new Jn(0,0,H,J),K=new Jn(0,0,H,J);let se=!1;const te=new rx;let ue=!1,fe=!1,_e=null;const Ie=new ln,Ve=new Je,qe=new re,Ye={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function et(){return P===null?ie:1}let ae=s;function Be(ne,Ce){for(let Fe=0;Fe<ne.length;Fe++){const $e=ne[Fe],Pe=t.getContext($e,Ce);if(Pe!==null)return Pe}return null}try{const ne={alpha:!0,depth:r,stencil:i,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:u,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Q0}`),t.addEventListener("webglcontextlost",ut,!1),t.addEventListener("webglcontextrestored",ge,!1),t.addEventListener("webglcontextcreationerror",ct,!1),ae===null){const Ce=["webgl2","webgl","experimental-webgl"];if(T.isWebGL1Renderer===!0&&Ce.shift(),ae=Be(Ce,ne),ae===null)throw Be(Ce)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&ae instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),ae.getShaderPrecisionFormat===void 0&&(ae.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(ne){throw console.error("THREE.WebGLRenderer: "+ne.message),ne}let De,He,Re,at,Qe,ee,X,Se,We,Xe,je,xt,it,dt,It,Yt,Ke,hn,un,qt,Bt,yt,jt,Nn;function jn(){De=new b8(ae),He=new g8(ae,De,e),De.init(He),yt=new eO(ae,De,He),Re=new sX(ae,De,He),at=new C8(ae),Qe=new Hj,ee=new rX(ae,De,Re,Qe,He,yt,at),X=new x8(T),Se=new S8(T),We=new DH(ae,He),jt=new p8(ae,De,We,He),Xe=new _8(ae,We,at,jt),je=new A8(ae,Xe,We,at),un=new N8(ae,He,ee),Yt=new y8(Qe),xt=new Gj(T,X,Se,De,He,jt,Yt),it=new aX(T,Qe),dt=new Xj,It=new Qj(De,He),hn=new f8(T,X,Se,Re,je,f,l),Ke=new nX(T,je,He),Nn=new lX(ae,at,He,Re),qt=new m8(ae,De,at,He),Bt=new T8(ae,De,at,He),at.programs=xt.programs,T.capabilities=He,T.extensions=De,T.properties=Qe,T.renderLists=dt,T.shadowMap=Ke,T.state=Re,T.info=at}jn();const sn=new oX(T,ae);this.xr=sn,this.getContext=function(){return ae},this.getContextAttributes=function(){return ae.getContextAttributes()},this.forceContextLoss=function(){const ne=De.get("WEBGL_lose_context");ne&&ne.loseContext()},this.forceContextRestore=function(){const ne=De.get("WEBGL_lose_context");ne&&ne.restoreContext()},this.getPixelRatio=function(){return ie},this.setPixelRatio=function(ne){ne!==void 0&&(ie=ne,this.setSize(H,J,!1))},this.getSize=function(ne){return ne.set(H,J)},this.setSize=function(ne,Ce,Fe=!0){if(sn.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}H=ne,J=Ce,t.width=Math.floor(ne*ie),t.height=Math.floor(Ce*ie),Fe===!0&&(t.style.width=ne+"px",t.style.height=Ce+"px"),this.setViewport(0,0,ne,Ce)},this.getDrawingBufferSize=function(ne){return ne.set(H*ie,J*ie).floor()},this.setDrawingBufferSize=function(ne,Ce,Fe){H=ne,J=Ce,ie=Fe,t.width=Math.floor(ne*Fe),t.height=Math.floor(Ce*Fe),this.setViewport(0,0,ne,Ce)},this.getCurrentViewport=function(ne){return ne.copy(D)},this.getViewport=function(ne){return ne.copy(B)},this.setViewport=function(ne,Ce,Fe,$e){ne.isVector4?B.set(ne.x,ne.y,ne.z,ne.w):B.set(ne,Ce,Fe,$e),Re.viewport(D.copy(B).multiplyScalar(ie).floor())},this.getScissor=function(ne){return ne.copy(K)},this.setScissor=function(ne,Ce,Fe,$e){ne.isVector4?K.set(ne.x,ne.y,ne.z,ne.w):K.set(ne,Ce,Fe,$e),Re.scissor(L.copy(K).multiplyScalar(ie).floor())},this.getScissorTest=function(){return se},this.setScissorTest=function(ne){Re.setScissorTest(se=ne)},this.setOpaqueSort=function(ne){V=ne},this.setTransparentSort=function(ne){Y=ne},this.getClearColor=function(ne){return ne.copy(hn.getClearColor())},this.setClearColor=function(){hn.setClearColor.apply(hn,arguments)},this.getClearAlpha=function(){return hn.getClearAlpha()},this.setClearAlpha=function(){hn.setClearAlpha.apply(hn,arguments)},this.clear=function(ne=!0,Ce=!0,Fe=!0){let $e=0;if(ne){let Pe=!1;if(P!==null){const bt=P.texture.format;Pe=bt===sI||bt===nI||bt===tI}if(Pe){const bt=P.texture.type,Vt=bt===ou||bt===ic||bt===jS||bt===Th||bt===Q2||bt===eI,Zt=hn.getClearColor(),Ct=hn.getClearAlpha(),rn=Zt.r,en=Zt.g,nn=Zt.b;Vt?(p[0]=rn,p[1]=en,p[2]=nn,p[3]=Ct,ae.clearBufferuiv(ae.COLOR,0,p)):(g[0]=rn,g[1]=en,g[2]=nn,g[3]=Ct,ae.clearBufferiv(ae.COLOR,0,g))}else $e|=ae.COLOR_BUFFER_BIT}Ce&&($e|=ae.DEPTH_BUFFER_BIT),Fe&&($e|=ae.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),ae.clear($e)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",ut,!1),t.removeEventListener("webglcontextrestored",ge,!1),t.removeEventListener("webglcontextcreationerror",ct,!1),dt.dispose(),It.dispose(),Qe.dispose(),X.dispose(),Se.dispose(),je.dispose(),jt.dispose(),Nn.dispose(),xt.dispose(),sn.dispose(),sn.removeEventListener("sessionstart",Ys),sn.removeEventListener("sessionend",Fn),_e&&(_e.dispose(),_e=null),Zs.stop()};function ut(ne){ne.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),C=!0}function ge(){console.log("THREE.WebGLRenderer: Context Restored."),C=!1;const ne=at.autoReset,Ce=Ke.enabled,Fe=Ke.autoUpdate,$e=Ke.needsUpdate,Pe=Ke.type;jn(),at.autoReset=ne,Ke.enabled=Ce,Ke.autoUpdate=Fe,Ke.needsUpdate=$e,Ke.type=Pe}function ct(ne){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",ne.statusMessage)}function pt(ne){const Ce=ne.target;Ce.removeEventListener("dispose",pt),Kt(Ce)}function Kt(ne){Gt(ne),Qe.remove(ne)}function Gt(ne){const Ce=Qe.get(ne).programs;Ce!==void 0&&(Ce.forEach(function(Fe){xt.releaseProgram(Fe)}),ne.isShaderMaterial&&xt.releaseShaderCache(ne))}this.renderBufferDirect=function(ne,Ce,Fe,$e,Pe,bt){Ce===null&&(Ce=Ye);const Vt=Pe.isMesh&&Pe.matrixWorld.determinant()<0,Zt=Kg(ne,Ce,Fe,$e,Pe);Re.setMaterial($e,Vt);let Ct=Fe.index,rn=1;if($e.wireframe===!0){if(Ct=Xe.getWireframeAttribute(Fe),Ct===void 0)return;rn=2}const en=Fe.drawRange,nn=Fe.attributes.position;let ts=en.start*rn,Cr=(en.start+en.count)*rn;bt!==null&&(ts=Math.max(ts,bt.start*rn),Cr=Math.min(Cr,(bt.start+bt.count)*rn)),Ct!==null?(ts=Math.max(ts,0),Cr=Math.min(Cr,Ct.count)):nn!=null&&(ts=Math.max(ts,0),Cr=Math.min(Cr,nn.count));const ns=Cr-ts;if(ns<0||ns===1/0)return;jt.setup(Pe,$e,Zt,Fe,Ct);let Rs,zt=qt;if(Ct!==null&&(Rs=We.get(Ct),zt=Bt,zt.setIndex(Rs)),Pe.isMesh)$e.wireframe===!0?(Re.setLineWidth($e.wireframeLinewidth*et()),zt.setMode(ae.LINES)):zt.setMode(ae.TRIANGLES);else if(Pe.isLine){let At=$e.linewidth;At===void 0&&(At=1),Re.setLineWidth(At*et()),Pe.isLineSegments?zt.setMode(ae.LINES):Pe.isLineLoop?zt.setMode(ae.LINE_LOOP):zt.setMode(ae.LINE_STRIP)}else Pe.isPoints?zt.setMode(ae.POINTS):Pe.isSprite&&zt.setMode(ae.TRIANGLES);if(Pe.isBatchedMesh)zt.renderMultiDraw(Pe._multiDrawStarts,Pe._multiDrawCounts,Pe._multiDrawCount);else if(Pe.isInstancedMesh)zt.renderInstances(ts,ns,Pe.count);else if(Fe.isInstancedBufferGeometry){const At=Fe._maxInstanceCount!==void 0?Fe._maxInstanceCount:1/0,Cs=Math.min(Fe.instanceCount,At);zt.renderInstances(ts,ns,Cs)}else zt.render(ts,ns)};function Bn(ne,Ce,Fe){ne.transparent===!0&&ne.side===su&&ne.forceSinglePass===!1?(ne.side=no,ne.needsUpdate=!0,Dl(ne,Ce,Fe),ne.side=hc,ne.needsUpdate=!0,Dl(ne,Ce,Fe),ne.side=su):Dl(ne,Ce,Fe)}this.compile=function(ne,Ce,Fe=null){Fe===null&&(Fe=ne),x=It.get(Fe),x.init(),_.push(x),Fe.traverseVisible(function(Pe){Pe.isLight&&Pe.layers.test(Ce.layers)&&(x.pushLight(Pe),Pe.castShadow&&x.pushShadow(Pe))}),ne!==Fe&&ne.traverseVisible(function(Pe){Pe.isLight&&Pe.layers.test(Ce.layers)&&(x.pushLight(Pe),Pe.castShadow&&x.pushShadow(Pe))}),x.setupLights(T._useLegacyLights);const $e=new Set;return ne.traverse(function(Pe){const bt=Pe.material;if(bt)if(Array.isArray(bt))for(let Vt=0;Vt<bt.length;Vt++){const Zt=bt[Vt];Bn(Zt,Fe,Pe),$e.add(Zt)}else Bn(bt,Fe,Pe),$e.add(bt)}),_.pop(),x=null,$e},this.compileAsync=function(ne,Ce,Fe=null){const $e=this.compile(ne,Ce,Fe);return new Promise(Pe=>{function bt(){if($e.forEach(function(Vt){Qe.get(Vt).currentProgram.isReady()&&$e.delete(Vt)}),$e.size===0){Pe(ne);return}setTimeout(bt,10)}De.get("KHR_parallel_shader_compile")!==null?bt():setTimeout(bt,10)})};let kn=null;function xs(ne){kn&&kn(ne)}function Ys(){Zs.stop()}function Fn(){Zs.start()}const Zs=new q3;Zs.setAnimationLoop(xs),typeof self<"u"&&Zs.setContext(self),this.setAnimationLoop=function(ne){kn=ne,sn.setAnimationLoop(ne),ne===null?Zs.stop():Zs.start()},sn.addEventListener("sessionstart",Ys),sn.addEventListener("sessionend",Fn),this.render=function(ne,Ce){if(Ce!==void 0&&Ce.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(C===!0)return;ne.matrixWorldAutoUpdate===!0&&ne.updateMatrixWorld(),Ce.parent===null&&Ce.matrixWorldAutoUpdate===!0&&Ce.updateMatrixWorld(),sn.enabled===!0&&sn.isPresenting===!0&&(sn.cameraAutoUpdate===!0&&sn.updateCamera(Ce),Ce=sn.getCamera()),ne.isScene===!0&&ne.onBeforeRender(T,ne,Ce,P),x=It.get(ne,_.length),x.init(),_.push(x),Ie.multiplyMatrices(Ce.projectionMatrix,Ce.matrixWorldInverse),te.setFromProjectionMatrix(Ie),fe=this.localClippingEnabled,ue=Yt.init(this.clippingPlanes,fe),S=dt.get(ne,w.length),S.init(),w.push(S),Ur(ne,Ce,0,T.sortObjects),S.finish(),T.sortObjects===!0&&S.sort(V,Y),this.info.render.frame++,ue===!0&&Yt.beginShadows();const Fe=x.state.shadowsArray;if(Ke.render(Fe,ne,Ce),ue===!0&&Yt.endShadows(),this.info.autoReset===!0&&this.info.reset(),hn.render(S,ne),x.setupLights(T._useLegacyLights),Ce.isArrayCamera){const $e=Ce.cameras;for(let Pe=0,bt=$e.length;Pe<bt;Pe++){const Vt=$e[Pe];cd(S,ne,Vt,Vt.viewport)}}else cd(S,ne,Ce);P!==null&&(ee.updateMultisampleRenderTarget(P),ee.updateRenderTargetMipmap(P)),ne.isScene===!0&&ne.onAfterRender(T,ne,Ce),jt.resetDefaultState(),$=-1,R=null,_.pop(),_.length>0?x=_[_.length-1]:x=null,w.pop(),w.length>0?S=w[w.length-1]:S=null};function Ur(ne,Ce,Fe,$e){if(ne.visible===!1)return;if(ne.layers.test(Ce.layers)){if(ne.isGroup)Fe=ne.renderOrder;else if(ne.isLOD)ne.autoUpdate===!0&&ne.update(Ce);else if(ne.isLight)x.pushLight(ne),ne.castShadow&&x.pushShadow(ne);else if(ne.isSprite){if(!ne.frustumCulled||te.intersectsSprite(ne)){$e&&qe.setFromMatrixPosition(ne.matrixWorld).applyMatrix4(Ie);const Vt=je.update(ne),Zt=ne.material;Zt.visible&&S.push(ne,Vt,Zt,Fe,qe.z,null)}}else if((ne.isMesh||ne.isLine||ne.isPoints)&&(!ne.frustumCulled||te.intersectsObject(ne))){const Vt=je.update(ne),Zt=ne.material;if($e&&(ne.boundingSphere!==void 0?(ne.boundingSphere===null&&ne.computeBoundingSphere(),qe.copy(ne.boundingSphere.center)):(Vt.boundingSphere===null&&Vt.computeBoundingSphere(),qe.copy(Vt.boundingSphere.center)),qe.applyMatrix4(ne.matrixWorld).applyMatrix4(Ie)),Array.isArray(Zt)){const Ct=Vt.groups;for(let rn=0,en=Ct.length;rn<en;rn++){const nn=Ct[rn],ts=Zt[nn.materialIndex];ts&&ts.visible&&S.push(ne,Vt,ts,Fe,qe.z,nn)}}else Zt.visible&&S.push(ne,Vt,Zt,Fe,qe.z,null)}}const bt=ne.children;for(let Vt=0,Zt=bt.length;Vt<Zt;Vt++)Ur(bt[Vt],Ce,Fe,$e)}function cd(ne,Ce,Fe,$e){const Pe=ne.opaque,bt=ne.transmissive,Vt=ne.transparent;x.setupLightsView(Fe),ue===!0&&Yt.setGlobalState(T.clippingPlanes,Fe),bt.length>0&&Ua(Pe,bt,Ce,Fe),$e&&Re.viewport(D.copy($e)),Pe.length>0&&Ba(Pe,Ce,Fe),bt.length>0&&Ba(bt,Ce,Fe),Vt.length>0&&Ba(Vt,Ce,Fe),Re.buffers.depth.setTest(!0),Re.buffers.depth.setMask(!0),Re.buffers.color.setMask(!0),Re.setPolygonOffset(!1)}function Ua(ne,Ce,Fe,$e){if((Fe.isScene===!0?Fe.overrideMaterial:null)!==null)return;const bt=He.isWebGL2;_e===null&&(_e=new _l(1,1,{generateMipmaps:!0,type:De.has("EXT_color_buffer_half_float")?rg:ou,minFilter:Rh,samples:bt?4:0})),T.getDrawingBufferSize(Ve),bt?_e.setSize(Ve.x,Ve.y):_e.setSize(lS(Ve.x),lS(Ve.y));const Vt=T.getRenderTarget();T.setRenderTarget(_e),T.getClearColor(Q),W=T.getClearAlpha(),W<1&&T.setClearColor(16777215,.5),T.clear();const Zt=T.toneMapping;T.toneMapping=iu,Ba(ne,Fe,$e),ee.updateMultisampleRenderTarget(_e),ee.updateRenderTargetMipmap(_e);let Ct=!1;for(let rn=0,en=Ce.length;rn<en;rn++){const nn=Ce[rn],ts=nn.object,Cr=nn.geometry,ns=nn.material,Rs=nn.group;if(ns.side===su&&ts.layers.test($e.layers)){const zt=ns.side;ns.side=no,ns.needsUpdate=!0,Go(ts,Fe,$e,Cr,ns,Rs),ns.side=zt,ns.needsUpdate=!0,Ct=!0}}Ct===!0&&(ee.updateMultisampleRenderTarget(_e),ee.updateRenderTargetMipmap(_e)),T.setRenderTarget(Vt),T.setClearColor(Q,W),T.toneMapping=Zt}function Ba(ne,Ce,Fe){const $e=Ce.isScene===!0?Ce.overrideMaterial:null;for(let Pe=0,bt=ne.length;Pe<bt;Pe++){const Vt=ne[Pe],Zt=Vt.object,Ct=Vt.geometry,rn=$e===null?Vt.material:$e,en=Vt.group;Zt.layers.test(Fe.layers)&&Go(Zt,Ce,Fe,Ct,rn,en)}}function Go(ne,Ce,Fe,$e,Pe,bt){ne.onBeforeRender(T,Ce,Fe,$e,Pe,bt),ne.modelViewMatrix.multiplyMatrices(Fe.matrixWorldInverse,ne.matrixWorld),ne.normalMatrix.getNormalMatrix(ne.modelViewMatrix),Pe.onBeforeRender(T,Ce,Fe,$e,ne,bt),Pe.transparent===!0&&Pe.side===su&&Pe.forceSinglePass===!1?(Pe.side=no,Pe.needsUpdate=!0,T.renderBufferDirect(Fe,Ce,$e,Pe,ne,bt),Pe.side=hc,Pe.needsUpdate=!0,T.renderBufferDirect(Fe,Ce,$e,Pe,ne,bt),Pe.side=su):T.renderBufferDirect(Fe,Ce,$e,Pe,ne,bt),ne.onAfterRender(T,Ce,Fe,$e,Pe,bt)}function Dl(ne,Ce,Fe){Ce.isScene!==!0&&(Ce=Ye);const $e=Qe.get(ne),Pe=x.state.lights,bt=x.state.shadowsArray,Vt=Pe.state.version,Zt=xt.getParameters(ne,Pe.state,bt,Ce,Fe),Ct=xt.getProgramCacheKey(Zt);let rn=$e.programs;$e.environment=ne.isMeshStandardMaterial?Ce.environment:null,$e.fog=Ce.fog,$e.envMap=(ne.isMeshStandardMaterial?Se:X).get(ne.envMap||$e.environment),rn===void 0&&(ne.addEventListener("dispose",pt),rn=new Map,$e.programs=rn);let en=rn.get(Ct);if(en!==void 0){if($e.currentProgram===en&&$e.lightsStateVersion===Vt)return op(ne,Zt),en}else Zt.uniforms=xt.getUniforms(ne),ne.onBuild(Fe,Zt,T),ne.onBeforeCompile(Zt,T),en=xt.acquireProgram(Zt,Ct),rn.set(Ct,en),$e.uniforms=Zt.uniforms;const nn=$e.uniforms;return(!ne.isShaderMaterial&&!ne.isRawShaderMaterial||ne.clipping===!0)&&(nn.clippingPlanes=Yt.uniform),op(ne,Zt),$e.needsLights=ap(ne),$e.lightsStateVersion=Vt,$e.needsLights&&(nn.ambientLightColor.value=Pe.state.ambient,nn.lightProbe.value=Pe.state.probe,nn.directionalLights.value=Pe.state.directional,nn.directionalLightShadows.value=Pe.state.directionalShadow,nn.spotLights.value=Pe.state.spot,nn.spotLightShadows.value=Pe.state.spotShadow,nn.rectAreaLights.value=Pe.state.rectArea,nn.ltc_1.value=Pe.state.rectAreaLTC1,nn.ltc_2.value=Pe.state.rectAreaLTC2,nn.pointLights.value=Pe.state.point,nn.pointLightShadows.value=Pe.state.pointShadow,nn.hemisphereLights.value=Pe.state.hemi,nn.directionalShadowMap.value=Pe.state.directionalShadowMap,nn.directionalShadowMatrix.value=Pe.state.directionalShadowMatrix,nn.spotShadowMap.value=Pe.state.spotShadowMap,nn.spotLightMatrix.value=Pe.state.spotLightMatrix,nn.spotLightMap.value=Pe.state.spotLightMap,nn.pointShadowMap.value=Pe.state.pointShadowMap,nn.pointShadowMatrix.value=Pe.state.pointShadowMatrix),$e.currentProgram=en,$e.uniformsList=null,en}function ip(ne){if(ne.uniformsList===null){const Ce=ne.currentProgram.getUniforms();ne.uniformsList=Ww.seqWithValue(Ce.seq,ne.uniforms)}return ne.uniformsList}function op(ne,Ce){const Fe=Qe.get(ne);Fe.outputColorSpace=Ce.outputColorSpace,Fe.batching=Ce.batching,Fe.instancing=Ce.instancing,Fe.instancingColor=Ce.instancingColor,Fe.skinning=Ce.skinning,Fe.morphTargets=Ce.morphTargets,Fe.morphNormals=Ce.morphNormals,Fe.morphColors=Ce.morphColors,Fe.morphTargetsCount=Ce.morphTargetsCount,Fe.numClippingPlanes=Ce.numClippingPlanes,Fe.numIntersection=Ce.numClipIntersection,Fe.vertexAlphas=Ce.vertexAlphas,Fe.vertexTangents=Ce.vertexTangents,Fe.toneMapping=Ce.toneMapping}function Kg(ne,Ce,Fe,$e,Pe){Ce.isScene!==!0&&(Ce=Ye),ee.resetTextureUnits();const bt=Ce.fog,Vt=$e.isMeshStandardMaterial?Ce.environment:null,Zt=P===null?T.outputColorSpace:P.isXRRenderTarget===!0?P.texture.colorSpace:du,Ct=($e.isMeshStandardMaterial?Se:X).get($e.envMap||Vt),rn=$e.vertexColors===!0&&!!Fe.attributes.color&&Fe.attributes.color.itemSize===4,en=!!Fe.attributes.tangent&&(!!$e.normalMap||$e.anisotropy>0),nn=!!Fe.morphAttributes.position,ts=!!Fe.morphAttributes.normal,Cr=!!Fe.morphAttributes.color;let ns=iu;$e.toneMapped&&(P===null||P.isXRRenderTarget===!0)&&(ns=T.toneMapping);const Rs=Fe.morphAttributes.position||Fe.morphAttributes.normal||Fe.morphAttributes.color,zt=Rs!==void 0?Rs.length:0,At=Qe.get($e),Cs=x.state.lights;if(ue===!0&&(fe===!0||ne!==R)){const Er=ne===R&&$e.id===$;Yt.setState($e,ne,Er)}let xn=!1;$e.version===At.__version?(At.needsLights&&At.lightsStateVersion!==Cs.state.version||At.outputColorSpace!==Zt||Pe.isBatchedMesh&&At.batching===!1||!Pe.isBatchedMesh&&At.batching===!0||Pe.isInstancedMesh&&At.instancing===!1||!Pe.isInstancedMesh&&At.instancing===!0||Pe.isSkinnedMesh&&At.skinning===!1||!Pe.isSkinnedMesh&&At.skinning===!0||Pe.isInstancedMesh&&At.instancingColor===!0&&Pe.instanceColor===null||Pe.isInstancedMesh&&At.instancingColor===!1&&Pe.instanceColor!==null||At.envMap!==Ct||$e.fog===!0&&At.fog!==bt||At.numClippingPlanes!==void 0&&(At.numClippingPlanes!==Yt.numPlanes||At.numIntersection!==Yt.numIntersection)||At.vertexAlphas!==rn||At.vertexTangents!==en||At.morphTargets!==nn||At.morphNormals!==ts||At.morphColors!==Cr||At.toneMapping!==ns||He.isWebGL2===!0&&At.morphTargetsCount!==zt)&&(xn=!0):(xn=!0,At.__version=$e.version);let Es=At.currentProgram;xn===!0&&(Es=Dl($e,Ce,Pe));let ha=!1,ti=!1,Ds=!1;const ls=Es.getUniforms(),Bi=At.uniforms;if(Re.useProgram(Es.program)&&(ha=!0,ti=!0,Ds=!0),$e.id!==$&&($=$e.id,ti=!0),ha||R!==ne){ls.setValue(ae,"projectionMatrix",ne.projectionMatrix),ls.setValue(ae,"viewMatrix",ne.matrixWorldInverse);const Er=ls.map.cameraPosition;Er!==void 0&&Er.setValue(ae,qe.setFromMatrixPosition(ne.matrixWorld)),He.logarithmicDepthBuffer&&ls.setValue(ae,"logDepthBufFC",2/(Math.log(ne.far+1)/Math.LN2)),($e.isMeshPhongMaterial||$e.isMeshToonMaterial||$e.isMeshLambertMaterial||$e.isMeshBasicMaterial||$e.isMeshStandardMaterial||$e.isShaderMaterial)&&ls.setValue(ae,"isOrthographic",ne.isOrthographicCamera===!0),R!==ne&&(R=ne,ti=!0,Ds=!0)}if(Pe.isSkinnedMesh){ls.setOptional(ae,Pe,"bindMatrix"),ls.setOptional(ae,Pe,"bindMatrixInverse");const Er=Pe.skeleton;Er&&(He.floatVertexTextures?(Er.boneTexture===null&&Er.computeBoneTexture(),ls.setValue(ae,"boneTexture",Er.boneTexture,ee)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}Pe.isBatchedMesh&&(ls.setOptional(ae,Pe,"batchingTexture"),ls.setValue(ae,"batchingTexture",Pe._matricesTexture,ee));const Cc=Fe.morphAttributes;if((Cc.position!==void 0||Cc.normal!==void 0||Cc.color!==void 0&&He.isWebGL2===!0)&&un.update(Pe,Fe,Es),(ti||At.receiveShadow!==Pe.receiveShadow)&&(At.receiveShadow=Pe.receiveShadow,ls.setValue(ae,"receiveShadow",Pe.receiveShadow)),$e.isMeshGouraudMaterial&&$e.envMap!==null&&(Bi.envMap.value=Ct,Bi.flipEnvMap.value=Ct.isCubeTexture&&Ct.isRenderTargetTexture===!1?-1:1),ti&&(ls.setValue(ae,"toneMappingExposure",T.toneMappingExposure),At.needsLights&&Va(Bi,Ds),bt&&$e.fog===!0&&it.refreshFogUniforms(Bi,bt),it.refreshMaterialUniforms(Bi,$e,ie,J,_e),Ww.upload(ae,ip(At),Bi,ee)),$e.isShaderMaterial&&$e.uniformsNeedUpdate===!0&&(Ww.upload(ae,ip(At),Bi,ee),$e.uniformsNeedUpdate=!1),$e.isSpriteMaterial&&ls.setValue(ae,"center",Pe.center),ls.setValue(ae,"modelViewMatrix",Pe.modelViewMatrix),ls.setValue(ae,"normalMatrix",Pe.normalMatrix),ls.setValue(ae,"modelMatrix",Pe.matrixWorld),$e.isShaderMaterial||$e.isRawShaderMaterial){const Er=$e.uniformsGroups;for(let Pl=0,wi=Er.length;Pl<wi;Pl++)if(He.isWebGL2){const Ec=Er[Pl];Nn.update(Ec,Es),Nn.bind(Ec,Es)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Es}function Va(ne,Ce){ne.ambientLightColor.needsUpdate=Ce,ne.lightProbe.needsUpdate=Ce,ne.directionalLights.needsUpdate=Ce,ne.directionalLightShadows.needsUpdate=Ce,ne.pointLights.needsUpdate=Ce,ne.pointLightShadows.needsUpdate=Ce,ne.spotLights.needsUpdate=Ce,ne.spotLightShadows.needsUpdate=Ce,ne.rectAreaLights.needsUpdate=Ce,ne.hemisphereLights.needsUpdate=Ce}function ap(ne){return ne.isMeshLambertMaterial||ne.isMeshToonMaterial||ne.isMeshPhongMaterial||ne.isMeshStandardMaterial||ne.isShadowMaterial||ne.isShaderMaterial&&ne.lights===!0}this.getActiveCubeFace=function(){return N},this.getActiveMipmapLevel=function(){return M},this.getRenderTarget=function(){return P},this.setRenderTargetTextures=function(ne,Ce,Fe){Qe.get(ne.texture).__webglTexture=Ce,Qe.get(ne.depthTexture).__webglTexture=Fe;const $e=Qe.get(ne);$e.__hasExternalTextures=!0,$e.__hasExternalTextures&&($e.__autoAllocateDepthBuffer=Fe===void 0,$e.__autoAllocateDepthBuffer||De.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),$e.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(ne,Ce){const Fe=Qe.get(ne);Fe.__webglFramebuffer=Ce,Fe.__useDefaultFramebuffer=Ce===void 0},this.setRenderTarget=function(ne,Ce=0,Fe=0){P=ne,N=Ce,M=Fe;let $e=!0,Pe=null,bt=!1,Vt=!1;if(ne){const Ct=Qe.get(ne);Ct.__useDefaultFramebuffer!==void 0?(Re.bindFramebuffer(ae.FRAMEBUFFER,null),$e=!1):Ct.__webglFramebuffer===void 0?ee.setupRenderTarget(ne):Ct.__hasExternalTextures&&ee.rebindTextures(ne,Qe.get(ne.texture).__webglTexture,Qe.get(ne.depthTexture).__webglTexture);const rn=ne.texture;(rn.isData3DTexture||rn.isDataArrayTexture||rn.isCompressedArrayTexture)&&(Vt=!0);const en=Qe.get(ne).__webglFramebuffer;ne.isWebGLCubeRenderTarget?(Array.isArray(en[Ce])?Pe=en[Ce][Fe]:Pe=en[Ce],bt=!0):He.isWebGL2&&ne.samples>0&&ee.useMultisampledRTT(ne)===!1?Pe=Qe.get(ne).__webglMultisampledFramebuffer:Array.isArray(en)?Pe=en[Fe]:Pe=en,D.copy(ne.viewport),L.copy(ne.scissor),G=ne.scissorTest}else D.copy(B).multiplyScalar(ie).floor(),L.copy(K).multiplyScalar(ie).floor(),G=se;if(Re.bindFramebuffer(ae.FRAMEBUFFER,Pe)&&He.drawBuffers&&$e&&Re.drawBuffers(ne,Pe),Re.viewport(D),Re.scissor(L),Re.setScissorTest(G),bt){const Ct=Qe.get(ne.texture);ae.framebufferTexture2D(ae.FRAMEBUFFER,ae.COLOR_ATTACHMENT0,ae.TEXTURE_CUBE_MAP_POSITIVE_X+Ce,Ct.__webglTexture,Fe)}else if(Vt){const Ct=Qe.get(ne.texture),rn=Ce||0;ae.framebufferTextureLayer(ae.FRAMEBUFFER,ae.COLOR_ATTACHMENT0,Ct.__webglTexture,Fe||0,rn)}$=-1},this.readRenderTargetPixels=function(ne,Ce,Fe,$e,Pe,bt,Vt){if(!(ne&&ne.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Zt=Qe.get(ne).__webglFramebuffer;if(ne.isWebGLCubeRenderTarget&&Vt!==void 0&&(Zt=Zt[Vt]),Zt){Re.bindFramebuffer(ae.FRAMEBUFFER,Zt);try{const Ct=ne.texture,rn=Ct.format,en=Ct.type;if(rn!==eo&&yt.convert(rn)!==ae.getParameter(ae.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const nn=en===rg&&(De.has("EXT_color_buffer_half_float")||He.isWebGL2&&De.has("EXT_color_buffer_float"));if(en!==ou&&yt.convert(en)!==ae.getParameter(ae.IMPLEMENTATION_COLOR_READ_TYPE)&&!(en===xl&&(He.isWebGL2||De.has("OES_texture_float")||De.has("WEBGL_color_buffer_float")))&&!nn){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Ce>=0&&Ce<=ne.width-$e&&Fe>=0&&Fe<=ne.height-Pe&&ae.readPixels(Ce,Fe,$e,Pe,yt.convert(rn),yt.convert(en),bt)}finally{const Ct=P!==null?Qe.get(P).__webglFramebuffer:null;Re.bindFramebuffer(ae.FRAMEBUFFER,Ct)}}},this.copyFramebufferToTexture=function(ne,Ce,Fe=0){const $e=Math.pow(2,-Fe),Pe=Math.floor(Ce.image.width*$e),bt=Math.floor(Ce.image.height*$e);ee.setTexture2D(Ce,0),ae.copyTexSubImage2D(ae.TEXTURE_2D,Fe,0,0,ne.x,ne.y,Pe,bt),Re.unbindTexture()},this.copyTextureToTexture=function(ne,Ce,Fe,$e=0){const Pe=Ce.image.width,bt=Ce.image.height,Vt=yt.convert(Fe.format),Zt=yt.convert(Fe.type);ee.setTexture2D(Fe,0),ae.pixelStorei(ae.UNPACK_FLIP_Y_WEBGL,Fe.flipY),ae.pixelStorei(ae.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Fe.premultiplyAlpha),ae.pixelStorei(ae.UNPACK_ALIGNMENT,Fe.unpackAlignment),Ce.isDataTexture?ae.texSubImage2D(ae.TEXTURE_2D,$e,ne.x,ne.y,Pe,bt,Vt,Zt,Ce.image.data):Ce.isCompressedTexture?ae.compressedTexSubImage2D(ae.TEXTURE_2D,$e,ne.x,ne.y,Ce.mipmaps[0].width,Ce.mipmaps[0].height,Vt,Ce.mipmaps[0].data):ae.texSubImage2D(ae.TEXTURE_2D,$e,ne.x,ne.y,Vt,Zt,Ce.image),$e===0&&Fe.generateMipmaps&&ae.generateMipmap(ae.TEXTURE_2D),Re.unbindTexture()},this.copyTextureToTexture3D=function(ne,Ce,Fe,$e,Pe=0){if(T.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const bt=ne.max.x-ne.min.x+1,Vt=ne.max.y-ne.min.y+1,Zt=ne.max.z-ne.min.z+1,Ct=yt.convert($e.format),rn=yt.convert($e.type);let en;if($e.isData3DTexture)ee.setTexture3D($e,0),en=ae.TEXTURE_3D;else if($e.isDataArrayTexture||$e.isCompressedArrayTexture)ee.setTexture2DArray($e,0),en=ae.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}ae.pixelStorei(ae.UNPACK_FLIP_Y_WEBGL,$e.flipY),ae.pixelStorei(ae.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$e.premultiplyAlpha),ae.pixelStorei(ae.UNPACK_ALIGNMENT,$e.unpackAlignment);const nn=ae.getParameter(ae.UNPACK_ROW_LENGTH),ts=ae.getParameter(ae.UNPACK_IMAGE_HEIGHT),Cr=ae.getParameter(ae.UNPACK_SKIP_PIXELS),ns=ae.getParameter(ae.UNPACK_SKIP_ROWS),Rs=ae.getParameter(ae.UNPACK_SKIP_IMAGES),zt=Fe.isCompressedTexture?Fe.mipmaps[Pe]:Fe.image;ae.pixelStorei(ae.UNPACK_ROW_LENGTH,zt.width),ae.pixelStorei(ae.UNPACK_IMAGE_HEIGHT,zt.height),ae.pixelStorei(ae.UNPACK_SKIP_PIXELS,ne.min.x),ae.pixelStorei(ae.UNPACK_SKIP_ROWS,ne.min.y),ae.pixelStorei(ae.UNPACK_SKIP_IMAGES,ne.min.z),Fe.isDataTexture||Fe.isData3DTexture?ae.texSubImage3D(en,Pe,Ce.x,Ce.y,Ce.z,bt,Vt,Zt,Ct,rn,zt.data):Fe.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ae.compressedTexSubImage3D(en,Pe,Ce.x,Ce.y,Ce.z,bt,Vt,Zt,Ct,zt.data)):ae.texSubImage3D(en,Pe,Ce.x,Ce.y,Ce.z,bt,Vt,Zt,Ct,rn,zt),ae.pixelStorei(ae.UNPACK_ROW_LENGTH,nn),ae.pixelStorei(ae.UNPACK_IMAGE_HEIGHT,ts),ae.pixelStorei(ae.UNPACK_SKIP_PIXELS,Cr),ae.pixelStorei(ae.UNPACK_SKIP_ROWS,ns),ae.pixelStorei(ae.UNPACK_SKIP_IMAGES,Rs),Pe===0&&$e.generateMipmaps&&ae.generateMipmap(en),Re.unbindTexture()},this.initTexture=function(ne){ne.isCubeTexture?ee.setTextureCube(ne,0):ne.isData3DTexture?ee.setTexture3D(ne,0):ne.isDataArrayTexture||ne.isCompressedArrayTexture?ee.setTexture2DArray(ne,0):ee.setTexture2D(ne,0),Re.unbindTexture()},this.resetState=function(){N=0,M=0,P=null,Re.reset(),jt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return vl}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===qS?"display-p3":"srgb",t.unpackColorSpace=Zn.workingColorSpace===tx?"display-p3":"srgb"}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===kr?Eh:oI}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===Eh?kr:du}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class nO extends yI{}nO.prototype.isWebGL1Renderer=!0;class ZS{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new vt(e),this.density=t}clone(){return new ZS(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class JS{constructor(e,t=1,s=1e3){this.isFog=!0,this.name="",this.color=new vt(e),this.near=t,this.far=s}clone(){return new JS(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class uS extends zn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class QS{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=C0,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=oa()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let r=0,i=this.stride;r<i;r++)this.array[e+r]=t.array[s+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=oa()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=oa()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Yi=new re;class kf{constructor(e,t,s,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)Yi.fromBufferAttribute(this,t),Yi.applyMatrix4(e),this.setXYZ(t,Yi.x,Yi.y,Yi.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Yi.fromBufferAttribute(this,t),Yi.applyNormalMatrix(e),this.setXYZ(t,Yi.x,Yi.y,Yi.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Yi.fromBufferAttribute(this,t),Yi.transformDirection(e),this.setXYZ(t,Yi.x,Yi.y,Yi.z);return this}setX(e,t){return this.normalized&&(t=Sn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Sn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Sn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Sn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Ao(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Ao(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Ao(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Ao(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array),r=Sn(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=r,this}setXYZW(e,t,s,r,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Sn(t,this.array),s=Sn(s,this.array),r=Sn(r,this.array),i=Sn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=r,this.data.array[e+3]=i,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const r=s*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[r+i])}return new Qn(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new kf(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const r=s*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[r+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class xI extends xi{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new vt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Tm;const Vy=new re,Cm=new re,Em=new re,Im=new Je,Wy=new Je,sO=new ln,Y1=new re,Gy=new re,Z1=new re,_R=new Je,fC=new Je,TR=new Je;class rO extends zn{constructor(e=new xI){if(super(),this.isSprite=!0,this.type="Sprite",Tm===void 0){Tm=new bn;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new QS(t,5);Tm.setIndex([0,1,2,0,2,3]),Tm.setAttribute("position",new kf(s,3,0,!1)),Tm.setAttribute("uv",new kf(s,2,3,!1))}this.geometry=Tm,this.material=e,this.center=new Je(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Cm.setFromMatrixScale(this.matrixWorld),sO.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Em.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Cm.multiplyScalar(-Em.z);const s=this.material.rotation;let r,i;s!==0&&(i=Math.cos(s),r=Math.sin(s));const o=this.center;J1(Y1.set(-.5,-.5,0),Em,o,Cm,r,i),J1(Gy.set(.5,-.5,0),Em,o,Cm,r,i),J1(Z1.set(.5,.5,0),Em,o,Cm,r,i),_R.set(0,0),fC.set(1,0),TR.set(1,1);let a=e.ray.intersectTriangle(Y1,Gy,Z1,!1,Vy);if(a===null&&(J1(Gy.set(-.5,.5,0),Em,o,Cm,r,i),fC.set(0,1),a=e.ray.intersectTriangle(Y1,Z1,Gy,!1,Vy),a===null))return;const l=e.ray.origin.distanceTo(Vy);l<e.near||l>e.far||t.push({distance:l,point:Vy.clone(),uv:No.getInterpolation(Vy,Y1,Gy,Z1,_R,fC,TR,new Je),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function J1(n,e,t,s,r,i){Im.subVectors(n,t).addScalar(.5).multiply(s),r!==void 0?(Wy.x=i*Im.x-r*Im.y,Wy.y=r*Im.x+i*Im.y):Wy.copy(Im),n.copy(e),n.x+=Wy.x,n.y+=Wy.y,n.applyMatrix4(sO)}const Q1=new re,CR=new re;class iO extends zn{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let s=0,r=t.length;s<r;s++){const i=t[s];this.addLevel(i.object.clone(),i.distance,i.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,s=0){t=Math.abs(t);const r=this.levels;let i;for(i=0;i<r.length&&!(t<r[i].distance);i++);return r.splice(i,0,{distance:t,hysteresis:s,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let s,r;for(s=1,r=t.length;s<r;s++){let i=t[s].distance;if(t[s].object.visible&&(i-=i*t[s].hysteresis),e<i)break}return t[s-1].object}return null}raycast(e,t){if(this.levels.length>0){Q1.setFromMatrixPosition(this.matrixWorld);const r=e.ray.origin.distanceTo(Q1);this.getObjectForDistance(r).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Q1.setFromMatrixPosition(e.matrixWorld),CR.setFromMatrixPosition(this.matrixWorld);const s=Q1.distanceTo(CR)/e.zoom;t[0].object.visible=!0;let r,i;for(r=1,i=t.length;r<i;r++){let o=t[r].distance;if(t[r].object.visible&&(o-=o*t[r].hysteresis),s>=o)t[r-1].object.visible=!1,t[r].object.visible=!0;else break}for(this._currentLevel=r-1;r<i;r++)t[r].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const s=this.levels;for(let r=0,i=s.length;r<i;r++){const o=s[r];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const ER=new re,IR=new Jn,NR=new Jn,uX=new re,AR=new ln,ew=new re,pC=new Fi,MR=new ln,mC=new Tg;class oO extends Dr{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=fE,this.bindMatrix=new ln,this.bindMatrixInverse=new ln,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new so),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,ew),this.boundingBox.expandByPoint(ew)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Fi),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,ew),this.boundingSphere.expandByPoint(ew)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const s=this.material,r=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),pC.copy(this.boundingSphere),pC.applyMatrix4(r),e.ray.intersectsSphere(pC)!==!1&&(MR.copy(r).invert(),mC.copy(e.ray).applyMatrix4(MR),!(this.boundingBox!==null&&mC.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,mC)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Jn,t=this.geometry.attributes.skinWeight;for(let s=0,r=t.count;s<r;s++){e.fromBufferAttribute(t,s);const i=1/e.manhattanLength();i!==1/0?e.multiplyScalar(i):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===fE?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===x3?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const s=this.skeleton,r=this.geometry;IR.fromBufferAttribute(r.attributes.skinIndex,e),NR.fromBufferAttribute(r.attributes.skinWeight,e),ER.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let i=0;i<4;i++){const o=NR.getComponent(i);if(o!==0){const a=IR.getComponent(i);AR.multiplyMatrices(s.bones[a].matrixWorld,s.boneInverses[a]),t.addScaledVector(uX.copy(ER).applyMatrix4(AR),o)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class vI extends zn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Ef extends Hs{constructor(e=null,t=1,s=1,r,i,o,a,l,u=sr,c=sr,h,f){super(null,o,a,l,u,c,r,i,h,f),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const kR=new ln,cX=new ln;class eb{constructor(e=[],t=[]){this.uuid=oa(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,r=this.bones.length;s<r;s++)this.boneInverses.push(new ln)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new ln;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,r=this.boneTexture;for(let i=0,o=e.length;i<o;i++){const a=e[i]?e[i].matrixWorld:cX;kR.multiplyMatrices(a,t[i]),kR.toArray(s,i*16)}r!==null&&(r.needsUpdate=!0)}clone(){return new eb(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new Ef(t,e,e,eo,xl);return s.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=s,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const r=this.bones[t];if(r.name===e)return r}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,r=e.bones.length;s<r;s++){const i=e.bones[s];let o=t[i];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),o=new vI),this.bones.push(o),this.boneInverses.push(new ln().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let r=0,i=t.length;r<i;r++){const o=t[r];e.bones.push(o.uuid);const a=s[r];e.boneInverses.push(a.toArray())}return e}}class lg extends Qn{constructor(e,t,s,r=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Nm=new ln,RR=new ln,tw=[],DR=new so,hX=new ln,Hy=new Dr,jy=new Fi;class aO extends Dr{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new lg(new Float32Array(s*16),16),this.instanceColor=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let r=0;r<s;r++)this.setMatrixAt(r,hX)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new so),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,Nm),DR.copy(e.boundingBox).applyMatrix4(Nm),this.boundingBox.union(DR)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new Fi),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,Nm),jy.copy(e.boundingSphere).applyMatrix4(Nm),this.boundingSphere.union(jy)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const s=this.matrixWorld,r=this.count;if(Hy.geometry=this.geometry,Hy.material=this.material,Hy.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),jy.copy(this.boundingSphere),jy.applyMatrix4(s),e.ray.intersectsSphere(jy)!==!1))for(let i=0;i<r;i++){this.getMatrixAt(i,Nm),RR.multiplyMatrices(s,Nm),Hy.matrixWorld=RR,Hy.raycast(e,tw);for(let o=0,a=tw.length;o<a;o++){const l=tw[o];l.instanceId=i,l.object=this,t.push(l)}tw.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new lg(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function dX(n,e){return n.z-e.z}function fX(n,e){return e.z-n.z}class pX{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t){const s=this.pool,r=this.list;this.index>=s.length&&s.push({start:-1,count:-1,z:-1});const i=s[this.index];r.push(i),this.index++,i.start=e.start,i.count=e.count,i.z=t}reset(){this.list.length=0,this.index=0}}const Am="batchId",mh=new ln,PR=new ln,mX=new ln,LR=new ln,gC=new rx,nw=new so,Zd=new Fi,Xy=new re,yC=new pX,ki=new Dr,sw=[];function gX(n,e,t=0){const s=e.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==e.array.constructor){const r=n.count;for(let i=0;i<r;i++)for(let o=0;o<s;o++)e.setComponent(i+t,o,n.getComponent(i,o))}else e.array.set(n.array,t*s);e.needsUpdate=!0}class lO extends Dr{get maxGeometryCount(){return this._maxGeometryCount}constructor(e,t,s=t*2,r){super(new bn,r),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=e,this._maxVertexCount=t,this._maxIndexCount=s,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxGeometryCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),s=new Ef(t,e,e,eo,xl);this._matricesTexture=s}_initializeGeometry(e){const t=this.geometry,s=this._maxVertexCount,r=this._maxGeometryCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const a in e.attributes){const l=e.getAttribute(a),{array:u,itemSize:c,normalized:h}=l,f=new u.constructor(s*c),p=new l.constructor(f,c,h);p.setUsage(l.usage),t.setAttribute(a,p)}if(e.getIndex()!==null){const a=s>65536?new Uint32Array(i):new Uint16Array(i);t.setIndex(new Qn(a,1))}const o=r>65536?new Uint32Array(s):new Uint16Array(s);t.setAttribute(Am,new Qn(o,1)),this._geometryInitialized=!0}}_validateGeometry(e){if(e.getAttribute(Am))throw new Error(`BatchedMesh: Geometry cannot use attribute "${Am}"`);const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const s in t.attributes){if(s===Am)continue;if(!e.hasAttribute(s))throw new Error(`BatchedMesh: Added geometry missing "${s}". All geometries must have consistent attributes.`);const r=e.getAttribute(s),i=t.getAttribute(s);if(r.itemSize!==i.itemSize||r.normalized!==i.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new so);const e=this._geometryCount,t=this.boundingBox,s=this._active;t.makeEmpty();for(let r=0;r<e;r++)s[r]!==!1&&(this.getMatrixAt(r,mh),this.getBoundingBoxAt(r,nw).applyMatrix4(mh),t.union(nw))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Fi);const e=this._geometryCount,t=this.boundingSphere,s=this._active;t.makeEmpty();for(let r=0;r<e;r++)s[r]!==!1&&(this.getMatrixAt(r,mh),this.getBoundingSphereAt(r,Zd).applyMatrix4(mh),t.union(Zd))}addGeometry(e,t=-1,s=-1){if(this._initializeGeometry(e),this._validateGeometry(e),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const r={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let i=null;const o=this._reservedRanges,a=this._drawRanges,l=this._bounds;this._geometryCount!==0&&(i=o[o.length-1]),t===-1?r.vertexCount=e.getAttribute("position").count:r.vertexCount=t,i===null?r.vertexStart=0:r.vertexStart=i.vertexStart+i.vertexCount;const u=e.getIndex(),c=u!==null;if(c&&(s===-1?r.indexCount=u.count:r.indexCount=s,i===null?r.indexStart=0:r.indexStart=i.indexStart+i.indexCount),r.indexStart!==-1&&r.indexStart+r.indexCount>this._maxIndexCount||r.vertexStart+r.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const h=this._visibility,f=this._active,p=this._matricesTexture,g=this._matricesTexture.image.data;h.push(!0),f.push(!0);const S=this._geometryCount;this._geometryCount++,mX.toArray(g,S*16),p.needsUpdate=!0,o.push(r),a.push({start:c?r.indexStart:r.vertexStart,count:-1}),l.push({boxInitialized:!1,box:new so,sphereInitialized:!1,sphere:new Fi});const x=this.geometry.getAttribute(Am);for(let w=0;w<r.vertexCount;w++)x.setX(r.vertexStart+w,S);return x.needsUpdate=!0,this.setGeometryAt(S,e),S}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const s=this.geometry,r=s.getIndex()!==null,i=s.getIndex(),o=t.getIndex(),a=this._reservedRanges[e];if(r&&o.count>a.indexCount||t.attributes.position.count>a.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const l=a.vertexStart,u=a.vertexCount;for(const p in s.attributes){if(p===Am)continue;const g=t.getAttribute(p),S=s.getAttribute(p);gX(g,S,l);const x=g.itemSize;for(let w=g.count,_=u;w<_;w++){const T=l+w;for(let C=0;C<x;C++)S.setComponent(T,C,0)}S.needsUpdate=!0}if(r){const p=a.indexStart;for(let g=0;g<o.count;g++)i.setX(p+g,l+o.getX(g));for(let g=o.count,S=a.indexCount;g<S;g++)i.setX(p+g,l);i.needsUpdate=!0}const c=this._bounds[e];t.boundingBox!==null?(c.box.copy(t.boundingBox),c.boxInitialized=!0):c.boxInitialized=!1,t.boundingSphere!==null?(c.sphere.copy(t.boundingSphere),c.sphereInitialized=!0):c.sphereInitialized=!1;const h=this._drawRanges[e],f=t.getAttribute("position");return h.count=r?o.count:f.count,this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._active;return e>=t.length||t[e]===!1?this:(t[e]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(e,t){if(this._active[e]===!1)return this;const r=this._bounds[e],i=r.box,o=this.geometry;if(r.boxInitialized===!1){i.makeEmpty();const a=o.index,l=o.attributes.position,u=this._drawRanges[e];for(let c=u.start,h=u.start+u.count;c<h;c++){let f=c;a&&(f=a.getX(f)),i.expandByPoint(Xy.fromBufferAttribute(l,f))}r.boxInitialized=!0}return t.copy(i),t}getBoundingSphereAt(e,t){if(this._active[e]===!1)return this;const r=this._bounds[e],i=r.sphere,o=this.geometry;if(r.sphereInitialized===!1){i.makeEmpty(),this.getBoundingBoxAt(e,nw),nw.getCenter(i.center);const a=o.index,l=o.attributes.position,u=this._drawRanges[e];let c=0;for(let h=u.start,f=u.start+u.count;h<f;h++){let p=h;a&&(p=a.getX(p)),Xy.fromBufferAttribute(l,p),c=Math.max(c,i.center.distanceToSquared(Xy))}i.radius=Math.sqrt(c),r.sphereInitialized=!0}return t.copy(i),t}setMatrixAt(e,t){const s=this._active,r=this._matricesTexture,i=this._matricesTexture.image.data,o=this._geometryCount;return e>=o||s[e]===!1?this:(t.toArray(i,e*16),r.needsUpdate=!0,this)}getMatrixAt(e,t){const s=this._active,r=this._matricesTexture.image.data,i=this._geometryCount;return e>=i||s[e]===!1?null:t.fromArray(r,e*16)}setVisibleAt(e,t){const s=this._visibility,r=this._active,i=this._geometryCount;return e>=i||r[e]===!1||s[e]===t?this:(s[e]=t,this._visibilityChanged=!0,this)}getVisibleAt(e){const t=this._visibility,s=this._active,r=this._geometryCount;return e>=r||s[e]===!1?!1:t[e]}raycast(e,t){const s=this._visibility,r=this._active,i=this._drawRanges,o=this._geometryCount,a=this.matrixWorld,l=this.geometry;ki.material=this.material,ki.geometry.index=l.index,ki.geometry.attributes=l.attributes,ki.geometry.boundingBox===null&&(ki.geometry.boundingBox=new so),ki.geometry.boundingSphere===null&&(ki.geometry.boundingSphere=new Fi);for(let u=0;u<o;u++){if(!s[u]||!r[u])continue;const c=i[u];ki.geometry.setDrawRange(c.start,c.count),this.getMatrixAt(u,ki.matrixWorld).premultiply(a),this.getBoundingBoxAt(u,ki.geometry.boundingBox),this.getBoundingSphereAt(u,ki.geometry.boundingSphere),ki.raycast(e,sw);for(let h=0,f=sw.length;h<f;h++){const p=sw[h];p.object=this,p.batchId=u,t.push(p)}sw.length=0}ki.material=null,ki.geometry.index=null,ki.geometry.attributes={},ki.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._drawRanges=e._drawRanges.map(t=>({...t})),this._reservedRanges=e._reservedRanges.map(t=>({...t})),this._visibility=e._visibility.slice(),this._active=e._active.slice(),this._bounds=e._bounds.map(t=>({boxInitialized:t.boxInitialized,box:t.box.clone(),sphereInitialized:t.sphereInitialized,sphere:t.sphere.clone()})),this._maxGeometryCount=e._maxGeometryCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(e,t,s,r,i){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=r.getIndex(),a=o===null?1:o.array.BYTES_PER_ELEMENT,l=this._visibility,u=this._multiDrawStarts,c=this._multiDrawCounts,h=this._drawRanges,f=this.perObjectFrustumCulled;f&&(LR.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse).multiply(this.matrixWorld),gC.setFromProjectionMatrix(LR,e.isWebGPURenderer?ig:vl));let p=0;if(this.sortObjects){PR.copy(this.matrixWorld).invert(),Xy.setFromMatrixPosition(s.matrixWorld).applyMatrix4(PR);for(let x=0,w=l.length;x<w;x++)if(l[x]){this.getMatrixAt(x,mh),this.getBoundingSphereAt(x,Zd).applyMatrix4(mh);let _=!1;if(f&&(_=!gC.intersectsSphere(Zd)),!_){const T=Xy.distanceTo(Zd.center);yC.push(h[x],T)}}const g=yC.list,S=this.customSort;S===null?g.sort(i.transparent?fX:dX):S.call(this,g,s);for(let x=0,w=g.length;x<w;x++){const _=g[x];u[p]=_.start*a,c[p]=_.count,p++}yC.reset()}else for(let g=0,S=l.length;g<S;g++)if(l[g]){let x=!1;if(f&&(this.getMatrixAt(g,mh),this.getBoundingSphereAt(g,Zd).applyMatrix4(mh),x=!gC.intersectsSphere(Zd)),!x){const w=h[g];u[p]=w.start*a,c[p]=w.count,p++}}this._multiDrawCount=p,this._visibilityChanged=!1}onBeforeShadow(e,t,s,r,i,o){this.onBeforeRender(e,null,r,i,o)}}class oo extends xi{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new vt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const OR=new re,FR=new re,$R=new ln,xC=new Tg,rw=new Fi;class Dh extends zn{constructor(e=new bn,t=new oo){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let r=1,i=t.count;r<i;r++)OR.fromBufferAttribute(t,r-1),FR.fromBufferAttribute(t,r),s[r]=s[r-1],s[r]+=OR.distanceTo(FR);e.setAttribute("lineDistance",new $t(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,r=this.matrixWorld,i=e.params.Line.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),rw.copy(s.boundingSphere),rw.applyMatrix4(r),rw.radius+=i,e.ray.intersectsSphere(rw)===!1)return;$R.copy(r).invert(),xC.copy(e.ray).applyMatrix4($R);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=new re,c=new re,h=new re,f=new re,p=this.isLineSegments?2:1,g=s.index,x=s.attributes.position;if(g!==null){const w=Math.max(0,o.start),_=Math.min(g.count,o.start+o.count);for(let T=w,C=_-1;T<C;T+=p){const N=g.getX(T),M=g.getX(T+1);if(u.fromBufferAttribute(x,N),c.fromBufferAttribute(x,M),xC.distanceSqToSegment(u,c,f,h)>l)continue;f.applyMatrix4(this.matrixWorld);const $=e.ray.origin.distanceTo(f);$<e.near||$>e.far||t.push({distance:$,point:h.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}else{const w=Math.max(0,o.start),_=Math.min(x.count,o.start+o.count);for(let T=w,C=_-1;T<C;T+=p){if(u.fromBufferAttribute(x,T),c.fromBufferAttribute(x,T+1),xC.distanceSqToSegment(u,c,f,h)>l)continue;f.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(f);M<e.near||M>e.far||t.push({distance:M,point:h.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}}const zR=new re,UR=new re;class gu extends Dh{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let r=0,i=t.count;r<i;r+=2)zR.fromBufferAttribute(t,r),UR.fromBufferAttribute(t,r+1),s[r]=r===0?0:s[r-1],s[r+1]=s[r]+zR.distanceTo(UR);e.setAttribute("lineDistance",new $t(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class uO extends Dh{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class wI extends xi{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new vt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const BR=new ln,GE=new Tg,iw=new Fi,ow=new re;class cO extends zn{constructor(e=new bn,t=new wI){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,r=this.matrixWorld,i=e.params.Points.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),iw.copy(s.boundingSphere),iw.applyMatrix4(r),iw.radius+=i,e.ray.intersectsSphere(iw)===!1)return;BR.copy(r).invert(),GE.copy(e.ray).applyMatrix4(BR);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=s.index,h=s.attributes.position;if(u!==null){const f=Math.max(0,o.start),p=Math.min(u.count,o.start+o.count);for(let g=f,S=p;g<S;g++){const x=u.getX(g);ow.fromBufferAttribute(h,x),VR(ow,x,l,r,e,t,this)}}else{const f=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let g=f,S=p;g<S;g++)ow.fromBufferAttribute(h,g),VR(ow,g,l,r,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}}function VR(n,e,t,s,r,i,o){const a=GE.distanceSqToPoint(n);if(a<t){const l=new re;GE.closestPointToPoint(n,l),l.applyMatrix4(s);const u=r.ray.origin.distanceTo(l);if(u<r.near||u>r.far)return;i.push({distance:u,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class yX extends Hs{constructor(e,t,s,r,i,o,a,l,u){super(e,t,s,r,i,o,a,l,u),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:rr,this.magFilter=i!==void 0?i:rr,this.generateMipmaps=!1;const c=this;function h(){c.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class xX extends Hs{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=sr,this.minFilter=sr,this.generateMipmaps=!1,this.needsUpdate=!0}}class tb extends Hs{constructor(e,t,s,r,i,o,a,l,u,c,h,f){super(null,o,a,l,u,c,r,i,h,f),this.isCompressedTexture=!0,this.image={width:t,height:s},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class vX extends tb{constructor(e,t,s,r,i,o){super(e,t,s,i,o),this.isCompressedArrayTexture=!0,this.image.depth=r,this.wrapR=Pi}}class wX extends tb{constructor(e,t,s){super(void 0,e[0].width,e[0].height,t,s,dc),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class I0 extends Hs{constructor(e,t,s,r,i,o,a,l,u){super(e,t,s,r,i,o,a,l,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Al{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const s=this.getUtoTmapping(e);return this.getPoint(s,t)}getPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return t}getSpacedPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPointAt(s/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let s,r=this.getPoint(0),i=0;t.push(0);for(let o=1;o<=e;o++)s=this.getPoint(o/e),i+=s.distanceTo(r),t.push(i),r=s;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const s=this.getLengths();let r=0;const i=s.length;let o;t?o=t:o=e*s[i-1];let a=0,l=i-1,u;for(;a<=l;)if(r=Math.floor(a+(l-a)/2),u=s[r]-o,u<0)a=r+1;else if(u>0)l=r-1;else{l=r;break}if(r=l,s[r]===o)return r/(i-1);const c=s[r],f=s[r+1]-c,p=(o-c)/f;return(r+p)/(i-1)}getTangent(e,t){let r=e-1e-4,i=e+1e-4;r<0&&(r=0),i>1&&(i=1);const o=this.getPoint(r),a=this.getPoint(i),l=t||(o.isVector2?new Je:new re);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const s=this.getUtoTmapping(e);return this.getTangent(s,t)}computeFrenetFrames(e,t){const s=new re,r=[],i=[],o=[],a=new re,l=new ln;for(let p=0;p<=e;p++){const g=p/e;r[p]=this.getTangentAt(g,new re)}i[0]=new re,o[0]=new re;let u=Number.MAX_VALUE;const c=Math.abs(r[0].x),h=Math.abs(r[0].y),f=Math.abs(r[0].z);c<=u&&(u=c,s.set(1,0,0)),h<=u&&(u=h,s.set(0,1,0)),f<=u&&s.set(0,0,1),a.crossVectors(r[0],s).normalize(),i[0].crossVectors(r[0],a),o[0].crossVectors(r[0],i[0]);for(let p=1;p<=e;p++){if(i[p]=i[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(r[p-1],r[p]),a.length()>Number.EPSILON){a.normalize();const g=Math.acos(Ws(r[p-1].dot(r[p]),-1,1));i[p].applyMatrix4(l.makeRotationAxis(a,g))}o[p].crossVectors(r[p],i[p])}if(t===!0){let p=Math.acos(Ws(i[0].dot(i[e]),-1,1));p/=e,r[0].dot(a.crossVectors(i[0],i[e]))>0&&(p=-p);for(let g=1;g<=e;g++)i[g].applyMatrix4(l.makeRotationAxis(r[g],p*g)),o[g].crossVectors(r[g],i[g])}return{tangents:r,normals:i,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class nb extends Al{constructor(e=0,t=0,s=1,r=1,i=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=s,this.yRadius=r,this.aStartAngle=i,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const s=t||new Je,r=Math.PI*2;let i=this.aEndAngle-this.aStartAngle;const o=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(o?i=0:i=r),this.aClockwise===!0&&!o&&(i===r?i=-r:i=i-r);const a=this.aStartAngle+e*i;let l=this.aX+this.xRadius*Math.cos(a),u=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const c=Math.cos(this.aRotation),h=Math.sin(this.aRotation),f=l-this.aX,p=u-this.aY;l=f*c-p*h+this.aX,u=f*h+p*c+this.aY}return s.set(l,u)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class hO extends nb{constructor(e,t,s,r,i,o){super(e,t,s,s,r,i,o),this.isArcCurve=!0,this.type="ArcCurve"}}function SI(){let n=0,e=0,t=0,s=0;function r(i,o,a,l){n=i,e=a,t=-3*i+3*o-2*a-l,s=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,u){r(o,a,u*(a-i),u*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,u,c,h){let f=(o-i)/u-(a-i)/(u+c)+(a-o)/c,p=(a-o)/c-(l-o)/(c+h)+(l-a)/h;f*=c,p*=c,r(o,a,f,p)},calc:function(i){const o=i*i,a=o*i;return n+e*i+t*o+s*a}}}const aw=new re,vC=new SI,wC=new SI,SC=new SI;class bI extends Al{constructor(e=[],t=!1,s="centripetal",r=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=s,this.tension=r}getPoint(e,t=new re){const s=t,r=this.points,i=r.length,o=(i-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/i)+1)*i:l===0&&a===i-1&&(a=i-2,l=1);let u,c;this.closed||a>0?u=r[(a-1)%i]:(aw.subVectors(r[0],r[1]).add(r[0]),u=aw);const h=r[a%i],f=r[(a+1)%i];if(this.closed||a+2<i?c=r[(a+2)%i]:(aw.subVectors(r[i-1],r[i-2]).add(r[i-1]),c=aw),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let g=Math.pow(u.distanceToSquared(h),p),S=Math.pow(h.distanceToSquared(f),p),x=Math.pow(f.distanceToSquared(c),p);S<1e-4&&(S=1),g<1e-4&&(g=S),x<1e-4&&(x=S),vC.initNonuniformCatmullRom(u.x,h.x,f.x,c.x,g,S,x),wC.initNonuniformCatmullRom(u.y,h.y,f.y,c.y,g,S,x),SC.initNonuniformCatmullRom(u.z,h.z,f.z,c.z,g,S,x)}else this.curveType==="catmullrom"&&(vC.initCatmullRom(u.x,h.x,f.x,c.x,this.tension),wC.initCatmullRom(u.y,h.y,f.y,c.y,this.tension),SC.initCatmullRom(u.z,h.z,f.z,c.z,this.tension));return s.set(vC.calc(l),wC.calc(l),SC.calc(l)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(new re().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function WR(n,e,t,s,r){const i=(s-e)*.5,o=(r-t)*.5,a=n*n,l=n*a;return(2*t-2*s+i+o)*l+(-3*t+3*s-2*i-o)*a+i*n+t}function SX(n,e){const t=1-n;return t*t*e}function bX(n,e){return 2*(1-n)*n*e}function _X(n,e){return n*n*e}function d0(n,e,t,s){return SX(n,e)+bX(n,t)+_X(n,s)}function TX(n,e){const t=1-n;return t*t*t*e}function CX(n,e){const t=1-n;return 3*t*t*n*e}function EX(n,e){return 3*(1-n)*n*n*e}function IX(n,e){return n*n*n*e}function f0(n,e,t,s,r){return TX(n,e)+CX(n,t)+EX(n,s)+IX(n,r)}class _I extends Al{constructor(e=new Je,t=new Je,s=new Je,r=new Je){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=s,this.v3=r}getPoint(e,t=new Je){const s=t,r=this.v0,i=this.v1,o=this.v2,a=this.v3;return s.set(f0(e,r.x,i.x,o.x,a.x),f0(e,r.y,i.y,o.y,a.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class dO extends Al{constructor(e=new re,t=new re,s=new re,r=new re){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=s,this.v3=r}getPoint(e,t=new re){const s=t,r=this.v0,i=this.v1,o=this.v2,a=this.v3;return s.set(f0(e,r.x,i.x,o.x,a.x),f0(e,r.y,i.y,o.y,a.y),f0(e,r.z,i.z,o.z,a.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class TI extends Al{constructor(e=new Je,t=new Je){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Je){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Je){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class fO extends Al{constructor(e=new re,t=new re){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new re){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new re){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class CI extends Al{constructor(e=new Je,t=new Je,s=new Je){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new Je){const s=t,r=this.v0,i=this.v1,o=this.v2;return s.set(d0(e,r.x,i.x,o.x),d0(e,r.y,i.y,o.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class EI extends Al{constructor(e=new re,t=new re,s=new re){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new re){const s=t,r=this.v0,i=this.v1,o=this.v2;return s.set(d0(e,r.x,i.x,o.x),d0(e,r.y,i.y,o.y),d0(e,r.z,i.z,o.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class II extends Al{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Je){const s=t,r=this.points,i=(r.length-1)*e,o=Math.floor(i),a=i-o,l=r[o===0?o:o-1],u=r[o],c=r[o>r.length-2?r.length-1:o+1],h=r[o>r.length-3?r.length-1:o+2];return s.set(WR(a,l.x,u.x,c.x,h.x),WR(a,l.y,u.y,c.y,h.y)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(new Je().fromArray(r))}return this}}var cS=Object.freeze({__proto__:null,ArcCurve:hO,CatmullRomCurve3:bI,CubicBezierCurve:_I,CubicBezierCurve3:dO,EllipseCurve:nb,LineCurve:TI,LineCurve3:fO,QuadraticBezierCurve:CI,QuadraticBezierCurve3:EI,SplineCurve:II});class pO extends Al{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const s=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new cS[s](t,e))}return this}getPoint(e,t){const s=e*this.getLength(),r=this.getCurveLengths();let i=0;for(;i<r.length;){if(r[i]>=s){const o=r[i]-s,a=this.curves[i],l=a.getLength(),u=l===0?0:1-o/l;return a.getPointAt(u,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let s=0,r=this.curves.length;s<r;s++)t+=this.curves[s].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let s;for(let r=0,i=this.curves;r<i.length;r++){const o=i[r],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let u=0;u<l.length;u++){const c=l[u];s&&s.equals(c)||(t.push(c),s=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,s=this.curves.length;t<s;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const r=e.curves[t];this.curves.push(new cS[r.type]().fromJSON(r))}return this}}class N0 extends pO{constructor(e){super(),this.type="Path",this.currentPoint=new Je,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,s=e.length;t<s;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const s=new TI(this.currentPoint.clone(),new Je(e,t));return this.curves.push(s),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,s,r){const i=new CI(this.currentPoint.clone(),new Je(e,t),new Je(s,r));return this.curves.push(i),this.currentPoint.set(s,r),this}bezierCurveTo(e,t,s,r,i,o){const a=new _I(this.currentPoint.clone(),new Je(e,t),new Je(s,r),new Je(i,o));return this.curves.push(a),this.currentPoint.set(i,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),s=new II(t);return this.curves.push(s),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,s,r,i,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,s,r,i,o),this}absarc(e,t,s,r,i,o){return this.absellipse(e,t,s,s,r,i,o),this}ellipse(e,t,s,r,i,o,a,l){const u=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+u,t+c,s,r,i,o,a,l),this}absellipse(e,t,s,r,i,o,a,l){const u=new nb(e,t,s,r,i,o,a,l);if(this.curves.length>0){const h=u.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(u);const c=u.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class ax extends bn{constructor(e=[new Je(0,-.5),new Je(.5,0),new Je(0,.5)],t=12,s=0,r=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:s,phiLength:r},t=Math.floor(t),r=Ws(r,0,Math.PI*2);const i=[],o=[],a=[],l=[],u=[],c=1/t,h=new re,f=new Je,p=new re,g=new re,S=new re;let x=0,w=0;for(let _=0;_<=e.length-1;_++)switch(_){case 0:x=e[_+1].x-e[_].x,w=e[_+1].y-e[_].y,p.x=w*1,p.y=-x,p.z=w*0,S.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case e.length-1:l.push(S.x,S.y,S.z);break;default:x=e[_+1].x-e[_].x,w=e[_+1].y-e[_].y,p.x=w*1,p.y=-x,p.z=w*0,g.copy(p),p.x+=S.x,p.y+=S.y,p.z+=S.z,p.normalize(),l.push(p.x,p.y,p.z),S.copy(g)}for(let _=0;_<=t;_++){const T=s+_*c*r,C=Math.sin(T),N=Math.cos(T);for(let M=0;M<=e.length-1;M++){h.x=e[M].x*C,h.y=e[M].y,h.z=e[M].x*N,o.push(h.x,h.y,h.z),f.x=_/t,f.y=M/(e.length-1),a.push(f.x,f.y);const P=l[3*M+0]*C,$=l[3*M+1],R=l[3*M+0]*N;u.push(P,$,R)}}for(let _=0;_<t;_++)for(let T=0;T<e.length-1;T++){const C=T+_*e.length,N=C,M=C+e.length,P=C+e.length+1,$=C+1;i.push(N,M,$),i.push(P,$,M)}this.setIndex(i),this.setAttribute("position",new $t(o,3)),this.setAttribute("uv",new $t(a,2)),this.setAttribute("normal",new $t(u,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ax(e.points,e.segments,e.phiStart,e.phiLength)}}class sb extends ax{constructor(e=1,t=1,s=4,r=8){const i=new N0;i.absarc(0,-t/2,e,Math.PI*1.5,0),i.absarc(0,t/2,e,0,Math.PI*.5),super(i.getPoints(s),r),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:s,radialSegments:r}}static fromJSON(e){return new sb(e.radius,e.length,e.capSegments,e.radialSegments)}}class rb extends bn{constructor(e=1,t=32,s=0,r=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:s,thetaLength:r},t=Math.max(3,t);const i=[],o=[],a=[],l=[],u=new re,c=new Je;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,f=3;h<=t;h++,f+=3){const p=s+h/t*r;u.x=e*Math.cos(p),u.y=e*Math.sin(p),o.push(u.x,u.y,u.z),a.push(0,0,1),c.x=(o[f]/e+1)/2,c.y=(o[f+1]/e+1)/2,l.push(c.x,c.y)}for(let h=1;h<=t;h++)i.push(h,h+1,0);this.setIndex(i),this.setAttribute("position",new $t(o,3)),this.setAttribute("normal",new $t(a,3)),this.setAttribute("uv",new $t(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new rb(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Ig extends bn{constructor(e=1,t=1,s=1,r=32,i=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:s,radialSegments:r,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l};const u=this;r=Math.floor(r),i=Math.floor(i);const c=[],h=[],f=[],p=[];let g=0;const S=[],x=s/2;let w=0;_(),o===!1&&(e>0&&T(!0),t>0&&T(!1)),this.setIndex(c),this.setAttribute("position",new $t(h,3)),this.setAttribute("normal",new $t(f,3)),this.setAttribute("uv",new $t(p,2));function _(){const C=new re,N=new re;let M=0;const P=(t-e)/s;for(let $=0;$<=i;$++){const R=[],D=$/i,L=D*(t-e)+e;for(let G=0;G<=r;G++){const Q=G/r,W=Q*l+a,H=Math.sin(W),J=Math.cos(W);N.x=L*H,N.y=-D*s+x,N.z=L*J,h.push(N.x,N.y,N.z),C.set(H,P,J).normalize(),f.push(C.x,C.y,C.z),p.push(Q,1-D),R.push(g++)}S.push(R)}for(let $=0;$<r;$++)for(let R=0;R<i;R++){const D=S[R][$],L=S[R+1][$],G=S[R+1][$+1],Q=S[R][$+1];c.push(D,L,Q),c.push(L,G,Q),M+=6}u.addGroup(w,M,0),w+=M}function T(C){const N=g,M=new Je,P=new re;let $=0;const R=C===!0?e:t,D=C===!0?1:-1;for(let G=1;G<=r;G++)h.push(0,x*D,0),f.push(0,D,0),p.push(.5,.5),g++;const L=g;for(let G=0;G<=r;G++){const W=G/r*l+a,H=Math.cos(W),J=Math.sin(W);P.x=R*J,P.y=x*D,P.z=R*H,h.push(P.x,P.y,P.z),f.push(0,D,0),M.x=H*.5+.5,M.y=J*.5*D+.5,p.push(M.x,M.y),g++}for(let G=0;G<r;G++){const Q=N+G,W=L+G;C===!0?c.push(W,W+1,Q):c.push(W+1,W,Q),$+=3}u.addGroup(w,$,C===!0?1:2),w+=$}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ig(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ib extends Ig{constructor(e=1,t=1,s=32,r=1,i=!1,o=0,a=Math.PI*2){super(0,e,t,s,r,i,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:s,heightSegments:r,openEnded:i,thetaStart:o,thetaLength:a}}static fromJSON(e){return new ib(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Yh extends bn{constructor(e=[],t=[],s=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:s,detail:r};const i=[],o=[];a(r),u(s),c(),this.setAttribute("position",new $t(i,3)),this.setAttribute("normal",new $t(i.slice(),3)),this.setAttribute("uv",new $t(o,2)),r===0?this.computeVertexNormals():this.normalizeNormals();function a(_){const T=new re,C=new re,N=new re;for(let M=0;M<t.length;M+=3)p(t[M+0],T),p(t[M+1],C),p(t[M+2],N),l(T,C,N,_)}function l(_,T,C,N){const M=N+1,P=[];for(let $=0;$<=M;$++){P[$]=[];const R=_.clone().lerp(C,$/M),D=T.clone().lerp(C,$/M),L=M-$;for(let G=0;G<=L;G++)G===0&&$===M?P[$][G]=R:P[$][G]=R.clone().lerp(D,G/L)}for(let $=0;$<M;$++)for(let R=0;R<2*(M-$)-1;R++){const D=Math.floor(R/2);R%2===0?(f(P[$][D+1]),f(P[$+1][D]),f(P[$][D])):(f(P[$][D+1]),f(P[$+1][D+1]),f(P[$+1][D]))}}function u(_){const T=new re;for(let C=0;C<i.length;C+=3)T.x=i[C+0],T.y=i[C+1],T.z=i[C+2],T.normalize().multiplyScalar(_),i[C+0]=T.x,i[C+1]=T.y,i[C+2]=T.z}function c(){const _=new re;for(let T=0;T<i.length;T+=3){_.x=i[T+0],_.y=i[T+1],_.z=i[T+2];const C=x(_)/2/Math.PI+.5,N=w(_)/Math.PI+.5;o.push(C,1-N)}g(),h()}function h(){for(let _=0;_<o.length;_+=6){const T=o[_+0],C=o[_+2],N=o[_+4],M=Math.max(T,C,N),P=Math.min(T,C,N);M>.9&&P<.1&&(T<.2&&(o[_+0]+=1),C<.2&&(o[_+2]+=1),N<.2&&(o[_+4]+=1))}}function f(_){i.push(_.x,_.y,_.z)}function p(_,T){const C=_*3;T.x=e[C+0],T.y=e[C+1],T.z=e[C+2]}function g(){const _=new re,T=new re,C=new re,N=new re,M=new Je,P=new Je,$=new Je;for(let R=0,D=0;R<i.length;R+=9,D+=6){_.set(i[R+0],i[R+1],i[R+2]),T.set(i[R+3],i[R+4],i[R+5]),C.set(i[R+6],i[R+7],i[R+8]),M.set(o[D+0],o[D+1]),P.set(o[D+2],o[D+3]),$.set(o[D+4],o[D+5]),N.copy(_).add(T).add(C).divideScalar(3);const L=x(N);S(M,D+0,_,L),S(P,D+2,T,L),S($,D+4,C,L)}}function S(_,T,C,N){N<0&&_.x===1&&(o[T]=_.x-1),C.x===0&&C.z===0&&(o[T]=N/2/Math.PI+.5)}function x(_){return Math.atan2(_.z,-_.x)}function w(_){return Math.atan2(-_.y,Math.sqrt(_.x*_.x+_.z*_.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Yh(e.vertices,e.indices,e.radius,e.details)}}class ob extends Yh{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,r=1/s,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-s,0,-r,s,0,r,-s,0,r,s,-r,-s,0,-r,s,0,r,-s,0,r,s,0,-s,0,-r,s,0,-r,-s,0,r,s,0,r],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new ob(e.radius,e.detail)}}const lw=new re,uw=new re,bC=new re,cw=new No;class mO extends bn{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const r=Math.pow(10,4),i=Math.cos(Tf*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,u=[0,0,0],c=["a","b","c"],h=new Array(3),f={},p=[];for(let g=0;g<l;g+=3){o?(u[0]=o.getX(g),u[1]=o.getX(g+1),u[2]=o.getX(g+2)):(u[0]=g,u[1]=g+1,u[2]=g+2);const{a:S,b:x,c:w}=cw;if(S.fromBufferAttribute(a,u[0]),x.fromBufferAttribute(a,u[1]),w.fromBufferAttribute(a,u[2]),cw.getNormal(bC),h[0]=`${Math.round(S.x*r)},${Math.round(S.y*r)},${Math.round(S.z*r)}`,h[1]=`${Math.round(x.x*r)},${Math.round(x.y*r)},${Math.round(x.z*r)}`,h[2]=`${Math.round(w.x*r)},${Math.round(w.y*r)},${Math.round(w.z*r)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let _=0;_<3;_++){const T=(_+1)%3,C=h[_],N=h[T],M=cw[c[_]],P=cw[c[T]],$=`${C}_${N}`,R=`${N}_${C}`;R in f&&f[R]?(bC.dot(f[R].normal)<=i&&(p.push(M.x,M.y,M.z),p.push(P.x,P.y,P.z)),f[R]=null):$ in f||(f[$]={index0:u[_],index1:u[T],normal:bC.clone()})}}for(const g in f)if(f[g]){const{index0:S,index1:x}=f[g];lw.fromBufferAttribute(a,S),uw.fromBufferAttribute(a,x),p.push(lw.x,lw.y,lw.z),p.push(uw.x,uw.y,uw.z)}this.setAttribute("position",new $t(p,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class lc extends N0{constructor(e){super(e),this.uuid=oa(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let s=0,r=this.holes.length;s<r;s++)t[s]=this.holes[s].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,s=this.holes.length;t<s;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const r=e.holes[t];this.holes.push(new N0().fromJSON(r))}return this}}const NX={triangulate:function(n,e,t=2){const s=e&&e.length,r=s?e[0]*t:n.length;let i=gO(n,0,r,t,!0);const o=[];if(!i||i.next===i.prev)return o;let a,l,u,c,h,f,p;if(s&&(i=DX(n,e,i,t)),n.length>80*t){a=u=n[0],l=c=n[1];for(let g=t;g<r;g+=t)h=n[g],f=n[g+1],h<a&&(a=h),f<l&&(l=f),h>u&&(u=h),f>c&&(c=f);p=Math.max(u-a,c-l),p=p!==0?32767/p:0}return A0(i,o,t,a,l,p,0),o}};function gO(n,e,t,s,r){let i,o;if(r===GX(n,e,t,s)>0)for(i=e;i<t;i+=s)o=GR(i,n[i],n[i+1],o);else for(i=t-s;i>=e;i-=s)o=GR(i,n[i],n[i+1],o);return o&&ab(o,o.next)&&(k0(o),o=o.next),o}function Rf(n,e){if(!n)return n;e||(e=n);let t=n,s;do if(s=!1,!t.steiner&&(ab(t,t.next)||Fs(t.prev,t,t.next)===0)){if(k0(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function A0(n,e,t,s,r,i,o){if(!n)return;!o&&i&&$X(n,s,r,i);let a=n,l,u;for(;n.prev!==n.next;){if(l=n.prev,u=n.next,i?MX(n,s,r,i):AX(n)){e.push(l.i/t|0),e.push(n.i/t|0),e.push(u.i/t|0),k0(n),n=u.next,a=u.next;continue}if(n=u,n===a){o?o===1?(n=kX(Rf(n),e,t),A0(n,e,t,s,r,i,2)):o===2&&RX(n,e,t,s,r,i):A0(Rf(n),e,t,s,r,i,1);break}}}function AX(n){const e=n.prev,t=n,s=n.next;if(Fs(e,t,s)>=0)return!1;const r=e.x,i=t.x,o=s.x,a=e.y,l=t.y,u=s.y,c=r<i?r<o?r:o:i<o?i:o,h=a<l?a<u?a:u:l<u?l:u,f=r>i?r>o?r:o:i>o?i:o,p=a>l?a>u?a:u:l>u?l:u;let g=s.next;for(;g!==e;){if(g.x>=c&&g.x<=f&&g.y>=h&&g.y<=p&&Xm(r,a,i,l,o,u,g.x,g.y)&&Fs(g.prev,g,g.next)>=0)return!1;g=g.next}return!0}function MX(n,e,t,s){const r=n.prev,i=n,o=n.next;if(Fs(r,i,o)>=0)return!1;const a=r.x,l=i.x,u=o.x,c=r.y,h=i.y,f=o.y,p=a<l?a<u?a:u:l<u?l:u,g=c<h?c<f?c:f:h<f?h:f,S=a>l?a>u?a:u:l>u?l:u,x=c>h?c>f?c:f:h>f?h:f,w=HE(p,g,e,t,s),_=HE(S,x,e,t,s);let T=n.prevZ,C=n.nextZ;for(;T&&T.z>=w&&C&&C.z<=_;){if(T.x>=p&&T.x<=S&&T.y>=g&&T.y<=x&&T!==r&&T!==o&&Xm(a,c,l,h,u,f,T.x,T.y)&&Fs(T.prev,T,T.next)>=0||(T=T.prevZ,C.x>=p&&C.x<=S&&C.y>=g&&C.y<=x&&C!==r&&C!==o&&Xm(a,c,l,h,u,f,C.x,C.y)&&Fs(C.prev,C,C.next)>=0))return!1;C=C.nextZ}for(;T&&T.z>=w;){if(T.x>=p&&T.x<=S&&T.y>=g&&T.y<=x&&T!==r&&T!==o&&Xm(a,c,l,h,u,f,T.x,T.y)&&Fs(T.prev,T,T.next)>=0)return!1;T=T.prevZ}for(;C&&C.z<=_;){if(C.x>=p&&C.x<=S&&C.y>=g&&C.y<=x&&C!==r&&C!==o&&Xm(a,c,l,h,u,f,C.x,C.y)&&Fs(C.prev,C,C.next)>=0)return!1;C=C.nextZ}return!0}function kX(n,e,t){let s=n;do{const r=s.prev,i=s.next.next;!ab(r,i)&&yO(r,s,s.next,i)&&M0(r,i)&&M0(i,r)&&(e.push(r.i/t|0),e.push(s.i/t|0),e.push(i.i/t|0),k0(s),k0(s.next),s=n=i),s=s.next}while(s!==n);return Rf(s)}function RX(n,e,t,s,r,i){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&BX(o,a)){let l=xO(o,a);o=Rf(o,o.next),l=Rf(l,l.next),A0(o,e,t,s,r,i,0),A0(l,e,t,s,r,i,0);return}a=a.next}o=o.next}while(o!==n)}function DX(n,e,t,s){const r=[];let i,o,a,l,u;for(i=0,o=e.length;i<o;i++)a=e[i]*s,l=i<o-1?e[i+1]*s:n.length,u=gO(n,a,l,s,!1),u===u.next&&(u.steiner=!0),r.push(UX(u));for(r.sort(PX),i=0;i<r.length;i++)t=LX(r[i],t);return t}function PX(n,e){return n.x-e.x}function LX(n,e){const t=OX(n,e);if(!t)return e;const s=xO(t,n);return Rf(s,s.next),Rf(t,t.next)}function OX(n,e){let t=e,s=-1/0,r;const i=n.x,o=n.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const f=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=i&&f>s&&(s=f,r=t.x<t.next.x?t:t.next,f===i))return r}t=t.next}while(t!==e);if(!r)return null;const a=r,l=r.x,u=r.y;let c=1/0,h;t=r;do i>=t.x&&t.x>=l&&i!==t.x&&Xm(o<u?i:s,o,l,u,o<u?s:i,o,t.x,t.y)&&(h=Math.abs(o-t.y)/(i-t.x),M0(t,n)&&(h<c||h===c&&(t.x>r.x||t.x===r.x&&FX(r,t)))&&(r=t,c=h)),t=t.next;while(t!==a);return r}function FX(n,e){return Fs(n.prev,n,e.prev)<0&&Fs(e.next,n,n.next)<0}function $X(n,e,t,s){let r=n;do r.z===0&&(r.z=HE(r.x,r.y,e,t,s)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,zX(r)}function zX(n){let e,t,s,r,i,o,a,l,u=1;do{for(t=n,n=null,i=null,o=0;t;){for(o++,s=t,a=0,e=0;e<u&&(a++,s=s.nextZ,!!s);e++);for(l=u;a>0||l>0&&s;)a!==0&&(l===0||!s||t.z<=s.z)?(r=t,t=t.nextZ,a--):(r=s,s=s.nextZ,l--),i?i.nextZ=r:n=r,r.prevZ=i,i=r;t=s}i.nextZ=null,u*=2}while(o>1);return n}function HE(n,e,t,s,r){return n=(n-t)*r|0,e=(e-s)*r|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function UX(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Xm(n,e,t,s,r,i,o,a){return(r-o)*(e-a)>=(n-o)*(i-a)&&(n-o)*(s-a)>=(t-o)*(e-a)&&(t-o)*(i-a)>=(r-o)*(s-a)}function BX(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!VX(n,e)&&(M0(n,e)&&M0(e,n)&&WX(n,e)&&(Fs(n.prev,n,e.prev)||Fs(n,e.prev,e))||ab(n,e)&&Fs(n.prev,n,n.next)>0&&Fs(e.prev,e,e.next)>0)}function Fs(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function ab(n,e){return n.x===e.x&&n.y===e.y}function yO(n,e,t,s){const r=dw(Fs(n,e,t)),i=dw(Fs(n,e,s)),o=dw(Fs(t,s,n)),a=dw(Fs(t,s,e));return!!(r!==i&&o!==a||r===0&&hw(n,t,e)||i===0&&hw(n,s,e)||o===0&&hw(t,n,s)||a===0&&hw(t,e,s))}function hw(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function dw(n){return n>0?1:n<0?-1:0}function VX(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&yO(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function M0(n,e){return Fs(n.prev,n,n.next)<0?Fs(n,e,n.next)>=0&&Fs(n,n.prev,e)>=0:Fs(n,e,n.prev)<0||Fs(n,n.next,e)<0}function WX(n,e){let t=n,s=!1;const r=(n.x+e.x)/2,i=(n.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&r<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==n);return s}function xO(n,e){const t=new jE(n.i,n.x,n.y),s=new jE(e.i,e.x,e.y),r=n.next,i=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,s.next=t,t.prev=s,i.next=s,s.prev=i,s}function GR(n,e,t,s){const r=new jE(n,e,t);return s?(r.next=s.next,r.prev=s,s.next.prev=r,s.next=r):(r.prev=r,r.next=r),r}function k0(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function jE(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function GX(n,e,t,s){let r=0;for(let i=e,o=t-s;i<t;i+=s)r+=(n[o]-n[i])*(n[i+1]+n[o+1]),o=i;return r}class au{static area(e){const t=e.length;let s=0;for(let r=t-1,i=0;i<t;r=i++)s+=e[r].x*e[i].y-e[i].x*e[r].y;return s*.5}static isClockWise(e){return au.area(e)<0}static triangulateShape(e,t){const s=[],r=[],i=[];HR(e),jR(s,e);let o=e.length;t.forEach(HR);for(let l=0;l<t.length;l++)r.push(o),o+=t[l].length,jR(s,t[l]);const a=NX.triangulate(s,r);for(let l=0;l<a.length;l+=3)i.push(a.slice(l,l+3));return i}}function HR(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function jR(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class Ng extends bn{constructor(e=new lc([new Je(.5,.5),new Je(-.5,.5),new Je(-.5,-.5),new Je(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const s=this,r=[],i=[];for(let a=0,l=e.length;a<l;a++){const u=e[a];o(u)}this.setAttribute("position",new $t(r,3)),this.setAttribute("uv",new $t(i,2)),this.computeVertexNormals();function o(a){const l=[],u=t.curveSegments!==void 0?t.curveSegments:12,c=t.steps!==void 0?t.steps:1,h=t.depth!==void 0?t.depth:1;let f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,g=t.bevelSize!==void 0?t.bevelSize:p-.1,S=t.bevelOffset!==void 0?t.bevelOffset:0,x=t.bevelSegments!==void 0?t.bevelSegments:3;const w=t.extrudePath,_=t.UVGenerator!==void 0?t.UVGenerator:HX;let T,C=!1,N,M,P,$;w&&(T=w.getSpacedPoints(c),C=!0,f=!1,N=w.computeFrenetFrames(c,!1),M=new re,P=new re,$=new re),f||(x=0,p=0,g=0,S=0);const R=a.extractPoints(u);let D=R.shape;const L=R.holes;if(!au.isClockWise(D)){D=D.reverse();for(let ae=0,Be=L.length;ae<Be;ae++){const De=L[ae];au.isClockWise(De)&&(L[ae]=De.reverse())}}const Q=au.triangulateShape(D,L),W=D;for(let ae=0,Be=L.length;ae<Be;ae++){const De=L[ae];D=D.concat(De)}function H(ae,Be,De){return Be||console.error("THREE.ExtrudeGeometry: vec does not exist"),ae.clone().addScaledVector(Be,De)}const J=D.length,ie=Q.length;function V(ae,Be,De){let He,Re,at;const Qe=ae.x-Be.x,ee=ae.y-Be.y,X=De.x-ae.x,Se=De.y-ae.y,We=Qe*Qe+ee*ee,Xe=Qe*Se-ee*X;if(Math.abs(Xe)>Number.EPSILON){const je=Math.sqrt(We),xt=Math.sqrt(X*X+Se*Se),it=Be.x-ee/je,dt=Be.y+Qe/je,It=De.x-Se/xt,Yt=De.y+X/xt,Ke=((It-it)*Se-(Yt-dt)*X)/(Qe*Se-ee*X);He=it+Qe*Ke-ae.x,Re=dt+ee*Ke-ae.y;const hn=He*He+Re*Re;if(hn<=2)return new Je(He,Re);at=Math.sqrt(hn/2)}else{let je=!1;Qe>Number.EPSILON?X>Number.EPSILON&&(je=!0):Qe<-Number.EPSILON?X<-Number.EPSILON&&(je=!0):Math.sign(ee)===Math.sign(Se)&&(je=!0),je?(He=-ee,Re=Qe,at=Math.sqrt(We)):(He=Qe,Re=ee,at=Math.sqrt(We/2))}return new Je(He/at,Re/at)}const Y=[];for(let ae=0,Be=W.length,De=Be-1,He=ae+1;ae<Be;ae++,De++,He++)De===Be&&(De=0),He===Be&&(He=0),Y[ae]=V(W[ae],W[De],W[He]);const B=[];let K,se=Y.concat();for(let ae=0,Be=L.length;ae<Be;ae++){const De=L[ae];K=[];for(let He=0,Re=De.length,at=Re-1,Qe=He+1;He<Re;He++,at++,Qe++)at===Re&&(at=0),Qe===Re&&(Qe=0),K[He]=V(De[He],De[at],De[Qe]);B.push(K),se=se.concat(K)}for(let ae=0;ae<x;ae++){const Be=ae/x,De=p*Math.cos(Be*Math.PI/2),He=g*Math.sin(Be*Math.PI/2)+S;for(let Re=0,at=W.length;Re<at;Re++){const Qe=H(W[Re],Y[Re],He);Ie(Qe.x,Qe.y,-De)}for(let Re=0,at=L.length;Re<at;Re++){const Qe=L[Re];K=B[Re];for(let ee=0,X=Qe.length;ee<X;ee++){const Se=H(Qe[ee],K[ee],He);Ie(Se.x,Se.y,-De)}}}const te=g+S;for(let ae=0;ae<J;ae++){const Be=f?H(D[ae],se[ae],te):D[ae];C?(P.copy(N.normals[0]).multiplyScalar(Be.x),M.copy(N.binormals[0]).multiplyScalar(Be.y),$.copy(T[0]).add(P).add(M),Ie($.x,$.y,$.z)):Ie(Be.x,Be.y,0)}for(let ae=1;ae<=c;ae++)for(let Be=0;Be<J;Be++){const De=f?H(D[Be],se[Be],te):D[Be];C?(P.copy(N.normals[ae]).multiplyScalar(De.x),M.copy(N.binormals[ae]).multiplyScalar(De.y),$.copy(T[ae]).add(P).add(M),Ie($.x,$.y,$.z)):Ie(De.x,De.y,h/c*ae)}for(let ae=x-1;ae>=0;ae--){const Be=ae/x,De=p*Math.cos(Be*Math.PI/2),He=g*Math.sin(Be*Math.PI/2)+S;for(let Re=0,at=W.length;Re<at;Re++){const Qe=H(W[Re],Y[Re],He);Ie(Qe.x,Qe.y,h+De)}for(let Re=0,at=L.length;Re<at;Re++){const Qe=L[Re];K=B[Re];for(let ee=0,X=Qe.length;ee<X;ee++){const Se=H(Qe[ee],K[ee],He);C?Ie(Se.x,Se.y+T[c-1].y,T[c-1].x+De):Ie(Se.x,Se.y,h+De)}}}ue(),fe();function ue(){const ae=r.length/3;if(f){let Be=0,De=J*Be;for(let He=0;He<ie;He++){const Re=Q[He];Ve(Re[2]+De,Re[1]+De,Re[0]+De)}Be=c+x*2,De=J*Be;for(let He=0;He<ie;He++){const Re=Q[He];Ve(Re[0]+De,Re[1]+De,Re[2]+De)}}else{for(let Be=0;Be<ie;Be++){const De=Q[Be];Ve(De[2],De[1],De[0])}for(let Be=0;Be<ie;Be++){const De=Q[Be];Ve(De[0]+J*c,De[1]+J*c,De[2]+J*c)}}s.addGroup(ae,r.length/3-ae,0)}function fe(){const ae=r.length/3;let Be=0;_e(W,Be),Be+=W.length;for(let De=0,He=L.length;De<He;De++){const Re=L[De];_e(Re,Be),Be+=Re.length}s.addGroup(ae,r.length/3-ae,1)}function _e(ae,Be){let De=ae.length;for(;--De>=0;){const He=De;let Re=De-1;Re<0&&(Re=ae.length-1);for(let at=0,Qe=c+x*2;at<Qe;at++){const ee=J*at,X=J*(at+1),Se=Be+He+ee,We=Be+Re+ee,Xe=Be+Re+X,je=Be+He+X;qe(Se,We,Xe,je)}}}function Ie(ae,Be,De){l.push(ae),l.push(Be),l.push(De)}function Ve(ae,Be,De){Ye(ae),Ye(Be),Ye(De);const He=r.length/3,Re=_.generateTopUV(s,r,He-3,He-2,He-1);et(Re[0]),et(Re[1]),et(Re[2])}function qe(ae,Be,De,He){Ye(ae),Ye(Be),Ye(He),Ye(Be),Ye(De),Ye(He);const Re=r.length/3,at=_.generateSideWallUV(s,r,Re-6,Re-3,Re-2,Re-1);et(at[0]),et(at[1]),et(at[3]),et(at[1]),et(at[2]),et(at[3])}function Ye(ae){r.push(l[ae*3+0]),r.push(l[ae*3+1]),r.push(l[ae*3+2])}function et(ae){i.push(ae.x),i.push(ae.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,s=this.parameters.options;return jX(t,s,e)}static fromJSON(e,t){const s=[];for(let i=0,o=e.shapes.length;i<o;i++){const a=t[e.shapes[i]];s.push(a)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new cS[r.type]().fromJSON(r)),new Ng(s,e.options)}}const HX={generateTopUV:function(n,e,t,s,r){const i=e[t*3],o=e[t*3+1],a=e[s*3],l=e[s*3+1],u=e[r*3],c=e[r*3+1];return[new Je(i,o),new Je(a,l),new Je(u,c)]},generateSideWallUV:function(n,e,t,s,r,i){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],u=e[s*3],c=e[s*3+1],h=e[s*3+2],f=e[r*3],p=e[r*3+1],g=e[r*3+2],S=e[i*3],x=e[i*3+1],w=e[i*3+2];return Math.abs(a-c)<Math.abs(o-u)?[new Je(o,1-l),new Je(u,1-h),new Je(f,1-g),new Je(S,1-w)]:[new Je(a,1-l),new Je(c,1-h),new Je(p,1-g),new Je(x,1-w)]}};function jX(n,e,t){if(t.shapes=[],Array.isArray(n))for(let s=0,r=n.length;s<r;s++){const i=n[s];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class lb extends Yh{constructor(e=1,t=0){const s=(1+Math.sqrt(5))/2,r=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(r,i,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new lb(e.radius,e.detail)}}class lx extends Yh{constructor(e=1,t=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],r=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,r,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new lx(e.radius,e.detail)}}class ub extends bn{constructor(e=.5,t=1,s=32,r=1,i=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:s,phiSegments:r,thetaStart:i,thetaLength:o},s=Math.max(3,s),r=Math.max(1,r);const a=[],l=[],u=[],c=[];let h=e;const f=(t-e)/r,p=new re,g=new Je;for(let S=0;S<=r;S++){for(let x=0;x<=s;x++){const w=i+x/s*o;p.x=h*Math.cos(w),p.y=h*Math.sin(w),l.push(p.x,p.y,p.z),u.push(0,0,1),g.x=(p.x/t+1)/2,g.y=(p.y/t+1)/2,c.push(g.x,g.y)}h+=f}for(let S=0;S<r;S++){const x=S*(s+1);for(let w=0;w<s;w++){const _=w+x,T=_,C=_+s+1,N=_+s+2,M=_+1;a.push(T,C,M),a.push(C,N,M)}}this.setIndex(a),this.setAttribute("position",new $t(l,3)),this.setAttribute("normal",new $t(u,3)),this.setAttribute("uv",new $t(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ub(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class cb extends bn{constructor(e=new lc([new Je(0,.5),new Je(-.5,-.5),new Je(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const s=[],r=[],i=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)u(e);else for(let c=0;c<e.length;c++)u(e[c]),this.addGroup(a,l,c),a+=l,l=0;this.setIndex(s),this.setAttribute("position",new $t(r,3)),this.setAttribute("normal",new $t(i,3)),this.setAttribute("uv",new $t(o,2));function u(c){const h=r.length/3,f=c.extractPoints(t);let p=f.shape;const g=f.holes;au.isClockWise(p)===!1&&(p=p.reverse());for(let x=0,w=g.length;x<w;x++){const _=g[x];au.isClockWise(_)===!0&&(g[x]=_.reverse())}const S=au.triangulateShape(p,g);for(let x=0,w=g.length;x<w;x++){const _=g[x];p=p.concat(_)}for(let x=0,w=p.length;x<w;x++){const _=p[x];r.push(_.x,_.y,0),i.push(0,0,1),o.push(_.x,_.y)}for(let x=0,w=S.length;x<w;x++){const _=S[x],T=_[0]+h,C=_[1]+h,N=_[2]+h;s.push(T,C,N),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return XX(t,e)}static fromJSON(e,t){const s=[];for(let r=0,i=e.shapes.length;r<i;r++){const o=t[e.shapes[r]];s.push(o)}return new cb(s,e.curveSegments)}}function XX(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,s=n.length;t<s;t++){const r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}class Ag extends bn{constructor(e=1,t=32,s=16,r=0,i=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:s,phiStart:r,phiLength:i,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),s=Math.max(2,Math.floor(s));const l=Math.min(o+a,Math.PI);let u=0;const c=[],h=new re,f=new re,p=[],g=[],S=[],x=[];for(let w=0;w<=s;w++){const _=[],T=w/s;let C=0;w===0&&o===0?C=.5/t:w===s&&l===Math.PI&&(C=-.5/t);for(let N=0;N<=t;N++){const M=N/t;h.x=-e*Math.cos(r+M*i)*Math.sin(o+T*a),h.y=e*Math.cos(o+T*a),h.z=e*Math.sin(r+M*i)*Math.sin(o+T*a),g.push(h.x,h.y,h.z),f.copy(h).normalize(),S.push(f.x,f.y,f.z),x.push(M+C,1-T),_.push(u++)}c.push(_)}for(let w=0;w<s;w++)for(let _=0;_<t;_++){const T=c[w][_+1],C=c[w][_],N=c[w+1][_],M=c[w+1][_+1];(w!==0||o>0)&&p.push(T,C,M),(w!==s-1||l<Math.PI)&&p.push(C,N,M)}this.setIndex(p),this.setAttribute("position",new $t(g,3)),this.setAttribute("normal",new $t(S,3)),this.setAttribute("uv",new $t(x,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ag(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class hb extends Yh{constructor(e=1,t=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],r=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,r,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new hb(e.radius,e.detail)}}class db extends bn{constructor(e=1,t=.4,s=12,r=48,i=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:s,tubularSegments:r,arc:i},s=Math.floor(s),r=Math.floor(r);const o=[],a=[],l=[],u=[],c=new re,h=new re,f=new re;for(let p=0;p<=s;p++)for(let g=0;g<=r;g++){const S=g/r*i,x=p/s*Math.PI*2;h.x=(e+t*Math.cos(x))*Math.cos(S),h.y=(e+t*Math.cos(x))*Math.sin(S),h.z=t*Math.sin(x),a.push(h.x,h.y,h.z),c.x=e*Math.cos(S),c.y=e*Math.sin(S),f.subVectors(h,c).normalize(),l.push(f.x,f.y,f.z),u.push(g/r),u.push(p/s)}for(let p=1;p<=s;p++)for(let g=1;g<=r;g++){const S=(r+1)*p+g-1,x=(r+1)*(p-1)+g-1,w=(r+1)*(p-1)+g,_=(r+1)*p+g;o.push(S,x,_),o.push(x,w,_)}this.setIndex(o),this.setAttribute("position",new $t(a,3)),this.setAttribute("normal",new $t(l,3)),this.setAttribute("uv",new $t(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new db(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class fb extends bn{constructor(e=1,t=.4,s=64,r=8,i=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:s,radialSegments:r,p:i,q:o},s=Math.floor(s),r=Math.floor(r);const a=[],l=[],u=[],c=[],h=new re,f=new re,p=new re,g=new re,S=new re,x=new re,w=new re;for(let T=0;T<=s;++T){const C=T/s*i*Math.PI*2;_(C,i,o,e,p),_(C+.01,i,o,e,g),x.subVectors(g,p),w.addVectors(g,p),S.crossVectors(x,w),w.crossVectors(S,x),S.normalize(),w.normalize();for(let N=0;N<=r;++N){const M=N/r*Math.PI*2,P=-t*Math.cos(M),$=t*Math.sin(M);h.x=p.x+(P*w.x+$*S.x),h.y=p.y+(P*w.y+$*S.y),h.z=p.z+(P*w.z+$*S.z),l.push(h.x,h.y,h.z),f.subVectors(h,p).normalize(),u.push(f.x,f.y,f.z),c.push(T/s),c.push(N/r)}}for(let T=1;T<=s;T++)for(let C=1;C<=r;C++){const N=(r+1)*(T-1)+(C-1),M=(r+1)*T+(C-1),P=(r+1)*T+C,$=(r+1)*(T-1)+C;a.push(N,M,$),a.push(M,P,$)}this.setIndex(a),this.setAttribute("position",new $t(l,3)),this.setAttribute("normal",new $t(u,3)),this.setAttribute("uv",new $t(c,2));function _(T,C,N,M,P){const $=Math.cos(T),R=Math.sin(T),D=N/C*T,L=Math.cos(D);P.x=M*(2+L)*.5*$,P.y=M*(2+L)*R*.5,P.z=M*Math.sin(D)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new fb(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class ux extends bn{constructor(e=new EI(new re(-1,-1,0),new re(-1,1,0),new re(1,1,0)),t=64,s=1,r=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:s,radialSegments:r,closed:i};const o=e.computeFrenetFrames(t,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new re,l=new re,u=new Je;let c=new re;const h=[],f=[],p=[],g=[];S(),this.setIndex(g),this.setAttribute("position",new $t(h,3)),this.setAttribute("normal",new $t(f,3)),this.setAttribute("uv",new $t(p,2));function S(){for(let T=0;T<t;T++)x(T);x(i===!1?t:0),_(),w()}function x(T){c=e.getPointAt(T/t,c);const C=o.normals[T],N=o.binormals[T];for(let M=0;M<=r;M++){const P=M/r*Math.PI*2,$=Math.sin(P),R=-Math.cos(P);l.x=R*C.x+$*N.x,l.y=R*C.y+$*N.y,l.z=R*C.z+$*N.z,l.normalize(),f.push(l.x,l.y,l.z),a.x=c.x+s*l.x,a.y=c.y+s*l.y,a.z=c.z+s*l.z,h.push(a.x,a.y,a.z)}}function w(){for(let T=1;T<=t;T++)for(let C=1;C<=r;C++){const N=(r+1)*(T-1)+(C-1),M=(r+1)*T+(C-1),P=(r+1)*T+C,$=(r+1)*(T-1)+C;g.push(N,M,$),g.push(M,P,$)}}function _(){for(let T=0;T<=t;T++)for(let C=0;C<=r;C++)u.x=T/t,u.y=C/r,p.push(u.x,u.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new ux(new cS[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class vO extends bn{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],s=new Set,r=new re,i=new re;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let u=0,c=l.length;u<c;++u){const h=l[u],f=h.start,p=h.count;for(let g=f,S=f+p;g<S;g+=3)for(let x=0;x<3;x++){const w=a.getX(g+x),_=a.getX(g+(x+1)%3);r.fromBufferAttribute(o,w),i.fromBufferAttribute(o,_),XR(r,i,s)===!0&&(t.push(r.x,r.y,r.z),t.push(i.x,i.y,i.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let u=0;u<3;u++){const c=3*a+u,h=3*a+(u+1)%3;r.fromBufferAttribute(o,c),i.fromBufferAttribute(o,h),XR(r,i,s)===!0&&(t.push(r.x,r.y,r.z),t.push(i.x,i.y,i.z))}}this.setAttribute("position",new $t(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function XR(n,e,t){const s=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(s)===!0||t.has(r)===!0?!1:(t.add(s),t.add(r),!0)}var qR=Object.freeze({__proto__:null,BoxGeometry:Kh,CapsuleGeometry:sb,CircleGeometry:rb,ConeGeometry:ib,CylinderGeometry:Ig,DodecahedronGeometry:ob,EdgesGeometry:mO,ExtrudeGeometry:Ng,IcosahedronGeometry:lb,LatheGeometry:ax,OctahedronGeometry:lx,PlaneGeometry:ix,PolyhedronGeometry:Yh,RingGeometry:ub,ShapeGeometry:cb,SphereGeometry:Ag,TetrahedronGeometry:hb,TorusGeometry:db,TorusKnotGeometry:fb,TubeGeometry:ux,WireframeGeometry:vO});class wO extends xi{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new vt(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class SO extends Tl{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class pb extends xi{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new vt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new vt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Xh,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class bO extends pb{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Je(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ws(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new vt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new vt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new vt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class _O extends xi{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new vt(16777215),this.specular=new vt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new vt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Xh,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ex,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class TO extends xi{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new vt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new vt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Xh,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class CO extends xi{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Xh,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class EO extends xi{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new vt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new vt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Xh,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ex,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class IO extends xi{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new vt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Xh,this.normalScale=new Je(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class NO extends oo{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function xf(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function AO(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function MO(n){function e(r,i){return n[r]-n[i]}const t=n.length,s=new Array(t);for(let r=0;r!==t;++r)s[r]=r;return s.sort(e),s}function XE(n,e,t){const s=n.length,r=new n.constructor(s);for(let i=0,o=0;o!==s;++i){const a=t[i]*e;for(let l=0;l!==e;++l)r[o++]=n[a+l]}return r}function NI(n,e,t,s){let r=1,i=n[0];for(;i!==void 0&&i[s]===void 0;)i=n[r++];if(i===void 0)return;let o=i[s];if(o!==void 0)if(Array.isArray(o))do o=i[s],o!==void 0&&(e.push(i.time),t.push.apply(t,o)),i=n[r++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[s],o!==void 0&&(e.push(i.time),o.toArray(t,t.length)),i=n[r++];while(i!==void 0);else do o=i[s],o!==void 0&&(e.push(i.time),t.push(o)),i=n[r++];while(i!==void 0)}function qX(n,e,t,s,r=30){const i=n.clone();i.name=e;const o=[];for(let l=0;l<i.tracks.length;++l){const u=i.tracks[l],c=u.getValueSize(),h=[],f=[];for(let p=0;p<u.times.length;++p){const g=u.times[p]*r;if(!(g<t||g>=s)){h.push(u.times[p]);for(let S=0;S<c;++S)f.push(u.values[p*c+S])}}h.length!==0&&(u.times=xf(h,u.times.constructor),u.values=xf(f,u.values.constructor),o.push(u))}i.tracks=o;let a=1/0;for(let l=0;l<i.tracks.length;++l)a>i.tracks[l].times[0]&&(a=i.tracks[l].times[0]);for(let l=0;l<i.tracks.length;++l)i.tracks[l].shift(-1*a);return i.resetDuration(),i}function KX(n,e=0,t=n,s=30){s<=0&&(s=30);const r=t.tracks.length,i=e/s;for(let o=0;o<r;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const u=n.tracks.find(function(w){return w.name===a.name&&w.ValueTypeName===l});if(u===void 0)continue;let c=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);let f=0;const p=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=p/3);const g=a.times.length-1;let S;if(i<=a.times[0]){const w=c,_=h-c;S=a.values.slice(w,_)}else if(i>=a.times[g]){const w=g*h+c,_=w+h-c;S=a.values.slice(w,_)}else{const w=a.createInterpolant(),_=c,T=h-c;w.evaluate(i),S=w.resultBuffer.slice(_,T)}l==="quaternion"&&new Do().fromArray(S).normalize().conjugate().toArray(S);const x=u.times.length;for(let w=0;w<x;++w){const _=w*p+f;if(l==="quaternion")Do.multiplyQuaternionsFlat(u.values,_,S,0,u.values,_);else{const T=p-f*2;for(let C=0;C<T;++C)u.values[_+C]-=S[C]}}}return n.blendMode=iI,n}const YX={convertArray:xf,isTypedArray:AO,getKeyframeOrder:MO,sortedArray:XE,flattenJSON:NI,subclip:qX,makeClipAdditive:KX};class cx{constructor(e,t,s,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,r=t[s],i=t[s-1];e:{t:{let o;n:{s:if(!(e<r)){for(let a=s+2;;){if(r===void 0){if(e<i)break s;return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===a)break;if(i=r,r=t[++s],e<r)break t}o=t.length;break n}if(!(e>=i)){const a=t[1];e<a&&(s=2,i=a);for(let l=s-2;;){if(i===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(r=i,i=t[--s-1],e>=i)break t}o=s,s=0;break n}break e}for(;s<o;){const a=s+o>>>1;e<t[a]?o=a:s=a+1}if(r=t[s],i=t[s-1],i===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===void 0)return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,i,r)}return this.interpolate_(s,i,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,r=this.valueSize,i=e*r;for(let o=0;o!==r;++o)t[o]=s[i+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class kO extends cx{constructor(e,t,s,r){super(e,t,s,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:mf,endingEnd:mf}}intervalChanged_(e,t,s){const r=this.parameterPositions;let i=e-2,o=e+1,a=r[i],l=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case gf:i=e,a=2*t-s;break;case S0:i=r.length-2,a=t+r[i]-r[i+1];break;default:i=e,a=s}if(l===void 0)switch(this.getSettings_().endingEnd){case gf:o=e,l=2*s-t;break;case S0:o=1,l=s+r[1]-r[0];break;default:o=e-1,l=t}const u=(s-t)*.5,c=this.valueSize;this._weightPrev=u/(t-a),this._weightNext=u/(l-s),this._offsetPrev=i*c,this._offsetNext=o*c}interpolate_(e,t,s,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=this._offsetPrev,h=this._offsetNext,f=this._weightPrev,p=this._weightNext,g=(s-t)/(r-t),S=g*g,x=S*g,w=-f*x+2*f*S-f*g,_=(1+f)*x+(-1.5-2*f)*S+(-.5+f)*g+1,T=(-1-p)*x+(1.5+p)*S+.5*g,C=p*x-p*S;for(let N=0;N!==a;++N)i[N]=w*o[c+N]+_*o[u+N]+T*o[l+N]+C*o[h+N];return i}}class AI extends cx{constructor(e,t,s,r){super(e,t,s,r)}interpolate_(e,t,s,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=(s-t)/(r-t),h=1-c;for(let f=0;f!==a;++f)i[f]=o[u+f]*h+o[l+f]*c;return i}}class RO extends cx{constructor(e,t,s,r){super(e,t,s,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class Ml{constructor(e,t,s,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=xf(t,this.TimeBufferType),this.values=xf(s,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:xf(e.times,Array),values:xf(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(s.interpolation=r)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new RO(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new AI(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new kO(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case v0:t=this.InterpolantFactoryMethodDiscrete;break;case w0:t=this.InterpolantFactoryMethodLinear;break;case Vw:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return v0;case this.InterpolantFactoryMethodLinear:return w0;case this.InterpolantFactoryMethodSmooth:return Vw}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,r=t.length;s!==r;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,r=t.length;s!==r;++s)t[s]*=e}return this}trim(e,t){const s=this.times,r=s.length;let i=0,o=r-1;for(;i!==r&&s[i]<e;)++i;for(;o!==-1&&s[o]>t;)--o;if(++o,i!==0||o!==r){i>=o&&(o=Math.max(o,1),i=o-1);const a=this.getValueSize();this.times=s.slice(i,o),this.values=this.values.slice(i*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,r=this.values,i=s.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==i;a++){const l=s[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(r!==void 0&&AO(r))for(let a=0,l=r.length;a!==l;++a){const u=r[a];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,u),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),s=this.getValueSize(),r=this.getInterpolation()===Vw,i=e.length-1;let o=1;for(let a=1;a<i;++a){let l=!1;const u=e[a],c=e[a+1];if(u!==c&&(a!==1||u!==e[0]))if(r)l=!0;else{const h=a*s,f=h-s,p=h+s;for(let g=0;g!==s;++g){const S=t[h+g];if(S!==t[f+g]||S!==t[p+g]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*s,f=o*s;for(let p=0;p!==s;++p)t[f+p]=t[h+p]}++o}}if(i>0){e[o]=e[i];for(let a=i*s,l=o*s,u=0;u!==s;++u)t[l+u]=t[a+u];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*s)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),s=this.constructor,r=new s(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}Ml.prototype.TimeBufferType=Float32Array;Ml.prototype.ValueBufferType=Float32Array;Ml.prototype.DefaultInterpolation=w0;class Xf extends Ml{}Xf.prototype.ValueTypeName="bool";Xf.prototype.ValueBufferType=Array;Xf.prototype.DefaultInterpolation=v0;Xf.prototype.InterpolantFactoryMethodLinear=void 0;Xf.prototype.InterpolantFactoryMethodSmooth=void 0;class MI extends Ml{}MI.prototype.ValueTypeName="color";class R0 extends Ml{}R0.prototype.ValueTypeName="number";class DO extends cx{constructor(e,t,s,r){super(e,t,s,r)}interpolate_(e,t,s,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(s-t)/(r-t);let u=e*a;for(let c=u+a;u!==c;u+=4)Do.slerpFlat(i,0,o,u-a,o,u,l);return i}}class Mg extends Ml{InterpolantFactoryMethodLinear(e){return new DO(this.times,this.values,this.getValueSize(),e)}}Mg.prototype.ValueTypeName="quaternion";Mg.prototype.DefaultInterpolation=w0;Mg.prototype.InterpolantFactoryMethodSmooth=void 0;class qf extends Ml{}qf.prototype.ValueTypeName="string";qf.prototype.ValueBufferType=Array;qf.prototype.DefaultInterpolation=v0;qf.prototype.InterpolantFactoryMethodLinear=void 0;qf.prototype.InterpolantFactoryMethodSmooth=void 0;class D0 extends Ml{}D0.prototype.ValueTypeName="vector";class P0{constructor(e,t=-1,s,r=XS){this.name=e,this.tracks=s,this.duration=t,this.blendMode=r,this.uuid=oa(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,r=1/(e.fps||1);for(let o=0,a=s.length;o!==a;++o)t.push(JX(s[o]).scale(r));const i=new this(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i}static toJSON(e){const t=[],s=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let i=0,o=s.length;i!==o;++i)t.push(Ml.toJSON(s[i]));return r}static CreateFromMorphTargetSequence(e,t,s,r){const i=t.length,o=[];for(let a=0;a<i;a++){let l=[],u=[];l.push((a+i-1)%i,a,(a+1)%i),u.push(0,1,0);const c=MO(l);l=XE(l,1,c),u=XE(u,1,c),!r&&l[0]===0&&(l.push(i),u.push(u[0])),o.push(new R0(".morphTargetInfluences["+t[a].name+"]",l,u).scale(1/s))}return new this(e,-1,o)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const r=e;s=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<s.length;r++)if(s[r].name===t)return s[r];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const r={},i=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const u=e[a],c=u.name.match(i);if(c&&c.length>1){const h=c[1];let f=r[h];f||(r[h]=f=[]),f.push(u)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],t,s));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(h,f,p,g,S){if(p.length!==0){const x=[],w=[];NI(p,x,w,g),x.length!==0&&S.push(new h(f,x,w))}},r=[],i=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const u=e.hierarchy||[];for(let h=0;h<u.length;h++){const f=u[h].keys;if(!(!f||f.length===0))if(f[0].morphTargets){const p={};let g;for(g=0;g<f.length;g++)if(f[g].morphTargets)for(let S=0;S<f[g].morphTargets.length;S++)p[f[g].morphTargets[S]]=-1;for(const S in p){const x=[],w=[];for(let _=0;_!==f[g].morphTargets.length;++_){const T=f[g];x.push(T.time),w.push(T.morphTarget===S?1:0)}r.push(new R0(".morphTargetInfluence["+S+"]",x,w))}l=p.length*o}else{const p=".bones["+t[h].name+"]";s(D0,p+".position",f,"pos",r),s(Mg,p+".quaternion",f,"rot",r),s(D0,p+".scale",f,"scl",r)}}return r.length===0?null:new this(i,l,r,a)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,r=e.length;s!==r;++s){const i=this.tracks[s];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function ZX(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return R0;case"vector":case"vector2":case"vector3":case"vector4":return D0;case"color":return MI;case"quaternion":return Mg;case"bool":case"boolean":return Xf;case"string":return qf}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function JX(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=ZX(n.type);if(n.times===void 0){const t=[],s=[];NI(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const oc={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class kI{constructor(e,t,s){const r=this;let i=!1,o=0,a=0,l;const u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.itemStart=function(c){a++,i===!1&&r.onStart!==void 0&&r.onStart(c,o,a),i=!0},this.itemEnd=function(c){o++,r.onProgress!==void 0&&r.onProgress(c,o,a),o===a&&(i=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return l?l(c):c},this.setURLModifier=function(c){return l=c,this},this.addHandler=function(c,h){return u.push(c,h),this},this.removeHandler=function(c){const h=u.indexOf(c);return h!==-1&&u.splice(h,2),this},this.getHandler=function(c){for(let h=0,f=u.length;h<f;h+=2){const p=u[h],g=u[h+1];if(p.global&&(p.lastIndex=0),p.test(c))return g}return null}}}const PO=new kI;class Bo{constructor(e){this.manager=e!==void 0?e:PO,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(r,i){s.load(e,r,t,i)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Bo.DEFAULT_MATERIAL_NAME="__DEFAULT";const Zu={};class QX extends Error{constructor(e,t){super(e),this.response=t}}class fc extends Bo{constructor(e){super(e)}load(e,t,s,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=oc.get(e);if(i!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(i),this.manager.itemEnd(e)},0),i;if(Zu[e]!==void 0){Zu[e].push({onLoad:t,onProgress:s,onError:r});return}Zu[e]=[],Zu[e].push({onLoad:t,onProgress:s,onError:r});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(u=>{if(u.status===200||u.status===0){if(u.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||u.body===void 0||u.body.getReader===void 0)return u;const c=Zu[e],h=u.body.getReader(),f=u.headers.get("Content-Length")||u.headers.get("X-File-Size"),p=f?parseInt(f):0,g=p!==0;let S=0;const x=new ReadableStream({start(w){_();function _(){h.read().then(({done:T,value:C})=>{if(T)w.close();else{S+=C.byteLength;const N=new ProgressEvent("progress",{lengthComputable:g,loaded:S,total:p});for(let M=0,P=c.length;M<P;M++){const $=c[M];$.onProgress&&$.onProgress(N)}w.enqueue(C),_()}})}}});return new Response(x)}else throw new QX(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)}).then(u=>{switch(l){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(c=>new DOMParser().parseFromString(c,a));case"json":return u.json();default:if(a===void 0)return u.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),f=h&&h[1]?h[1].toLowerCase():void 0,p=new TextDecoder(f);return u.arrayBuffer().then(g=>p.decode(g))}}}).then(u=>{oc.add(e,u);const c=Zu[e];delete Zu[e];for(let h=0,f=c.length;h<f;h++){const p=c[h];p.onLoad&&p.onLoad(u)}}).catch(u=>{const c=Zu[e];if(c===void 0)throw this.manager.itemError(e),u;delete Zu[e];for(let h=0,f=c.length;h<f;h++){const p=c[h];p.onError&&p.onError(u)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class eq extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=this,o=new fc(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),i.manager.itemError(e)}},s,r)}parse(e){const t=[];for(let s=0;s<e.length;s++){const r=P0.parse(e[s]);t.push(r)}return t}}class tq extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=this,o=[],a=new tb,l=new fc(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(i.withCredentials);let u=0;function c(h){l.load(e[h],function(f){const p=i.parse(f,!0);o[h]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},u+=1,u===6&&(p.mipmapCount===1&&(a.minFilter=rr),a.image=o,a.format=p.format,a.needsUpdate=!0,t&&t(a))},s,r)}if(Array.isArray(e))for(let h=0,f=e.length;h<f;++h)c(h);else l.load(e,function(h){const f=i.parse(h,!0);if(f.isCubemap){const p=f.mipmaps.length/f.mipmapCount;for(let g=0;g<p;g++){o[g]={mipmaps:[]};for(let S=0;S<f.mipmapCount;S++)o[g].mipmaps.push(f.mipmaps[g*f.mipmapCount+S]),o[g].format=f.format,o[g].width=f.width,o[g].height=f.height}a.image=o}else a.image.width=f.width,a.image.height=f.height,a.mipmaps=f.mipmaps;f.mipmapCount===1&&(a.minFilter=rr),a.format=f.format,a.needsUpdate=!0,t&&t(a)},s,r);return a}}class L0 extends Bo{constructor(e){super(e)}load(e,t,s,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=oc.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a=E0("img");function l(){c(),oc.add(e,this),t&&t(this),i.manager.itemEnd(e)}function u(h){c(),r&&r(h),i.manager.itemError(e),i.manager.itemEnd(e)}function c(){a.removeEventListener("load",l,!1),a.removeEventListener("error",u,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",u,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(e),a.src=e,a}}class nq extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=new sx;i.colorSpace=kr;const o=new L0(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(u){o.load(e[u],function(c){i.images[u]=c,a++,a===6&&(i.needsUpdate=!0,t&&t(i))},void 0,r)}for(let u=0;u<e.length;++u)l(u);return i}}class sq extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=this,o=new Ef,a=new fc(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(e,function(l){let u;try{u=i.parse(l)}catch(c){if(r!==void 0)r(c);else{console.error(c);return}}u.image!==void 0?o.image=u.image:u.data!==void 0&&(o.image.width=u.width,o.image.height=u.height,o.image.data=u.data),o.wrapS=u.wrapS!==void 0?u.wrapS:Pi,o.wrapT=u.wrapT!==void 0?u.wrapT:Pi,o.magFilter=u.magFilter!==void 0?u.magFilter:rr,o.minFilter=u.minFilter!==void 0?u.minFilter:rr,o.anisotropy=u.anisotropy!==void 0?u.anisotropy:1,u.colorSpace!==void 0?o.colorSpace=u.colorSpace:u.encoding!==void 0&&(o.encoding=u.encoding),u.flipY!==void 0&&(o.flipY=u.flipY),u.format!==void 0&&(o.format=u.format),u.type!==void 0&&(o.type=u.type),u.mipmaps!==void 0&&(o.mipmaps=u.mipmaps,o.minFilter=Rh),u.mipmapCount===1&&(o.minFilter=rr),u.generateMipmaps!==void 0&&(o.generateMipmaps=u.generateMipmaps),o.needsUpdate=!0,t&&t(o,u)},s,r),o}}class LO extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=new Hs,o=new L0(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){i.image=a,i.needsUpdate=!0,t!==void 0&&t(i)},s,r),i}}class Zh extends zn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new vt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class OO extends Zh{constructor(e,t,s){super(e,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(zn.DEFAULT_UP),this.updateMatrix(),this.groundColor=new vt(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const _C=new ln,KR=new re,YR=new re;class RI{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Je(512,512),this.map=null,this.mapPass=null,this.matrix=new ln,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new rx,this._frameExtents=new Je(1,1),this._viewportCount=1,this._viewports=[new Jn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;KR.setFromMatrixPosition(e.matrixWorld),t.position.copy(KR),YR.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(YR),t.updateMatrixWorld(),_C.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_C),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(_C)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class rq extends RI{constructor(){super(new jr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,s=og*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;(s!==t.fov||r!==t.aspect||i!==t.far)&&(t.fov=s,t.aspect=r,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class FO extends Zh{constructor(e,t,s=0,r=Math.PI/3,i=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(zn.DEFAULT_UP),this.updateMatrix(),this.target=new zn,this.distance=s,this.angle=r,this.penumbra=i,this.decay=o,this.map=null,this.shadow=new rq}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const ZR=new ln,qy=new re,TC=new re;class iq extends RI{constructor(){super(new jr(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Je(4,2),this._viewportCount=6,this._viewports=[new Jn(2,1,1,1),new Jn(0,1,1,1),new Jn(3,1,1,1),new Jn(1,1,1,1),new Jn(3,0,1,1),new Jn(1,0,1,1)],this._cubeDirections=[new re(1,0,0),new re(-1,0,0),new re(0,0,1),new re(0,0,-1),new re(0,1,0),new re(0,-1,0)],this._cubeUps=[new re(0,1,0),new re(0,1,0),new re(0,1,0),new re(0,1,0),new re(0,0,1),new re(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,r=this.matrix,i=e.distance||s.far;i!==s.far&&(s.far=i,s.updateProjectionMatrix()),qy.setFromMatrixPosition(e.matrixWorld),s.position.copy(qy),TC.copy(s.position),TC.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(TC),s.updateMatrixWorld(),r.makeTranslation(-qy.x,-qy.y,-qy.z),ZR.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ZR)}}class $O extends Zh{constructor(e,t,s=0,r=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=r,this.shadow=new iq}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class oq extends RI{constructor(){super(new ox(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class zO extends Zh{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(zn.DEFAULT_UP),this.updateMatrix(),this.target=new zn,this.shadow=new oq}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class UO extends Zh{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class BO extends Zh{constructor(e,t,s=10,r=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class VO{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new re)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const s=e.x,r=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*s),t.addScaledVector(o[4],1.092548*(s*r)),t.addScaledVector(o[5],1.092548*(r*i)),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],1.092548*(s*i)),t.addScaledVector(o[8],.546274*(s*s-r*r)),t}getIrradianceAt(e,t){const s=e.x,r=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*i),t.addScaledVector(o[3],2*.511664*s),t.addScaledVector(o[4],2*.429043*s*r),t.addScaledVector(o[5],2*.429043*r*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],2*.429043*s*i),t.addScaledVector(o[8],.429043*(s*s-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const s=this.coefficients;for(let r=0;r<9;r++)s[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const s=this.coefficients;for(let r=0;r<9;r++)s[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const s=e.x,r=e.y,i=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*i,t[3]=.488603*s,t[4]=1.092548*s*r,t[5]=1.092548*r*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*s*i,t[8]=.546274*(s*s-r*r)}}class WO extends Zh{constructor(e=new VO,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class mb extends Bo{constructor(e){super(e),this.textures={}}load(e,t,s,r){const i=this,o=new fc(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),i.manager.itemError(e)}},s,r)}parse(e){const t=this.textures;function s(i){return t[i]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",i),t[i]}const r=mb.createMaterialFromType(e.type);if(e.uuid!==void 0&&(r.uuid=e.uuid),e.name!==void 0&&(r.name=e.name),e.color!==void 0&&r.color!==void 0&&r.color.setHex(e.color),e.roughness!==void 0&&(r.roughness=e.roughness),e.metalness!==void 0&&(r.metalness=e.metalness),e.sheen!==void 0&&(r.sheen=e.sheen),e.sheenColor!==void 0&&(r.sheenColor=new vt().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(r.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(e.emissive),e.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(e.specular),e.specularIntensity!==void 0&&(r.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&r.specularColor!==void 0&&r.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(r.shininess=e.shininess),e.clearcoat!==void 0&&(r.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(r.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(r.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(r.transmission=e.transmission),e.thickness!==void 0&&(r.thickness=e.thickness),e.attenuationDistance!==void 0&&(r.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&r.attenuationColor!==void 0&&r.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(r.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(r.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(r.fog=e.fog),e.flatShading!==void 0&&(r.flatShading=e.flatShading),e.blending!==void 0&&(r.blending=e.blending),e.combine!==void 0&&(r.combine=e.combine),e.side!==void 0&&(r.side=e.side),e.shadowSide!==void 0&&(r.shadowSide=e.shadowSide),e.opacity!==void 0&&(r.opacity=e.opacity),e.transparent!==void 0&&(r.transparent=e.transparent),e.alphaTest!==void 0&&(r.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(r.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(r.depthFunc=e.depthFunc),e.depthTest!==void 0&&(r.depthTest=e.depthTest),e.depthWrite!==void 0&&(r.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(r.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(r.blendSrc=e.blendSrc),e.blendDst!==void 0&&(r.blendDst=e.blendDst),e.blendEquation!==void 0&&(r.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(r.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(r.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(r.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&r.blendColor!==void 0&&r.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(r.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(r.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(r.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(r.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(r.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(r.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(r.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(r.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(r.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(r.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(r.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(r.rotation=e.rotation),e.linewidth!==void 0&&(r.linewidth=e.linewidth),e.dashSize!==void 0&&(r.dashSize=e.dashSize),e.gapSize!==void 0&&(r.gapSize=e.gapSize),e.scale!==void 0&&(r.scale=e.scale),e.polygonOffset!==void 0&&(r.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(r.dithering=e.dithering),e.alphaToCoverage!==void 0&&(r.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(r.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(r.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(r.visible=e.visible),e.toneMapped!==void 0&&(r.toneMapped=e.toneMapped),e.userData!==void 0&&(r.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?r.vertexColors=e.vertexColors>0:r.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const i in e.uniforms){const o=e.uniforms[i];switch(r.uniforms[i]={},o.type){case"t":r.uniforms[i].value=s(o.value);break;case"c":r.uniforms[i].value=new vt().setHex(o.value);break;case"v2":r.uniforms[i].value=new Je().fromArray(o.value);break;case"v3":r.uniforms[i].value=new re().fromArray(o.value);break;case"v4":r.uniforms[i].value=new Jn().fromArray(o.value);break;case"m3":r.uniforms[i].value=new _n().fromArray(o.value);break;case"m4":r.uniforms[i].value=new ln().fromArray(o.value);break;default:r.uniforms[i].value=o.value}}if(e.defines!==void 0&&(r.defines=e.defines),e.vertexShader!==void 0&&(r.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(r.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(r.glslVersion=e.glslVersion),e.extensions!==void 0)for(const i in e.extensions)r.extensions[i]=e.extensions[i];if(e.lights!==void 0&&(r.lights=e.lights),e.clipping!==void 0&&(r.clipping=e.clipping),e.size!==void 0&&(r.size=e.size),e.sizeAttenuation!==void 0&&(r.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(r.map=s(e.map)),e.matcap!==void 0&&(r.matcap=s(e.matcap)),e.alphaMap!==void 0&&(r.alphaMap=s(e.alphaMap)),e.bumpMap!==void 0&&(r.bumpMap=s(e.bumpMap)),e.bumpScale!==void 0&&(r.bumpScale=e.bumpScale),e.normalMap!==void 0&&(r.normalMap=s(e.normalMap)),e.normalMapType!==void 0&&(r.normalMapType=e.normalMapType),e.normalScale!==void 0){let i=e.normalScale;Array.isArray(i)===!1&&(i=[i,i]),r.normalScale=new Je().fromArray(i)}return e.displacementMap!==void 0&&(r.displacementMap=s(e.displacementMap)),e.displacementScale!==void 0&&(r.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(r.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(r.roughnessMap=s(e.roughnessMap)),e.metalnessMap!==void 0&&(r.metalnessMap=s(e.metalnessMap)),e.emissiveMap!==void 0&&(r.emissiveMap=s(e.emissiveMap)),e.emissiveIntensity!==void 0&&(r.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(r.specularMap=s(e.specularMap)),e.specularIntensityMap!==void 0&&(r.specularIntensityMap=s(e.specularIntensityMap)),e.specularColorMap!==void 0&&(r.specularColorMap=s(e.specularColorMap)),e.envMap!==void 0&&(r.envMap=s(e.envMap)),e.envMapIntensity!==void 0&&(r.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(r.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(r.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(r.lightMap=s(e.lightMap)),e.lightMapIntensity!==void 0&&(r.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(r.aoMap=s(e.aoMap)),e.aoMapIntensity!==void 0&&(r.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(r.gradientMap=s(e.gradientMap)),e.clearcoatMap!==void 0&&(r.clearcoatMap=s(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=s(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=s(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new Je().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(r.iridescenceMap=s(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(r.iridescenceThicknessMap=s(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(r.transmissionMap=s(e.transmissionMap)),e.thicknessMap!==void 0&&(r.thicknessMap=s(e.thicknessMap)),e.anisotropyMap!==void 0&&(r.anisotropyMap=s(e.anisotropyMap)),e.sheenColorMap!==void 0&&(r.sheenColorMap=s(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(r.sheenRoughnessMap=s(e.sheenRoughnessMap)),r}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:wO,SpriteMaterial:xI,RawShaderMaterial:SO,ShaderMaterial:Tl,PointsMaterial:wI,MeshPhysicalMaterial:bO,MeshStandardMaterial:pb,MeshPhongMaterial:_O,MeshToonMaterial:TO,MeshNormalMaterial:CO,MeshLambertMaterial:EO,MeshDepthMaterial:mI,MeshDistanceMaterial:gI,MeshBasicMaterial:qh,MeshMatcapMaterial:IO,LineDashedMaterial:NO,LineBasicMaterial:oo,Material:xi};return new t[e]}}class qE{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class GO extends bn{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class HO extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=this,o=new fc(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(l){r?r(l):console.error(l),i.manager.itemError(e)}},s,r)}parse(e){const t={},s={};function r(p,g){if(t[g]!==void 0)return t[g];const x=p.interleavedBuffers[g],w=i(p,x.buffer),_=Wm(x.type,w),T=new QS(_,x.stride);return T.uuid=x.uuid,t[g]=T,T}function i(p,g){if(s[g]!==void 0)return s[g];const x=p.arrayBuffers[g],w=new Uint32Array(x).buffer;return s[g]=w,w}const o=e.isInstancedBufferGeometry?new GO:new bn,a=e.data.index;if(a!==void 0){const p=Wm(a.type,a.array);o.setIndex(new Qn(p,1))}const l=e.data.attributes;for(const p in l){const g=l[p];let S;if(g.isInterleavedBufferAttribute){const x=r(e.data,g.data);S=new kf(x,g.itemSize,g.offset,g.normalized)}else{const x=Wm(g.type,g.array),w=g.isInstancedBufferAttribute?lg:Qn;S=new w(x,g.itemSize,g.normalized)}g.name!==void 0&&(S.name=g.name),g.usage!==void 0&&S.setUsage(g.usage),o.setAttribute(p,S)}const u=e.data.morphAttributes;if(u)for(const p in u){const g=u[p],S=[];for(let x=0,w=g.length;x<w;x++){const _=g[x];let T;if(_.isInterleavedBufferAttribute){const C=r(e.data,_.data);T=new kf(C,_.itemSize,_.offset,_.normalized)}else{const C=Wm(_.type,_.array);T=new Qn(C,_.itemSize,_.normalized)}_.name!==void 0&&(T.name=_.name),S.push(T)}o.morphAttributes[p]=S}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let p=0,g=h.length;p!==g;++p){const S=h[p];o.addGroup(S.start,S.count,S.materialIndex)}const f=e.data.boundingSphere;if(f!==void 0){const p=new re;f.center!==void 0&&p.fromArray(f.center),o.boundingSphere=new Fi(p,f.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class aq extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=this,o=this.path===""?qE.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new fc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let u=null;try{u=JSON.parse(l)}catch(h){r!==void 0&&r(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const c=u.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry"){r!==void 0&&r(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}i.parse(u,t)},s,r)}async loadAsync(e,t){const s=this,r=this.path===""?qE.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||r;const i=new fc(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const o=await i.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await s.parseAsync(a)}parse(e,t){const s=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,r),o=this.parseImages(e.images,function(){t!==void 0&&t(u)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),u=this.parseObject(e.object,i,l,a,s),c=this.parseSkeletons(e.skeletons,u);if(this.bindSkeletons(u,c),t!==void 0){let h=!1;for(const f in o)if(o[f].data instanceof HTMLImageElement){h=!0;break}h===!1&&t(u)}return u}async parseAsync(e){const t=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,s),i=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,i),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,r,a,o,t),u=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,u),l}parseShapes(e){const t={};if(e!==void 0)for(let s=0,r=e.length;s<r;s++){const i=new lc().fromJSON(e[s]);t[i.uuid]=i}return t}parseSkeletons(e,t){const s={},r={};if(t.traverse(function(i){i.isBone&&(r[i.uuid]=i)}),e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=new eb().fromJSON(e[i],r);s[a.uuid]=a}return s}parseGeometries(e,t){const s={};if(e!==void 0){const r=new HO;for(let i=0,o=e.length;i<o;i++){let a;const l=e[i];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=r.parse(l);break;default:l.type in qR?a=qR[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),l.userData!==void 0&&(a.userData=l.userData),s[l.uuid]=a}}return s}parseMaterials(e,t){const s={},r={};if(e!==void 0){const i=new mb;i.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];s[l.uuid]===void 0&&(s[l.uuid]=i.parse(l)),r[l.uuid]=s[l.uuid]}}return r}parseAnimations(e){const t={};if(e!==void 0)for(let s=0;s<e.length;s++){const r=e[s],i=P0.parse(r);t[i.uuid]=i}return t}parseImages(e,t){const s=this,r={};let i;function o(l){return s.manager.itemStart(l),i.load(l,function(){s.manager.itemEnd(l)},void 0,function(){s.manager.itemError(l),s.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const u=l,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:s.resourcePath+u;return o(c)}else return l.data?{data:Wm(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new kI(t);i=new L0(l),i.setCrossOrigin(this.crossOrigin);for(let u=0,c=e.length;u<c;u++){const h=e[u],f=h.url;if(Array.isArray(f)){const p=[];for(let g=0,S=f.length;g<S;g++){const x=f[g],w=a(x);w!==null&&(w instanceof HTMLImageElement?p.push(w):p.push(new Ef(w.data,w.width,w.height)))}r[h.uuid]=new yf(p)}else{const p=a(h.url);r[h.uuid]=new yf(p)}}}return r}async parseImagesAsync(e){const t=this,s={};let r;async function i(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await r.loadAsync(l)}else return o.data?{data:Wm(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){r=new L0(this.manager),r.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],u=l.url;if(Array.isArray(u)){const c=[];for(let h=0,f=u.length;h<f;h++){const p=u[h],g=await i(p);g!==null&&(g instanceof HTMLImageElement?c.push(g):c.push(new Ef(g.data,g.width,g.height)))}s[l.uuid]=new yf(c)}else{const c=await i(l.url);s[l.uuid]=new yf(c)}}}return s}parseTextures(e,t){function s(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const r={};if(e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=e[i];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],u=l.data;let c;Array.isArray(u)?(c=new sx,u.length===6&&(c.needsUpdate=!0)):(u&&u.data?c=new Ef:c=new Hs,u&&(c.needsUpdate=!0)),c.source=l,c.uuid=a.uuid,a.name!==void 0&&(c.name=a.name),a.mapping!==void 0&&(c.mapping=s(a.mapping,lq)),a.channel!==void 0&&(c.channel=a.channel),a.offset!==void 0&&c.offset.fromArray(a.offset),a.repeat!==void 0&&c.repeat.fromArray(a.repeat),a.center!==void 0&&c.center.fromArray(a.center),a.rotation!==void 0&&(c.rotation=a.rotation),a.wrap!==void 0&&(c.wrapS=s(a.wrap[0],JR),c.wrapT=s(a.wrap[1],JR)),a.format!==void 0&&(c.format=a.format),a.internalFormat!==void 0&&(c.internalFormat=a.internalFormat),a.type!==void 0&&(c.type=a.type),a.colorSpace!==void 0&&(c.colorSpace=a.colorSpace),a.encoding!==void 0&&(c.encoding=a.encoding),a.minFilter!==void 0&&(c.minFilter=s(a.minFilter,QR)),a.magFilter!==void 0&&(c.magFilter=s(a.magFilter,QR)),a.anisotropy!==void 0&&(c.anisotropy=a.anisotropy),a.flipY!==void 0&&(c.flipY=a.flipY),a.generateMipmaps!==void 0&&(c.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(c.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(c.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(c.compareFunction=a.compareFunction),a.userData!==void 0&&(c.userData=a.userData),r[a.uuid]=c}return r}parseObject(e,t,s,r,i){let o;function a(f){return t[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",f),t[f]}function l(f){if(f!==void 0){if(Array.isArray(f)){const p=[];for(let g=0,S=f.length;g<S;g++){const x=f[g];s[x]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",x),p.push(s[x])}return p}return s[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",f),s[f]}}function u(f){return r[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",f),r[f]}let c,h;switch(e.type){case"Scene":o=new uS,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new vt(e.background):o.background=u(e.background)),e.environment!==void 0&&(o.environment=u(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new JS(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new ZS(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity);break;case"PerspectiveCamera":o=new jr(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new ox(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new UO(e.color,e.intensity);break;case"DirectionalLight":o=new zO(e.color,e.intensity);break;case"PointLight":o=new $O(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new BO(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new FO(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new OO(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new WO().fromJSON(e);break;case"SkinnedMesh":c=a(e.geometry),h=l(e.material),o=new oO(c,h),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":c=a(e.geometry),h=l(e.material),o=new Dr(c,h);break;case"InstancedMesh":c=a(e.geometry),h=l(e.material);const f=e.count,p=e.instanceMatrix,g=e.instanceColor;o=new aO(c,h,f),o.instanceMatrix=new lg(new Float32Array(p.array),16),g!==void 0&&(o.instanceColor=new lg(new Float32Array(g.array),g.itemSize));break;case"BatchedMesh":c=a(e.geometry),h=l(e.material),o=new lO(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,h),o.geometry=c,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._visibility=e.visibility,o._active=e.active,o._bounds=e.bounds.map(S=>{const x=new so;x.min.fromArray(S.boxMin),x.max.fromArray(S.boxMax);const w=new Fi;return w.radius=S.sphereRadius,w.center.fromArray(S.sphereCenter),{boxInitialized:S.boxInitialized,box:x,sphereInitialized:S.sphereInitialized,sphere:w}}),o._maxGeometryCount=e.maxGeometryCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._geometryCount=e.geometryCount,o._matricesTexture=u(e.matricesTexture.uuid);break;case"LOD":o=new iO;break;case"Line":o=new Dh(a(e.geometry),l(e.material));break;case"LineLoop":o=new uO(a(e.geometry),l(e.material));break;case"LineSegments":o=new gu(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new cO(a(e.geometry),l(e.material));break;case"Sprite":o=new rO(l(e.material));break;case"Group":o=new jm;break;case"Bone":o=new vI;break;default:o=new zn}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const f=e.children;for(let p=0;p<f.length;p++)o.add(this.parseObject(f[p],t,s,r,i))}if(e.animations!==void 0){const f=e.animations;for(let p=0;p<f.length;p++){const g=f[p];o.animations.push(i[g])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const f=e.levels;for(let p=0;p<f.length;p++){const g=f[p],S=o.getObjectByProperty("uuid",g.object);S!==void 0&&o.addLevel(S,g.distance,g.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(s){if(s.isSkinnedMesh===!0&&s.skeleton!==void 0){const r=t[s.skeleton];r===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",s.skeleton):s.bind(r,s.bindMatrix)}})}}const lq={UVMapping:HS,CubeReflectionMapping:dc,CubeRefractionMapping:kh,EquirectangularReflectionMapping:g0,EquirectangularRefractionMapping:y0,CubeUVReflectionMapping:_g},JR={RepeatWrapping:Af,ClampToEdgeWrapping:Pi,MirroredRepeatWrapping:x0},QR={NearestFilter:sr,NearestMipmapNearestFilter:oS,NearestMipmapLinearFilter:u0,LinearFilter:rr,LinearMipmapNearestFilter:Z2,LinearMipmapLinearFilter:Rh};class uq extends Bo{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,s,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=oc.get(e);if(o!==void 0){if(i.manager.itemStart(e),o.then){o.then(u=>{t&&t(u),i.manager.itemEnd(e)}).catch(u=>{r&&r(u)});return}return setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader;const l=fetch(e,a).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(u){return oc.add(e,u),t&&t(u),i.manager.itemEnd(e),u}).catch(function(u){r&&r(u),oc.remove(e),i.manager.itemError(e),i.manager.itemEnd(e)});oc.add(e,l),i.manager.itemStart(e)}}let fw;class DI{static getContext(){return fw===void 0&&(fw=new(window.AudioContext||window.webkitAudioContext)),fw}static setContext(e){fw=e}}class cq extends Bo{constructor(e){super(e)}load(e,t,s,r){const i=this,o=new fc(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const u=l.slice(0);DI.getContext().decodeAudioData(u,function(h){t(h)}).catch(a)}catch(u){a(u)}},s,r);function a(l){r?r(l):console.error(l),i.manager.itemError(e)}}}const eD=new ln,tD=new ln,Jd=new ln;class hq{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new jr,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new jr,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Jd.copy(e.projectionMatrix);const r=t.eyeSep/2,i=r*t.near/t.focus,o=t.near*Math.tan(Tf*t.fov*.5)/t.zoom;let a,l;tD.elements[12]=-r,eD.elements[12]=r,a=-o*t.aspect+i,l=o*t.aspect+i,Jd.elements[0]=2*t.near/(l-a),Jd.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(Jd),a=-o*t.aspect-i,l=o*t.aspect-i,Jd.elements[0]=2*t.near/(l-a),Jd.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(Jd)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(tD),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(eD)}}class PI{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=nD(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=nD();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function nD(){return(typeof performance>"u"?Date:performance).now()}const Qd=new re,sD=new Do,dq=new re,ef=new re;class fq extends zn{constructor(){super(),this.type="AudioListener",this.context=DI.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new PI}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,s=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Qd,sD,dq),ef.set(0,0,-1).applyQuaternion(sD),t.positionX){const r=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Qd.x,r),t.positionY.linearRampToValueAtTime(Qd.y,r),t.positionZ.linearRampToValueAtTime(Qd.z,r),t.forwardX.linearRampToValueAtTime(ef.x,r),t.forwardY.linearRampToValueAtTime(ef.y,r),t.forwardZ.linearRampToValueAtTime(ef.z,r),t.upX.linearRampToValueAtTime(s.x,r),t.upY.linearRampToValueAtTime(s.y,r),t.upZ.linearRampToValueAtTime(s.z,r)}else t.setPosition(Qd.x,Qd.y,Qd.z),t.setOrientation(ef.x,ef.y,ef.z,s.x,s.y,s.z)}}class jO extends zn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const tf=new re,rD=new Do,pq=new re,nf=new re;class mq extends jO{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,s){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=s,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(tf,rD,pq),nf.set(0,0,1).applyQuaternion(rD);const t=this.panner;if(t.positionX){const s=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(tf.x,s),t.positionY.linearRampToValueAtTime(tf.y,s),t.positionZ.linearRampToValueAtTime(tf.z,s),t.orientationX.linearRampToValueAtTime(nf.x,s),t.orientationY.linearRampToValueAtTime(nf.y,s),t.orientationZ.linearRampToValueAtTime(nf.z,s)}else t.setPosition(tf.x,tf.y,tf.z),t.setOrientation(nf.x,nf.y,nf.z)}}class gq{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let s=0;s<t.length;s++)e+=t[s];return e/t.length}}class XO{constructor(e,t,s){this.binding=e,this.valueSize=s;let r,i,o;switch(t){case"quaternion":r=this._slerp,i=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:r=this._lerp,i=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const s=this.buffer,r=this.valueSize,i=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)s[i+a]=s[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(s,i,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,s=this.valueSize,r=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,s=this.buffer,r=e*t+t,i=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const l=t*this._origIndex;this._mixBufferRegion(s,r,l,1-i,t)}o>0&&this._mixBufferRegionAdditive(s,r,this._addIndex*t,1,t);for(let l=t,u=t+t;l!==u;++l)if(s[l]!==s[l+t]){a.setValue(s,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,s=this.valueSize,r=s*this._origIndex;e.getValue(t,r);for(let i=s,o=r;i!==o;++i)t[i]=t[r+i%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let s=e;s<t;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[t+s]=this.buffer[e+s]}_select(e,t,s,r,i){if(r>=.5)for(let o=0;o!==i;++o)e[t+o]=e[s+o]}_slerp(e,t,s,r){Do.slerpFlat(e,t,e,t,e,s,r)}_slerpAdditive(e,t,s,r,i){const o=this._workIndex*i;Do.multiplyQuaternionsFlat(e,o,e,t,e,s),Do.slerpFlat(e,t,e,t,e,o,r)}_lerp(e,t,s,r,i){const o=1-r;for(let a=0;a!==i;++a){const l=t+a;e[l]=e[l]*o+e[s+a]*r}}_lerpAdditive(e,t,s,r,i){for(let o=0;o!==i;++o){const a=t+o;e[a]=e[a]+e[s+o]*r}}}const LI="\\[\\]\\.:\\/",yq=new RegExp("["+LI+"]","g"),OI="[^"+LI+"]",xq="[^"+LI.replace("\\.","")+"]",vq=/((?:WC+[\/:])*)/.source.replace("WC",OI),wq=/(WCOD+)?/.source.replace("WCOD",xq),Sq=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",OI),bq=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",OI),_q=new RegExp("^"+vq+wq+Sq+bq+"$"),Tq=["material","materials","bones","map"];class Cq{constructor(e,t,s){const r=s||Wn.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,r=this._bindings[s];r!==void 0&&r.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=s.length;r!==i;++r)s[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class Wn{constructor(e,t,s){this.path=t,this.parsedPath=s||Wn.parseTrackName(t),this.node=Wn.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new Wn.Composite(e,t,s):new Wn(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(yq,"")}static parseTrackName(e){const t=_q.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=s.nodeName&&s.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const i=s.nodeName.substring(r+1);Tq.indexOf(i)!==-1&&(s.nodeName=s.nodeName.substring(0,r),s.objectName=i)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(i){for(let o=0;o<i.length;o++){const a=i[o];if(a.name===t||a.uuid===t)return a;const l=s(a.children);if(l)return l}return null},r=s(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)e[t++]=s[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)s[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)s[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)s[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,r=t.propertyName;let i=t.propertyIndex;if(e||(e=Wn.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let u=t.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===u){u=c;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(u!==void 0){if(e[u]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[u]}}const o=e[r];if(o===void 0){const u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(i!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[i]!==void 0&&(i=e.morphTargetDictionary[i])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=i}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Wn.Composite=Cq;Wn.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Wn.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Wn.prototype.GetterByBindingType=[Wn.prototype._getValue_direct,Wn.prototype._getValue_array,Wn.prototype._getValue_arrayElement,Wn.prototype._getValue_toArray];Wn.prototype.SetterByBindingTypeAndVersioning=[[Wn.prototype._setValue_direct,Wn.prototype._setValue_direct_setNeedsUpdate,Wn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Wn.prototype._setValue_array,Wn.prototype._setValue_array_setNeedsUpdate,Wn.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Wn.prototype._setValue_arrayElement,Wn.prototype._setValue_arrayElement_setNeedsUpdate,Wn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Wn.prototype._setValue_fromArray,Wn.prototype._setValue_fromArray_setNeedsUpdate,Wn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Eq{constructor(){this.isAnimationObjectGroup=!0,this.uuid=oa(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let s=0,r=arguments.length;s!==r;++s)e[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,s=this._paths,r=this._parsedPaths,i=this._bindings,o=i.length;let a,l=e.length,u=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const f=arguments[c],p=f.uuid;let g=t[p];if(g===void 0){g=l++,t[p]=g,e.push(f);for(let S=0,x=o;S!==x;++S)i[S].push(new Wn(f,s[S],r[S]))}else if(g<u){a=e[g];const S=--u,x=e[S];t[x.uuid]=g,e[g]=x,t[p]=S,e[S]=f;for(let w=0,_=o;w!==_;++w){const T=i[w],C=T[S];let N=T[g];T[g]=C,N===void 0&&(N=new Wn(f,s[w],r[w])),T[S]=N}}else e[g]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=u}remove(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,r=s.length;let i=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],u=l.uuid,c=t[u];if(c!==void 0&&c>=i){const h=i++,f=e[h];t[f.uuid]=c,e[c]=f,t[u]=h,e[h]=l;for(let p=0,g=r;p!==g;++p){const S=s[p],x=S[h],w=S[c];S[c]=x,S[h]=w}}}this.nCachedObjects_=i}uncache(){const e=this._objects,t=this._indicesByUUID,s=this._bindings,r=s.length;let i=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const u=arguments[a],c=u.uuid,h=t[c];if(h!==void 0)if(delete t[c],h<i){const f=--i,p=e[f],g=--o,S=e[g];t[p.uuid]=h,e[h]=p,t[S.uuid]=f,e[f]=S,e.pop();for(let x=0,w=r;x!==w;++x){const _=s[x],T=_[f],C=_[g];_[h]=T,_[f]=C,_.pop()}}else{const f=--o,p=e[f];f>0&&(t[p.uuid]=h),e[h]=p,e.pop();for(let g=0,S=r;g!==S;++g){const x=s[g];x[h]=x[f],x.pop()}}}this.nCachedObjects_=i}subscribe_(e,t){const s=this._bindingsIndicesByPath;let r=s[e];const i=this._bindings;if(r!==void 0)return i[r];const o=this._paths,a=this._parsedPaths,l=this._objects,u=l.length,c=this.nCachedObjects_,h=new Array(u);r=i.length,s[e]=r,o.push(e),a.push(t),i.push(h);for(let f=c,p=l.length;f!==p;++f){const g=l[f];h[f]=new Wn(g,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,s=t[e];if(s!==void 0){const r=this._paths,i=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],u=e[a];t[u]=s,o[s]=l,o.pop(),i[s]=i[a],i.pop(),r[s]=r[a],r.pop()}}}class qO{constructor(e,t,s=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=s,this.blendMode=r;const i=t.tracks,o=i.length,a=new Array(o),l={endingStart:mf,endingEnd:mf};for(let u=0;u!==o;++u){const c=i[u].createInterpolant(null);a[u]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=N3,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,s){if(e.fadeOut(t),this.fadeIn(t),s){const r=this._clip.duration,i=e._clip.duration,o=i/r,a=r/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,s){return e.crossFadeFrom(this,t,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,s){const r=this._mixer,i=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,u=a.sampleValues;return l[0]=i,l[1]=i+s,u[0]=e/o,u[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,s,r){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const l=(e-i)*s;l<0||s===0?t=0:(this._startTime=null,t=s*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,u=this._propertyBindings;switch(this.blendMode){case iI:for(let c=0,h=l.length;c!==h;++c)l[c].evaluate(o),u[c].accumulateAdditive(a);break;case XS:default:for(let c=0,h=l.length;c!==h;++c)l[c].evaluate(o),u[c].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const s=this._weightInterpolant;if(s!==null){const r=s.evaluate(e)[0];t*=r,e>s.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const r=s.evaluate(e)[0];t*=r,e>s.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,s=this.loop;let r=this.time+e,i=this._loopCount;const o=s===A3;if(e===0)return i===-1?r:o&&(i&1)===1?t-r:r;if(s===I3){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,i+=Math.abs(a);const l=this.repetitions-i;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const u=e<0;this._setEndings(u,!u,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(i&1)===1)return t-r}return r}_setEndings(e,t,s){const r=this._interpolantSettings;s?(r.endingStart=gf,r.endingEnd=gf):(e?r.endingStart=this.zeroSlopeAtStart?gf:mf:r.endingStart=S0,t?r.endingEnd=this.zeroSlopeAtEnd?gf:mf:r.endingEnd=S0)}_scheduleFading(e,t,s){const r=this._mixer,i=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,l[0]=t,a[1]=i+e,l[1]=s,this}}const Iq=new Float32Array(1);class Nq extends xc{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const s=e._localRoot||this._root,r=e._clip.tracks,i=r.length,o=e._propertyBindings,a=e._interpolants,l=s.uuid,u=this._bindingsByRootAndName;let c=u[l];c===void 0&&(c={},u[l]=c);for(let h=0;h!==i;++h){const f=r[h],p=f.name;let g=c[p];if(g!==void 0)++g.referenceCount,o[h]=g;else{if(g=o[h],g!==void 0){g._cacheIndex===null&&(++g.referenceCount,this._addInactiveBinding(g,l,p));continue}const S=t&&t._propertyBindings[h].binding.parsedPath;g=new XO(Wn.create(s,p,S),f.ValueTypeName,f.getValueSize()),++g.referenceCount,this._addInactiveBinding(g,l,p),o[h]=g}a[h].resultBuffer=g.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,r=e._clip.uuid,i=this._actionsByClip[r];this._bindAction(e,i&&i.knownActions[0]),this._addInactiveAction(e,r,s)}const t=e._propertyBindings;for(let s=0,r=t.length;s!==r;++s){const i=t[s];i.useCount++===0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let s=0,r=t.length;s!==r;++s){const i=t[s];--i.useCount===0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,s){const r=this._actions,i=this._actionsByClip;let o=i[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,i[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[s]=e}_removeInactiveAction(e){const t=this._actions,s=t[t.length-1],r=e._cacheIndex;s._cacheIndex=r,t[r]=s,t.pop(),e._cacheIndex=null;const i=e._clip.uuid,o=this._actionsByClip,a=o[i],l=a.knownActions,u=l[l.length-1],c=e._byClipCacheIndex;u._byClipCacheIndex=c,l[c]=u,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,f=(e._localRoot||this._root).uuid;delete h[f],l.length===0&&delete o[i],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let s=0,r=t.length;s!==r;++s){const i=t[s];--i.referenceCount===0&&this._removeInactiveBinding(i)}}_lendAction(e){const t=this._actions,s=e._cacheIndex,r=this._nActiveActions++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_takeBackAction(e){const t=this._actions,s=e._cacheIndex,r=--this._nActiveActions,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_addInactiveBinding(e,t,s){const r=this._bindingsByRootAndName,i=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[s]=e,e._cacheIndex=i.length,i.push(e)}_removeInactiveBinding(e){const t=this._bindings,s=e.binding,r=s.rootNode.uuid,i=s.path,o=this._bindingsByRootAndName,a=o[r],l=t[t.length-1],u=e._cacheIndex;l._cacheIndex=u,t[u]=l,t.pop(),delete a[i],Object.keys(a).length===0&&delete o[r]}_lendBinding(e){const t=this._bindings,s=e._cacheIndex,r=this._nActiveBindings++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_takeBackBinding(e){const t=this._bindings,s=e._cacheIndex,r=--this._nActiveBindings,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let s=e[t];return s===void 0&&(s=new AI(new Float32Array(2),new Float32Array(2),1,Iq),s.__cacheIndex=t,e[t]=s),s}_takeBackControlInterpolant(e){const t=this._controlInterpolants,s=e.__cacheIndex,r=--this._nActiveControlInterpolants,i=t[r];e.__cacheIndex=r,t[r]=e,i.__cacheIndex=s,t[s]=i}clipAction(e,t,s){const r=t||this._root,i=r.uuid;let o=typeof e=="string"?P0.findByName(r,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let u=null;if(s===void 0&&(o!==null?s=o.blendMode:s=XS),l!==void 0){const h=l.actionByRoot[i];if(h!==void 0&&h.blendMode===s)return h;u=l.knownActions[0],o===null&&(o=u._clip)}if(o===null)return null;const c=new qO(this,o,t,s);return this._bindAction(c,u),this._addInactiveAction(c,a,i),c}existingAction(e,t){const s=t||this._root,r=s.uuid,i=typeof e=="string"?P0.findByName(s,e):e,o=i?i.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let s=t-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const t=this._actions,s=this._nActiveActions,r=this.time+=e,i=Math.sign(e),o=this._accuIndex^=1;for(let u=0;u!==s;++u)t[u]._update(r,e,i,o);const a=this._bindings,l=this._nActiveBindings;for(let u=0;u!==l;++u)a[u].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,s=e.uuid,r=this._actionsByClip,i=r[s];if(i!==void 0){const o=i.knownActions;for(let a=0,l=o.length;a!==l;++a){const u=o[a];this._deactivateAction(u);const c=u._cacheIndex,h=t[t.length-1];u._cacheIndex=null,u._byClipCacheIndex=null,h._cacheIndex=c,t[c]=h,t.pop(),this._removeInactiveBindingsForAction(u)}delete r[s]}}uncacheRoot(e){const t=e.uuid,s=this._actionsByClip;for(const o in s){const a=s[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,i=r[t];if(i!==void 0)for(const o in i){const a=i[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const s=this.existingAction(e,t);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}class FI{constructor(e){this.value=e}clone(){return new FI(this.value.clone===void 0?this.value:this.value.clone())}}let Aq=0;class Mq extends xc{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:Aq++}),this.name="",this.usage=C0,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let s=0,r=t.length;s<r;s++){const i=Array.isArray(t[s])?t[s]:[t[s]];for(let o=0;o<i.length;o++)this.uniforms.push(i[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class kq extends QS{constructor(e,t,s=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class Rq{constructor(e,t,s,r,i){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=s,this.elementSize=r,this.count=i,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class KO{constructor(e,t,s=0,r=1/0){this.ray=new Tg(e,t),this.near=s,this.far=r,this.camera=null,this.layers=new Cf,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,s=[]){return KE(e,this,s,t),s.sort(iD),s}intersectObjects(e,t=!0,s=[]){for(let r=0,i=e.length;r<i;r++)KE(e[r],this,s,t);return s.sort(iD),s}}function iD(n,e){return n.distance-e.distance}function KE(n,e,t,s){if(n.layers.test(e.layers)&&n.raycast(e,t),s===!0){const r=n.children;for(let i=0,o=r.length;i<o;i++)KE(r[i],e,t,!0)}}class YO{constructor(e=1,t=0,s=0){return this.radius=e,this.phi=t,this.theta=s,this}set(e,t,s){return this.radius=e,this.phi=t,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+t*t+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(Ws(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Dq{constructor(e=1,t=0,s=0){return this.radius=e,this.theta=t,this.y=s,this}set(e,t,s){return this.radius=e,this.theta=t,this.y=s,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+s*s),this.theta=Math.atan2(e,s),this.y=t,this}clone(){return new this.constructor().copy(this)}}const oD=new Je;class Pq{constructor(e=new Je(1/0,1/0),t=new Je(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=oD.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,oD).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const aD=new re,pw=new re;class Lq{constructor(e=new re,t=new re){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){aD.subVectors(e,this.start),pw.subVectors(this.end,this.start);const s=pw.dot(pw);let i=pw.dot(aD)/s;return t&&(i=Ws(i,0,1)),i}closestPointToPoint(e,t,s){const r=this.closestPointToPointParameter(e,t);return this.delta(s).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const lD=new re;class Oq extends zn{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const s=new bn,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const u=o/l*Math.PI*2,c=a/l*Math.PI*2;r.push(Math.cos(u),Math.sin(u),1,Math.cos(c),Math.sin(c),1)}s.setAttribute("position",new $t(r,3));const i=new oo({fog:!1,toneMapped:!1});this.cone=new gu(s,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),lD.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(lD),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const gh=new re,mw=new ln,CC=new ln;class Fq extends gu{constructor(e){const t=ZO(e),s=new bn,r=[],i=[],o=new vt(0,0,1),a=new vt(0,1,0);for(let u=0;u<t.length;u++){const c=t[u];c.parent&&c.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}s.setAttribute("position",new $t(r,3)),s.setAttribute("color",new $t(i,3));const l=new oo({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,s=this.geometry,r=s.getAttribute("position");CC.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(mw.multiplyMatrices(CC,a.matrixWorld),gh.setFromMatrixPosition(mw),r.setXYZ(o,gh.x,gh.y,gh.z),mw.multiplyMatrices(CC,a.parent.matrixWorld),gh.setFromMatrixPosition(mw),r.setXYZ(o+1,gh.x,gh.y,gh.z),o+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function ZO(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,ZO(n.children[t]));return e}class $q extends Dr{constructor(e,t,s){const r=new Ag(t,4,2),i=new qh({wireframe:!0,fog:!1,toneMapped:!1});super(r,i),this.light=e,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const zq=new re,uD=new vt,cD=new vt;class Uq extends zn{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="HemisphereLightHelper";const r=new lx(t);r.rotateY(Math.PI*.5),this.material=new qh({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=r.getAttribute("position"),o=new Float32Array(i.count*3);r.setAttribute("color",new Qn(o,3)),this.add(new Dr(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");uD.copy(this.light.color),cD.copy(this.light.groundColor);for(let s=0,r=t.count;s<r;s++){const i=s<r/2?uD:cD;t.setXYZ(s,i.r,i.g,i.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(zq.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Bq extends gu{constructor(e=10,t=10,s=4473924,r=8947848){s=new vt(s),r=new vt(r);const i=t/2,o=e/t,a=e/2,l=[],u=[];for(let f=0,p=0,g=-a;f<=t;f++,g+=o){l.push(-a,0,g,a,0,g),l.push(g,0,-a,g,0,a);const S=f===i?s:r;S.toArray(u,p),p+=3,S.toArray(u,p),p+=3,S.toArray(u,p),p+=3,S.toArray(u,p),p+=3}const c=new bn;c.setAttribute("position",new $t(l,3)),c.setAttribute("color",new $t(u,3));const h=new oo({vertexColors:!0,toneMapped:!1});super(c,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class Vq extends gu{constructor(e=10,t=16,s=8,r=64,i=4473924,o=8947848){i=new vt(i),o=new vt(o);const a=[],l=[];if(t>1)for(let h=0;h<t;h++){const f=h/t*(Math.PI*2),p=Math.sin(f)*e,g=Math.cos(f)*e;a.push(0,0,0),a.push(p,0,g);const S=h&1?i:o;l.push(S.r,S.g,S.b),l.push(S.r,S.g,S.b)}for(let h=0;h<s;h++){const f=h&1?i:o,p=e-e/s*h;for(let g=0;g<r;g++){let S=g/r*(Math.PI*2),x=Math.sin(S)*p,w=Math.cos(S)*p;a.push(x,0,w),l.push(f.r,f.g,f.b),S=(g+1)/r*(Math.PI*2),x=Math.sin(S)*p,w=Math.cos(S)*p,a.push(x,0,w),l.push(f.r,f.g,f.b)}}const u=new bn;u.setAttribute("position",new $t(a,3)),u.setAttribute("color",new $t(l,3));const c=new oo({vertexColors:!0,toneMapped:!1});super(u,c),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const hD=new re,gw=new re,dD=new re;class Wq extends zn{constructor(e,t,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",t===void 0&&(t=1);let r=new bn;r.setAttribute("position",new $t([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new oo({fog:!1,toneMapped:!1});this.lightPlane=new Dh(r,i),this.add(this.lightPlane),r=new bn,r.setAttribute("position",new $t([0,0,0,0,0,1],3)),this.targetLine=new Dh(r,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),hD.setFromMatrixPosition(this.light.matrixWorld),gw.setFromMatrixPosition(this.light.target.matrixWorld),dD.subVectors(gw,hD),this.lightPlane.lookAt(gw),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(gw),this.targetLine.scale.z=dD.length()}}const yw=new re,Vs=new nx;class Gq extends gu{constructor(e){const t=new bn,s=new oo({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],i=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(g,S){l(g),l(S)}function l(g){r.push(0,0,0),i.push(0,0,0),o[g]===void 0&&(o[g]=[]),o[g].push(r.length/3-1)}t.setAttribute("position",new $t(r,3)),t.setAttribute("color",new $t(i,3)),super(t,s),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const u=new vt(16755200),c=new vt(16711680),h=new vt(43775),f=new vt(16777215),p=new vt(3355443);this.setColors(u,c,h,f,p)}setColors(e,t,s,r,i){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,s.r,s.g,s.b),a.setXYZ(33,s.r,s.g,s.b),a.setXYZ(34,s.r,s.g,s.b),a.setXYZ(35,s.r,s.g,s.b),a.setXYZ(36,s.r,s.g,s.b),a.setXYZ(37,s.r,s.g,s.b),a.setXYZ(38,r.r,r.g,r.b),a.setXYZ(39,r.r,r.g,r.b),a.setXYZ(40,i.r,i.g,i.b),a.setXYZ(41,i.r,i.g,i.b),a.setXYZ(42,i.r,i.g,i.b),a.setXYZ(43,i.r,i.g,i.b),a.setXYZ(44,i.r,i.g,i.b),a.setXYZ(45,i.r,i.g,i.b),a.setXYZ(46,i.r,i.g,i.b),a.setXYZ(47,i.r,i.g,i.b),a.setXYZ(48,i.r,i.g,i.b),a.setXYZ(49,i.r,i.g,i.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,s=1,r=1;Vs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),nr("c",t,e,Vs,0,0,-1),nr("t",t,e,Vs,0,0,1),nr("n1",t,e,Vs,-s,-r,-1),nr("n2",t,e,Vs,s,-r,-1),nr("n3",t,e,Vs,-s,r,-1),nr("n4",t,e,Vs,s,r,-1),nr("f1",t,e,Vs,-s,-r,1),nr("f2",t,e,Vs,s,-r,1),nr("f3",t,e,Vs,-s,r,1),nr("f4",t,e,Vs,s,r,1),nr("u1",t,e,Vs,s*.7,r*1.1,-1),nr("u2",t,e,Vs,-s*.7,r*1.1,-1),nr("u3",t,e,Vs,0,r*2,-1),nr("cf1",t,e,Vs,-s,0,1),nr("cf2",t,e,Vs,s,0,1),nr("cf3",t,e,Vs,0,-r,1),nr("cf4",t,e,Vs,0,r,1),nr("cn1",t,e,Vs,-s,0,-1),nr("cn2",t,e,Vs,s,0,-1),nr("cn3",t,e,Vs,0,-r,-1),nr("cn4",t,e,Vs,0,r,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function nr(n,e,t,s,r,i,o){yw.set(r,i,o).unproject(s);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let u=0,c=a.length;u<c;u++)l.setXYZ(a[u],yw.x,yw.y,yw.z)}}const xw=new so;class Hq extends gu{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),i=new bn;i.setIndex(new Qn(s,1)),i.setAttribute("position",new Qn(r,3)),super(i,new oo({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&xw.setFromObject(this.object),xw.isEmpty())return;const t=xw.min,s=xw.max,r=this.geometry.attributes.position,i=r.array;i[0]=s.x,i[1]=s.y,i[2]=s.z,i[3]=t.x,i[4]=s.y,i[5]=s.z,i[6]=t.x,i[7]=t.y,i[8]=s.z,i[9]=s.x,i[10]=t.y,i[11]=s.z,i[12]=s.x,i[13]=s.y,i[14]=t.z,i[15]=t.x,i[16]=s.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=s.x,i[22]=t.y,i[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class jq extends gu{constructor(e,t=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],i=new bn;i.setIndex(new Qn(s,1)),i.setAttribute("position",new $t(r,3)),super(i,new oo({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class Xq extends Dh{constructor(e,t=1,s=16776960){const r=s,i=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new bn;o.setAttribute("position",new $t(i,3)),o.computeBoundingSphere(),super(o,new oo({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new bn;l.setAttribute("position",new $t(a,3)),l.computeBoundingSphere(),this.add(new Dr(l,new qh({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const fD=new re;let vw,EC;class qq extends zn{constructor(e=new re(0,0,1),t=new re(0,0,0),s=1,r=16776960,i=s*.2,o=i*.2){super(),this.type="ArrowHelper",vw===void 0&&(vw=new bn,vw.setAttribute("position",new $t([0,0,0,0,1,0],3)),EC=new Ig(0,.5,1,5,1),EC.translate(0,-.5,0)),this.position.copy(t),this.line=new Dh(vw,new oo({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Dr(EC,new qh({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(s,i,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{fD.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(fD,t)}}setLength(e,t=e*.2,s=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(s,t,s),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class Kq extends gu{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new bn;r.setAttribute("position",new $t(t,3)),r.setAttribute("color",new $t(s,3));const i=new oo({vertexColors:!0,toneMapped:!1});super(r,i),this.type="AxesHelper"}setColors(e,t,s){const r=new vt,i=this.geometry.attributes.color.array;return r.set(e),r.toArray(i,0),r.toArray(i,3),r.set(t),r.toArray(i,6),r.toArray(i,9),r.set(s),r.toArray(i,12),r.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Yq{constructor(){this.type="ShapePath",this.color=new vt,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new N0,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,s,r){return this.currentPath.quadraticCurveTo(e,t,s,r),this}bezierCurveTo(e,t,s,r,i,o){return this.currentPath.bezierCurveTo(e,t,s,r,i,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(w){const _=[];for(let T=0,C=w.length;T<C;T++){const N=w[T],M=new lc;M.curves=N.curves,_.push(M)}return _}function s(w,_){const T=_.length;let C=!1;for(let N=T-1,M=0;M<T;N=M++){let P=_[N],$=_[M],R=$.x-P.x,D=$.y-P.y;if(Math.abs(D)>Number.EPSILON){if(D<0&&(P=_[M],R=-R,$=_[N],D=-D),w.y<P.y||w.y>$.y)continue;if(w.y===P.y){if(w.x===P.x)return!0}else{const L=D*(w.x-P.x)-R*(w.y-P.y);if(L===0)return!0;if(L<0)continue;C=!C}}else{if(w.y!==P.y)continue;if($.x<=w.x&&w.x<=P.x||P.x<=w.x&&w.x<=$.x)return!0}}return C}const r=au.isClockWise,i=this.subPaths;if(i.length===0)return[];let o,a,l;const u=[];if(i.length===1)return a=i[0],l=new lc,l.curves=a.curves,u.push(l),u;let c=!r(i[0].getPoints());c=e?!c:c;const h=[],f=[];let p=[],g=0,S;f[g]=void 0,p[g]=[];for(let w=0,_=i.length;w<_;w++)a=i[w],S=a.getPoints(),o=r(S),o=e?!o:o,o?(!c&&f[g]&&g++,f[g]={s:new lc,p:S},f[g].s.curves=a.curves,c&&g++,p[g]=[]):p[g].push({h:a,p:S[0]});if(!f[0])return t(i);if(f.length>1){let w=!1,_=0;for(let T=0,C=f.length;T<C;T++)h[T]=[];for(let T=0,C=f.length;T<C;T++){const N=p[T];for(let M=0;M<N.length;M++){const P=N[M];let $=!0;for(let R=0;R<f.length;R++)s(P.p,f[R].p)&&(T!==R&&_++,$?($=!1,h[R].push(P)):w=!0);$&&h[T].push(P)}}_>0&&w===!1&&(p=h)}let x;for(let w=0,_=f.length;w<_;w++){l=f[w].s,u.push(l),x=p[w];for(let T=0,C=x.length;T<C;T++)l.holes.push(x[T].h)}return u}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Q0}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Q0);const Zq=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:GS,AddEquation:wh,AddOperation:d3,AdditiveAnimationBlendMode:iI,AdditiveBlending:sS,AgXToneMapping:y3,AlphaFormat:S3,AlwaysCompare:z3,AlwaysDepth:i3,AlwaysStencilFunc:zE,AmbientLight:UO,AnimationAction:qO,AnimationClip:P0,AnimationLoader:eq,AnimationMixer:Nq,AnimationObjectGroup:Eq,AnimationUtils:YX,ArcCurve:hO,ArrayCamera:tO,ArrowHelper:qq,AttachedBindMode:fE,Audio:jO,AudioAnalyser:gq,AudioContext:DI,AudioListener:fq,AudioLoader:cq,AxesHelper:Kq,BackSide:no,BasicDepthPacking:M3,BasicShadowMap:BL,BatchedMesh:lO,Bone:vI,BooleanKeyframeTrack:Xf,Box2:Pq,Box3:so,Box3Helper:jq,BoxGeometry:Kh,BoxHelper:Hq,BufferAttribute:Qn,BufferGeometry:bn,BufferGeometryLoader:HO,ByteType:v3,Cache:oc,Camera:nx,CameraHelper:Gq,CanvasTexture:I0,CapsuleGeometry:sb,CatmullRomCurve3:bI,CineonToneMapping:m3,CircleGeometry:rb,ClampToEdgeWrapping:Pi,Clock:PI,Color:vt,ColorKeyframeTrack:MI,ColorManagement:Zn,CompressedArrayTexture:vX,CompressedCubeTexture:wX,CompressedTexture:tb,CompressedTextureLoader:tq,ConeGeometry:ib,ConstantAlphaFactor:n3,ConstantColorFactor:e3,CubeCamera:j3,CubeReflectionMapping:dc,CubeRefractionMapping:kh,CubeTexture:sx,CubeTextureLoader:nq,CubeUVReflectionMapping:_g,CubicBezierCurve:_I,CubicBezierCurve3:dO,CubicInterpolant:kO,CullFaceBack:lE,CullFaceFront:UL,CullFaceFrontBack:uG,CullFaceNone:zL,Curve:Al,CurvePath:pO,CustomBlending:VL,CustomToneMapping:g3,CylinderGeometry:Ig,Cylindrical:Dq,Data3DTexture:cI,DataArrayTexture:KS,DataTexture:Ef,DataTextureLoader:sq,DataUtils:xH,DecrementStencilOp:SG,DecrementWrapStencilOp:_G,DefaultLoadingManager:PO,DepthFormat:Ch,DepthStencilFormat:Mf,DepthTexture:pI,DetachedBindMode:x3,DirectionalLight:zO,DirectionalLightHelper:Wq,DiscreteInterpolant:RO,DisplayP3ColorSpace:qS,DodecahedronGeometry:ob,DoubleSide:su,DstAlphaFactor:KL,DstColorFactor:ZL,DynamicCopyUsage:$G,DynamicDrawUsage:RG,DynamicReadUsage:LG,EdgesGeometry:mO,EllipseCurve:nb,EqualCompare:L3,EqualDepth:a3,EqualStencilFunc:IG,EquirectangularReflectionMapping:g0,EquirectangularRefractionMapping:y0,Euler:Cg,EventDispatcher:xc,ExtrudeGeometry:Ng,FileLoader:fc,Float16BufferAttribute:TH,Float32BufferAttribute:$t,Float64BufferAttribute:CH,FloatType:xl,Fog:JS,FogExp2:ZS,FramebufferTexture:xX,FrontSide:hc,Frustum:rx,GLBufferAttribute:Rq,GLSL1:UG,GLSL3:UE,GreaterCompare:O3,GreaterDepth:u3,GreaterEqualCompare:$3,GreaterEqualDepth:l3,GreaterEqualStencilFunc:kG,GreaterStencilFunc:AG,GridHelper:Bq,Group:jm,HalfFloatType:rg,HemisphereLight:OO,HemisphereLightHelper:Uq,IcosahedronGeometry:lb,ImageBitmapLoader:uq,ImageLoader:L0,ImageUtils:uI,IncrementStencilOp:wG,IncrementWrapStencilOp:bG,InstancedBufferAttribute:lg,InstancedBufferGeometry:GO,InstancedInterleavedBuffer:kq,InstancedMesh:aO,Int16BufferAttribute:bH,Int32BufferAttribute:_H,Int8BufferAttribute:vH,IntType:J2,InterleavedBuffer:QS,InterleavedBufferAttribute:kf,Interpolant:cx,InterpolateDiscrete:v0,InterpolateLinear:w0,InterpolateSmooth:Vw,InvertStencilOp:TG,KeepStencilOp:af,KeyframeTrack:Ml,LOD:iO,LatheGeometry:ax,Layers:Cf,LessCompare:P3,LessDepth:o3,LessEqualCompare:aI,LessEqualDepth:m0,LessEqualStencilFunc:NG,LessStencilFunc:EG,Light:Zh,LightProbe:WO,Line:Dh,Line3:Lq,LineBasicMaterial:oo,LineCurve:TI,LineCurve3:fO,LineDashedMaterial:NO,LineLoop:uO,LineSegments:gu,LinearDisplayP3ColorSpace:tx,LinearEncoding:oI,LinearFilter:rr,LinearInterpolant:AI,LinearMipMapLinearFilter:pG,LinearMipMapNearestFilter:fG,LinearMipmapLinearFilter:Rh,LinearMipmapNearestFilter:Z2,LinearSRGBColorSpace:du,LinearToneMapping:f3,LinearTransfer:b0,Loader:Bo,LoaderUtils:qE,LoadingManager:kI,LoopOnce:I3,LoopPingPong:A3,LoopRepeat:N3,LuminanceAlphaFormat:_3,LuminanceFormat:b3,MOUSE:aG,Material:xi,MaterialLoader:mb,MathUtils:Qu,Matrix3:_n,Matrix4:ln,MaxEquation:dE,Mesh:Dr,MeshBasicMaterial:qh,MeshDepthMaterial:mI,MeshDistanceMaterial:gI,MeshLambertMaterial:EO,MeshMatcapMaterial:IO,MeshNormalMaterial:CO,MeshPhongMaterial:_O,MeshPhysicalMaterial:bO,MeshStandardMaterial:pb,MeshToonMaterial:TO,MinEquation:hE,MirroredRepeatWrapping:x0,MixOperation:h3,MultiplyBlending:cE,MultiplyOperation:ex,NearestFilter:sr,NearestMipMapLinearFilter:dG,NearestMipMapNearestFilter:hG,NearestMipmapLinearFilter:u0,NearestMipmapNearestFilter:oS,NeverCompare:D3,NeverDepth:r3,NeverStencilFunc:CG,NoBlending:ac,NoColorSpace:sa,NoToneMapping:iu,NormalAnimationBlendMode:XS,NormalBlending:_f,NotEqualCompare:F3,NotEqualDepth:c3,NotEqualStencilFunc:MG,NumberKeyframeTrack:R0,Object3D:zn,ObjectLoader:aq,ObjectSpaceNormalMap:R3,OctahedronGeometry:lx,OneFactor:jL,OneMinusConstantAlphaFactor:s3,OneMinusConstantColorFactor:t3,OneMinusDstAlphaFactor:YL,OneMinusDstColorFactor:JL,OneMinusSrcAlphaFactor:iS,OneMinusSrcColorFactor:qL,OrthographicCamera:ox,P3Primaries:T0,PCFShadowMap:WS,PCFSoftShadowMap:l0,PMREMGenerator:VE,Path:N0,PerspectiveCamera:jr,Plane:xh,PlaneGeometry:ix,PlaneHelper:Xq,PointLight:$O,PointLightHelper:$q,Points:cO,PointsMaterial:wI,PolarGridHelper:Vq,PolyhedronGeometry:Yh,PositionalAudio:mq,PropertyBinding:Wn,PropertyMixer:XO,QuadraticBezierCurve:CI,QuadraticBezierCurve3:EI,Quaternion:Do,QuaternionKeyframeTrack:Mg,QuaternionLinearInterpolant:DO,RED_GREEN_RGTC2_Format:FE,RED_RGTC1_Format:E3,REVISION:Q0,RGBADepthPacking:k3,RGBAFormat:eo,RGBAIntegerFormat:sI,RGBA_ASTC_10x10_Format:kE,RGBA_ASTC_10x5_Format:NE,RGBA_ASTC_10x6_Format:AE,RGBA_ASTC_10x8_Format:ME,RGBA_ASTC_12x10_Format:RE,RGBA_ASTC_12x12_Format:DE,RGBA_ASTC_4x4_Format:wE,RGBA_ASTC_5x4_Format:SE,RGBA_ASTC_5x5_Format:bE,RGBA_ASTC_6x5_Format:_E,RGBA_ASTC_6x6_Format:TE,RGBA_ASTC_8x5_Format:CE,RGBA_ASTC_8x6_Format:EE,RGBA_ASTC_8x8_Format:IE,RGBA_BPTC_Format:Bw,RGBA_ETC2_EAC_Format:vE,RGBA_PVRTC_2BPPV1_Format:yE,RGBA_PVRTC_4BPPV1_Format:gE,RGBA_S3TC_DXT1_Format:$w,RGBA_S3TC_DXT3_Format:zw,RGBA_S3TC_DXT5_Format:Uw,RGB_BPTC_SIGNED_Format:PE,RGB_BPTC_UNSIGNED_Format:LE,RGB_ETC1_Format:rI,RGB_ETC2_Format:xE,RGB_PVRTC_2BPPV1_Format:mE,RGB_PVRTC_4BPPV1_Format:pE,RGB_S3TC_DXT1_Format:Fw,RGFormat:C3,RGIntegerFormat:nI,RawShaderMaterial:SO,Ray:Tg,Raycaster:KO,Rec709Primaries:_0,RectAreaLight:BO,RedFormat:T3,RedIntegerFormat:tI,ReinhardToneMapping:p3,RenderTarget:V3,RepeatWrapping:Af,ReplaceStencilOp:vG,ReverseSubtractEquation:GL,RingGeometry:ub,SIGNED_RED_GREEN_RGTC2_Format:$E,SIGNED_RED_RGTC1_Format:OE,SRGBColorSpace:kr,SRGBTransfer:ms,Scene:uS,ShaderChunk:wn,ShaderLib:ml,ShaderMaterial:Tl,ShadowMaterial:wO,Shape:lc,ShapeGeometry:cb,ShapePath:Yq,ShapeUtils:au,ShortType:w3,Skeleton:eb,SkeletonHelper:Fq,SkinnedMesh:oO,Source:yf,Sphere:Fi,SphereGeometry:Ag,Spherical:YO,SphericalHarmonics3:VO,SplineCurve:II,SpotLight:FO,SpotLightHelper:Oq,Sprite:rO,SpriteMaterial:xI,SrcAlphaFactor:rS,SrcAlphaSaturateFactor:QL,SrcColorFactor:XL,StaticCopyUsage:FG,StaticDrawUsage:C0,StaticReadUsage:PG,StereoCamera:hq,StreamCopyUsage:zG,StreamDrawUsage:DG,StreamReadUsage:OG,StringKeyframeTrack:qf,SubtractEquation:WL,SubtractiveBlending:uE,TOUCH:lG,TangentSpaceNormalMap:Xh,TetrahedronGeometry:hb,Texture:Hs,TextureLoader:LO,TorusGeometry:db,TorusKnotGeometry:fb,Triangle:No,TriangleFanDrawMode:yG,TriangleStripDrawMode:gG,TrianglesDrawMode:mG,TubeGeometry:ux,TwoPassDoubleSide:cG,UVMapping:HS,Uint16BufferAttribute:hI,Uint32BufferAttribute:dI,Uint8BufferAttribute:wH,Uint8ClampedBufferAttribute:SH,Uniform:FI,UniformsGroup:Mq,UniformsLib:mt,UniformsUtils:H3,UnsignedByteType:ou,UnsignedInt248Type:Th,UnsignedIntType:ic,UnsignedShort4444Type:Q2,UnsignedShort5551Type:eI,UnsignedShortType:jS,VSMShadowMap:pl,Vector2:Je,Vector3:re,Vector4:Jn,VectorKeyframeTrack:D0,VideoTexture:yX,WebGL1Renderer:nO,WebGL3DRenderTarget:oH,WebGLArrayRenderTarget:iH,WebGLCoordinateSystem:vl,WebGLCubeRenderTarget:X3,WebGLMultipleRenderTargets:aH,WebGLRenderTarget:_l,WebGLRenderer:yI,WebGLUtils:eO,WebGPUCoordinateSystem:ig,WireframeGeometry:vO,WrapAroundEnding:S0,ZeroCurvatureEnding:mf,ZeroFactor:HL,ZeroSlopeEnding:gf,ZeroStencilOp:xG,_SRGBAFormat:aS,createCanvasElement:B3,sRGBEncoding:Eh},Symbol.toStringTag,{value:"Module"}));var IC={exports:{}},yh={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pD;function Jq(){return pD||(pD=1,yh.ConcurrentRoot=1,yh.ContinuousEventPriority=4,yh.DefaultEventPriority=16,yh.DiscreteEventPriority=1,yh.IdleEventPriority=536870912,yh.LegacyRoot=0),yh}var mD;function Qq(){return mD||(mD=1,IC.exports=Jq()),IC.exports}var qm=Qq();function e9(n){let e;const t=new Set,s=(u,c)=>{const h=typeof u=="function"?u(e):u;if(h!==e){const f=e;e=c?h:Object.assign({},e,h),t.forEach(p=>p(e,f))}},r=()=>e,i=(u,c=r,h=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let f=c(e);function p(){const g=c(e);if(!h(f,g)){const S=f;u(f=g,S)}}return t.add(p),()=>t.delete(p)},l={setState:s,getState:r,subscribe:(u,c,h)=>c||h?i(u,c,h):(t.add(u),()=>t.delete(u)),destroy:()=>t.clear()};return e=n(s,r,l),l}const t9=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),gD=t9?Ee.useEffect:Ee.useLayoutEffect;function n9(n){const e=typeof n=="function"?e9(n):n,t=(s=e.getState,r=Object.is)=>{const[,i]=Ee.useReducer(x=>x+1,0),o=e.getState(),a=Ee.useRef(o),l=Ee.useRef(s),u=Ee.useRef(r),c=Ee.useRef(!1),h=Ee.useRef();h.current===void 0&&(h.current=s(o));let f,p=!1;(a.current!==o||l.current!==s||u.current!==r||c.current)&&(f=s(o),p=!r(h.current,f)),gD(()=>{p&&(h.current=f),a.current=o,l.current=s,u.current=r,c.current=!1});const g=Ee.useRef(o);gD(()=>{const x=()=>{try{const _=e.getState(),T=l.current(_);u.current(h.current,T)||(a.current=_,h.current=T,i())}catch{c.current=!0,i()}},w=e.subscribe(x);return e.getState()!==g.current&&x(),w},[]);const S=p?f:h.current;return Ee.useDebugValue(S),S};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const s=[t,e];return{next(){const r=s.length<=0;return{value:s.shift(),done:r}}}},t}var NC={exports:{}},AC={exports:{}},MC={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yD;function s9(){return yD||(yD=1,(function(n){function e(V,Y){var B=V.length;V.push(Y);e:for(;0<B;){var K=B-1>>>1,se=V[K];if(0<r(se,Y))V[K]=Y,V[B]=se,B=K;else break e}}function t(V){return V.length===0?null:V[0]}function s(V){if(V.length===0)return null;var Y=V[0],B=V.pop();if(B!==Y){V[0]=B;e:for(var K=0,se=V.length,te=se>>>1;K<te;){var ue=2*(K+1)-1,fe=V[ue],_e=ue+1,Ie=V[_e];if(0>r(fe,B))_e<se&&0>r(Ie,fe)?(V[K]=Ie,V[_e]=B,K=_e):(V[K]=fe,V[ue]=B,K=ue);else if(_e<se&&0>r(Ie,B))V[K]=Ie,V[_e]=B,K=_e;else break e}}return Y}function r(V,Y){var B=V.sortIndex-Y.sortIndex;return B!==0?B:V.id-Y.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,h=null,f=3,p=!1,g=!1,S=!1,x=typeof setTimeout=="function"?setTimeout:null,w=typeof clearTimeout=="function"?clearTimeout:null,_=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function T(V){for(var Y=t(u);Y!==null;){if(Y.callback===null)s(u);else if(Y.startTime<=V)s(u),Y.sortIndex=Y.expirationTime,e(l,Y);else break;Y=t(u)}}function C(V){if(S=!1,T(V),!g)if(t(l)!==null)g=!0,J(N);else{var Y=t(u);Y!==null&&ie(C,Y.startTime-V)}}function N(V,Y){g=!1,S&&(S=!1,w($),$=-1),p=!0;var B=f;try{for(T(Y),h=t(l);h!==null&&(!(h.expirationTime>Y)||V&&!L());){var K=h.callback;if(typeof K=="function"){h.callback=null,f=h.priorityLevel;var se=K(h.expirationTime<=Y);Y=n.unstable_now(),typeof se=="function"?h.callback=se:h===t(l)&&s(l),T(Y)}else s(l);h=t(l)}if(h!==null)var te=!0;else{var ue=t(u);ue!==null&&ie(C,ue.startTime-Y),te=!1}return te}finally{h=null,f=B,p=!1}}var M=!1,P=null,$=-1,R=5,D=-1;function L(){return!(n.unstable_now()-D<R)}function G(){if(P!==null){var V=n.unstable_now();D=V;var Y=!0;try{Y=P(!0,V)}finally{Y?Q():(M=!1,P=null)}}else M=!1}var Q;if(typeof _=="function")Q=function(){_(G)};else if(typeof MessageChannel<"u"){var W=new MessageChannel,H=W.port2;W.port1.onmessage=G,Q=function(){H.postMessage(null)}}else Q=function(){x(G,0)};function J(V){P=V,M||(M=!0,Q())}function ie(V,Y){$=x(function(){V(n.unstable_now())},Y)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(V){V.callback=null},n.unstable_continueExecution=function(){g||p||(g=!0,J(N))},n.unstable_forceFrameRate=function(V){0>V||125<V?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<V?Math.floor(1e3/V):5},n.unstable_getCurrentPriorityLevel=function(){return f},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(V){switch(f){case 1:case 2:case 3:var Y=3;break;default:Y=f}var B=f;f=Y;try{return V()}finally{f=B}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(V,Y){switch(V){case 1:case 2:case 3:case 4:case 5:break;default:V=3}var B=f;f=V;try{return Y()}finally{f=B}},n.unstable_scheduleCallback=function(V,Y,B){var K=n.unstable_now();switch(typeof B=="object"&&B!==null?(B=B.delay,B=typeof B=="number"&&0<B?K+B:K):B=K,V){case 1:var se=-1;break;case 2:se=250;break;case 5:se=1073741823;break;case 4:se=1e4;break;default:se=5e3}return se=B+se,V={id:c++,callback:Y,priorityLevel:V,startTime:B,expirationTime:se,sortIndex:-1},B>K?(V.sortIndex=B,e(u,V),t(l)===null&&V===t(u)&&(S?(w($),$=-1):S=!0,ie(C,B-K))):(V.sortIndex=se,e(l,V),g||p||(g=!0,J(N))),V},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(V){var Y=f;return function(){var B=f;f=Y;try{return V.apply(this,arguments)}finally{f=B}}}})(MC)),MC}var xD;function JO(){return xD||(xD=1,AC.exports=s9()),AC.exports}/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kC,vD;function r9(){return vD||(vD=1,kC=function(e){var t={},s=J0(),r=JO(),i=Object.assign;function o(y){for(var v="https://reactjs.org/docs/error-decoder.html?invariant="+y,E=1;E<arguments.length;E++)v+="&args[]="+encodeURIComponent(arguments[E]);return"Minified React error #"+y+"; visit "+v+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,l=Symbol.for("react.element"),u=Symbol.for("react.portal"),c=Symbol.for("react.fragment"),h=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),g=Symbol.for("react.context"),S=Symbol.for("react.forward_ref"),x=Symbol.for("react.suspense"),w=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),T=Symbol.for("react.lazy"),C=Symbol.for("react.offscreen"),N=Symbol.iterator;function M(y){return y===null||typeof y!="object"?null:(y=N&&y[N]||y["@@iterator"],typeof y=="function"?y:null)}function P(y){if(y==null)return null;if(typeof y=="function")return y.displayName||y.name||null;if(typeof y=="string")return y;switch(y){case c:return"Fragment";case u:return"Portal";case f:return"Profiler";case h:return"StrictMode";case x:return"Suspense";case w:return"SuspenseList"}if(typeof y=="object")switch(y.$$typeof){case g:return(y.displayName||"Context")+".Consumer";case p:return(y._context.displayName||"Context")+".Provider";case S:var v=y.render;return y=y.displayName,y||(y=v.displayName||v.name||"",y=y!==""?"ForwardRef("+y+")":"ForwardRef"),y;case _:return v=y.displayName||null,v!==null?v:P(y.type)||"Memo";case T:v=y._payload,y=y._init;try{return P(y(v))}catch{}}return null}function $(y){var v=y.type;switch(y.tag){case 24:return"Cache";case 9:return(v.displayName||"Context")+".Consumer";case 10:return(v._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return y=v.render,y=y.displayName||y.name||"",v.displayName||(y!==""?"ForwardRef("+y+")":"ForwardRef");case 7:return"Fragment";case 5:return v;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return P(v);case 8:return v===h?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof v=="function")return v.displayName||v.name||null;if(typeof v=="string")return v}return null}function R(y){var v=y,E=y;if(y.alternate)for(;v.return;)v=v.return;else{y=v;do v=y,(v.flags&4098)!==0&&(E=v.return),y=v.return;while(y)}return v.tag===3?E:null}function D(y){if(R(y)!==y)throw Error(o(188))}function L(y){var v=y.alternate;if(!v){if(v=R(y),v===null)throw Error(o(188));return v!==y?null:y}for(var E=y,A=v;;){var O=E.return;if(O===null)break;var U=O.alternate;if(U===null){if(A=O.return,A!==null){E=A;continue}break}if(O.child===U.child){for(U=O.child;U;){if(U===E)return D(O),y;if(U===A)return D(O),v;U=U.sibling}throw Error(o(188))}if(E.return!==A.return)E=O,A=U;else{for(var oe=!1,ve=O.child;ve;){if(ve===E){oe=!0,E=O,A=U;break}if(ve===A){oe=!0,A=O,E=U;break}ve=ve.sibling}if(!oe){for(ve=U.child;ve;){if(ve===E){oe=!0,E=U,A=O;break}if(ve===A){oe=!0,A=U,E=O;break}ve=ve.sibling}if(!oe)throw Error(o(189))}}if(E.alternate!==A)throw Error(o(190))}if(E.tag!==3)throw Error(o(188));return E.stateNode.current===E?y:v}function G(y){return y=L(y),y!==null?Q(y):null}function Q(y){if(y.tag===5||y.tag===6)return y;for(y=y.child;y!==null;){var v=Q(y);if(v!==null)return v;y=y.sibling}return null}function W(y){if(y.tag===5||y.tag===6)return y;for(y=y.child;y!==null;){if(y.tag!==4){var v=W(y);if(v!==null)return v}y=y.sibling}return null}var H=Array.isArray,J=e.getPublicInstance,ie=e.getRootHostContext,V=e.getChildHostContext,Y=e.prepareForCommit,B=e.resetAfterCommit,K=e.createInstance,se=e.appendInitialChild,te=e.finalizeInitialChildren,ue=e.prepareUpdate,fe=e.shouldSetTextContent,_e=e.createTextInstance,Ie=e.scheduleTimeout,Ve=e.cancelTimeout,qe=e.noTimeout,Ye=e.isPrimaryRenderer,et=e.supportsMutation,ae=e.supportsPersistence,Be=e.supportsHydration,De=e.getInstanceFromNode,He=e.preparePortalMount,Re=e.getCurrentEventPriority,at=e.detachDeletedInstance,Qe=e.supportsMicrotasks,ee=e.scheduleMicrotask,X=e.supportsTestSelectors,Se=e.findFiberRoot,We=e.getBoundingRect,Xe=e.getTextContent,je=e.isHiddenSubtree,xt=e.matchAccessibilityRole,it=e.setFocusIfFocusable,dt=e.setupIntersectionObserver,It=e.appendChild,Yt=e.appendChildToContainer,Ke=e.commitTextUpdate,hn=e.commitMount,un=e.commitUpdate,qt=e.insertBefore,Bt=e.insertInContainerBefore,yt=e.removeChild,jt=e.removeChildFromContainer,Nn=e.resetTextContent,jn=e.hideInstance,sn=e.hideTextInstance,ut=e.unhideInstance,ge=e.unhideTextInstance,ct=e.clearContainer,pt=e.cloneInstance,Kt=e.createContainerChildSet,Gt=e.appendChildToContainerChildSet,Bn=e.finalizeContainerChildren,kn=e.replaceContainerChildren,xs=e.cloneHiddenInstance,Ys=e.cloneHiddenTextInstance,Fn=e.canHydrateInstance,Zs=e.canHydrateTextInstance,Ur=e.canHydrateSuspenseInstance,cd=e.isSuspenseInstancePending,Ua=e.isSuspenseInstanceFallback,Ba=e.registerSuspenseInstanceRetry,Go=e.getNextHydratableSibling,Dl=e.getFirstHydratableChild,ip=e.getFirstHydratableChildWithinContainer,op=e.getFirstHydratableChildWithinSuspenseInstance,Kg=e.hydrateInstance,Va=e.hydrateTextInstance,ap=e.hydrateSuspenseInstance,ne=e.getNextHydratableInstanceAfterSuspenseInstance,Ce=e.commitHydratedContainer,Fe=e.commitHydratedSuspenseInstance,$e=e.clearSuspenseBoundary,Pe=e.clearSuspenseBoundaryFromContainer,bt=e.shouldDeleteUnhydratedTailInstances,Vt=e.didNotMatchHydratedContainerTextInstance,Zt=e.didNotMatchHydratedTextInstance,Ct;function rn(y){if(Ct===void 0)try{throw Error()}catch(E){var v=E.stack.trim().match(/\n( *(at )?)/);Ct=v&&v[1]||""}return`
`+Ct+y}var en=!1;function nn(y,v){if(!y||en)return"";en=!0;var E=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(v)if(v=function(){throw Error()},Object.defineProperty(v.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(v,[])}catch(ot){var A=ot}Reflect.construct(y,[],v)}else{try{v.call()}catch(ot){A=ot}y.call(v.prototype)}else{try{throw Error()}catch(ot){A=ot}y()}}catch(ot){if(ot&&A&&typeof ot.stack=="string"){for(var O=ot.stack.split(`
`),U=A.stack.split(`
`),oe=O.length-1,ve=U.length-1;1<=oe&&0<=ve&&O[oe]!==U[ve];)ve--;for(;1<=oe&&0<=ve;oe--,ve--)if(O[oe]!==U[ve]){if(oe!==1||ve!==1)do if(oe--,ve--,0>ve||O[oe]!==U[ve]){var Ge=`
`+O[oe].replace(" at new "," at ");return y.displayName&&Ge.includes("<anonymous>")&&(Ge=Ge.replace("<anonymous>",y.displayName)),Ge}while(1<=oe&&0<=ve);break}}}finally{en=!1,Error.prepareStackTrace=E}return(y=y?y.displayName||y.name:"")?rn(y):""}var ts=Object.prototype.hasOwnProperty,Cr=[],ns=-1;function Rs(y){return{current:y}}function zt(y){0>ns||(y.current=Cr[ns],Cr[ns]=null,ns--)}function At(y,v){ns++,Cr[ns]=y.current,y.current=v}var Cs={},xn=Rs(Cs),Es=Rs(!1),ha=Cs;function ti(y,v){var E=y.type.contextTypes;if(!E)return Cs;var A=y.stateNode;if(A&&A.__reactInternalMemoizedUnmaskedChildContext===v)return A.__reactInternalMemoizedMaskedChildContext;var O={},U;for(U in E)O[U]=v[U];return A&&(y=y.stateNode,y.__reactInternalMemoizedUnmaskedChildContext=v,y.__reactInternalMemoizedMaskedChildContext=O),O}function Ds(y){return y=y.childContextTypes,y!=null}function ls(){zt(Es),zt(xn)}function Bi(y,v,E){if(xn.current!==Cs)throw Error(o(168));At(xn,v),At(Es,E)}function Cc(y,v,E){var A=y.stateNode;if(v=v.childContextTypes,typeof A.getChildContext!="function")return E;A=A.getChildContext();for(var O in A)if(!(O in v))throw Error(o(108,$(y)||"Unknown",O));return i({},E,A)}function Er(y){return y=(y=y.stateNode)&&y.__reactInternalMemoizedMergedChildContext||Cs,ha=xn.current,At(xn,y),At(Es,Es.current),!0}function Pl(y,v,E){var A=y.stateNode;if(!A)throw Error(o(169));E?(y=Cc(y,v,ha),A.__reactInternalMemoizedMergedChildContext=y,zt(Es),zt(xn),At(xn,y)):zt(Es),At(Es,E)}var wi=Math.clz32?Math.clz32:uT,Ec=Math.log,hd=Math.LN2;function uT(y){return y>>>=0,y===0?32:31-(Ec(y)/hd|0)|0}var Ic=64,$n=4194304;function Nc(y){switch(y&-y){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return y&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return y&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return y}}function dd(y,v){var E=y.pendingLanes;if(E===0)return 0;var A=0,O=y.suspendedLanes,U=y.pingedLanes,oe=E&268435455;if(oe!==0){var ve=oe&~O;ve!==0?A=Nc(ve):(U&=oe,U!==0&&(A=Nc(U)))}else oe=E&~O,oe!==0?A=Nc(oe):U!==0&&(A=Nc(U));if(A===0)return 0;if(v!==0&&v!==A&&(v&O)===0&&(O=A&-A,U=v&-v,O>=U||O===16&&(U&4194240)!==0))return v;if((A&4)!==0&&(A|=E&16),v=y.entangledLanes,v!==0)for(y=y.entanglements,v&=A;0<v;)E=31-wi(v),O=1<<E,A|=y[E],v&=~O;return A}function Yg(y,v){switch(y){case 1:case 2:case 4:return v+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return v+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Dv(y,v){for(var E=y.suspendedLanes,A=y.pingedLanes,O=y.expirationTimes,U=y.pendingLanes;0<U;){var oe=31-wi(U),ve=1<<oe,Ge=O[oe];Ge===-1?((ve&E)===0||(ve&A)!==0)&&(O[oe]=Yg(ve,v)):Ge<=v&&(y.expiredLanes|=ve),U&=~ve}}function lp(y){return y=y.pendingLanes&-1073741825,y!==0?y:y&1073741824?1073741824:0}function up(y){for(var v=[],E=0;31>E;E++)v.push(y);return v}function vu(y,v,E){y.pendingLanes|=v,v!==536870912&&(y.suspendedLanes=0,y.pingedLanes=0),y=y.eventTimes,v=31-wi(v),y[v]=E}function cp(y,v){var E=y.pendingLanes&~v;y.pendingLanes=v,y.suspendedLanes=0,y.pingedLanes=0,y.expiredLanes&=v,y.mutableReadLanes&=v,y.entangledLanes&=v,v=y.entanglements;var A=y.eventTimes;for(y=y.expirationTimes;0<E;){var O=31-wi(E),U=1<<O;v[O]=0,A[O]=-1,y[O]=-1,E&=~U}}function da(y,v){var E=y.entangledLanes|=v;for(y=y.entanglements;E;){var A=31-wi(E),O=1<<A;O&v|y[A]&v&&(y[A]|=v),E&=~O}}var vn=0;function Wa(y){return y&=-y,1<y?4<y?(y&268435455)!==0?16:536870912:4:1}var wu=r.unstable_scheduleCallback,Ac=r.unstable_cancelCallback,Ll=r.unstable_shouldYield,cT=r.unstable_requestPaint,Js=r.unstable_now,Su=r.unstable_ImmediatePriority,hT=r.unstable_UserBlockingPriority,hp=r.unstable_NormalPriority,dp=r.unstable_IdlePriority,fd=null,fa=null;function pd(y){if(fa&&typeof fa.onCommitFiberRoot=="function")try{fa.onCommitFiberRoot(fd,y,void 0,(y.current.flags&128)===128)}catch{}}function md(y,v){return y===v&&(y!==0||1/y===1/v)||y!==y&&v!==v}var ni=typeof Object.is=="function"?Object.is:md,lo=null,fp=!1,Zg=!1;function pp(y){lo===null?lo=[y]:lo.push(y)}function mp(y){fp=!0,pp(y)}function uo(){if(!Zg&&lo!==null){Zg=!0;var y=0,v=vn;try{var E=lo;for(vn=1;y<E.length;y++){var A=E[y];do A=A(!0);while(A!==null)}lo=null,fp=!1}catch(O){throw lo!==null&&(lo=lo.slice(y+1)),wu(Su,uo),O}finally{vn=v,Zg=!1}}return null}var Pv=a.ReactCurrentBatchConfig;function Ho(y,v){if(ni(y,v))return!0;if(typeof y!="object"||y===null||typeof v!="object"||v===null)return!1;var E=Object.keys(y),A=Object.keys(v);if(E.length!==A.length)return!1;for(A=0;A<E.length;A++){var O=E[A];if(!ts.call(v,O)||!ni(y[O],v[O]))return!1}return!0}function Jg(y){switch(y.tag){case 5:return rn(y.type);case 16:return rn("Lazy");case 13:return rn("Suspense");case 19:return rn("SuspenseList");case 0:case 2:case 15:return y=nn(y.type,!1),y;case 11:return y=nn(y.type.render,!1),y;case 1:return y=nn(y.type,!0),y;default:return""}}function Si(y,v){if(y&&y.defaultProps){v=i({},v),y=y.defaultProps;for(var E in y)v[E]===void 0&&(v[E]=y[E]);return v}return v}var gd=Rs(null),bu=null,Ga=null,gp=null;function si(){gp=Ga=bu=null}function _u(y,v,E){Ye?(At(gd,v._currentValue),v._currentValue=E):(At(gd,v._currentValue2),v._currentValue2=E)}function yd(y){var v=gd.current;zt(gd),Ye?y._currentValue=v:y._currentValue2=v}function Tu(y,v,E){for(;y!==null;){var A=y.alternate;if((y.childLanes&v)!==v?(y.childLanes|=v,A!==null&&(A.childLanes|=v)):A!==null&&(A.childLanes&v)!==v&&(A.childLanes|=v),y===E)break;y=y.return}}function Mc(y,v){bu=y,gp=Ga=null,y=y.dependencies,y!==null&&y.firstContext!==null&&((y.lanes&v)!==0&&(ur=!0),y.firstContext=null)}function bi(y){var v=Ye?y._currentValue:y._currentValue2;if(gp!==y)if(y={context:y,memoizedValue:v,next:null},Ga===null){if(bu===null)throw Error(o(308));Ga=y,bu.dependencies={lanes:0,firstContext:y}}else Ga=Ga.next=y;return v}var co=null,ho=!1;function kc(y){y.updateQueue={baseState:y.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Qg(y,v){y=y.updateQueue,v.updateQueue===y&&(v.updateQueue={baseState:y.baseState,firstBaseUpdate:y.firstBaseUpdate,lastBaseUpdate:y.lastBaseUpdate,shared:y.shared,effects:y.effects})}function Ha(y,v){return{eventTime:y,lane:v,tag:0,payload:null,callback:null,next:null}}function Ol(y,v){var E=y.updateQueue;E!==null&&(E=E.shared,Ss!==null&&(y.mode&1)!==0&&(pn&2)===0?(y=E.interleaved,y===null?(v.next=v,co===null?co=[E]:co.push(E)):(v.next=y.next,y.next=v),E.interleaved=v):(y=E.pending,y===null?v.next=v:(v.next=y.next,y.next=v),E.pending=v))}function yp(y,v,E){if(v=v.updateQueue,v!==null&&(v=v.shared,(E&4194240)!==0)){var A=v.lanes;A&=y.pendingLanes,E|=A,v.lanes=E,da(y,E)}}function xp(y,v){var E=y.updateQueue,A=y.alternate;if(A!==null&&(A=A.updateQueue,E===A)){var O=null,U=null;if(E=E.firstBaseUpdate,E!==null){do{var oe={eventTime:E.eventTime,lane:E.lane,tag:E.tag,payload:E.payload,callback:E.callback,next:null};U===null?O=U=oe:U=U.next=oe,E=E.next}while(E!==null);U===null?O=U=v:U=U.next=v}else O=U=v;E={baseState:A.baseState,firstBaseUpdate:O,lastBaseUpdate:U,shared:A.shared,effects:A.effects},y.updateQueue=E;return}y=E.lastBaseUpdate,y===null?E.firstBaseUpdate=v:y.next=v,E.lastBaseUpdate=v}function vp(y,v,E,A){var O=y.updateQueue;ho=!1;var U=O.firstBaseUpdate,oe=O.lastBaseUpdate,ve=O.shared.pending;if(ve!==null){O.shared.pending=null;var Ge=ve,ot=Ge.next;Ge.next=null,oe===null?U=ot:oe.next=ot,oe=Ge;var Nt=y.alternate;Nt!==null&&(Nt=Nt.updateQueue,ve=Nt.lastBaseUpdate,ve!==oe&&(ve===null?Nt.firstBaseUpdate=ot:ve.next=ot,Nt.lastBaseUpdate=Ge))}if(U!==null){var cn=O.baseState;oe=0,Nt=ot=Ge=null,ve=U;do{var Xt=ve.lane,Yn=ve.eventTime;if((A&Xt)===Xt){Nt!==null&&(Nt=Nt.next={eventTime:Yn,lane:0,tag:ve.tag,payload:ve.payload,callback:ve.callback,next:null});e:{var _t=y,Gn=ve;switch(Xt=v,Yn=E,Gn.tag){case 1:if(_t=Gn.payload,typeof _t=="function"){cn=_t.call(Yn,cn,Xt);break e}cn=_t;break e;case 3:_t.flags=_t.flags&-65537|128;case 0:if(_t=Gn.payload,Xt=typeof _t=="function"?_t.call(Yn,cn,Xt):_t,Xt==null)break e;cn=i({},cn,Xt);break e;case 2:ho=!0}}ve.callback!==null&&ve.lane!==0&&(y.flags|=64,Xt=O.effects,Xt===null?O.effects=[ve]:Xt.push(ve))}else Yn={eventTime:Yn,lane:Xt,tag:ve.tag,payload:ve.payload,callback:ve.callback,next:null},Nt===null?(ot=Nt=Yn,Ge=cn):Nt=Nt.next=Yn,oe|=Xt;if(ve=ve.next,ve===null){if(ve=O.shared.pending,ve===null)break;Xt=ve,ve=Xt.next,Xt.next=null,O.lastBaseUpdate=Xt,O.shared.pending=null}}while(!0);if(Nt===null&&(Ge=cn),O.baseState=Ge,O.firstBaseUpdate=ot,O.lastBaseUpdate=Nt,v=O.shared.interleaved,v!==null){O=v;do oe|=O.lane,O=O.next;while(O!==v)}else U===null&&(O.shared.lanes=0);Uu|=oe,y.lanes=oe,y.memoizedState=cn}}function Lv(y,v,E){if(y=v.effects,v.effects=null,y!==null)for(v=0;v<y.length;v++){var A=y[v],O=A.callback;if(O!==null){if(A.callback=null,A=E,typeof O!="function")throw Error(o(191,O));O.call(A)}}}var Ov=new s.Component().refs;function ey(y,v,E,A){v=y.memoizedState,E=E(A,v),E=E==null?v:i({},v,E),y.memoizedState=E,y.lanes===0&&(y.updateQueue.baseState=E)}var wp={isMounted:function(y){return(y=y._reactInternals)?R(y)===y:!1},enqueueSetState:function(y,v,E){y=y._reactInternals;var A=dr(),O=va(y),U=Ha(A,O);U.payload=v,E!=null&&(U.callback=E),Ol(y,U),v=Ei(y,O,A),v!==null&&yp(v,y,O)},enqueueReplaceState:function(y,v,E){y=y._reactInternals;var A=dr(),O=va(y),U=Ha(A,O);U.tag=1,U.payload=v,E!=null&&(U.callback=E),Ol(y,U),v=Ei(y,O,A),v!==null&&yp(v,y,O)},enqueueForceUpdate:function(y,v){y=y._reactInternals;var E=dr(),A=va(y),O=Ha(E,A);O.tag=2,v!=null&&(O.callback=v),Ol(y,O),v=Ei(y,A,E),v!==null&&yp(v,y,A)}};function ty(y,v,E,A,O,U,oe){return y=y.stateNode,typeof y.shouldComponentUpdate=="function"?y.shouldComponentUpdate(A,U,oe):v.prototype&&v.prototype.isPureReactComponent?!Ho(E,A)||!Ho(O,U):!0}function Fv(y,v,E){var A=!1,O=Cs,U=v.contextType;return typeof U=="object"&&U!==null?U=bi(U):(O=Ds(v)?ha:xn.current,A=v.contextTypes,U=(A=A!=null)?ti(y,O):Cs),v=new v(E,U),y.memoizedState=v.state!==null&&v.state!==void 0?v.state:null,v.updater=wp,y.stateNode=v,v._reactInternals=y,A&&(y=y.stateNode,y.__reactInternalMemoizedUnmaskedChildContext=O,y.__reactInternalMemoizedMaskedChildContext=U),v}function $v(y,v,E,A){y=v.state,typeof v.componentWillReceiveProps=="function"&&v.componentWillReceiveProps(E,A),typeof v.UNSAFE_componentWillReceiveProps=="function"&&v.UNSAFE_componentWillReceiveProps(E,A),v.state!==y&&wp.enqueueReplaceState(v,v.state,null)}function ny(y,v,E,A){var O=y.stateNode;O.props=E,O.state=y.memoizedState,O.refs=Ov,kc(y);var U=v.contextType;typeof U=="object"&&U!==null?O.context=bi(U):(U=Ds(v)?ha:xn.current,O.context=ti(y,U)),O.state=y.memoizedState,U=v.getDerivedStateFromProps,typeof U=="function"&&(ey(y,v,U,E),O.state=y.memoizedState),typeof v.getDerivedStateFromProps=="function"||typeof O.getSnapshotBeforeUpdate=="function"||typeof O.UNSAFE_componentWillMount!="function"&&typeof O.componentWillMount!="function"||(v=O.state,typeof O.componentWillMount=="function"&&O.componentWillMount(),typeof O.UNSAFE_componentWillMount=="function"&&O.UNSAFE_componentWillMount(),v!==O.state&&wp.enqueueReplaceState(O,O.state,null),vp(y,E,O,A),O.state=y.memoizedState),typeof O.componentDidMount=="function"&&(y.flags|=4194308)}var Rc=[],Fl=0,Sp=null,bp=0,fo=[],Vi=0,Cu=null,ja=1,Xa="";function Eu(y,v){Rc[Fl++]=bp,Rc[Fl++]=Sp,Sp=y,bp=v}function zv(y,v,E){fo[Vi++]=ja,fo[Vi++]=Xa,fo[Vi++]=Cu,Cu=y;var A=ja;y=Xa;var O=32-wi(A)-1;A&=~(1<<O),E+=1;var U=32-wi(v)+O;if(30<U){var oe=O-O%5;U=(A&(1<<oe)-1).toString(32),A>>=oe,O-=oe,ja=1<<32-wi(v)+O|E<<O|A,Xa=U+y}else ja=1<<U|E<<O|A,Xa=y}function sy(y){y.return!==null&&(Eu(y,1),zv(y,1,0))}function ry(y){for(;y===Sp;)Sp=Rc[--Fl],Rc[Fl]=null,bp=Rc[--Fl],Rc[Fl]=null;for(;y===Cu;)Cu=fo[--Vi],fo[Vi]=null,Xa=fo[--Vi],fo[Vi]=null,ja=fo[--Vi],fo[Vi]=null}var ri=null,Ir=null,fs=!1,Dc=!1,po=null;function iy(y,v){var E=Xi(5,null,null,0);E.elementType="DELETED",E.stateNode=v,E.return=y,v=y.deletions,v===null?(y.deletions=[E],y.flags|=16):v.push(E)}function oy(y,v){switch(y.tag){case 5:return v=Fn(v,y.type,y.pendingProps),v!==null?(y.stateNode=v,ri=y,Ir=Dl(v),!0):!1;case 6:return v=Zs(v,y.pendingProps),v!==null?(y.stateNode=v,ri=y,Ir=null,!0):!1;case 13:if(v=Ur(v),v!==null){var E=Cu!==null?{id:ja,overflow:Xa}:null;return y.memoizedState={dehydrated:v,treeContext:E,retryLane:1073741824},E=Xi(18,null,null,0),E.stateNode=v,E.return=y,y.child=E,ri=y,Ir=null,!0}return!1;default:return!1}}function _p(y){return(y.mode&1)!==0&&(y.flags&128)===0}function $l(y){if(fs){var v=Ir;if(v){var E=v;if(!oy(y,v)){if(_p(y))throw Error(o(418));v=Go(E);var A=ri;v&&oy(y,v)?iy(A,E):(y.flags=y.flags&-4097|2,fs=!1,ri=y)}}else{if(_p(y))throw Error(o(418));y.flags=y.flags&-4097|2,fs=!1,ri=y}}}function Uv(y){for(y=y.return;y!==null&&y.tag!==5&&y.tag!==3&&y.tag!==13;)y=y.return;ri=y}function xd(y){if(!Be||y!==ri)return!1;if(!fs)return Uv(y),fs=!0,!1;if(y.tag!==3&&(y.tag!==5||bt(y.type)&&!fe(y.type,y.memoizedProps))){var v=Ir;if(v){if(_p(y)){for(y=Ir;y;)y=Go(y);throw Error(o(418))}for(;v;)iy(y,v),v=Go(v)}}if(Uv(y),y.tag===13){if(!Be)throw Error(o(316));if(y=y.memoizedState,y=y!==null?y.dehydrated:null,!y)throw Error(o(317));Ir=ne(y)}else Ir=ri?Go(y.stateNode):null;return!0}function Pc(){Be&&(Ir=ri=null,Dc=fs=!1)}function Tp(y){po===null?po=[y]:po.push(y)}function Lc(y,v,E){if(y=E.ref,y!==null&&typeof y!="function"&&typeof y!="object"){if(E._owner){if(E=E._owner,E){if(E.tag!==1)throw Error(o(309));var A=E.stateNode}if(!A)throw Error(o(147,y));var O=A,U=""+y;return v!==null&&v.ref!==null&&typeof v.ref=="function"&&v.ref._stringRef===U?v.ref:(v=function(oe){var ve=O.refs;ve===Ov&&(ve=O.refs={}),oe===null?delete ve[U]:ve[U]=oe},v._stringRef=U,v)}if(typeof y!="string")throw Error(o(284));if(!E._owner)throw Error(o(290,y))}return y}function zl(y,v){throw y=Object.prototype.toString.call(v),Error(o(31,y==="[object Object]"?"object with keys {"+Object.keys(v).join(", ")+"}":y))}function Oc(y){var v=y._init;return v(y._payload)}function Bv(y){function v(ke,we){if(y){var ze=ke.deletions;ze===null?(ke.deletions=[we],ke.flags|=16):ze.push(we)}}function E(ke,we){if(!y)return null;for(;we!==null;)v(ke,we),we=we.sibling;return null}function A(ke,we){for(ke=new Map;we!==null;)we.key!==null?ke.set(we.key,we):ke.set(we.index,we),we=we.sibling;return ke}function O(ke,we){return ke=il(ke,we),ke.index=0,ke.sibling=null,ke}function U(ke,we,ze){return ke.index=ze,y?(ze=ke.alternate,ze!==null?(ze=ze.index,ze<we?(ke.flags|=2,we):ze):(ke.flags|=2,we)):(ke.flags|=1048576,we)}function oe(ke){return y&&ke.alternate===null&&(ke.flags|=2),ke}function ve(ke,we,ze,wt){return we===null||we.tag!==6?(we=nm(ze,ke.mode,wt),we.return=ke,we):(we=O(we,ze),we.return=ke,we)}function Ge(ke,we,ze,wt){var Ot=ze.type;return Ot===c?Nt(ke,we,ze.props.children,wt,ze.key):we!==null&&(we.elementType===Ot||typeof Ot=="object"&&Ot!==null&&Ot.$$typeof===T&&Oc(Ot)===we.type)?(wt=O(we,ze.props),wt.ref=Lc(ke,we,ze),wt.return=ke,wt):(wt=Bd(ze.type,ze.key,ze.props,null,ke.mode,wt),wt.ref=Lc(ke,we,ze),wt.return=ke,wt)}function ot(ke,we,ze,wt){return we===null||we.tag!==4||we.stateNode.containerInfo!==ze.containerInfo||we.stateNode.implementation!==ze.implementation?(we=sm(ze,ke.mode,wt),we.return=ke,we):(we=O(we,ze.children||[]),we.return=ke,we)}function Nt(ke,we,ze,wt,Ot){return we===null||we.tag!==7?(we=Zl(ze,ke.mode,wt,Ot),we.return=ke,we):(we=O(we,ze),we.return=ke,we)}function cn(ke,we,ze){if(typeof we=="string"&&we!==""||typeof we=="number")return we=nm(""+we,ke.mode,ze),we.return=ke,we;if(typeof we=="object"&&we!==null){switch(we.$$typeof){case l:return ze=Bd(we.type,we.key,we.props,null,ke.mode,ze),ze.ref=Lc(ke,null,we),ze.return=ke,ze;case u:return we=sm(we,ke.mode,ze),we.return=ke,we;case T:var wt=we._init;return cn(ke,wt(we._payload),ze)}if(H(we)||M(we))return we=Zl(we,ke.mode,ze,null),we.return=ke,we;zl(ke,we)}return null}function Xt(ke,we,ze,wt){var Ot=we!==null?we.key:null;if(typeof ze=="string"&&ze!==""||typeof ze=="number")return Ot!==null?null:ve(ke,we,""+ze,wt);if(typeof ze=="object"&&ze!==null){switch(ze.$$typeof){case l:return ze.key===Ot?Ge(ke,we,ze,wt):null;case u:return ze.key===Ot?ot(ke,we,ze,wt):null;case T:return Ot=ze._init,Xt(ke,we,Ot(ze._payload),wt)}if(H(ze)||M(ze))return Ot!==null?null:Nt(ke,we,ze,wt,null);zl(ke,ze)}return null}function Yn(ke,we,ze,wt,Ot){if(typeof wt=="string"&&wt!==""||typeof wt=="number")return ke=ke.get(ze)||null,ve(we,ke,""+wt,Ot);if(typeof wt=="object"&&wt!==null){switch(wt.$$typeof){case l:return ke=ke.get(wt.key===null?ze:wt.key)||null,Ge(we,ke,wt,Ot);case u:return ke=ke.get(wt.key===null?ze:wt.key)||null,ot(we,ke,wt,Ot);case T:var fn=wt._init;return Yn(ke,we,ze,fn(wt._payload),Ot)}if(H(wt)||M(wt))return ke=ke.get(ze)||null,Nt(we,ke,wt,Ot,null);zl(we,wt)}return null}function _t(ke,we,ze,wt){for(var Ot=null,fn=null,on=we,Ln=we=0,er=null;on!==null&&Ln<ze.length;Ln++){on.index>Ln?(er=on,on=null):er=on.sibling;var Rn=Xt(ke,on,ze[Ln],wt);if(Rn===null){on===null&&(on=er);break}y&&on&&Rn.alternate===null&&v(ke,on),we=U(Rn,we,Ln),fn===null?Ot=Rn:fn.sibling=Rn,fn=Rn,on=er}if(Ln===ze.length)return E(ke,on),fs&&Eu(ke,Ln),Ot;if(on===null){for(;Ln<ze.length;Ln++)on=cn(ke,ze[Ln],wt),on!==null&&(we=U(on,we,Ln),fn===null?Ot=on:fn.sibling=on,fn=on);return fs&&Eu(ke,Ln),Ot}for(on=A(ke,on);Ln<ze.length;Ln++)er=Yn(on,ke,Ln,ze[Ln],wt),er!==null&&(y&&er.alternate!==null&&on.delete(er.key===null?Ln:er.key),we=U(er,we,Ln),fn===null?Ot=er:fn.sibling=er,fn=er);return y&&on.forEach(function(wa){return v(ke,wa)}),fs&&Eu(ke,Ln),Ot}function Gn(ke,we,ze,wt){var Ot=M(ze);if(typeof Ot!="function")throw Error(o(150));if(ze=Ot.call(ze),ze==null)throw Error(o(151));for(var fn=Ot=null,on=we,Ln=we=0,er=null,Rn=ze.next();on!==null&&!Rn.done;Ln++,Rn=ze.next()){on.index>Ln?(er=on,on=null):er=on.sibling;var wa=Xt(ke,on,Rn.value,wt);if(wa===null){on===null&&(on=er);break}y&&on&&wa.alternate===null&&v(ke,on),we=U(wa,we,Ln),fn===null?Ot=wa:fn.sibling=wa,fn=wa,on=er}if(Rn.done)return E(ke,on),fs&&Eu(ke,Ln),Ot;if(on===null){for(;!Rn.done;Ln++,Rn=ze.next())Rn=cn(ke,Rn.value,wt),Rn!==null&&(we=U(Rn,we,Ln),fn===null?Ot=Rn:fn.sibling=Rn,fn=Rn);return fs&&Eu(ke,Ln),Ot}for(on=A(ke,on);!Rn.done;Ln++,Rn=ze.next())Rn=Yn(on,ke,Ln,Rn.value,wt),Rn!==null&&(y&&Rn.alternate!==null&&on.delete(Rn.key===null?Ln:Rn.key),we=U(Rn,we,Ln),fn===null?Ot=Rn:fn.sibling=Rn,fn=Rn);return y&&on.forEach(function(o1){return v(ke,o1)}),fs&&Eu(ke,Ln),Ot}function qi(ke,we,ze,wt){if(typeof ze=="object"&&ze!==null&&ze.type===c&&ze.key===null&&(ze=ze.props.children),typeof ze=="object"&&ze!==null){switch(ze.$$typeof){case l:e:{for(var Ot=ze.key,fn=we;fn!==null;){if(fn.key===Ot){if(Ot=ze.type,Ot===c){if(fn.tag===7){E(ke,fn.sibling),we=O(fn,ze.props.children),we.return=ke,ke=we;break e}}else if(fn.elementType===Ot||typeof Ot=="object"&&Ot!==null&&Ot.$$typeof===T&&Oc(Ot)===fn.type){E(ke,fn.sibling),we=O(fn,ze.props),we.ref=Lc(ke,fn,ze),we.return=ke,ke=we;break e}E(ke,fn);break}else v(ke,fn);fn=fn.sibling}ze.type===c?(we=Zl(ze.props.children,ke.mode,wt,ze.key),we.return=ke,ke=we):(wt=Bd(ze.type,ze.key,ze.props,null,ke.mode,wt),wt.ref=Lc(ke,we,ze),wt.return=ke,ke=wt)}return oe(ke);case u:e:{for(fn=ze.key;we!==null;){if(we.key===fn)if(we.tag===4&&we.stateNode.containerInfo===ze.containerInfo&&we.stateNode.implementation===ze.implementation){E(ke,we.sibling),we=O(we,ze.children||[]),we.return=ke,ke=we;break e}else{E(ke,we);break}else v(ke,we);we=we.sibling}we=sm(ze,ke.mode,wt),we.return=ke,ke=we}return oe(ke);case T:return fn=ze._init,qi(ke,we,fn(ze._payload),wt)}if(H(ze))return _t(ke,we,ze,wt);if(M(ze))return Gn(ke,we,ze,wt);zl(ke,ze)}return typeof ze=="string"&&ze!==""||typeof ze=="number"?(ze=""+ze,we!==null&&we.tag===6?(E(ke,we.sibling),we=O(we,ze),we.return=ke,ke=we):(E(ke,we),we=nm(ze,ke.mode,wt),we.return=ke,ke=we),oe(ke)):E(ke,we)}return qi}var qa=Bv(!0),Vv=Bv(!1),Fc={},_i=Rs(Fc),Iu=Rs(Fc),Nu=Rs(Fc);function jo(y){if(y===Fc)throw Error(o(174));return y}function Cp(y,v){At(Nu,v),At(Iu,y),At(_i,Fc),y=ie(v),zt(_i),At(_i,y)}function $c(){zt(_i),zt(Iu),zt(Nu)}function Wv(y){var v=jo(Nu.current),E=jo(_i.current);v=V(E,y.type,v),E!==v&&(At(Iu,y),At(_i,v))}function ay(y){Iu.current===y&&(zt(_i),zt(Iu))}var vs=Rs(0);function Ep(y){for(var v=y;v!==null;){if(v.tag===13){var E=v.memoizedState;if(E!==null&&(E=E.dehydrated,E===null||cd(E)||Ua(E)))return v}else if(v.tag===19&&v.memoizedProps.revealOrder!==void 0){if((v.flags&128)!==0)return v}else if(v.child!==null){v.child.return=v,v=v.child;continue}if(v===y)break;for(;v.sibling===null;){if(v.return===null||v.return===y)return null;v=v.return}v.sibling.return=v.return,v=v.sibling}return null}var Wi=[];function Au(){for(var y=0;y<Wi.length;y++){var v=Wi[y];Ye?v._workInProgressVersionPrimary=null:v._workInProgressVersionSecondary=null}Wi.length=0}var vd=a.ReactCurrentDispatcher,Gi=a.ReactCurrentBatchConfig,Mu=0,ws=null,or=null,ar=null,Ip=!1,pa=!1,ku=0,wd=0;function lr(){throw Error(o(321))}function Np(y,v){if(v===null)return!1;for(var E=0;E<v.length&&E<y.length;E++)if(!ni(y[E],v[E]))return!1;return!0}function zc(y,v,E,A,O,U){if(Mu=U,ws=v,v.memoizedState=null,v.updateQueue=null,v.lanes=0,vd.current=y===null||y.memoizedState===null?fy:py,y=E(A,O),pa){U=0;do{if(pa=!1,ku=0,25<=U)throw Error(o(301));U+=1,ar=or=null,v.updateQueue=null,vd.current=my,y=E(A,O)}while(pa)}if(vd.current=Wc,v=or!==null&&or.next!==null,Mu=0,ar=or=ws=null,Ip=!1,v)throw Error(o(300));return y}function Ul(){var y=ku!==0;return ku=0,y}function Xo(){var y={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return ar===null?ws.memoizedState=ar=y:ar=ar.next=y,ar}function qo(){if(or===null){var y=ws.alternate;y=y!==null?y.memoizedState:null}else y=or.next;var v=ar===null?ws.memoizedState:ar.next;if(v!==null)ar=v,or=y;else{if(y===null)throw Error(o(310));or=y,y={memoizedState:or.memoizedState,baseState:or.baseState,baseQueue:or.baseQueue,queue:or.queue,next:null},ar===null?ws.memoizedState=ar=y:ar=ar.next=y}return ar}function ma(y,v){return typeof v=="function"?v(y):v}function Sd(y){var v=qo(),E=v.queue;if(E===null)throw Error(o(311));E.lastRenderedReducer=y;var A=or,O=A.baseQueue,U=E.pending;if(U!==null){if(O!==null){var oe=O.next;O.next=U.next,U.next=oe}A.baseQueue=O=U,E.pending=null}if(O!==null){U=O.next,A=A.baseState;var ve=oe=null,Ge=null,ot=U;do{var Nt=ot.lane;if((Mu&Nt)===Nt)Ge!==null&&(Ge=Ge.next={lane:0,action:ot.action,hasEagerState:ot.hasEagerState,eagerState:ot.eagerState,next:null}),A=ot.hasEagerState?ot.eagerState:y(A,ot.action);else{var cn={lane:Nt,action:ot.action,hasEagerState:ot.hasEagerState,eagerState:ot.eagerState,next:null};Ge===null?(ve=Ge=cn,oe=A):Ge=Ge.next=cn,ws.lanes|=Nt,Uu|=Nt}ot=ot.next}while(ot!==null&&ot!==U);Ge===null?oe=A:Ge.next=ve,ni(A,v.memoizedState)||(ur=!0),v.memoizedState=A,v.baseState=oe,v.baseQueue=Ge,E.lastRenderedState=A}if(y=E.interleaved,y!==null){O=y;do U=O.lane,ws.lanes|=U,Uu|=U,O=O.next;while(O!==y)}else O===null&&(E.lanes=0);return[v.memoizedState,E.dispatch]}function bd(y){var v=qo(),E=v.queue;if(E===null)throw Error(o(311));E.lastRenderedReducer=y;var A=E.dispatch,O=E.pending,U=v.memoizedState;if(O!==null){E.pending=null;var oe=O=O.next;do U=y(U,oe.action),oe=oe.next;while(oe!==O);ni(U,v.memoizedState)||(ur=!0),v.memoizedState=U,v.baseQueue===null&&(v.baseState=U),E.lastRenderedState=U}return[U,A]}function ly(){}function uy(y,v){var E=ws,A=qo(),O=v(),U=!ni(A.memoizedState,O);if(U&&(A.memoizedState=O,ur=!0),A=A.queue,Uc(Ka.bind(null,E,A,y),[y]),A.getSnapshot!==v||U||ar!==null&&ar.memoizedState.tag&1){if(E.flags|=2048,Td(9,hy.bind(null,E,A,O,v),void 0,null),Ss===null)throw Error(o(349));(Mu&30)!==0||cy(E,v,O)}return O}function cy(y,v,E){y.flags|=16384,y={getSnapshot:v,value:E},v=ws.updateQueue,v===null?(v={lastEffect:null,stores:null},ws.updateQueue=v,v.stores=[y]):(E=v.stores,E===null?v.stores=[y]:E.push(y))}function hy(y,v,E,A){v.value=E,v.getSnapshot=A,Ap(v)&&Ei(y,1,-1)}function Ka(y,v,E){return E(function(){Ap(v)&&Ei(y,1,-1)})}function Ap(y){var v=y.getSnapshot;y=y.value;try{var E=v();return!ni(y,E)}catch{return!0}}function _d(y){var v=Xo();return typeof y=="function"&&(y=y()),v.memoizedState=v.baseState=y,y={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ma,lastRenderedState:y},v.queue=y,y=y.dispatch=dT.bind(null,ws,y),[v.memoizedState,y]}function Td(y,v,E,A){return y={tag:y,create:v,destroy:E,deps:A,next:null},v=ws.updateQueue,v===null?(v={lastEffect:null,stores:null},ws.updateQueue=v,v.lastEffect=y.next=y):(E=v.lastEffect,E===null?v.lastEffect=y.next=y:(A=E.next,E.next=y,y.next=A,v.lastEffect=y)),y}function Gv(){return qo().memoizedState}function Bl(y,v,E,A){var O=Xo();ws.flags|=y,O.memoizedState=Td(1|v,E,void 0,A===void 0?null:A)}function Mp(y,v,E,A){var O=qo();A=A===void 0?null:A;var U=void 0;if(or!==null){var oe=or.memoizedState;if(U=oe.destroy,A!==null&&Np(A,oe.deps)){O.memoizedState=Td(v,E,U,A);return}}ws.flags|=y,O.memoizedState=Td(1|v,E,U,A)}function kp(y,v){return Bl(8390656,8,y,v)}function Uc(y,v){return Mp(2048,8,y,v)}function ss(y,v){return Mp(4,2,y,v)}function Rp(y,v){return Mp(4,4,y,v)}function Cd(y,v){if(typeof v=="function")return y=y(),v(y),function(){v(null)};if(v!=null)return y=y(),v.current=y,function(){v.current=null}}function Bc(y,v,E){return E=E!=null?E.concat([y]):null,Mp(4,4,Cd.bind(null,v,y),E)}function Dp(){}function Pp(y,v){var E=qo();v=v===void 0?null:v;var A=E.memoizedState;return A!==null&&v!==null&&Np(v,A[1])?A[0]:(E.memoizedState=[y,v],y)}function Vc(y,v){var E=qo();v=v===void 0?null:v;var A=E.memoizedState;return A!==null&&v!==null&&Np(v,A[1])?A[0]:(y=y(),E.memoizedState=[y,v],y)}function Lp(y,v){var E=vn;vn=E!==0&&4>E?E:4,y(!0);var A=Gi.transition;Gi.transition={};try{y(!1),v()}finally{vn=E,Gi.transition=A}}function Ru(){return qo().memoizedState}function Hv(y,v,E){var A=va(y);E={lane:A,action:E,hasEagerState:!1,eagerState:null,next:null},jv(y)?dy(v,E):(Ed(y,v,E),E=dr(),y=Ei(y,A,E),y!==null&&Id(y,v,A))}function dT(y,v,E){var A=va(y),O={lane:A,action:E,hasEagerState:!1,eagerState:null,next:null};if(jv(y))dy(v,O);else{Ed(y,v,O);var U=y.alternate;if(y.lanes===0&&(U===null||U.lanes===0)&&(U=v.lastRenderedReducer,U!==null))try{var oe=v.lastRenderedState,ve=U(oe,E);if(O.hasEagerState=!0,O.eagerState=ve,ni(ve,oe))return}catch{}finally{}E=dr(),y=Ei(y,A,E),y!==null&&Id(y,v,A)}}function jv(y){var v=y.alternate;return y===ws||v!==null&&v===ws}function dy(y,v){pa=Ip=!0;var E=y.pending;E===null?v.next=v:(v.next=E.next,E.next=v),y.pending=v}function Ed(y,v,E){Ss!==null&&(y.mode&1)!==0&&(pn&2)===0?(y=v.interleaved,y===null?(E.next=E,co===null?co=[v]:co.push(v)):(E.next=y.next,y.next=E),v.interleaved=E):(y=v.pending,y===null?E.next=E:(E.next=y.next,y.next=E),v.pending=E)}function Id(y,v,E){if((E&4194240)!==0){var A=v.lanes;A&=y.pendingLanes,E|=A,v.lanes=E,da(y,E)}}var Wc={readContext:bi,useCallback:lr,useContext:lr,useEffect:lr,useImperativeHandle:lr,useInsertionEffect:lr,useLayoutEffect:lr,useMemo:lr,useReducer:lr,useRef:lr,useState:lr,useDebugValue:lr,useDeferredValue:lr,useTransition:lr,useMutableSource:lr,useSyncExternalStore:lr,useId:lr,unstable_isNewReconciler:!1},fy={readContext:bi,useCallback:function(y,v){return Xo().memoizedState=[y,v===void 0?null:v],y},useContext:bi,useEffect:kp,useImperativeHandle:function(y,v,E){return E=E!=null?E.concat([y]):null,Bl(4194308,4,Cd.bind(null,v,y),E)},useLayoutEffect:function(y,v){return Bl(4194308,4,y,v)},useInsertionEffect:function(y,v){return Bl(4,2,y,v)},useMemo:function(y,v){var E=Xo();return v=v===void 0?null:v,y=y(),E.memoizedState=[y,v],y},useReducer:function(y,v,E){var A=Xo();return v=E!==void 0?E(v):v,A.memoizedState=A.baseState=v,y={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:y,lastRenderedState:v},A.queue=y,y=y.dispatch=Hv.bind(null,ws,y),[A.memoizedState,y]},useRef:function(y){var v=Xo();return y={current:y},v.memoizedState=y},useState:_d,useDebugValue:Dp,useDeferredValue:function(y){var v=_d(y),E=v[0],A=v[1];return kp(function(){var O=Gi.transition;Gi.transition={};try{A(y)}finally{Gi.transition=O}},[y]),E},useTransition:function(){var y=_d(!1),v=y[0];return y=Lp.bind(null,y[1]),Xo().memoizedState=y,[v,y]},useMutableSource:function(){},useSyncExternalStore:function(y,v,E){var A=ws,O=Xo();if(fs){if(E===void 0)throw Error(o(407));E=E()}else{if(E=v(),Ss===null)throw Error(o(349));(Mu&30)!==0||cy(A,v,E)}O.memoizedState=E;var U={value:E,getSnapshot:v};return O.queue=U,kp(Ka.bind(null,A,U,y),[y]),A.flags|=2048,Td(9,hy.bind(null,A,U,E,v),void 0,null),E},useId:function(){var y=Xo(),v=Ss.identifierPrefix;if(fs){var E=Xa,A=ja;E=(A&~(1<<32-wi(A)-1)).toString(32)+E,v=":"+v+"R"+E,E=ku++,0<E&&(v+="H"+E.toString(32)),v+=":"}else E=wd++,v=":"+v+"r"+E.toString(32)+":";return y.memoizedState=v},unstable_isNewReconciler:!1},py={readContext:bi,useCallback:Pp,useContext:bi,useEffect:Uc,useImperativeHandle:Bc,useInsertionEffect:ss,useLayoutEffect:Rp,useMemo:Vc,useReducer:Sd,useRef:Gv,useState:function(){return Sd(ma)},useDebugValue:Dp,useDeferredValue:function(y){var v=Sd(ma),E=v[0],A=v[1];return Uc(function(){var O=Gi.transition;Gi.transition={};try{A(y)}finally{Gi.transition=O}},[y]),E},useTransition:function(){var y=Sd(ma)[0],v=qo().memoizedState;return[y,v]},useMutableSource:ly,useSyncExternalStore:uy,useId:Ru,unstable_isNewReconciler:!1},my={readContext:bi,useCallback:Pp,useContext:bi,useEffect:Uc,useImperativeHandle:Bc,useInsertionEffect:ss,useLayoutEffect:Rp,useMemo:Vc,useReducer:bd,useRef:Gv,useState:function(){return bd(ma)},useDebugValue:Dp,useDeferredValue:function(y){var v=bd(ma),E=v[0],A=v[1];return Uc(function(){var O=Gi.transition;Gi.transition={};try{A(y)}finally{Gi.transition=O}},[y]),E},useTransition:function(){var y=bd(ma)[0],v=qo().memoizedState;return[y,v]},useMutableSource:ly,useSyncExternalStore:uy,useId:Ru,unstable_isNewReconciler:!1};function gy(y,v){try{var E="",A=v;do E+=Jg(A),A=A.return;while(A);var O=E}catch(U){O=`
Error generating stack: `+U.message+`
`+U.stack}return{value:y,source:v,stack:O}}function Op(y,v){try{console.error(v.value)}catch(E){setTimeout(function(){throw E})}}var fT=typeof WeakMap=="function"?WeakMap:Map;function Xv(y,v,E){E=Ha(-1,E),E.tag=3,E.payload={element:null};var A=v.value;return E.callback=function(){jl||(jl=!0,xo=A),Op(y,v)},E}function Fp(y,v,E){E=Ha(-1,E),E.tag=3;var A=y.type.getDerivedStateFromError;if(typeof A=="function"){var O=v.value;E.payload=function(){return A(O)},E.callback=function(){Op(y,v)}}var U=y.stateNode;return U!==null&&typeof U.componentDidCatch=="function"&&(E.callback=function(){Op(y,v),typeof A!="function"&&(vo===null?vo=new Set([this]):vo.add(this));var oe=v.stack;this.componentDidCatch(v.value,{componentStack:oe!==null?oe:""})}),E}function Ya(y,v,E){var A=y.pingCache;if(A===null){A=y.pingCache=new fT;var O=new Set;A.set(v,O)}else O=A.get(v),O===void 0&&(O=new Set,A.set(v,O));O.has(E)||(O.add(E),y=Zv.bind(null,y,v,E),v.then(y,y))}function yy(y){do{var v;if((v=y.tag===13)&&(v=y.memoizedState,v=v!==null?v.dehydrated!==null:!0),v)return y;y=y.return}while(y!==null);return null}function Du(y,v,E,A,O){return(y.mode&1)===0?(y===v?y.flags|=65536:(y.flags|=128,E.flags|=131072,E.flags&=-52805,E.tag===1&&(E.alternate===null?E.tag=17:(v=Ha(-1,1),v.tag=2,Ol(E,v))),E.lanes|=1),y):(y.flags|=65536,y.lanes=O,y)}function Qs(y){y.flags|=4}function Gc(y,v){if(y!==null&&y.child===v.child)return!0;if((v.flags&16)!==0)return!1;for(y=v.child;y!==null;){if((y.flags&12854)!==0||(y.subtreeFlags&12854)!==0)return!1;y=y.sibling}return!0}var Hi,Pu,$p,zp;if(et)Hi=function(y,v){for(var E=v.child;E!==null;){if(E.tag===5||E.tag===6)se(y,E.stateNode);else if(E.tag!==4&&E.child!==null){E.child.return=E,E=E.child;continue}if(E===v)break;for(;E.sibling===null;){if(E.return===null||E.return===v)return;E=E.return}E.sibling.return=E.return,E=E.sibling}},Pu=function(){},$p=function(y,v,E,A,O){if(y=y.memoizedProps,y!==A){var U=v.stateNode,oe=jo(_i.current);E=ue(U,E,y,A,O,oe),(v.updateQueue=E)&&Qs(v)}},zp=function(y,v,E,A){E!==A&&Qs(v)};else if(ae){Hi=function(y,v,E,A){for(var O=v.child;O!==null;){if(O.tag===5){var U=O.stateNode;E&&A&&(U=xs(U,O.type,O.memoizedProps,O)),se(y,U)}else if(O.tag===6)U=O.stateNode,E&&A&&(U=Ys(U,O.memoizedProps,O)),se(y,U);else if(O.tag!==4){if(O.tag===22&&O.memoizedState!==null)U=O.child,U!==null&&(U.return=O),Hi(y,O,!0,!0);else if(O.child!==null){O.child.return=O,O=O.child;continue}}if(O===v)break;for(;O.sibling===null;){if(O.return===null||O.return===v)return;O=O.return}O.sibling.return=O.return,O=O.sibling}};var Vl=function(y,v,E,A){for(var O=v.child;O!==null;){if(O.tag===5){var U=O.stateNode;E&&A&&(U=xs(U,O.type,O.memoizedProps,O)),Gt(y,U)}else if(O.tag===6)U=O.stateNode,E&&A&&(U=Ys(U,O.memoizedProps,O)),Gt(y,U);else if(O.tag!==4){if(O.tag===22&&O.memoizedState!==null)U=O.child,U!==null&&(U.return=O),Vl(y,O,!0,!0);else if(O.child!==null){O.child.return=O,O=O.child;continue}}if(O===v)break;for(;O.sibling===null;){if(O.return===null||O.return===v)return;O=O.return}O.sibling.return=O.return,O=O.sibling}};Pu=function(y,v){var E=v.stateNode;if(!Gc(y,v)){y=E.containerInfo;var A=Kt(y);Vl(A,v,!1,!1),E.pendingChildren=A,Qs(v),Bn(y,A)}},$p=function(y,v,E,A,O){var U=y.stateNode,oe=y.memoizedProps;if((y=Gc(y,v))&&oe===A)v.stateNode=U;else{var ve=v.stateNode,Ge=jo(_i.current),ot=null;oe!==A&&(ot=ue(ve,E,oe,A,O,Ge)),y&&ot===null?v.stateNode=U:(U=pt(U,ot,E,oe,A,v,y,ve),te(U,E,A,O,Ge)&&Qs(v),v.stateNode=U,y?Qs(v):Hi(U,v,!1,!1))}},zp=function(y,v,E,A){E!==A?(y=jo(Nu.current),E=jo(_i.current),v.stateNode=_e(A,y,E,v),Qs(v)):v.stateNode=y.stateNode}}else Pu=function(){},$p=function(){},zp=function(){};function Za(y,v){if(!fs)switch(y.tailMode){case"hidden":v=y.tail;for(var E=null;v!==null;)v.alternate!==null&&(E=v),v=v.sibling;E===null?y.tail=null:E.sibling=null;break;case"collapsed":E=y.tail;for(var A=null;E!==null;)E.alternate!==null&&(A=E),E=E.sibling;A===null?v||y.tail===null?y.tail=null:y.tail.sibling=null:A.sibling=null}}function Ps(y){var v=y.alternate!==null&&y.alternate.child===y.child,E=0,A=0;if(v)for(var O=y.child;O!==null;)E|=O.lanes|O.childLanes,A|=O.subtreeFlags&14680064,A|=O.flags&14680064,O.return=y,O=O.sibling;else for(O=y.child;O!==null;)E|=O.lanes|O.childLanes,A|=O.subtreeFlags,A|=O.flags,O.return=y,O=O.sibling;return y.subtreeFlags|=A,y.childLanes=E,v}function Up(y,v,E){var A=v.pendingProps;switch(ry(v),v.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ps(v),null;case 1:return Ds(v.type)&&ls(),Ps(v),null;case 3:return A=v.stateNode,$c(),zt(Es),zt(xn),Au(),A.pendingContext&&(A.context=A.pendingContext,A.pendingContext=null),(y===null||y.child===null)&&(xd(v)?Qs(v):y===null||y.memoizedState.isDehydrated&&(v.flags&256)===0||(v.flags|=1024,po!==null&&(Os(po),po=null))),Pu(y,v),Ps(v),null;case 5:ay(v),E=jo(Nu.current);var O=v.type;if(y!==null&&v.stateNode!=null)$p(y,v,O,A,E),y.ref!==v.ref&&(v.flags|=512,v.flags|=2097152);else{if(!A){if(v.stateNode===null)throw Error(o(166));return Ps(v),null}if(y=jo(_i.current),xd(v)){if(!Be)throw Error(o(175));y=Kg(v.stateNode,v.type,v.memoizedProps,E,y,v,!Dc),v.updateQueue=y,y!==null&&Qs(v)}else{var U=K(O,A,E,y,v);Hi(U,v,!1,!1),v.stateNode=U,te(U,O,A,E,y)&&Qs(v)}v.ref!==null&&(v.flags|=512,v.flags|=2097152)}return Ps(v),null;case 6:if(y&&v.stateNode!=null)zp(y,v,y.memoizedProps,A);else{if(typeof A!="string"&&v.stateNode===null)throw Error(o(166));if(y=jo(Nu.current),E=jo(_i.current),xd(v)){if(!Be)throw Error(o(176));if(y=v.stateNode,A=v.memoizedProps,(E=Va(y,A,v,!Dc))&&(O=ri,O!==null))switch(U=(O.mode&1)!==0,O.tag){case 3:Vt(O.stateNode.containerInfo,y,A,U);break;case 5:Zt(O.type,O.memoizedProps,O.stateNode,y,A,U)}E&&Qs(v)}else v.stateNode=_e(A,y,E,v)}return Ps(v),null;case 13:if(zt(vs),A=v.memoizedState,fs&&Ir!==null&&(v.mode&1)!==0&&(v.flags&128)===0){for(y=Ir;y;)y=Go(y);return Pc(),v.flags|=98560,v}if(A!==null&&A.dehydrated!==null){if(A=xd(v),y===null){if(!A)throw Error(o(318));if(!Be)throw Error(o(344));if(y=v.memoizedState,y=y!==null?y.dehydrated:null,!y)throw Error(o(317));ap(y,v)}else Pc(),(v.flags&128)===0&&(v.memoizedState=null),v.flags|=4;return Ps(v),null}return po!==null&&(Os(po),po=null),(v.flags&128)!==0?(v.lanes=E,v):(A=A!==null,E=!1,y===null?xd(v):E=y.memoizedState!==null,A&&!E&&(v.child.flags|=8192,(v.mode&1)!==0&&(y===null||(vs.current&1)!==0?Us===0&&(Us=3):Od())),v.updateQueue!==null&&(v.flags|=4),Ps(v),null);case 4:return $c(),Pu(y,v),y===null&&He(v.stateNode.containerInfo),Ps(v),null;case 10:return yd(v.type._context),Ps(v),null;case 17:return Ds(v.type)&&ls(),Ps(v),null;case 19:if(zt(vs),O=v.memoizedState,O===null)return Ps(v),null;if(A=(v.flags&128)!==0,U=O.rendering,U===null)if(A)Za(O,!1);else{if(Us!==0||y!==null&&(y.flags&128)!==0)for(y=v.child;y!==null;){if(U=Ep(y),U!==null){for(v.flags|=128,Za(O,!1),y=U.updateQueue,y!==null&&(v.updateQueue=y,v.flags|=4),v.subtreeFlags=0,y=E,A=v.child;A!==null;)E=A,O=y,E.flags&=14680066,U=E.alternate,U===null?(E.childLanes=0,E.lanes=O,E.child=null,E.subtreeFlags=0,E.memoizedProps=null,E.memoizedState=null,E.updateQueue=null,E.dependencies=null,E.stateNode=null):(E.childLanes=U.childLanes,E.lanes=U.lanes,E.child=U.child,E.subtreeFlags=0,E.deletions=null,E.memoizedProps=U.memoizedProps,E.memoizedState=U.memoizedState,E.updateQueue=U.updateQueue,E.type=U.type,O=U.dependencies,E.dependencies=O===null?null:{lanes:O.lanes,firstContext:O.firstContext}),A=A.sibling;return At(vs,vs.current&1|2),v.child}y=y.sibling}O.tail!==null&&Js()>Hl&&(v.flags|=128,A=!0,Za(O,!1),v.lanes=4194304)}else{if(!A)if(y=Ep(U),y!==null){if(v.flags|=128,A=!0,y=y.updateQueue,y!==null&&(v.updateQueue=y,v.flags|=4),Za(O,!0),O.tail===null&&O.tailMode==="hidden"&&!U.alternate&&!fs)return Ps(v),null}else 2*Js()-O.renderingStartTime>Hl&&E!==1073741824&&(v.flags|=128,A=!0,Za(O,!1),v.lanes=4194304);O.isBackwards?(U.sibling=v.child,v.child=U):(y=O.last,y!==null?y.sibling=U:v.child=U,O.last=U)}return O.tail!==null?(v=O.tail,O.rendering=v,O.tail=v.sibling,O.renderingStartTime=Js(),v.sibling=null,y=vs.current,At(vs,A?y&1|2:y&1),v):(Ps(v),null);case 22:case 23:return Ey(),A=v.memoizedState!==null,y!==null&&y.memoizedState!==null!==A&&(v.flags|=8192),A&&(v.mode&1)!==0?(ui&1073741824)!==0&&(Ps(v),et&&v.subtreeFlags&6&&(v.flags|=8192)):Ps(v),null;case 24:return null;case 25:return null}throw Error(o(156,v.tag))}var xy=a.ReactCurrentOwner,ur=!1;function Is(y,v,E,A){v.child=y===null?Vv(v,null,E,A):qa(v,y.child,E,A)}function rs(y,v,E,A,O){E=E.render;var U=v.ref;return Mc(v,O),A=zc(y,v,E,A,U,O),E=Ul(),y!==null&&!ur?(v.updateQueue=y.updateQueue,v.flags&=-2053,y.lanes&=~O,Ti(y,v,O)):(fs&&E&&sy(v),v.flags|=1,Is(y,v,A,O),v.child)}function Kn(y,v,E,A,O){if(y===null){var U=E.type;return typeof U=="function"&&!Ud(U)&&U.defaultProps===void 0&&E.compare===null&&E.defaultProps===void 0?(v.tag=15,v.type=U,Ja(y,v,U,A,O)):(y=Bd(E.type,null,A,v,v.mode,O),y.ref=v.ref,y.return=v,v.child=y)}if(U=y.child,(y.lanes&O)===0){var oe=U.memoizedProps;if(E=E.compare,E=E!==null?E:Ho,E(oe,A)&&y.ref===v.ref)return Ti(y,v,O)}return v.flags|=1,y=il(U,A),y.ref=v.ref,y.return=v,v.child=y}function Ja(y,v,E,A,O){if(y!==null&&Ho(y.memoizedProps,A)&&y.ref===v.ref)if(ur=!1,(y.lanes&O)!==0)(y.flags&131072)!==0&&(ur=!0);else return v.lanes=y.lanes,Ti(y,v,O);return Qa(y,v,E,A,O)}function Nr(y,v,E){var A=v.pendingProps,O=A.children,U=y!==null?y.memoizedState:null;if(A.mode==="hidden")if((v.mode&1)===0)v.memoizedState={baseLanes:0,cachePool:null},At(rl,ui),ui|=E;else if((E&1073741824)!==0)v.memoizedState={baseLanes:0,cachePool:null},A=U!==null?U.baseLanes:E,At(rl,ui),ui|=A;else return y=U!==null?U.baseLanes|E:E,v.lanes=v.childLanes=1073741824,v.memoizedState={baseLanes:y,cachePool:null},v.updateQueue=null,At(rl,ui),ui|=y,null;else U!==null?(A=U.baseLanes|E,v.memoizedState=null):A=E,At(rl,ui),ui|=A;return Is(y,v,O,E),v.child}function ii(y,v){var E=v.ref;(y===null&&E!==null||y!==null&&y.ref!==E)&&(v.flags|=512,v.flags|=2097152)}function Qa(y,v,E,A,O){var U=Ds(E)?ha:xn.current;return U=ti(v,U),Mc(v,O),E=zc(y,v,E,A,U,O),A=Ul(),y!==null&&!ur?(v.updateQueue=y.updateQueue,v.flags&=-2053,y.lanes&=~O,Ti(y,v,O)):(fs&&A&&sy(v),v.flags|=1,Is(y,v,E,O),v.child)}function Lu(y,v,E,A,O){if(Ds(E)){var U=!0;Er(v)}else U=!1;if(Mc(v,O),v.stateNode===null)y!==null&&(y.alternate=null,v.alternate=null,v.flags|=2),Fv(v,E,A),ny(v,E,A,O),A=!0;else if(y===null){var oe=v.stateNode,ve=v.memoizedProps;oe.props=ve;var Ge=oe.context,ot=E.contextType;typeof ot=="object"&&ot!==null?ot=bi(ot):(ot=Ds(E)?ha:xn.current,ot=ti(v,ot));var Nt=E.getDerivedStateFromProps,cn=typeof Nt=="function"||typeof oe.getSnapshotBeforeUpdate=="function";cn||typeof oe.UNSAFE_componentWillReceiveProps!="function"&&typeof oe.componentWillReceiveProps!="function"||(ve!==A||Ge!==ot)&&$v(v,oe,A,ot),ho=!1;var Xt=v.memoizedState;oe.state=Xt,vp(v,A,oe,O),Ge=v.memoizedState,ve!==A||Xt!==Ge||Es.current||ho?(typeof Nt=="function"&&(ey(v,E,Nt,A),Ge=v.memoizedState),(ve=ho||ty(v,E,ve,A,Xt,Ge,ot))?(cn||typeof oe.UNSAFE_componentWillMount!="function"&&typeof oe.componentWillMount!="function"||(typeof oe.componentWillMount=="function"&&oe.componentWillMount(),typeof oe.UNSAFE_componentWillMount=="function"&&oe.UNSAFE_componentWillMount()),typeof oe.componentDidMount=="function"&&(v.flags|=4194308)):(typeof oe.componentDidMount=="function"&&(v.flags|=4194308),v.memoizedProps=A,v.memoizedState=Ge),oe.props=A,oe.state=Ge,oe.context=ot,A=ve):(typeof oe.componentDidMount=="function"&&(v.flags|=4194308),A=!1)}else{oe=v.stateNode,Qg(y,v),ve=v.memoizedProps,ot=v.type===v.elementType?ve:Si(v.type,ve),oe.props=ot,cn=v.pendingProps,Xt=oe.context,Ge=E.contextType,typeof Ge=="object"&&Ge!==null?Ge=bi(Ge):(Ge=Ds(E)?ha:xn.current,Ge=ti(v,Ge));var Yn=E.getDerivedStateFromProps;(Nt=typeof Yn=="function"||typeof oe.getSnapshotBeforeUpdate=="function")||typeof oe.UNSAFE_componentWillReceiveProps!="function"&&typeof oe.componentWillReceiveProps!="function"||(ve!==cn||Xt!==Ge)&&$v(v,oe,A,Ge),ho=!1,Xt=v.memoizedState,oe.state=Xt,vp(v,A,oe,O);var _t=v.memoizedState;ve!==cn||Xt!==_t||Es.current||ho?(typeof Yn=="function"&&(ey(v,E,Yn,A),_t=v.memoizedState),(ot=ho||ty(v,E,ot,A,Xt,_t,Ge)||!1)?(Nt||typeof oe.UNSAFE_componentWillUpdate!="function"&&typeof oe.componentWillUpdate!="function"||(typeof oe.componentWillUpdate=="function"&&oe.componentWillUpdate(A,_t,Ge),typeof oe.UNSAFE_componentWillUpdate=="function"&&oe.UNSAFE_componentWillUpdate(A,_t,Ge)),typeof oe.componentDidUpdate=="function"&&(v.flags|=4),typeof oe.getSnapshotBeforeUpdate=="function"&&(v.flags|=1024)):(typeof oe.componentDidUpdate!="function"||ve===y.memoizedProps&&Xt===y.memoizedState||(v.flags|=4),typeof oe.getSnapshotBeforeUpdate!="function"||ve===y.memoizedProps&&Xt===y.memoizedState||(v.flags|=1024),v.memoizedProps=A,v.memoizedState=_t),oe.props=A,oe.state=_t,oe.context=Ge,A=ot):(typeof oe.componentDidUpdate!="function"||ve===y.memoizedProps&&Xt===y.memoizedState||(v.flags|=4),typeof oe.getSnapshotBeforeUpdate!="function"||ve===y.memoizedProps&&Xt===y.memoizedState||(v.flags|=1024),A=!1)}return Br(y,v,E,A,U,O)}function Br(y,v,E,A,O,U){ii(y,v);var oe=(v.flags&128)!==0;if(!A&&!oe)return O&&Pl(v,E,!1),Ti(y,v,U);A=v.stateNode,xy.current=v;var ve=oe&&typeof E.getDerivedStateFromError!="function"?null:A.render();return v.flags|=1,y!==null&&oe?(v.child=qa(v,y.child,null,U),v.child=qa(v,null,ve,U)):Is(y,v,ve,U),v.memoizedState=A.state,O&&Pl(v,E,!0),v.child}function Nd(y){var v=y.stateNode;v.pendingContext?Bi(y,v.pendingContext,v.pendingContext!==v.context):v.context&&Bi(y,v.context,!1),Cp(y,v.containerInfo)}function vy(y,v,E,A,O){return Pc(),Tp(O),v.flags|=256,Is(y,v,E,A),v.child}var Ad={dehydrated:null,treeContext:null,retryLane:0};function Ou(y){return{baseLanes:y,cachePool:null}}function wy(y,v,E){var A=v.pendingProps,O=vs.current,U=!1,oe=(v.flags&128)!==0,ve;if((ve=oe)||(ve=y!==null&&y.memoizedState===null?!1:(O&2)!==0),ve?(U=!0,v.flags&=-129):(y===null||y.memoizedState!==null)&&(O|=1),At(vs,O&1),y===null)return $l(v),y=v.memoizedState,y!==null&&(y=y.dehydrated,y!==null)?((v.mode&1)===0?v.lanes=1:Ua(y)?v.lanes=8:v.lanes=1073741824,null):(O=A.children,y=A.fallback,U?(A=v.mode,U=v.child,O={mode:"hidden",children:O},(A&1)===0&&U!==null?(U.childLanes=0,U.pendingProps=O):U=nh(O,A,0,null),y=Zl(y,A,E,null),U.return=v,y.return=v,U.sibling=y,v.child=U,v.child.memoizedState=Ou(E),v.memoizedState=Ad,y):Ko(v,O));if(O=y.memoizedState,O!==null){if(ve=O.dehydrated,ve!==null){if(oe)return v.flags&256?(v.flags&=-257,kd(y,v,E,Error(o(422)))):v.memoizedState!==null?(v.child=y.child,v.flags|=128,null):(U=A.fallback,O=v.mode,A=nh({mode:"visible",children:A.children},O,0,null),U=Zl(U,O,E,null),U.flags|=2,A.return=v,U.return=v,A.sibling=U,v.child=A,(v.mode&1)!==0&&qa(v,y.child,null,E),v.child.memoizedState=Ou(E),v.memoizedState=Ad,U);if((v.mode&1)===0)v=kd(y,v,E,null);else if(Ua(ve))v=kd(y,v,E,Error(o(419)));else if(A=(E&y.childLanes)!==0,ur||A){if(A=Ss,A!==null){switch(E&-E){case 4:U=2;break;case 16:U=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:U=32;break;case 536870912:U=268435456;break;default:U=0}A=(U&(A.suspendedLanes|E))!==0?0:U,A!==0&&A!==O.retryLane&&(O.retryLane=A,Ei(y,A,-1))}Od(),v=kd(y,v,E,Error(o(421)))}else cd(ve)?(v.flags|=128,v.child=y.child,v=Jv.bind(null,y),Ba(ve,v),v=null):(E=O.treeContext,Be&&(Ir=op(ve),ri=v,fs=!0,po=null,Dc=!1,E!==null&&(fo[Vi++]=ja,fo[Vi++]=Xa,fo[Vi++]=Cu,ja=E.id,Xa=E.overflow,Cu=v)),v=Ko(v,v.pendingProps.children),v.flags|=4096);return v}return U?(A=Bp(y,v,A.children,A.fallback,E),U=v.child,O=y.child.memoizedState,U.memoizedState=O===null?Ou(E):{baseLanes:O.baseLanes|E,cachePool:null},U.childLanes=y.childLanes&~E,v.memoizedState=Ad,A):(E=Md(y,v,A.children,E),v.memoizedState=null,E)}return U?(A=Bp(y,v,A.children,A.fallback,E),U=v.child,O=y.child.memoizedState,U.memoizedState=O===null?Ou(E):{baseLanes:O.baseLanes|E,cachePool:null},U.childLanes=y.childLanes&~E,v.memoizedState=Ad,A):(E=Md(y,v,A.children,E),v.memoizedState=null,E)}function Ko(y,v){return v=nh({mode:"visible",children:v},y.mode,0,null),v.return=y,y.child=v}function Md(y,v,E,A){var O=y.child;return y=O.sibling,E=il(O,{mode:"visible",children:E}),(v.mode&1)===0&&(E.lanes=A),E.return=v,E.sibling=null,y!==null&&(A=v.deletions,A===null?(v.deletions=[y],v.flags|=16):A.push(y)),v.child=E}function Bp(y,v,E,A,O){var U=v.mode;y=y.child;var oe=y.sibling,ve={mode:"hidden",children:E};return(U&1)===0&&v.child!==y?(E=v.child,E.childLanes=0,E.pendingProps=ve,v.deletions=null):(E=il(y,ve),E.subtreeFlags=y.subtreeFlags&14680064),oe!==null?A=il(oe,A):(A=Zl(A,U,O,null),A.flags|=2),A.return=v,E.return=v,E.sibling=A,v.child=E,A}function kd(y,v,E,A){return A!==null&&Tp(A),qa(v,y.child,null,E),y=Ko(v,v.pendingProps.children),y.flags|=2,v.memoizedState=null,y}function qv(y,v,E){y.lanes|=v;var A=y.alternate;A!==null&&(A.lanes|=v),Tu(y.return,v,E)}function ga(y,v,E,A,O){var U=y.memoizedState;U===null?y.memoizedState={isBackwards:v,rendering:null,renderingStartTime:0,last:A,tail:E,tailMode:O}:(U.isBackwards=v,U.rendering=null,U.renderingStartTime=0,U.last=A,U.tail=E,U.tailMode=O)}function Fu(y,v,E){var A=v.pendingProps,O=A.revealOrder,U=A.tail;if(Is(y,v,A.children,E),A=vs.current,(A&2)!==0)A=A&1|2,v.flags|=128;else{if(y!==null&&(y.flags&128)!==0)e:for(y=v.child;y!==null;){if(y.tag===13)y.memoizedState!==null&&qv(y,E,v);else if(y.tag===19)qv(y,E,v);else if(y.child!==null){y.child.return=y,y=y.child;continue}if(y===v)break e;for(;y.sibling===null;){if(y.return===null||y.return===v)break e;y=y.return}y.sibling.return=y.return,y=y.sibling}A&=1}if(At(vs,A),(v.mode&1)===0)v.memoizedState=null;else switch(O){case"forwards":for(E=v.child,O=null;E!==null;)y=E.alternate,y!==null&&Ep(y)===null&&(O=E),E=E.sibling;E=O,E===null?(O=v.child,v.child=null):(O=E.sibling,E.sibling=null),ga(v,!1,O,E,U);break;case"backwards":for(E=null,O=v.child,v.child=null;O!==null;){if(y=O.alternate,y!==null&&Ep(y)===null){v.child=O;break}y=O.sibling,O.sibling=E,E=O,O=y}ga(v,!0,E,null,U);break;case"together":ga(v,!1,null,null,void 0);break;default:v.memoizedState=null}return v.child}function Ti(y,v,E){if(y!==null&&(v.dependencies=y.dependencies),Uu|=v.lanes,(E&v.childLanes)===0)return null;if(y!==null&&v.child!==y.child)throw Error(o(153));if(v.child!==null){for(y=v.child,E=il(y,y.pendingProps),v.child=E,E.return=v;y.sibling!==null;)y=y.sibling,E=E.sibling=il(y,y.pendingProps),E.return=v;E.sibling=null}return v.child}function Vp(y,v,E){switch(v.tag){case 3:Nd(v),Pc();break;case 5:Wv(v);break;case 1:Ds(v.type)&&Er(v);break;case 4:Cp(v,v.stateNode.containerInfo);break;case 10:_u(v,v.type._context,v.memoizedProps.value);break;case 13:var A=v.memoizedState;if(A!==null)return A.dehydrated!==null?(At(vs,vs.current&1),v.flags|=128,null):(E&v.child.childLanes)!==0?wy(y,v,E):(At(vs,vs.current&1),y=Ti(y,v,E),y!==null?y.sibling:null);At(vs,vs.current&1);break;case 19:if(A=(E&v.childLanes)!==0,(y.flags&128)!==0){if(A)return Fu(y,v,E);v.flags|=128}var O=v.memoizedState;if(O!==null&&(O.rendering=null,O.tail=null,O.lastEffect=null),At(vs,vs.current),A)break;return null;case 22:case 23:return v.lanes=0,Nr(y,v,E)}return Ti(y,v,E)}function Wp(y,v){switch(ry(v),v.tag){case 1:return Ds(v.type)&&ls(),y=v.flags,y&65536?(v.flags=y&-65537|128,v):null;case 3:return $c(),zt(Es),zt(xn),Au(),y=v.flags,(y&65536)!==0&&(y&128)===0?(v.flags=y&-65537|128,v):null;case 5:return ay(v),null;case 13:if(zt(vs),y=v.memoizedState,y!==null&&y.dehydrated!==null){if(v.alternate===null)throw Error(o(340));Pc()}return y=v.flags,y&65536?(v.flags=y&-65537|128,v):null;case 19:return zt(vs),null;case 4:return $c(),null;case 10:return yd(v.type._context),null;case 22:case 23:return Ey(),null;case 24:return null;default:return null}}var oi=!1,cr=!1,$u=typeof WeakSet=="function"?WeakSet:Set,ht=null;function mo(y,v){var E=y.ref;if(E!==null)if(typeof E=="function")try{E(null)}catch(A){hi(y,v,A)}else E.current=null}function el(y,v,E){try{E()}catch(A){hi(y,v,A)}}var Sy=!1;function by(y,v){for(Y(y.containerInfo),ht=v;ht!==null;)if(y=ht,v=y.child,(y.subtreeFlags&1028)!==0&&v!==null)v.return=y,ht=v;else for(;ht!==null;){y=ht;try{var E=y.alternate;if((y.flags&1024)!==0)switch(y.tag){case 0:case 11:case 15:break;case 1:if(E!==null){var A=E.memoizedProps,O=E.memoizedState,U=y.stateNode,oe=U.getSnapshotBeforeUpdate(y.elementType===y.type?A:Si(y.type,A),O);U.__reactInternalSnapshotBeforeUpdate=oe}break;case 3:et&&ct(y.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(o(163))}}catch(ve){hi(y,y.return,ve)}if(v=y.sibling,v!==null){v.return=y.return,ht=v;break}ht=y.return}return E=Sy,Sy=!1,E}function tl(y,v,E){var A=v.updateQueue;if(A=A!==null?A.lastEffect:null,A!==null){var O=A=A.next;do{if((O.tag&y)===y){var U=O.destroy;O.destroy=void 0,U!==void 0&&el(v,E,U)}O=O.next}while(O!==A)}}function Ar(y,v){if(v=v.updateQueue,v=v!==null?v.lastEffect:null,v!==null){var E=v=v.next;do{if((E.tag&y)===y){var A=E.create;E.destroy=A()}E=E.next}while(E!==v)}}function ai(y){var v=y.ref;if(v!==null){var E=y.stateNode;switch(y.tag){case 5:y=J(E);break;default:y=E}typeof v=="function"?v(y):v.current=y}}function us(y,v,E){if(fa&&typeof fa.onCommitFiberUnmount=="function")try{fa.onCommitFiberUnmount(fd,v)}catch{}switch(v.tag){case 0:case 11:case 14:case 15:if(y=v.updateQueue,y!==null&&(y=y.lastEffect,y!==null)){var A=y=y.next;do{var O=A,U=O.destroy;O=O.tag,U!==void 0&&((O&2)!==0||(O&4)!==0)&&el(v,E,U),A=A.next}while(A!==y)}break;case 1:if(mo(v,E),y=v.stateNode,typeof y.componentWillUnmount=="function")try{y.props=v.memoizedProps,y.state=v.memoizedState,y.componentWillUnmount()}catch(oe){hi(v,E,oe)}break;case 5:mo(v,E);break;case 4:et?Cy(y,v,E):ae&&ae&&(v=v.stateNode.containerInfo,E=Kt(v),kn(v,E))}}function go(y,v,E){for(var A=v;;)if(us(y,A,E),A.child===null||et&&A.tag===4){if(A===v)break;for(;A.sibling===null;){if(A.return===null||A.return===v)return;A=A.return}A.sibling.return=A.return,A=A.sibling}else A.child.return=A,A=A.child}function _y(y){var v=y.alternate;v!==null&&(y.alternate=null,_y(v)),y.child=null,y.deletions=null,y.sibling=null,y.tag===5&&(v=y.stateNode,v!==null&&at(v)),y.stateNode=null,y.return=null,y.dependencies=null,y.memoizedProps=null,y.memoizedState=null,y.pendingProps=null,y.stateNode=null,y.updateQueue=null}function Ty(y){return y.tag===5||y.tag===3||y.tag===4}function Gp(y){e:for(;;){for(;y.sibling===null;){if(y.return===null||Ty(y.return))return null;y=y.return}for(y.sibling.return=y.return,y=y.sibling;y.tag!==5&&y.tag!==6&&y.tag!==18;){if(y.flags&2||y.child===null||y.tag===4)continue e;y.child.return=y,y=y.child}if(!(y.flags&2))return y.stateNode}}function Hp(y){if(et){e:{for(var v=y.return;v!==null;){if(Ty(v))break e;v=v.return}throw Error(o(160))}var E=v;switch(E.tag){case 5:v=E.stateNode,E.flags&32&&(Nn(v),E.flags&=-33),E=Gp(y),Hc(y,E,v);break;case 3:case 4:v=E.stateNode.containerInfo,E=Gp(y),jp(y,E,v);break;default:throw Error(o(161))}}}function jp(y,v,E){var A=y.tag;if(A===5||A===6)y=y.stateNode,v?Bt(E,y,v):Yt(E,y);else if(A!==4&&(y=y.child,y!==null))for(jp(y,v,E),y=y.sibling;y!==null;)jp(y,v,E),y=y.sibling}function Hc(y,v,E){var A=y.tag;if(A===5||A===6)y=y.stateNode,v?qt(E,y,v):It(E,y);else if(A!==4&&(y=y.child,y!==null))for(Hc(y,v,E),y=y.sibling;y!==null;)Hc(y,v,E),y=y.sibling}function Cy(y,v,E){for(var A=v,O=!1,U,oe;;){if(!O){O=A.return;e:for(;;){if(O===null)throw Error(o(160));switch(U=O.stateNode,O.tag){case 5:oe=!1;break e;case 3:U=U.containerInfo,oe=!0;break e;case 4:U=U.containerInfo,oe=!0;break e}O=O.return}O=!0}if(A.tag===5||A.tag===6)go(y,A,E),oe?jt(U,A.stateNode):yt(U,A.stateNode);else if(A.tag===18)oe?Pe(U,A.stateNode):$e(U,A.stateNode);else if(A.tag===4){if(A.child!==null){U=A.stateNode.containerInfo,oe=!0,A.child.return=A,A=A.child;continue}}else if(us(y,A,E),A.child!==null){A.child.return=A,A=A.child;continue}if(A===v)break;for(;A.sibling===null;){if(A.return===null||A.return===v)return;A=A.return,A.tag===4&&(O=!1)}A.sibling.return=A.return,A=A.sibling}}function Wl(y,v){if(et){switch(v.tag){case 0:case 11:case 14:case 15:tl(3,v,v.return),Ar(3,v),tl(5,v,v.return);return;case 1:return;case 5:var E=v.stateNode;if(E!=null){var A=v.memoizedProps;y=y!==null?y.memoizedProps:A;var O=v.type,U=v.updateQueue;v.updateQueue=null,U!==null&&un(E,U,O,y,A,v)}return;case 6:if(v.stateNode===null)throw Error(o(162));E=v.memoizedProps,Ke(v.stateNode,y!==null?y.memoizedProps:E,E);return;case 3:Be&&y!==null&&y.memoizedState.isDehydrated&&Ce(v.stateNode.containerInfo);return;case 12:return;case 13:jc(v);return;case 19:jc(v);return;case 17:return}throw Error(o(163))}switch(v.tag){case 0:case 11:case 14:case 15:tl(3,v,v.return),Ar(3,v),tl(5,v,v.return);return;case 12:return;case 13:jc(v);return;case 19:jc(v);return;case 3:Be&&y!==null&&y.memoizedState.isDehydrated&&Ce(v.stateNode.containerInfo);break;case 22:case 23:return}e:if(ae){switch(v.tag){case 1:case 5:case 6:break e;case 3:case 4:v=v.stateNode,kn(v.containerInfo,v.pendingChildren);break e}throw Error(o(163))}}function jc(y){var v=y.updateQueue;if(v!==null){y.updateQueue=null;var E=y.stateNode;E===null&&(E=y.stateNode=new $u),v.forEach(function(A){var O=$d.bind(null,y,A);E.has(A)||(E.add(A),A.then(O,O))})}}function pT(y,v){for(ht=v;ht!==null;){v=ht;var E=v.deletions;if(E!==null)for(var A=0;A<E.length;A++){var O=E[A];try{var U=y;et?Cy(U,O,v):go(U,O,v);var oe=O.alternate;oe!==null&&(oe.return=null),O.return=null}catch(Ot){hi(O,v,Ot)}}if(E=v.child,(v.subtreeFlags&12854)!==0&&E!==null)E.return=v,ht=E;else for(;ht!==null;){v=ht;try{var ve=v.flags;if(ve&32&&et&&Nn(v.stateNode),ve&512){var Ge=v.alternate;if(Ge!==null){var ot=Ge.ref;ot!==null&&(typeof ot=="function"?ot(null):ot.current=null)}}if(ve&8192)switch(v.tag){case 13:if(v.memoizedState!==null){var Nt=v.alternate;(Nt===null||Nt.memoizedState===null)&&(Kp=Js())}break;case 22:var cn=v.memoizedState!==null,Xt=v.alternate,Yn=Xt!==null&&Xt.memoizedState!==null;if(E=v,et){e:if(A=E,O=cn,U=null,et)for(var _t=A;;){if(_t.tag===5){if(U===null){U=_t;var Gn=_t.stateNode;O?jn(Gn):ut(_t.stateNode,_t.memoizedProps)}}else if(_t.tag===6){if(U===null){var qi=_t.stateNode;O?sn(qi):ge(qi,_t.memoizedProps)}}else if((_t.tag!==22&&_t.tag!==23||_t.memoizedState===null||_t===A)&&_t.child!==null){_t.child.return=_t,_t=_t.child;continue}if(_t===A)break;for(;_t.sibling===null;){if(_t.return===null||_t.return===A)break e;U===_t&&(U=null),_t=_t.return}U===_t&&(U=null),_t.sibling.return=_t.return,_t=_t.sibling}}if(cn&&!Yn&&(E.mode&1)!==0){ht=E;for(var ke=E.child;ke!==null;){for(E=ht=ke;ht!==null;){A=ht;var we=A.child;switch(A.tag){case 0:case 11:case 14:case 15:tl(4,A,A.return);break;case 1:mo(A,A.return);var ze=A.stateNode;if(typeof ze.componentWillUnmount=="function"){var wt=A.return;try{ze.props=A.memoizedProps,ze.state=A.memoizedState,ze.componentWillUnmount()}catch(Ot){hi(A,wt,Ot)}}break;case 5:mo(A,A.return);break;case 22:if(A.memoizedState!==null){zu(E);continue}}we!==null?(we.return=A,ht=we):zu(E)}ke=ke.sibling}}}switch(ve&4102){case 2:Hp(v),v.flags&=-3;break;case 6:Hp(v),v.flags&=-3,Wl(v.alternate,v);break;case 4096:v.flags&=-4097;break;case 4100:v.flags&=-4097,Wl(v.alternate,v);break;case 4:Wl(v.alternate,v)}}catch(Ot){hi(v,v.return,Ot)}if(E=v.sibling,E!==null){E.return=v.return,ht=E;break}ht=v.return}}}function Yo(y,v,E){ht=y,Rd(y)}function Rd(y,v,E){for(var A=(y.mode&1)!==0;ht!==null;){var O=ht,U=O.child;if(O.tag===22&&A){var oe=O.memoizedState!==null||oi;if(!oe){var ve=O.alternate,Ge=ve!==null&&ve.memoizedState!==null||cr;ve=oi;var ot=cr;if(oi=oe,(cr=Ge)&&!ot)for(ht=O;ht!==null;)oe=ht,Ge=oe.child,oe.tag===22&&oe.memoizedState!==null?Xp(O):Ge!==null?(Ge.return=oe,ht=Ge):Xp(O);for(;U!==null;)ht=U,Rd(U),U=U.sibling;ht=O,oi=ve,cr=ot}Dd(y)}else(O.subtreeFlags&8772)!==0&&U!==null?(U.return=O,ht=U):Dd(y)}}function Dd(y){for(;ht!==null;){var v=ht;if((v.flags&8772)!==0){var E=v.alternate;try{if((v.flags&8772)!==0)switch(v.tag){case 0:case 11:case 15:cr||Ar(5,v);break;case 1:var A=v.stateNode;if(v.flags&4&&!cr)if(E===null)A.componentDidMount();else{var O=v.elementType===v.type?E.memoizedProps:Si(v.type,E.memoizedProps);A.componentDidUpdate(O,E.memoizedState,A.__reactInternalSnapshotBeforeUpdate)}var U=v.updateQueue;U!==null&&Lv(v,U,A);break;case 3:var oe=v.updateQueue;if(oe!==null){if(E=null,v.child!==null)switch(v.child.tag){case 5:E=J(v.child.stateNode);break;case 1:E=v.child.stateNode}Lv(v,oe,E)}break;case 5:var ve=v.stateNode;E===null&&v.flags&4&&hn(ve,v.type,v.memoizedProps,v);break;case 6:break;case 4:break;case 12:break;case 13:if(Be&&v.memoizedState===null){var Ge=v.alternate;if(Ge!==null){var ot=Ge.memoizedState;if(ot!==null){var Nt=ot.dehydrated;Nt!==null&&Fe(Nt)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(o(163))}cr||v.flags&512&&ai(v)}catch(cn){hi(v,v.return,cn)}}if(v===y){ht=null;break}if(E=v.sibling,E!==null){E.return=v.return,ht=E;break}ht=v.return}}function zu(y){for(;ht!==null;){var v=ht;if(v===y){ht=null;break}var E=v.sibling;if(E!==null){E.return=v.return,ht=E;break}ht=v.return}}function Xp(y){for(;ht!==null;){var v=ht;try{switch(v.tag){case 0:case 11:case 15:var E=v.return;try{Ar(4,v)}catch(Ge){hi(v,E,Ge)}break;case 1:var A=v.stateNode;if(typeof A.componentDidMount=="function"){var O=v.return;try{A.componentDidMount()}catch(Ge){hi(v,O,Ge)}}var U=v.return;try{ai(v)}catch(Ge){hi(v,U,Ge)}break;case 5:var oe=v.return;try{ai(v)}catch(Ge){hi(v,oe,Ge)}}}catch(Ge){hi(v,v.return,Ge)}if(v===y){ht=null;break}var ve=v.sibling;if(ve!==null){ve.return=v.return,ht=ve;break}ht=v.return}}var Xc=0,qc=1,Kc=2,nl=3,li=4;if(typeof Symbol=="function"&&Symbol.for){var Zo=Symbol.for;Xc=Zo("selector.component"),qc=Zo("selector.has_pseudo_class"),Kc=Zo("selector.role"),nl=Zo("selector.test_id"),li=Zo("selector.text")}function Pd(y){var v=De(y);if(v!=null){if(typeof v.memoizedProps["data-testname"]!="string")throw Error(o(364));return v}if(y=Se(y),y===null)throw Error(o(362));return y.stateNode.current}function qp(y,v){switch(v.$$typeof){case Xc:if(y.type===v.value)return!0;break;case qc:e:{v=v.value,y=[y,0];for(var E=0;E<y.length;){var A=y[E++],O=y[E++],U=v[O];if(A.tag!==5||!je(A)){for(;U!=null&&qp(A,U);)O++,U=v[O];if(O===v.length){v=!0;break e}else for(A=A.child;A!==null;)y.push(A,O),A=A.sibling}}v=!1}return v;case Kc:if(y.tag===5&&xt(y.stateNode,v.value))return!0;break;case li:if((y.tag===5||y.tag===6)&&(y=Xe(y),y!==null&&0<=y.indexOf(v.value)))return!0;break;case nl:if(y.tag===5&&(y=y.memoizedProps["data-testname"],typeof y=="string"&&y.toLowerCase()===v.value.toLowerCase()))return!0;break;default:throw Error(o(365))}return!1}function Jo(y){switch(y.$$typeof){case Xc:return"<"+(P(y.value)||"Unknown")+">";case qc:return":has("+(Jo(y)||"")+")";case Kc:return'[role="'+y.value+'"]';case li:return'"'+y.value+'"';case nl:return'[data-testname="'+y.value+'"]';default:throw Error(o(365))}}function sl(y,v){var E=[];y=[y,0];for(var A=0;A<y.length;){var O=y[A++],U=y[A++],oe=v[U];if(O.tag!==5||!je(O)){for(;oe!=null&&qp(O,oe);)U++,oe=v[U];if(U===v.length)E.push(O);else for(O=O.child;O!==null;)y.push(O,U),O=O.sibling}}return E}function Ld(y,v){if(!X)throw Error(o(363));y=Pd(y),y=sl(y,v),v=[],y=Array.from(y);for(var E=0;E<y.length;){var A=y[E++];if(A.tag===5)je(A)||v.push(A.stateNode);else for(A=A.child;A!==null;)y.push(A),A=A.sibling}return v}var Kv=Math.ceil,yo=a.ReactCurrentDispatcher,ya=a.ReactCurrentOwner,ps=a.ReactCurrentBatchConfig,pn=0,Ss=null,Ls=null,hr=0,ui=0,rl=Rs(0),Us=0,Yc=null,Uu=0,Zc=0,Bu=0,Gl=null,ci=null,Kp=0,Hl=1/0;function Vu(){Hl=Js()+500}var jl=!1,xo=null,vo=null,Xl=!1,Ci=null,Jc=0,xa=0,Yp=null,Qc=-1,is=0;function dr(){return(pn&6)!==0?Js():Qc!==-1?Qc:Qc=Js()}function va(y){return(y.mode&1)===0?1:(pn&2)!==0&&hr!==0?hr&-hr:Pv.transition!==null?(is===0&&(y=Ic,Ic<<=1,(Ic&4194240)===0&&(Ic=64),is=y),is):(y=vn,y!==0?y:Re())}function Ei(y,v,E){if(50<xa)throw xa=0,Yp=null,Error(o(185));var A=Wu(y,v);return A===null?null:(vu(A,v,E),((pn&2)===0||A!==Ss)&&(A===Ss&&((pn&2)===0&&(Zc|=v),Us===4&&Qo(A,hr)),Vr(A,E),v===1&&pn===0&&(y.mode&1)===0&&(Vu(),fp&&uo())),A)}function Wu(y,v){y.lanes|=v;var E=y.alternate;for(E!==null&&(E.lanes|=v),E=y,y=y.return;y!==null;)y.childLanes|=v,E=y.alternate,E!==null&&(E.childLanes|=v),E=y,y=y.return;return E.tag===3?E.stateNode:null}function Vr(y,v){var E=y.callbackNode;Dv(y,v);var A=dd(y,y===Ss?hr:0);if(A===0)E!==null&&Ac(E),y.callbackNode=null,y.callbackPriority=0;else if(v=A&-A,y.callbackPriority!==v){if(E!=null&&Ac(E),v===1)y.tag===0?mp(eh.bind(null,y)):pp(eh.bind(null,y)),Qe?ee(function(){pn===0&&uo()}):wu(Su,uo),E=null;else{switch(Wa(A)){case 1:E=Su;break;case 4:E=hT;break;case 16:E=hp;break;case 536870912:E=dp;break;default:E=hp}E=zd(E,ql.bind(null,y))}y.callbackPriority=v,y.callbackNode=E}}function ql(y,v){if(Qc=-1,is=0,(pn&6)!==0)throw Error(o(327));var E=y.callbackNode;if(Yl()&&y.callbackNode!==E)return null;var A=dd(y,y===Ss?hr:0);if(A===0)return null;if((A&30)!==0||(A&y.expiredLanes)!==0||v)v=ji(y,A);else{v=A;var O=pn;pn|=2;var U=Jp();(Ss!==y||hr!==v)&&(Vu(),Ns(y,v));do try{Fd();break}catch(ve){Zp(y,ve)}while(!0);si(),yo.current=U,pn=O,Ls!==null?v=0:(Ss=null,hr=0,v=Us)}if(v!==0){if(v===2&&(O=lp(y),O!==0&&(A=O,v=cs(y,O))),v===1)throw E=Yc,Ns(y,0),Qo(y,A),Vr(y,Js()),E;if(v===6)Qo(y,A);else{if(O=y.current.alternate,(A&30)===0&&!fr(O)&&(v=ji(y,A),v===2&&(U=lp(y),U!==0&&(A=U,v=cs(y,U))),v===1))throw E=Yc,Ns(y,0),Qo(y,A),Vr(y,Js()),E;switch(y.finishedWork=O,y.finishedLanes=A,v){case 0:case 1:throw Error(o(345));case 2:Kl(y,ci);break;case 3:if(Qo(y,A),(A&130023424)===A&&(v=Kp+500-Js(),10<v)){if(dd(y,0)!==0)break;if(O=y.suspendedLanes,(O&A)!==A){dr(),y.pingedLanes|=y.suspendedLanes&O;break}y.timeoutHandle=Ie(Kl.bind(null,y,ci),v);break}Kl(y,ci);break;case 4:if(Qo(y,A),(A&4194240)===A)break;for(v=y.eventTimes,O=-1;0<A;){var oe=31-wi(A);U=1<<oe,oe=v[oe],oe>O&&(O=oe),A&=~U}if(A=O,A=Js()-A,A=(120>A?120:480>A?480:1080>A?1080:1920>A?1920:3e3>A?3e3:4320>A?4320:1960*Kv(A/1960))-A,10<A){y.timeoutHandle=Ie(Kl.bind(null,y,ci),A);break}Kl(y,ci);break;case 5:Kl(y,ci);break;default:throw Error(o(329))}}}return Vr(y,Js()),y.callbackNode===E?ql.bind(null,y):null}function cs(y,v){var E=Gl;return y.current.memoizedState.isDehydrated&&(Ns(y,v).flags|=256),y=ji(y,v),y!==2&&(v=ci,ci=E,v!==null&&Os(v)),y}function Os(y){ci===null?ci=y:ci.push.apply(ci,y)}function fr(y){for(var v=y;;){if(v.flags&16384){var E=v.updateQueue;if(E!==null&&(E=E.stores,E!==null))for(var A=0;A<E.length;A++){var O=E[A],U=O.getSnapshot;O=O.value;try{if(!ni(U(),O))return!1}catch{return!1}}}if(E=v.child,v.subtreeFlags&16384&&E!==null)E.return=v,v=E;else{if(v===y)break;for(;v.sibling===null;){if(v.return===null||v.return===y)return!0;v=v.return}v.sibling.return=v.return,v=v.sibling}}return!0}function Qo(y,v){for(v&=~Bu,v&=~Zc,y.suspendedLanes|=v,y.pingedLanes&=~v,y=y.expirationTimes;0<v;){var E=31-wi(v),A=1<<E;y[E]=-1,v&=~A}}function eh(y){if((pn&6)!==0)throw Error(o(327));Yl();var v=dd(y,0);if((v&1)===0)return Vr(y,Js()),null;var E=ji(y,v);if(y.tag!==0&&E===2){var A=lp(y);A!==0&&(v=A,E=cs(y,A))}if(E===1)throw E=Yc,Ns(y,0),Qo(y,v),Vr(y,Js()),E;if(E===6)throw Error(o(345));return y.finishedWork=y.current.alternate,y.finishedLanes=v,Kl(y,ci),Vr(y,Js()),null}function th(y){Ci!==null&&Ci.tag===0&&(pn&6)===0&&Yl();var v=pn;pn|=1;var E=ps.transition,A=vn;try{if(ps.transition=null,vn=1,y)return y()}finally{vn=A,ps.transition=E,pn=v,(pn&6)===0&&uo()}}function Ey(){ui=rl.current,zt(rl)}function Ns(y,v){y.finishedWork=null,y.finishedLanes=0;var E=y.timeoutHandle;if(E!==qe&&(y.timeoutHandle=qe,Ve(E)),Ls!==null)for(E=Ls.return;E!==null;){var A=E;switch(ry(A),A.tag){case 1:A=A.type.childContextTypes,A!=null&&ls();break;case 3:$c(),zt(Es),zt(xn),Au();break;case 5:ay(A);break;case 4:$c();break;case 13:zt(vs);break;case 19:zt(vs);break;case 10:yd(A.type._context);break;case 22:case 23:Ey()}E=E.return}if(Ss=y,Ls=y=il(y.current,null),hr=ui=v,Us=0,Yc=null,Bu=Zc=Uu=0,ci=Gl=null,co!==null){for(v=0;v<co.length;v++)if(E=co[v],A=E.interleaved,A!==null){E.interleaved=null;var O=A.next,U=E.pending;if(U!==null){var oe=U.next;U.next=O,A.next=oe}E.pending=A}co=null}return y}function Zp(y,v){do{var E=Ls;try{if(si(),vd.current=Wc,Ip){for(var A=ws.memoizedState;A!==null;){var O=A.queue;O!==null&&(O.pending=null),A=A.next}Ip=!1}if(Mu=0,ar=or=ws=null,pa=!1,ku=0,ya.current=null,E===null||E.return===null){Us=1,Yc=v,Ls=null;break}e:{var U=y,oe=E.return,ve=E,Ge=v;if(v=hr,ve.flags|=32768,Ge!==null&&typeof Ge=="object"&&typeof Ge.then=="function"){var ot=Ge,Nt=ve,cn=Nt.tag;if((Nt.mode&1)===0&&(cn===0||cn===11||cn===15)){var Xt=Nt.alternate;Xt?(Nt.updateQueue=Xt.updateQueue,Nt.memoizedState=Xt.memoizedState,Nt.lanes=Xt.lanes):(Nt.updateQueue=null,Nt.memoizedState=null)}var Yn=yy(oe);if(Yn!==null){Yn.flags&=-257,Du(Yn,oe,ve,U,v),Yn.mode&1&&Ya(U,ot,v),v=Yn,Ge=ot;var _t=v.updateQueue;if(_t===null){var Gn=new Set;Gn.add(Ge),v.updateQueue=Gn}else _t.add(Ge);break e}else{if((v&1)===0){Ya(U,ot,v),Od();break e}Ge=Error(o(426))}}else if(fs&&ve.mode&1){var qi=yy(oe);if(qi!==null){(qi.flags&65536)===0&&(qi.flags|=256),Du(qi,oe,ve,U,v),Tp(Ge);break e}}U=Ge,Us!==4&&(Us=2),Gl===null?Gl=[U]:Gl.push(U),Ge=gy(Ge,ve),ve=oe;do{switch(ve.tag){case 3:ve.flags|=65536,v&=-v,ve.lanes|=v;var ke=Xv(ve,Ge,v);xp(ve,ke);break e;case 1:U=Ge;var we=ve.type,ze=ve.stateNode;if((ve.flags&128)===0&&(typeof we.getDerivedStateFromError=="function"||ze!==null&&typeof ze.componentDidCatch=="function"&&(vo===null||!vo.has(ze)))){ve.flags|=65536,v&=-v,ve.lanes|=v;var wt=Fp(ve,U,v);xp(ve,wt);break e}}ve=ve.return}while(ve!==null)}em(E)}catch(Ot){v=Ot,Ls===E&&E!==null&&(Ls=E=E.return);continue}break}while(!0)}function Jp(){var y=yo.current;return yo.current=Wc,y===null?Wc:y}function Od(){(Us===0||Us===3||Us===2)&&(Us=4),Ss===null||(Uu&268435455)===0&&(Zc&268435455)===0||Qo(Ss,hr)}function ji(y,v){var E=pn;pn|=2;var A=Jp();Ss===y&&hr===v||Ns(y,v);do try{wo();break}catch(O){Zp(y,O)}while(!0);if(si(),pn=E,yo.current=A,Ls!==null)throw Error(o(261));return Ss=null,hr=0,Us}function wo(){for(;Ls!==null;)Qp(Ls)}function Fd(){for(;Ls!==null&&!Ll();)Qp(Ls)}function Qp(y){var v=Ay(y.alternate,y,ui);y.memoizedProps=y.pendingProps,v===null?em(y):Ls=v,ya.current=null}function em(y){var v=y;do{var E=v.alternate;if(y=v.return,(v.flags&32768)===0){if(E=Up(E,v,ui),E!==null){Ls=E;return}}else{if(E=Wp(E,v),E!==null){E.flags&=32767,Ls=E;return}if(y!==null)y.flags|=32768,y.subtreeFlags=0,y.deletions=null;else{Us=6,Ls=null;return}}if(v=v.sibling,v!==null){Ls=v;return}Ls=v=y}while(v!==null);Us===0&&(Us=5)}function Kl(y,v){var E=vn,A=ps.transition;try{ps.transition=null,vn=1,Yv(y,v,E)}finally{ps.transition=A,vn=E}return null}function Yv(y,v,E){do Yl();while(Ci!==null);if((pn&6)!==0)throw Error(o(327));var A=y.finishedWork,O=y.finishedLanes;if(A===null)return null;if(y.finishedWork=null,y.finishedLanes=0,A===y.current)throw Error(o(177));y.callbackNode=null,y.callbackPriority=0;var U=A.lanes|A.childLanes;if(cp(y,U),y===Ss&&(Ls=Ss=null,hr=0),(A.subtreeFlags&2064)===0&&(A.flags&2064)===0||Xl||(Xl=!0,zd(hp,function(){return Yl(),null})),U=(A.flags&15990)!==0,(A.subtreeFlags&15990)!==0||U){U=ps.transition,ps.transition=null;var oe=vn;vn=1;var ve=pn;pn|=4,ya.current=null,by(y,A),pT(y,A),B(y.containerInfo),y.current=A,Yo(A),cT(),pn=ve,vn=oe,ps.transition=U}else y.current=A;if(Xl&&(Xl=!1,Ci=y,Jc=O),U=y.pendingLanes,U===0&&(vo=null),pd(A.stateNode),Vr(y,Js()),v!==null)for(E=y.onRecoverableError,A=0;A<v.length;A++)E(v[A]);if(jl)throw jl=!1,y=xo,xo=null,y;return(Jc&1)!==0&&y.tag!==0&&Yl(),U=y.pendingLanes,(U&1)!==0?y===Yp?xa++:(xa=0,Yp=y):xa=0,uo(),null}function Yl(){if(Ci!==null){var y=Wa(Jc),v=ps.transition,E=vn;try{if(ps.transition=null,vn=16>y?16:y,Ci===null)var A=!1;else{if(y=Ci,Ci=null,Jc=0,(pn&6)!==0)throw Error(o(331));var O=pn;for(pn|=4,ht=y.current;ht!==null;){var U=ht,oe=U.child;if((ht.flags&16)!==0){var ve=U.deletions;if(ve!==null){for(var Ge=0;Ge<ve.length;Ge++){var ot=ve[Ge];for(ht=ot;ht!==null;){var Nt=ht;switch(Nt.tag){case 0:case 11:case 15:tl(8,Nt,U)}var cn=Nt.child;if(cn!==null)cn.return=Nt,ht=cn;else for(;ht!==null;){Nt=ht;var Xt=Nt.sibling,Yn=Nt.return;if(_y(Nt),Nt===ot){ht=null;break}if(Xt!==null){Xt.return=Yn,ht=Xt;break}ht=Yn}}}var _t=U.alternate;if(_t!==null){var Gn=_t.child;if(Gn!==null){_t.child=null;do{var qi=Gn.sibling;Gn.sibling=null,Gn=qi}while(Gn!==null)}}ht=U}}if((U.subtreeFlags&2064)!==0&&oe!==null)oe.return=U,ht=oe;else e:for(;ht!==null;){if(U=ht,(U.flags&2048)!==0)switch(U.tag){case 0:case 11:case 15:tl(9,U,U.return)}var ke=U.sibling;if(ke!==null){ke.return=U.return,ht=ke;break e}ht=U.return}}var we=y.current;for(ht=we;ht!==null;){oe=ht;var ze=oe.child;if((oe.subtreeFlags&2064)!==0&&ze!==null)ze.return=oe,ht=ze;else e:for(oe=we;ht!==null;){if(ve=ht,(ve.flags&2048)!==0)try{switch(ve.tag){case 0:case 11:case 15:Ar(9,ve)}}catch(Ot){hi(ve,ve.return,Ot)}if(ve===oe){ht=null;break e}var wt=ve.sibling;if(wt!==null){wt.return=ve.return,ht=wt;break e}ht=ve.return}}if(pn=O,uo(),fa&&typeof fa.onPostCommitFiberRoot=="function")try{fa.onPostCommitFiberRoot(fd,y)}catch{}A=!0}return A}finally{vn=E,ps.transition=v}}return!1}function Iy(y,v,E){v=gy(E,v),v=Xv(y,v,1),Ol(y,v),v=dr(),y=Wu(y,1),y!==null&&(vu(y,1,v),Vr(y,v))}function hi(y,v,E){if(y.tag===3)Iy(y,y,E);else for(;v!==null;){if(v.tag===3){Iy(v,y,E);break}else if(v.tag===1){var A=v.stateNode;if(typeof v.type.getDerivedStateFromError=="function"||typeof A.componentDidCatch=="function"&&(vo===null||!vo.has(A))){y=gy(E,y),y=Fp(v,y,1),Ol(v,y),y=dr(),v=Wu(v,1),v!==null&&(vu(v,1,y),Vr(v,y));break}}v=v.return}}function Zv(y,v,E){var A=y.pingCache;A!==null&&A.delete(v),v=dr(),y.pingedLanes|=y.suspendedLanes&E,Ss===y&&(hr&E)===E&&(Us===4||Us===3&&(hr&130023424)===hr&&500>Js()-Kp?Ns(y,0):Bu|=E),Vr(y,v)}function Ny(y,v){v===0&&((y.mode&1)===0?v=1:(v=$n,$n<<=1,($n&130023424)===0&&($n=4194304)));var E=dr();y=Wu(y,v),y!==null&&(vu(y,v,E),Vr(y,E))}function Jv(y){var v=y.memoizedState,E=0;v!==null&&(E=v.retryLane),Ny(y,E)}function $d(y,v){var E=0;switch(y.tag){case 13:var A=y.stateNode,O=y.memoizedState;O!==null&&(E=O.retryLane);break;case 19:A=y.stateNode;break;default:throw Error(o(314))}A!==null&&A.delete(v),Ny(y,E)}var Ay;Ay=function(y,v,E){if(y!==null)if(y.memoizedProps!==v.pendingProps||Es.current)ur=!0;else{if((y.lanes&E)===0&&(v.flags&128)===0)return ur=!1,Vp(y,v,E);ur=(y.flags&131072)!==0}else ur=!1,fs&&(v.flags&1048576)!==0&&zv(v,bp,v.index);switch(v.lanes=0,v.tag){case 2:var A=v.type;y!==null&&(y.alternate=null,v.alternate=null,v.flags|=2),y=v.pendingProps;var O=ti(v,xn.current);Mc(v,E),O=zc(null,v,A,y,O,E);var U=Ul();return v.flags|=1,typeof O=="object"&&O!==null&&typeof O.render=="function"&&O.$$typeof===void 0?(v.tag=1,v.memoizedState=null,v.updateQueue=null,Ds(A)?(U=!0,Er(v)):U=!1,v.memoizedState=O.state!==null&&O.state!==void 0?O.state:null,kc(v),O.updater=wp,v.stateNode=O,O._reactInternals=v,ny(v,A,y,E),v=Br(null,v,A,!0,U,E)):(v.tag=0,fs&&U&&sy(v),Is(null,v,O,E),v=v.child),v;case 16:A=v.elementType;e:{switch(y!==null&&(y.alternate=null,v.alternate=null,v.flags|=2),y=v.pendingProps,O=A._init,A=O(A._payload),v.type=A,O=v.tag=Qv(A),y=Si(A,y),O){case 0:v=Qa(null,v,A,y,E);break e;case 1:v=Lu(null,v,A,y,E);break e;case 11:v=rs(null,v,A,y,E);break e;case 14:v=Kn(null,v,A,Si(A.type,y),E);break e}throw Error(o(306,A,""))}return v;case 0:return A=v.type,O=v.pendingProps,O=v.elementType===A?O:Si(A,O),Qa(y,v,A,O,E);case 1:return A=v.type,O=v.pendingProps,O=v.elementType===A?O:Si(A,O),Lu(y,v,A,O,E);case 3:e:{if(Nd(v),y===null)throw Error(o(387));A=v.pendingProps,U=v.memoizedState,O=U.element,Qg(y,v),vp(v,A,null,E);var oe=v.memoizedState;if(A=oe.element,Be&&U.isDehydrated)if(U={element:A,isDehydrated:!1,cache:oe.cache,transitions:oe.transitions},v.updateQueue.baseState=U,v.memoizedState=U,v.flags&256){O=Error(o(423)),v=vy(y,v,A,E,O);break e}else if(A!==O){O=Error(o(424)),v=vy(y,v,A,E,O);break e}else for(Be&&(Ir=ip(v.stateNode.containerInfo),ri=v,fs=!0,po=null,Dc=!1),E=Vv(v,null,A,E),v.child=E;E;)E.flags=E.flags&-3|4096,E=E.sibling;else{if(Pc(),A===O){v=Ti(y,v,E);break e}Is(y,v,A,E)}v=v.child}return v;case 5:return Wv(v),y===null&&$l(v),A=v.type,O=v.pendingProps,U=y!==null?y.memoizedProps:null,oe=O.children,fe(A,O)?oe=null:U!==null&&fe(A,U)&&(v.flags|=32),ii(y,v),Is(y,v,oe,E),v.child;case 6:return y===null&&$l(v),null;case 13:return wy(y,v,E);case 4:return Cp(v,v.stateNode.containerInfo),A=v.pendingProps,y===null?v.child=qa(v,null,A,E):Is(y,v,A,E),v.child;case 11:return A=v.type,O=v.pendingProps,O=v.elementType===A?O:Si(A,O),rs(y,v,A,O,E);case 7:return Is(y,v,v.pendingProps,E),v.child;case 8:return Is(y,v,v.pendingProps.children,E),v.child;case 12:return Is(y,v,v.pendingProps.children,E),v.child;case 10:e:{if(A=v.type._context,O=v.pendingProps,U=v.memoizedProps,oe=O.value,_u(v,A,oe),U!==null)if(ni(U.value,oe)){if(U.children===O.children&&!Es.current){v=Ti(y,v,E);break e}}else for(U=v.child,U!==null&&(U.return=v);U!==null;){var ve=U.dependencies;if(ve!==null){oe=U.child;for(var Ge=ve.firstContext;Ge!==null;){if(Ge.context===A){if(U.tag===1){Ge=Ha(-1,E&-E),Ge.tag=2;var ot=U.updateQueue;if(ot!==null){ot=ot.shared;var Nt=ot.pending;Nt===null?Ge.next=Ge:(Ge.next=Nt.next,Nt.next=Ge),ot.pending=Ge}}U.lanes|=E,Ge=U.alternate,Ge!==null&&(Ge.lanes|=E),Tu(U.return,E,v),ve.lanes|=E;break}Ge=Ge.next}}else if(U.tag===10)oe=U.type===v.type?null:U.child;else if(U.tag===18){if(oe=U.return,oe===null)throw Error(o(341));oe.lanes|=E,ve=oe.alternate,ve!==null&&(ve.lanes|=E),Tu(oe,E,v),oe=U.sibling}else oe=U.child;if(oe!==null)oe.return=U;else for(oe=U;oe!==null;){if(oe===v){oe=null;break}if(U=oe.sibling,U!==null){U.return=oe.return,oe=U;break}oe=oe.return}U=oe}Is(y,v,O.children,E),v=v.child}return v;case 9:return O=v.type,A=v.pendingProps.children,Mc(v,E),O=bi(O),A=A(O),v.flags|=1,Is(y,v,A,E),v.child;case 14:return A=v.type,O=Si(A,v.pendingProps),O=Si(A.type,O),Kn(y,v,A,O,E);case 15:return Ja(y,v,v.type,v.pendingProps,E);case 17:return A=v.type,O=v.pendingProps,O=v.elementType===A?O:Si(A,O),y!==null&&(y.alternate=null,v.alternate=null,v.flags|=2),v.tag=1,Ds(A)?(y=!0,Er(v)):y=!1,Mc(v,E),Fv(v,A,O),ny(v,A,O,E),Br(null,v,A,!0,y,E);case 19:return Fu(y,v,E);case 22:return Nr(y,v,E)}throw Error(o(156,v.tag))};function zd(y,v){return wu(y,v)}function tm(y,v,E,A){this.tag=y,this.key=E,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=v,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=A,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Xi(y,v,E,A){return new tm(y,v,E,A)}function Ud(y){return y=y.prototype,!(!y||!y.isReactComponent)}function Qv(y){if(typeof y=="function")return Ud(y)?1:0;if(y!=null){if(y=y.$$typeof,y===S)return 11;if(y===_)return 14}return 2}function il(y,v){var E=y.alternate;return E===null?(E=Xi(y.tag,v,y.key,y.mode),E.elementType=y.elementType,E.type=y.type,E.stateNode=y.stateNode,E.alternate=y,y.alternate=E):(E.pendingProps=v,E.type=y.type,E.flags=0,E.subtreeFlags=0,E.deletions=null),E.flags=y.flags&14680064,E.childLanes=y.childLanes,E.lanes=y.lanes,E.child=y.child,E.memoizedProps=y.memoizedProps,E.memoizedState=y.memoizedState,E.updateQueue=y.updateQueue,v=y.dependencies,E.dependencies=v===null?null:{lanes:v.lanes,firstContext:v.firstContext},E.sibling=y.sibling,E.index=y.index,E.ref=y.ref,E}function Bd(y,v,E,A,O,U){var oe=2;if(A=y,typeof y=="function")Ud(y)&&(oe=1);else if(typeof y=="string")oe=5;else e:switch(y){case c:return Zl(E.children,O,U,v);case h:oe=8,O|=8;break;case f:return y=Xi(12,E,v,O|2),y.elementType=f,y.lanes=U,y;case x:return y=Xi(13,E,v,O),y.elementType=x,y.lanes=U,y;case w:return y=Xi(19,E,v,O),y.elementType=w,y.lanes=U,y;case C:return nh(E,O,U,v);default:if(typeof y=="object"&&y!==null)switch(y.$$typeof){case p:oe=10;break e;case g:oe=9;break e;case S:oe=11;break e;case _:oe=14;break e;case T:oe=16,A=null;break e}throw Error(o(130,y==null?y:typeof y,""))}return v=Xi(oe,E,v,O),v.elementType=y,v.type=A,v.lanes=U,v}function Zl(y,v,E,A){return y=Xi(7,y,A,v),y.lanes=E,y}function nh(y,v,E,A){return y=Xi(22,y,A,v),y.elementType=C,y.lanes=E,y.stateNode={},y}function nm(y,v,E){return y=Xi(6,y,null,v),y.lanes=E,y}function sm(y,v,E){return v=Xi(4,y.children!==null?y.children:[],y.key,v),v.lanes=E,v.stateNode={containerInfo:y.containerInfo,pendingChildren:null,implementation:y.implementation},v}function e1(y,v,E,A,O){this.tag=v,this.containerInfo=y,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=qe,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=up(0),this.expirationTimes=up(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=up(0),this.identifierPrefix=A,this.onRecoverableError=O,Be&&(this.mutableSourceEagerHydrationData=null)}function t1(y,v,E,A,O,U,oe,ve,Ge){return y=new e1(y,v,E,ve,Ge),v===1?(v=1,U===!0&&(v|=8)):v=0,U=Xi(3,null,null,v),y.current=U,U.stateNode=y,U.memoizedState={element:A,isDehydrated:E,cache:null,transitions:null},kc(U),y}function My(y){if(!y)return Cs;y=y._reactInternals;e:{if(R(y)!==y||y.tag!==1)throw Error(o(170));var v=y;do{switch(v.tag){case 3:v=v.stateNode.context;break e;case 1:if(Ds(v.type)){v=v.stateNode.__reactInternalMemoizedMergedChildContext;break e}}v=v.return}while(v!==null);throw Error(o(171))}if(y.tag===1){var E=y.type;if(Ds(E))return Cc(y,E,v)}return v}function n1(y){var v=y._reactInternals;if(v===void 0)throw typeof y.render=="function"?Error(o(188)):(y=Object.keys(y).join(","),Error(o(268,y)));return y=G(v),y===null?null:y.stateNode}function s1(y,v){if(y=y.memoizedState,y!==null&&y.dehydrated!==null){var E=y.retryLane;y.retryLane=E!==0&&E<v?E:v}}function rm(y,v){s1(y,v),(y=y.alternate)&&s1(y,v)}function r1(y){return y=G(y),y===null?null:y.stateNode}function i1(){return null}return t.attemptContinuousHydration=function(y){if(y.tag===13){var v=dr();Ei(y,134217728,v),rm(y,134217728)}},t.attemptHydrationAtCurrentPriority=function(y){if(y.tag===13){var v=dr(),E=va(y);Ei(y,E,v),rm(y,E)}},t.attemptSynchronousHydration=function(y){switch(y.tag){case 3:var v=y.stateNode;if(v.current.memoizedState.isDehydrated){var E=Nc(v.pendingLanes);E!==0&&(da(v,E|1),Vr(v,Js()),(pn&6)===0&&(Vu(),uo()))}break;case 13:var A=dr();th(function(){return Ei(y,1,A)}),rm(y,1)}},t.batchedUpdates=function(y,v){var E=pn;pn|=1;try{return y(v)}finally{pn=E,pn===0&&(Vu(),fp&&uo())}},t.createComponentSelector=function(y){return{$$typeof:Xc,value:y}},t.createContainer=function(y,v,E,A,O,U,oe){return t1(y,v,!1,null,E,A,O,U,oe)},t.createHasPseudoClassSelector=function(y){return{$$typeof:qc,value:y}},t.createHydrationContainer=function(y,v,E,A,O,U,oe,ve,Ge){return y=t1(E,A,!0,y,O,U,oe,ve,Ge),y.context=My(null),E=y.current,A=dr(),O=va(E),U=Ha(A,O),U.callback=v??null,Ol(E,U),y.current.lanes=O,vu(y,O,A),Vr(y,A),y},t.createPortal=function(y,v,E){var A=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:u,key:A==null?null:""+A,children:y,containerInfo:v,implementation:E}},t.createRoleSelector=function(y){return{$$typeof:Kc,value:y}},t.createTestNameSelector=function(y){return{$$typeof:nl,value:y}},t.createTextSelector=function(y){return{$$typeof:li,value:y}},t.deferredUpdates=function(y){var v=vn,E=ps.transition;try{return ps.transition=null,vn=16,y()}finally{vn=v,ps.transition=E}},t.discreteUpdates=function(y,v,E,A,O){var U=vn,oe=ps.transition;try{return ps.transition=null,vn=1,y(v,E,A,O)}finally{vn=U,ps.transition=oe,pn===0&&Vu()}},t.findAllNodes=Ld,t.findBoundingRects=function(y,v){if(!X)throw Error(o(363));v=Ld(y,v),y=[];for(var E=0;E<v.length;E++)y.push(We(v[E]));for(v=y.length-1;0<v;v--){E=y[v];for(var A=E.x,O=A+E.width,U=E.y,oe=U+E.height,ve=v-1;0<=ve;ve--)if(v!==ve){var Ge=y[ve],ot=Ge.x,Nt=ot+Ge.width,cn=Ge.y,Xt=cn+Ge.height;if(A>=ot&&U>=cn&&O<=Nt&&oe<=Xt){y.splice(v,1);break}else if(A!==ot||E.width!==Ge.width||Xt<U||cn>oe){if(!(U!==cn||E.height!==Ge.height||Nt<A||ot>O)){ot>A&&(Ge.width+=ot-A,Ge.x=A),Nt<O&&(Ge.width=O-ot),y.splice(v,1);break}}else{cn>U&&(Ge.height+=cn-U,Ge.y=U),Xt<oe&&(Ge.height=oe-cn),y.splice(v,1);break}}}return y},t.findHostInstance=n1,t.findHostInstanceWithNoPortals=function(y){return y=L(y),y=y!==null?W(y):null,y===null?null:y.stateNode},t.findHostInstanceWithWarning=function(y){return n1(y)},t.flushControlled=function(y){var v=pn;pn|=1;var E=ps.transition,A=vn;try{ps.transition=null,vn=1,y()}finally{vn=A,ps.transition=E,pn=v,pn===0&&(Vu(),uo())}},t.flushPassiveEffects=Yl,t.flushSync=th,t.focusWithin=function(y,v){if(!X)throw Error(o(363));for(y=Pd(y),v=sl(y,v),v=Array.from(v),y=0;y<v.length;){var E=v[y++];if(!je(E)){if(E.tag===5&&it(E.stateNode))return!0;for(E=E.child;E!==null;)v.push(E),E=E.sibling}}return!1},t.getCurrentUpdatePriority=function(){return vn},t.getFindAllNodesFailureDescription=function(y,v){if(!X)throw Error(o(363));var E=0,A=[];y=[Pd(y),0];for(var O=0;O<y.length;){var U=y[O++],oe=y[O++],ve=v[oe];if((U.tag!==5||!je(U))&&(qp(U,ve)&&(A.push(Jo(ve)),oe++,oe>E&&(E=oe)),oe<v.length))for(U=U.child;U!==null;)y.push(U,oe),U=U.sibling}if(E<v.length){for(y=[];E<v.length;E++)y.push(Jo(v[E]));return`findAllNodes was able to match part of the selector:
  `+(A.join(" > ")+`

No matching component was found for:
  `)+y.join(" > ")}return null},t.getPublicRootInstance=function(y){if(y=y.current,!y.child)return null;switch(y.child.tag){case 5:return J(y.child.stateNode);default:return y.child.stateNode}},t.injectIntoDevTools=function(y){if(y={bundleType:y.bundleType,version:y.version,rendererPackageName:y.rendererPackageName,rendererConfig:y.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:a.ReactCurrentDispatcher,findHostInstanceByFiber:r1,findFiberByHostInstance:y.findFiberByHostInstance||i1,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")y=!1;else{var v=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(v.isDisabled||!v.supportsFiber)y=!0;else{try{fd=v.inject(y),fa=v}catch{}y=!!v.checkDCE}}return y},t.isAlreadyRendering=function(){return!1},t.observeVisibleRects=function(y,v,E,A){if(!X)throw Error(o(363));y=Ld(y,v);var O=dt(y,E,A).disconnect;return{disconnect:function(){O()}}},t.registerMutableSourceForHydration=function(y,v){var E=v._getVersion;E=E(v._source),y.mutableSourceEagerHydrationData==null?y.mutableSourceEagerHydrationData=[v,E]:y.mutableSourceEagerHydrationData.push(v,E)},t.runWithPriority=function(y,v){var E=vn;try{return vn=y,v()}finally{vn=E}},t.shouldError=function(){return null},t.shouldSuspend=function(){return!1},t.updateContainer=function(y,v,E,A){var O=v.current,U=dr(),oe=va(O);return E=My(E),v.context===null?v.context=E:v.pendingContext=E,v=Ha(U,oe),v.payload={element:y},A=A===void 0?null:A,A!==null&&(v.callback=A),Ol(O,v),y=Ei(O,oe,U),y!==null&&yp(y,O,oe),oe},t}),kC}var wD;function i9(){return wD||(wD=1,NC.exports=r9()),NC.exports}var o9=i9();const a9=Z0(o9);var SD=JO();const l9=n=>typeof n=="object"&&typeof n.then=="function",vf=[];function QO(n,e,t=(s,r)=>s===r){if(n===e)return!0;if(!n||!e)return!1;const s=n.length;if(e.length!==s)return!1;for(let r=0;r<s;r++)if(!t(n[r],e[r]))return!1;return!0}function eF(n,e=null,t=!1,s={}){e===null&&(e=[n]);for(const i of vf)if(QO(e,i.keys,i.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(i,"error"))throw i.error;if(Object.prototype.hasOwnProperty.call(i,"response"))return s.lifespan&&s.lifespan>0&&(i.timeout&&clearTimeout(i.timeout),i.timeout=setTimeout(i.remove,s.lifespan)),i.response;if(!t)throw i.promise}const r={keys:e,equal:s.equal,remove:()=>{const i=vf.indexOf(r);i!==-1&&vf.splice(i,1)},promise:(l9(n)?n:n(...e)).then(i=>{r.response=i,s.lifespan&&s.lifespan>0&&(r.timeout=setTimeout(r.remove,s.lifespan))}).catch(i=>r.error=i)};if(vf.push(r),!t)throw r.promise}const u9=(n,e,t)=>eF(n,e,!1,t),c9=(n,e,t)=>void eF(n,e,!0,t),h9=n=>{if(n===void 0||n.length===0)vf.splice(0,vf.length);else{const e=vf.find(t=>QO(n,t.keys,t.equal));e&&e.remove()}},$I={},d9=n=>void Object.assign($I,n);function f9(n,e){function t(c,{args:h=[],attach:f,...p},g){let S=`${c[0].toUpperCase()}${c.slice(1)}`,x;if(c==="primitive"){if(p.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const w=p.object;x=Fm(w,{type:c,root:g,attach:f,primitive:!0})}else{const w=$I[S];if(!w)throw new Error(`R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(h))throw new Error("R3F: The args prop must be an array!");x=Fm(new w(...h),{type:c,root:g,attach:f,memoizedProps:{args:h}})}return x.__r3f.attach===void 0&&(x instanceof bn?x.__r3f.attach="geometry":x instanceof xi&&(x.__r3f.attach="material")),S!=="inject"&&PC(x,p),x}function s(c,h){let f=!1;if(h){var p,g;(p=h.__r3f)!=null&&p.attach?DC(c,h,h.__r3f.attach):h.isObject3D&&c.isObject3D&&(c.add(h),f=!0),f||(g=c.__r3f)==null||g.objects.push(h),h.__r3f||Fm(h,{}),h.__r3f.parent=c,ZE(h),$m(h)}}function r(c,h,f){let p=!1;if(h){var g,S;if((g=h.__r3f)!=null&&g.attach)DC(c,h,h.__r3f.attach);else if(h.isObject3D&&c.isObject3D){h.parent=c,h.dispatchEvent({type:"added"});const x=c.children.filter(_=>_!==h),w=x.indexOf(f);c.children=[...x.slice(0,w),h,...x.slice(w)],p=!0}p||(S=c.__r3f)==null||S.objects.push(h),h.__r3f||Fm(h,{}),h.__r3f.parent=c,ZE(h),$m(h)}}function i(c,h,f=!1){c&&[...c].forEach(p=>o(h,p,f))}function o(c,h,f){if(h){var p,g,S;if(h.__r3f&&(h.__r3f.parent=null),(p=c.__r3f)!=null&&p.objects&&(c.__r3f.objects=c.__r3f.objects.filter(C=>C!==h)),(g=h.__r3f)!=null&&g.attach)ED(c,h,h.__r3f.attach);else if(h.isObject3D&&c.isObject3D){var x;c.remove(h),(x=h.__r3f)!=null&&x.root&&S9(Gw(h),h)}const _=(S=h.__r3f)==null?void 0:S.primitive,T=!_&&(f===void 0?h.dispose!==null:f);if(!_){var w;i((w=h.__r3f)==null?void 0:w.objects,h,T),i(h.children,h,T)}if(delete h.__r3f,T&&h.dispose&&h.type!=="Scene"){const C=()=>{try{h.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?SD.unstable_scheduleCallback(SD.unstable_IdlePriority,C):C()}$m(c)}}function a(c,h,f,p){var g;const S=(g=c.__r3f)==null?void 0:g.parent;if(!S)return;const x=t(h,f,c.__r3f.root);if(c.children){for(const w of c.children)w.__r3f&&s(x,w);c.children=c.children.filter(w=>!w.__r3f)}c.__r3f.objects.forEach(w=>s(x,w)),c.__r3f.objects=[],c.__r3f.autoRemovedBeforeAppend||o(S,c),x.parent&&(x.__r3f.autoRemovedBeforeAppend=!0),s(S,x),x.raycast&&x.__r3f.eventCount&&Gw(x).getState().internal.interaction.push(x),[p,p.alternate].forEach(w=>{w!==null&&(w.stateNode=x,w.ref&&(typeof w.ref=="function"?w.ref(x):w.ref.current=x))})}const l=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:a9({createInstance:t,removeChild:o,appendChild:s,appendInitialChild:s,insertBefore:r,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(c,h)=>{if(!h)return;const f=c.getState().scene;f.__r3f&&(f.__r3f.root=c,s(f,h))},removeChildFromContainer:(c,h)=>{h&&o(c.getState().scene,h)},insertInContainerBefore:(c,h,f)=>{if(!h||!f)return;const p=c.getState().scene;p.__r3f&&r(p,h,f)},getRootHostContext:()=>null,getChildHostContext:c=>c,finalizeInitialChildren(c){var h;return!!((h=c==null?void 0:c.__r3f)!=null?h:{}).handlers},prepareUpdate(c,h,f,p){var g;if(((g=c==null?void 0:c.__r3f)!=null?g:{}).primitive&&p.object&&p.object!==c)return[!0];{const{args:x=[],children:w,..._}=p,{args:T=[],children:C,...N}=f;if(!Array.isArray(x))throw new Error("R3F: the args prop must be an array!");if(x.some((P,$)=>P!==T[$]))return[!0];const M=aF(c,_,N,!0);return M.changes.length?[!1,M]:null}},commitUpdate(c,[h,f],p,g,S,x){h?a(c,p,S,x):PC(c,f)},commitMount(c,h,f,p){var g;const S=(g=c.__r3f)!=null?g:{};c.raycast&&S.handlers&&S.eventCount&&Gw(c).getState().internal.interaction.push(c)},getPublicInstance:c=>c,prepareForCommit:()=>null,preparePortalMount:c=>Fm(c.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(c){var h;const{attach:f,parent:p}=(h=c.__r3f)!=null?h:{};f&&p&&ED(p,c,f),c.isObject3D&&(c.visible=!1),$m(c)},unhideInstance(c,h){var f;const{attach:p,parent:g}=(f=c.__r3f)!=null?f:{};p&&g&&DC(g,c,p),(c.isObject3D&&h.visible==null||h.visible)&&(c.visible=!0),$m(c)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:()=>e?e():qm.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&bs.fun(performance.now)?performance.now:bs.fun(Date.now)?Date.now:()=>0,scheduleTimeout:bs.fun(setTimeout)?setTimeout:void 0,cancelTimeout:bs.fun(clearTimeout)?clearTimeout:void 0}),applyProps:PC}}var bD,_D;const RC=n=>"colorSpace"in n||"outputColorSpace"in n,tF=()=>{var n;return(n=$I.ColorManagement)!=null?n:null},nF=n=>n&&n.isOrthographicCamera,p9=n=>n&&n.hasOwnProperty("current"),hx=typeof window<"u"&&((bD=window.document)!=null&&bD.createElement||((_D=window.navigator)==null?void 0:_D.product)==="ReactNative")?Ee.useLayoutEffect:Ee.useEffect;function sF(n){const e=Ee.useRef(n);return hx(()=>void(e.current=n),[n]),e}function m9({set:n}){return hx(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}class rF extends Ee.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}rF.getDerivedStateFromError=()=>({error:!0});const iF="__default",TD=new Map,g9=n=>n&&!!n.memoized&&!!n.changes;function oF(n){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(n)?Math.min(Math.max(n[0],t),n[1]):n}const Ky=n=>{var e;return(e=n.__r3f)==null?void 0:e.root.getState()};function Gw(n){let e=n.__r3f.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const bs={obj:n=>n===Object(n)&&!bs.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,arr:n=>Array.isArray(n),equ(n,e,{arrays:t="shallow",objects:s="reference",strict:r=!0}={}){if(typeof n!=typeof e||!!n!=!!e)return!1;if(bs.str(n)||bs.num(n))return n===e;const i=bs.obj(n);if(i&&s==="reference")return n===e;const o=bs.arr(n);if(o&&t==="reference")return n===e;if((o||i)&&n===e)return!0;let a;for(a in n)if(!(a in e))return!1;if(i&&t==="shallow"&&s==="shallow"){for(a in r?e:n)if(!bs.equ(n[a],e[a],{strict:r,objects:"reference"}))return!1}else for(a in r?e:n)if(n[a]!==e[a])return!1;if(bs.und(a)){if(o&&n.length===0&&e.length===0||i&&Object.keys(n).length===0&&Object.keys(e).length===0)return!0;if(n!==e)return!1}return!0}};function y9(n){const e={nodes:{},materials:{}};return n&&n.traverse(t=>{t.name&&(e.nodes[t.name]=t),t.material&&!e.materials[t.material.name]&&(e.materials[t.material.name]=t.material)}),e}function x9(n){n.dispose&&n.type!=="Scene"&&n.dispose();for(const e in n)e.dispose==null||e.dispose(),delete n[e]}function Fm(n,e){const t=n;return t.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},n}function YE(n,e){let t=n;if(e.includes("-")){const s=e.split("-"),r=s.pop();return t=s.reduce((i,o)=>i[o],n),{target:t,key:r}}else return{target:t,key:e}}const CD=/-\d+$/;function DC(n,e,t){if(bs.str(t)){if(CD.test(t)){const i=t.replace(CD,""),{target:o,key:a}=YE(n,i);Array.isArray(o[a])||(o[a]=[])}const{target:s,key:r}=YE(n,t);e.__r3f.previousAttach=s[r],s[r]=e}else e.__r3f.previousAttach=t(n,e)}function ED(n,e,t){var s,r;if(bs.str(t)){const{target:i,key:o}=YE(n,t),a=e.__r3f.previousAttach;a===void 0?delete i[o]:i[o]=a}else(s=e.__r3f)==null||s.previousAttach==null||s.previousAttach(n,e);(r=e.__r3f)==null||delete r.previousAttach}function aF(n,{children:e,key:t,ref:s,...r},{children:i,key:o,ref:a,...l}={},u=!1){var c;const h=(c=n==null?void 0:n.__r3f)!=null?c:{},f=Object.entries(r),p=[];if(u){const S=Object.keys(l);for(let x=0;x<S.length;x++)r.hasOwnProperty(S[x])||f.unshift([S[x],iF+"remove"])}f.forEach(([S,x])=>{var w;if((w=n.__r3f)!=null&&w.primitive&&S==="object"||bs.equ(x,l[S]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(S))return p.push([S,x,!0,[]]);let _=[];S.includes("-")&&(_=S.split("-")),p.push([S,x,!1,_]);for(const T in r){const C=r[T];T.startsWith(`${S}-`)&&p.push([T,C,!1,T.split("-")])}});const g={...r};return h.memoizedProps&&h.memoizedProps.args&&(g.args=h.memoizedProps.args),h.memoizedProps&&h.memoizedProps.attach&&(g.attach=h.memoizedProps.attach),{memoized:g,changes:p}}function PC(n,e){var t,s,r;const i=(t=n.__r3f)!=null?t:{},o=i.root,a=(s=o==null||o.getState==null?void 0:o.getState())!=null?s:{},{memoized:l,changes:u}=g9(e)?e:aF(n,e),c=i.eventCount;n.__r3f&&(n.__r3f.memoizedProps=l);for(let f=0;f<u.length;f++){let[p,g,S,x]=u[f];if(RC(n)){const C="srgb",N="srgb-linear";p==="encoding"?(p="colorSpace",g=g===3001?C:N):p==="outputEncoding"&&(p="outputColorSpace",g=g===3001?C:N)}let w=n,_=w[p];if(x.length&&(_=x.reduce((T,C)=>T[C],n),!(_&&_.set))){const[T,...C]=x.reverse();w=C.reverse().reduce((N,M)=>N[M],n),p=T}if(g===iF+"remove")if(w.constructor){let T=TD.get(w.constructor);T||(T=new w.constructor,TD.set(w.constructor,T)),g=T[p]}else g=0;if(S)g?i.handlers[p]=g:delete i.handlers[p],i.eventCount=Object.keys(i.handlers).length;else if(_&&_.set&&(_.copy||_ instanceof Cf)){if(Array.isArray(g))_.fromArray?_.fromArray(g):_.set(...g);else if(_.copy&&g&&g.constructor&&_.constructor===g.constructor)_.copy(g);else if(g!==void 0){const T=_ instanceof vt;!T&&_.setScalar?_.setScalar(g):_ instanceof Cf&&g instanceof Cf?_.mask=g.mask:_.set(g),!tF()&&!a.linear&&T&&_.convertSRGBToLinear()}}else if(w[p]=g,w[p]instanceof Hs&&w[p].format===eo&&w[p].type===ou){const T=w[p];RC(T)&&RC(a.gl)?T.colorSpace=a.gl.outputColorSpace:T.encoding=a.gl.outputEncoding}$m(n)}if(i.parent&&n.raycast&&c!==i.eventCount){const f=Gw(n).getState().internal,p=f.interaction.indexOf(n);p>-1&&f.interaction.splice(p,1),i.eventCount&&f.interaction.push(n)}return!(u.length===1&&u[0][0]==="onUpdate")&&u.length&&(r=n.__r3f)!=null&&r.parent&&ZE(n),n}function $m(n){var e,t;const s=(e=n.__r3f)==null||(t=e.root)==null||t.getState==null?void 0:t.getState();s&&s.internal.frames===0&&s.invalidate()}function ZE(n){n.onUpdate==null||n.onUpdate(n)}function v9(n,e){n.manual||(nF(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function ww(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function w9(){var n;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return qm.DefaultEventPriority;switch((n=e.event)==null?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return qm.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return qm.ContinuousEventPriority;default:return qm.DefaultEventPriority}}function lF(n,e,t,s){const r=t.get(e);r&&(t.delete(e),t.size===0&&(n.delete(s),r.target.releasePointerCapture(s)))}function S9(n,e){const{internal:t}=n.getState();t.interaction=t.interaction.filter(s=>s!==e),t.initialHits=t.initialHits.filter(s=>s!==e),t.hovered.forEach((s,r)=>{(s.eventObject===e||s.object===e)&&t.hovered.delete(r)}),t.capturedMap.forEach((s,r)=>{lF(t.capturedMap,e,s,r)})}function b9(n){function e(l){const{internal:u}=n.getState(),c=l.offsetX-u.initialClick[0],h=l.offsetY-u.initialClick[1];return Math.round(Math.sqrt(c*c+h*h))}function t(l){return l.filter(u=>["Move","Over","Enter","Out","Leave"].some(c=>{var h;return(h=u.__r3f)==null?void 0:h.handlers["onPointer"+c]}))}function s(l,u){const c=n.getState(),h=new Set,f=[],p=u?u(c.internal.interaction):c.internal.interaction;for(let w=0;w<p.length;w++){const _=Ky(p[w]);_&&(_.raycaster.camera=void 0)}c.previousRoot||c.events.compute==null||c.events.compute(l,c);function g(w){const _=Ky(w);if(!_||!_.events.enabled||_.raycaster.camera===null)return[];if(_.raycaster.camera===void 0){var T;_.events.compute==null||_.events.compute(l,_,(T=_.previousRoot)==null?void 0:T.getState()),_.raycaster.camera===void 0&&(_.raycaster.camera=null)}return _.raycaster.camera?_.raycaster.intersectObject(w,!0):[]}let S=p.flatMap(g).sort((w,_)=>{const T=Ky(w.object),C=Ky(_.object);return!T||!C?w.distance-_.distance:C.events.priority-T.events.priority||w.distance-_.distance}).filter(w=>{const _=ww(w);return h.has(_)?!1:(h.add(_),!0)});c.events.filter&&(S=c.events.filter(S,c));for(const w of S){let _=w.object;for(;_;){var x;(x=_.__r3f)!=null&&x.eventCount&&f.push({...w,eventObject:_}),_=_.parent}}if("pointerId"in l&&c.internal.capturedMap.has(l.pointerId))for(let w of c.internal.capturedMap.get(l.pointerId).values())h.has(ww(w.intersection))||f.push(w.intersection);return f}function r(l,u,c,h){const f=n.getState();if(l.length){const p={stopped:!1};for(const g of l){const S=Ky(g.object)||f,{raycaster:x,pointer:w,camera:_,internal:T}=S,C=new re(w.x,w.y,0).unproject(_),N=D=>{var L,G;return(L=(G=T.capturedMap.get(D))==null?void 0:G.has(g.eventObject))!=null?L:!1},M=D=>{const L={intersection:g,target:u.target};T.capturedMap.has(D)?T.capturedMap.get(D).set(g.eventObject,L):T.capturedMap.set(D,new Map([[g.eventObject,L]])),u.target.setPointerCapture(D)},P=D=>{const L=T.capturedMap.get(D);L&&lF(T.capturedMap,g.eventObject,L,D)};let $={};for(let D in u){let L=u[D];typeof L!="function"&&($[D]=L)}let R={...g,...$,pointer:w,intersections:l,stopped:p.stopped,delta:c,unprojectedPoint:C,ray:x.ray,camera:_,stopPropagation(){const D="pointerId"in u&&T.capturedMap.get(u.pointerId);if((!D||D.has(g.eventObject))&&(R.stopped=p.stopped=!0,T.hovered.size&&Array.from(T.hovered.values()).find(L=>L.eventObject===g.eventObject))){const L=l.slice(0,l.indexOf(g));i([...L,g])}},target:{hasPointerCapture:N,setPointerCapture:M,releasePointerCapture:P},currentTarget:{hasPointerCapture:N,setPointerCapture:M,releasePointerCapture:P},nativeEvent:u};if(h(R),p.stopped===!0)break}}return l}function i(l){const{internal:u}=n.getState();for(const c of u.hovered.values())if(!l.length||!l.find(h=>h.object===c.object&&h.index===c.index&&h.instanceId===c.instanceId)){const f=c.eventObject.__r3f,p=f==null?void 0:f.handlers;if(u.hovered.delete(ww(c)),f!=null&&f.eventCount){const g={...c,intersections:l};p.onPointerOut==null||p.onPointerOut(g),p.onPointerLeave==null||p.onPointerLeave(g)}}}function o(l,u){for(let c=0;c<u.length;c++){const h=u[c].__r3f;h==null||h.handlers.onPointerMissed==null||h.handlers.onPointerMissed(l)}}function a(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>i([]);case"onLostPointerCapture":return u=>{const{internal:c}=n.getState();"pointerId"in u&&c.capturedMap.has(u.pointerId)&&requestAnimationFrame(()=>{c.capturedMap.has(u.pointerId)&&(c.capturedMap.delete(u.pointerId),i([]))})}}return function(c){const{onPointerMissed:h,internal:f}=n.getState();f.lastEvent.current=c;const p=l==="onPointerMove",g=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",x=s(c,p?t:void 0),w=g?e(c):0;l==="onPointerDown"&&(f.initialClick=[c.offsetX,c.offsetY],f.initialHits=x.map(T=>T.eventObject)),g&&!x.length&&w<=2&&(o(c,f.interaction),h&&h(c)),p&&i(x);function _(T){const C=T.eventObject,N=C.__r3f,M=N==null?void 0:N.handlers;if(N!=null&&N.eventCount)if(p){if(M.onPointerOver||M.onPointerEnter||M.onPointerOut||M.onPointerLeave){const P=ww(T),$=f.hovered.get(P);$?$.stopped&&T.stopPropagation():(f.hovered.set(P,T),M.onPointerOver==null||M.onPointerOver(T),M.onPointerEnter==null||M.onPointerEnter(T))}M.onPointerMove==null||M.onPointerMove(T)}else{const P=M[l];P?(!g||f.initialHits.includes(C))&&(o(c,f.interaction.filter($=>!f.initialHits.includes($))),P(T)):g&&f.initialHits.includes(C)&&o(c,f.interaction.filter($=>!f.initialHits.includes($)))}}r(x,c,w,_)}}return{handlePointer:a}}const uF=n=>!!(n!=null&&n.render),cF=Ee.createContext(null),_9=(n,e)=>{const t=n9((a,l)=>{const u=new re,c=new re,h=new re;function f(w=l().camera,_=c,T=l().size){const{width:C,height:N,top:M,left:P}=T,$=C/N;_ instanceof re?h.copy(_):h.set(..._);const R=w.getWorldPosition(u).distanceTo(h);if(nF(w))return{width:C/w.zoom,height:N/w.zoom,top:M,left:P,factor:1,distance:R,aspect:$};{const D=w.fov*Math.PI/180,L=2*Math.tan(D/2)*R,G=L*(C/N);return{width:G,height:L,top:M,left:P,factor:C/G,distance:R,aspect:$}}}let p;const g=w=>a(_=>({performance:{..._.performance,current:w}})),S=new Je;return{set:a,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(w=1)=>n(l(),w),advance:(w,_)=>e(w,_,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new PI,pointer:S,mouse:S,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const w=l();p&&clearTimeout(p),w.performance.current!==w.performance.min&&g(w.performance.min),p=setTimeout(()=>g(l().performance.max),w.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:f},setEvents:w=>a(_=>({..._,events:{..._.events,...w}})),setSize:(w,_,T,C,N)=>{const M=l().camera,P={width:w,height:_,top:C||0,left:N||0,updateStyle:T};a($=>({size:P,viewport:{...$.viewport,...f(M,c,P)}}))},setDpr:w=>a(_=>{const T=oF(w);return{viewport:{..._.viewport,dpr:T,initialDpr:_.viewport.initialDpr||T}}}),setFrameloop:(w="always")=>{const _=l().clock;_.stop(),_.elapsedTime=0,w!=="never"&&(_.start(),_.elapsedTime=0),a(()=>({frameloop:w}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:Ee.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(w,_,T)=>{const C=l().internal;return C.priority=C.priority+(_>0?1:0),C.subscribers.push({ref:w,priority:_,store:T}),C.subscribers=C.subscribers.sort((N,M)=>N.priority-M.priority),()=>{const N=l().internal;N!=null&&N.subscribers&&(N.priority=N.priority-(_>0?1:0),N.subscribers=N.subscribers.filter(M=>M.ref!==w))}}}}}),s=t.getState();let r=s.size,i=s.viewport.dpr,o=s.camera;return t.subscribe(()=>{const{camera:a,size:l,viewport:u,gl:c,set:h}=t.getState();if(l.width!==r.width||l.height!==r.height||u.dpr!==i){var f;r=l,i=u.dpr,v9(a,l),c.setPixelRatio(u.dpr);const p=(f=l.updateStyle)!=null?f:typeof HTMLCanvasElement<"u"&&c.domElement instanceof HTMLCanvasElement;c.setSize(l.width,l.height,p)}a!==o&&(o=a,h(p=>({viewport:{...p.viewport,...p.viewport.getCurrentViewport(a)}})))}),t.subscribe(a=>n(a)),t};let Sw,T9=new Set,C9=new Set,E9=new Set;function LC(n,e){if(n.size)for(const{callback:t}of n.values())t(e)}function Yy(n,e){switch(n){case"before":return LC(T9,e);case"after":return LC(C9,e);case"tail":return LC(E9,e)}}let OC,FC;function $C(n,e,t){let s=e.clock.getDelta();for(e.frameloop==="never"&&typeof n=="number"&&(s=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),OC=e.internal.subscribers,Sw=0;Sw<OC.length;Sw++)FC=OC[Sw],FC.ref.current(FC.store.getState(),s,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function I9(n){let e=!1,t,s,r;function i(l){s=requestAnimationFrame(i),e=!0,t=0,Yy("before",l);for(const c of n.values()){var u;r=c.store.getState(),r.internal.active&&(r.frameloop==="always"||r.internal.frames>0)&&!((u=r.gl.xr)!=null&&u.isPresenting)&&(t+=$C(l,r))}if(Yy("after",l),t===0)return Yy("tail",l),e=!1,cancelAnimationFrame(s)}function o(l,u=1){var c;if(!l)return n.forEach(h=>o(h.store.getState()),u);(c=l.gl.xr)!=null&&c.isPresenting||!l.internal.active||l.frameloop==="never"||(l.internal.frames=Math.min(60,l.internal.frames+u),e||(e=!0,requestAnimationFrame(i)))}function a(l,u=!0,c,h){if(u&&Yy("before",l),c)$C(l,c,h);else for(const f of n.values())$C(l,f.store.getState());u&&Yy("after",l)}return{loop:i,invalidate:o,advance:a}}function hF(){const n=Ee.useContext(cF);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function dF(n=t=>t,e){return hF()(n,e)}function vc(n,e=0){const t=hF(),s=t.getState().internal.subscribe,r=sF(n);return hx(()=>s(r,e,t),[e,s,t]),null}const ID=new WeakMap;function fF(n,e){return function(t,...s){let r=ID.get(t);return r||(r=new t,ID.set(t,r)),n&&n(r),Promise.all(s.map(i=>new Promise((o,a)=>r.load(i,l=>{l.scene&&Object.assign(l,y9(l.scene)),o(l)},e,l=>a(new Error(`Could not load ${i}: ${l==null?void 0:l.message}`)))))).finally(()=>r.dispose==null?void 0:r.dispose())}}function zI(n,e,t,s){const r=Array.isArray(e)?e:[e],i=u9(fF(t,s),[n,...r],{equal:bs.equ});return Array.isArray(e)?i:i[0]}zI.preload=function(n,e,t){const s=Array.isArray(e)?e:[e];return c9(fF(t),[n,...s])};zI.clear=function(n,e){const t=Array.isArray(e)?e:[e];return h9([n,...t])};const ug=new Map,{invalidate:ND,advance:AD}=I9(ug),{reconciler:hS,applyProps:Mm}=f9(ug,w9),km={objects:"shallow",strict:!1},N9=(n,e)=>{const t=typeof n=="function"?n(e):n;return uF(t)?t:new yI({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...n})};function A9(n,e){const t=typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement;if(e){const{width:s,height:r,top:i,left:o,updateStyle:a=t}=e;return{width:s,height:r,top:i,left:o,updateStyle:a}}else if(typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement&&n.parentElement){const{width:s,height:r,top:i,left:o}=n.parentElement.getBoundingClientRect();return{width:s,height:r,top:i,left:o,updateStyle:t}}else if(typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas)return{width:n.width,height:n.height,top:0,left:0,updateStyle:t};return{width:0,height:0,top:0,left:0}}function M9(n){const e=ug.get(n),t=e==null?void 0:e.fiber,s=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const r=typeof reportError=="function"?reportError:console.error,i=s||_9(ND,AD),o=t||hS.createContainer(i,qm.ConcurrentRoot,null,!1,null,"",r,null);e||ug.set(n,{fiber:o,store:i});let a,l=!1,u;return{configure(c={}){let{gl:h,size:f,scene:p,events:g,onCreated:S,shadows:x=!1,linear:w=!1,flat:_=!1,legacy:T=!1,orthographic:C=!1,frameloop:N="always",dpr:M=[1,2],performance:P,raycaster:$,camera:R,onPointerMissed:D}=c,L=i.getState(),G=L.gl;L.gl||L.set({gl:G=N9(h,n)});let Q=L.raycaster;Q||L.set({raycaster:Q=new KO});const{params:W,...H}=$||{};if(bs.equ(H,Q,km)||Mm(Q,{...H}),bs.equ(W,Q.params,km)||Mm(Q,{params:{...Q.params,...W}}),!L.camera||L.camera===u&&!bs.equ(u,R,km)){u=R;const se=R instanceof nx,te=se?R:C?new ox(0,0,0,0,.1,1e3):new jr(75,0,.1,1e3);se||(te.position.z=5,R&&Mm(te,R),!L.camera&&!(R!=null&&R.rotation)&&te.lookAt(0,0,0)),L.set({camera:te}),Q.camera=te}if(!L.scene){let se;p instanceof uS?se=p:(se=new uS,p&&Mm(se,p)),L.set({scene:Fm(se)})}if(!L.xr){var J;const se=(fe,_e)=>{const Ie=i.getState();Ie.frameloop!=="never"&&AD(fe,!0,Ie,_e)},te=()=>{const fe=i.getState();fe.gl.xr.enabled=fe.gl.xr.isPresenting,fe.gl.xr.setAnimationLoop(fe.gl.xr.isPresenting?se:null),fe.gl.xr.isPresenting||ND(fe)},ue={connect(){const fe=i.getState().gl;fe.xr.addEventListener("sessionstart",te),fe.xr.addEventListener("sessionend",te)},disconnect(){const fe=i.getState().gl;fe.xr.removeEventListener("sessionstart",te),fe.xr.removeEventListener("sessionend",te)}};typeof((J=G.xr)==null?void 0:J.addEventListener)=="function"&&ue.connect(),L.set({xr:ue})}if(G.shadowMap){const se=G.shadowMap.enabled,te=G.shadowMap.type;if(G.shadowMap.enabled=!!x,bs.boo(x))G.shadowMap.type=l0;else if(bs.str(x)){var ie;const ue={basic:BL,percentage:WS,soft:l0,variance:pl};G.shadowMap.type=(ie=ue[x])!=null?ie:l0}else bs.obj(x)&&Object.assign(G.shadowMap,x);(se!==G.shadowMap.enabled||te!==G.shadowMap.type)&&(G.shadowMap.needsUpdate=!0)}const V=tF();V&&("enabled"in V?V.enabled=!T:"legacyMode"in V&&(V.legacyMode=T)),Mm(G,{outputEncoding:w?3e3:3001,toneMapping:_?iu:GS}),L.legacy!==T&&L.set(()=>({legacy:T})),L.linear!==w&&L.set(()=>({linear:w})),L.flat!==_&&L.set(()=>({flat:_})),h&&!bs.fun(h)&&!uF(h)&&!bs.equ(h,G,km)&&Mm(G,h),g&&!L.events.handlers&&L.set({events:g(i)});const K=A9(n,f);return bs.equ(K,L.size,km)||L.setSize(K.width,K.height,K.updateStyle,K.top,K.left),M&&L.viewport.dpr!==oF(M)&&L.setDpr(M),L.frameloop!==N&&L.setFrameloop(N),L.onPointerMissed||L.set({onPointerMissed:D}),P&&!bs.equ(P,L.performance,km)&&L.set(se=>({performance:{...se.performance,...P}})),a=S,l=!0,this},render(c){return l||this.configure(),hS.updateContainer(Ee.createElement(k9,{store:i,children:c,onCreated:a,rootElement:n}),o,null,()=>{}),i},unmount(){pF(n)}}}function k9({store:n,children:e,onCreated:t,rootElement:s}){return hx(()=>{const r=n.getState();r.set(i=>({internal:{...i.internal,active:!0}})),t&&t(r),n.getState().events.connected||r.events.connect==null||r.events.connect(s)},[]),Ee.createElement(cF.Provider,{value:n},e)}function pF(n,e){const t=ug.get(n),s=t==null?void 0:t.fiber;if(s){const r=t==null?void 0:t.store.getState();r&&(r.internal.active=!1),hS.updateContainer(null,s,null,()=>{r&&setTimeout(()=>{try{var i,o,a,l;r.events.disconnect==null||r.events.disconnect(),(i=r.gl)==null||(o=i.renderLists)==null||o.dispose==null||o.dispose(),(a=r.gl)==null||a.forceContextLoss==null||a.forceContextLoss(),(l=r.gl)!=null&&l.xr&&r.xr.disconnect(),x9(r),ug.delete(n)}catch{}},500)})}}hS.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:Ee.version});function dS(){return dS=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var s in t)({}).hasOwnProperty.call(t,s)&&(n[s]=t[s])}return n},dS.apply(null,arguments)}function MD(n,e){let t;return(...s)=>{window.clearTimeout(t),t=window.setTimeout(()=>n(...s),e)}}function R9({debounce:n,scroll:e,polyfill:t,offsetSize:s}={debounce:0,scroll:!1,offsetSize:!1}){const r=t||(typeof window>"u"?class{}:window.ResizeObserver);if(!r)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[i,o]=Ee.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),a=Ee.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:i,orientationHandler:null}),l=n?typeof n=="number"?n:n.scroll:null,u=n?typeof n=="number"?n:n.resize:null,c=Ee.useRef(!1);Ee.useEffect(()=>(c.current=!0,()=>void(c.current=!1)));const[h,f,p]=Ee.useMemo(()=>{const w=()=>{if(!a.current.element)return;const{left:_,top:T,width:C,height:N,bottom:M,right:P,x:$,y:R}=a.current.element.getBoundingClientRect(),D={left:_,top:T,width:C,height:N,bottom:M,right:P,x:$,y:R};a.current.element instanceof HTMLElement&&s&&(D.height=a.current.element.offsetHeight,D.width=a.current.element.offsetWidth),Object.freeze(D),c.current&&!O9(a.current.lastBounds,D)&&o(a.current.lastBounds=D)};return[w,u?MD(w,u):w,l?MD(w,l):w]},[o,s,l,u]);function g(){a.current.scrollContainers&&(a.current.scrollContainers.forEach(w=>w.removeEventListener("scroll",p,!0)),a.current.scrollContainers=null),a.current.resizeObserver&&(a.current.resizeObserver.disconnect(),a.current.resizeObserver=null),a.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",a.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",a.current.orientationHandler))}function S(){a.current.element&&(a.current.resizeObserver=new r(p),a.current.resizeObserver.observe(a.current.element),e&&a.current.scrollContainers&&a.current.scrollContainers.forEach(w=>w.addEventListener("scroll",p,{capture:!0,passive:!0})),a.current.orientationHandler=()=>{p()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",a.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",a.current.orientationHandler))}const x=w=>{!w||w===a.current.element||(g(),a.current.element=w,a.current.scrollContainers=mF(w),S())};return P9(p,!!e),D9(f),Ee.useEffect(()=>{g(),S()},[e,p,f]),Ee.useEffect(()=>g,[]),[x,i,h]}function D9(n){Ee.useEffect(()=>{const e=n;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[n])}function P9(n,e){Ee.useEffect(()=>{if(e){const t=n;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[n,e])}function mF(n){const e=[];if(!n||n===document.body)return e;const{overflow:t,overflowX:s,overflowY:r}=window.getComputedStyle(n);return[t,s,r].some(i=>i==="auto"||i==="scroll")&&e.push(n),[...e,...mF(n.parentElement)]}const L9=["x","y","top","bottom","left","right","width","height"],O9=(n,e)=>L9.every(t=>n[t]===e[t]);var F9=Object.defineProperty,$9=Object.defineProperties,z9=Object.getOwnPropertyDescriptors,kD=Object.getOwnPropertySymbols,U9=Object.prototype.hasOwnProperty,B9=Object.prototype.propertyIsEnumerable,RD=(n,e,t)=>e in n?F9(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,DD=(n,e)=>{for(var t in e||(e={}))U9.call(e,t)&&RD(n,t,e[t]);if(kD)for(var t of kD(e))B9.call(e,t)&&RD(n,t,e[t]);return n},V9=(n,e)=>$9(n,z9(e)),PD,LD;typeof window<"u"&&((PD=window.document)!=null&&PD.createElement||((LD=window.navigator)==null?void 0:LD.product)==="ReactNative")?Ee.useLayoutEffect:Ee.useEffect;function gF(n,e,t){if(!n)return;if(t(n)===!0)return n;let s=n.child;for(;s;){const r=gF(s,e,t);if(r)return r;s=s.sibling}}function yF(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const OD=console.error;console.error=function(){const n=[...arguments].join("");if(n!=null&&n.startsWith("Warning:")&&n.includes("useContext")){console.error=OD;return}return OD.apply(this,arguments)};const UI=yF(Ee.createContext(null));class xF extends Ee.Component{render(){return Ee.createElement(UI.Provider,{value:this._reactInternals},this.props.children)}}function W9(){const n=Ee.useContext(UI);if(n===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=Ee.useId();return Ee.useMemo(()=>{for(const s of[n,n==null?void 0:n.alternate]){if(!s)continue;const r=gF(s,!1,i=>{let o=i.memoizedState;for(;o;){if(o.memoizedState===e)return!0;o=o.next}});if(r)return r}},[n,e])}function G9(){const n=W9(),[e]=Ee.useState(()=>new Map);e.clear();let t=n;for(;t;){if(t.type&&typeof t.type=="object"){const r=t.type._context===void 0&&t.type.Provider===t.type?t.type:t.type._context;r&&r!==UI&&!e.has(r)&&e.set(r,Ee.useContext(yF(r)))}t=t.return}return e}function H9(){const n=G9();return Ee.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>s=>Ee.createElement(e,null,Ee.createElement(t.Provider,V9(DD({},s),{value:n.get(t)}))),e=>Ee.createElement(xF,DD({},e))),[n])}const zC={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function j9(n){const{handlePointer:e}=b9(n);return{priority:1,enabled:!0,compute(t,s,r){s.pointer.set(t.offsetX/s.size.width*2-1,-(t.offsetY/s.size.height)*2+1),s.raycaster.setFromCamera(s.pointer,s.camera)},connected:void 0,handlers:Object.keys(zC).reduce((t,s)=>({...t,[s]:e(s)}),{}),update:()=>{var t;const{events:s,internal:r}=n.getState();(t=r.lastEvent)!=null&&t.current&&s.handlers&&s.handlers.onPointerMove(r.lastEvent.current)},connect:t=>{var s;const{set:r,events:i}=n.getState();i.disconnect==null||i.disconnect(),r(o=>({events:{...o.events,connected:t}})),Object.entries((s=i.handlers)!=null?s:[]).forEach(([o,a])=>{const[l,u]=zC[o];t.addEventListener(l,a,{passive:u})})},disconnect:()=>{const{set:t,events:s}=n.getState();if(s.connected){var r;Object.entries((r=s.handlers)!=null?r:[]).forEach(([i,o])=>{if(s&&s.connected instanceof HTMLElement){const[a]=zC[i];s.connected.removeEventListener(a,o)}}),t(i=>({events:{...i.events,connected:void 0}}))}}}}const X9=Ee.forwardRef(function({children:e,fallback:t,resize:s,style:r,gl:i,events:o=j9,eventSource:a,eventPrefix:l,shadows:u,linear:c,flat:h,legacy:f,orthographic:p,frameloop:g,dpr:S,performance:x,raycaster:w,camera:_,scene:T,onPointerMissed:C,onCreated:N,...M},P){Ee.useMemo(()=>d9(Zq),[]);const $=H9(),[R,D]=R9({scroll:!0,debounce:{scroll:50,resize:0},...s}),L=Ee.useRef(null),G=Ee.useRef(null);Ee.useImperativeHandle(P,()=>L.current);const Q=sF(C),[W,H]=Ee.useState(!1),[J,ie]=Ee.useState(!1);if(W)throw W;if(J)throw J;const V=Ee.useRef(null);hx(()=>{const B=L.current;D.width>0&&D.height>0&&B&&(V.current||(V.current=M9(B)),V.current.configure({gl:i,events:o,shadows:u,linear:c,flat:h,legacy:f,orthographic:p,frameloop:g,dpr:S,performance:x,raycaster:w,camera:_,scene:T,size:D,onPointerMissed:(...K)=>Q.current==null?void 0:Q.current(...K),onCreated:K=>{K.events.connect==null||K.events.connect(a?p9(a)?a.current:a:G.current),l&&K.setEvents({compute:(se,te)=>{const ue=se[l+"X"],fe=se[l+"Y"];te.pointer.set(ue/te.size.width*2-1,-(fe/te.size.height)*2+1),te.raycaster.setFromCamera(te.pointer,te.camera)}}),N==null||N(K)}}),V.current.render(Ee.createElement($,null,Ee.createElement(rF,{set:ie},Ee.createElement(Ee.Suspense,{fallback:Ee.createElement(m9,{set:H})},e)))))}),Ee.useEffect(()=>{const B=L.current;if(B)return()=>pF(B)},[]);const Y=a?"none":"auto";return Ee.createElement("div",dS({ref:G,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:Y,...r}},M),Ee.createElement("div",{ref:R,style:{width:"100%",height:"100%"}},Ee.createElement("canvas",{ref:L,style:{display:"block"}},t)))}),q9=Ee.forwardRef(function(e,t){return Ee.createElement(xF,null,Ee.createElement(X9,dS({},e,{ref:t})))}),K9=()=>parseInt(Q0.replace(/\D+/g,"")),Y9=K9();class Z9 extends Tl{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:`
      uniform float time;
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);
        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));
        gl_Position = projectionMatrix * mvPosition;
      }`,fragmentShader:`
      uniform sampler2D pointTexture;
      uniform float fade;
      varying vec3 vColor;
      void main() {
        float opacity = 1.0;
        if (fade == 1.0) {
          float d = distance(gl_PointCoord, vec2(0.5, 0.5));
          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
        }
        gl_FragColor = vec4(vColor, opacity);

        #include <tonemapping_fragment>
	      #include <${Y9>=154?"colorspace_fragment":"encodings_fragment"}>
      }`})}}const J9=n=>new re().setFromSpherical(new YO(n,Math.acos(1-Math.random()*2),Math.random()*2*Math.PI)),Q9=Ee.forwardRef(({radius:n=100,depth:e=50,count:t=5e3,saturation:s=0,factor:r=4,fade:i=!1,speed:o=1},a)=>{const l=Ee.useRef(),[u,c,h]=Ee.useMemo(()=>{const p=[],g=[],S=Array.from({length:t},()=>(.5+.5*Math.random())*r),x=new vt;let w=n+e;const _=e/t;for(let T=0;T<t;T++)w-=_*Math.random(),p.push(...J9(w).toArray()),x.setHSL(T/t,s,.9),g.push(x.r,x.g,x.b);return[new Float32Array(p),new Float32Array(g),new Float32Array(S)]},[t,e,r,n,s]);vc(p=>l.current&&(l.current.uniforms.time.value=p.clock.getElapsedTime()*o));const[f]=Ee.useState(()=>new Z9);return Ee.createElement("points",{ref:a},Ee.createElement("bufferGeometry",null,Ee.createElement("bufferAttribute",{attach:"attributes-position",args:[u,3]}),Ee.createElement("bufferAttribute",{attach:"attributes-color",args:[c,3]}),Ee.createElement("bufferAttribute",{attach:"attributes-size",args:[h,1]})),Ee.createElement("primitive",{ref:l,object:f,attach:"material",blending:sS,"uniforms-fade-value":i,depthWrite:!1,transparent:!0,vertexColors:!0}))}),BI=n=>{const e=Math.random()*Math.PI*2,t=Math.acos(2*Math.random()-1),s=n*Math.sin(t)*Math.cos(e),r=n*Math.sin(t)*Math.sin(e),i=n*Math.cos(t);return new re(s,r,i)},e7=(n,e,t)=>{const s=(t-.5)*n,r=(1-t)*e,i=Math.random()*Math.PI*2,o=r*Math.cos(i),a=r*Math.sin(i);return new re(o,s,a)},t7=(n,e,t)=>{const s=new Float32Array(n*3),r=new Float32Array(n*3),i=new Float32Array(n);for(let o=0;o<n;o++){const a=1-Math.sqrt(Math.random()),l=e7(e,t,a);l.x+=(Math.random()-.5)*1,l.z+=(Math.random()-.5)*1,l.y+=(Math.random()-.5)*1,s[o*3]=l.x,s[o*3+1]=l.y,s[o*3+2]=l.z;const u=BI(e*1.5);r[o*3]=u.x,r[o*3+1]=u.y,r[o*3+2]=u.z,i[o]=Math.random()}return{target:s,chaos:r,randoms:i}},n7=(n,e,t,s)=>{const r=new Float32Array(n*3),i=new Float32Array(n*3);for(let o=0;o<n;o++){const a=o/n,l=(a-.5)*e,u=(1-a)*t+.5,c=a*Math.PI*2*s;r[o*3]=u*Math.cos(c),r[o*3+1]=l,r[o*3+2]=u*Math.sin(c);const h=BI(e*1.2);i[o*3]=h.x,i[o*3+1]=h.y,i[o*3+2]=h.z}return{target:r,chaos:i}},Oi=(n,e,t)=>n*(1-t)+e*t,s7=`
  precision highp float;
  uniform float uTime;
  uniform float uMix;
  uniform float uSize;
  
  attribute vec3 aTargetPos;
  attribute vec3 aChaosPos;
  attribute float aRandom;
  
  varying vec3 vPos;
  varying float vRandom;
  varying float vIsSnow;

  void main() {
    vRandom = aRandom;
    vIsSnow = step(0.85, aRandom); // Top 15% random values become snow

    // Interpolate position
    vec3 pos = mix(aChaosPos, aTargetPos, uMix);
    
    // Breathing effect
    float breath = sin(uTime + pos.y * 0.5) * 0.05 * uMix;
    pos.x += pos.x * breath;
    pos.z += pos.z * breath;

    vPos = pos;

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    
    // Size attenuation
    gl_PointSize = uSize * (20.0 / -mvPosition.z) * (0.6 + 0.8 * aRandom);
  }
`,r7=`
  precision highp float;
  uniform vec3 uColorBottom;
  uniform vec3 uColorTop;
  
  varying vec3 vPos;
  varying float vRandom;
  varying float vIsSnow;

  void main() {
    // Exact height normalization for tree (-9 to 9)
    float h = (vPos.y + 9.0) / 18.0;
    h = clamp(h, 0.0, 1.0);
    
    // Mix gradient
    vec3 color = mix(uColorBottom, uColorTop, h);
    
    // Depth Variation
    color *= 0.6 + 0.6 * vRandom;

    // Apply Snow
    // If vIsSnow is 1.0, mix with white
    vec3 snowColor = vec3(0.95, 0.98, 1.0);
    color = mix(color, snowColor, vIsSnow * 0.9); // 90% white blend

    // Circular particle
    float dist = length(gl_PointCoord - vec2(0.5));
    if (dist > 0.5) discard;
    
    // Soft edge
    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);

    gl_FragColor = vec4(color, alpha);
  }
`,i7=({mixFactor:n,colors:e})=>{const s=Ee.useRef(null),r=Ee.useRef(1),{target:i,chaos:o,randoms:a}=Ee.useMemo(()=>t7(75e3,18,7.5),[75e3]),l=Ee.useMemo(()=>({uTime:{value:0},uMix:{value:1},uSize:{value:4},uColorBottom:{value:new vt(e.bottom)},uColorTop:{value:new vt(e.top)}}),[]);return vc((u,c)=>{if(s.current){const h=2*c;r.current=Oi(r.current,n,h),s.current.uniforms.uTime.value=u.clock.elapsedTime,s.current.uniforms.uMix.value=r.current,s.current.uniforms.uColorBottom.value.set(e.bottom),s.current.uniforms.uColorTop.value.set(e.top)}}),Ae.jsxs("points",{children:[Ae.jsxs("bufferGeometry",{children:[Ae.jsx("bufferAttribute",{attach:"attributes-position",count:75e3,array:i,itemSize:3}),Ae.jsx("bufferAttribute",{attach:"attributes-aTargetPos",count:75e3,array:i,itemSize:3}),Ae.jsx("bufferAttribute",{attach:"attributes-aChaosPos",count:75e3,array:o,itemSize:3}),Ae.jsx("bufferAttribute",{attach:"attributes-aRandom",count:75e3,array:a,itemSize:1})]}),Ae.jsx("shaderMaterial",{ref:s,vertexShader:s7,fragmentShader:r7,uniforms:l,transparent:!0,depthWrite:!1})]})},o7=()=>{const n=new bI([new re(0,-1,0),new re(0,.5,0),new re(.1,.8,0),new re(.4,.9,0),new re(.6,.6,0)]),e=new ux(n,32,.12,8,!1);return e.center(),e},FD=(n,e,t,s)=>{const r=new lc,i=Math.PI*2/(n*2);r.moveTo(0,e);for(let a=0;a<n*2;a++){const l=a%2===0?e:t,u=a*i;r.lineTo(Math.sin(u)*l,Math.cos(u)*l)}r.closePath();const o=new Ng(r,{depth:s,bevelEnabled:!0,bevelThickness:.05,bevelSize:.05,bevelSegments:2});return o.center(),o},a7=()=>{const n=document.createElement("canvas");n.width=128,n.height=128;const e=n.getContext("2d");if(!e)return null;e.fillStyle="#ffffff",e.fillRect(0,0,128,128),e.fillStyle="#cc0000";for(let s=-128;s<256;s+=42)e.beginPath(),e.moveTo(s,0),e.lineTo(s+20,0),e.lineTo(s+20+128,128),e.lineTo(s+128,128),e.closePath(),e.fill();const t=new I0(n);return t.wrapS=Af,t.wrapT=Af,t.repeat.set(4,1),t},l7=n=>{const e=document.createElement("canvas");e.width=512,e.height=128;const t=e.getContext("2d");if(!t)return null;if(t.clearRect(0,0,e.width,e.height),!n)return new I0(e);t.fillStyle="#111111",t.textAlign="center",t.textBaseline="middle",t.font="bold 60px 'Monsieur La Doulaise', cursive",t.fillText(n,e.width/2,e.height/2);const s=new I0(e);return s.needsUpdate=!0,s},vF=({item:n,mixFactor:e,texture:t,signatureTexture:s})=>{const r=Ee.useRef(null),i=Ee.useRef(null),o=Ee.useRef(null),a=Ee.useRef(null),l=Ee.useRef(1),u=Ee.useMemo(()=>new re,[]),c=Ee.useMemo(()=>new re,[]),h=Ee.useMemo(()=>new re,[]),{frameArgs:f,photoArgs:p,photoPos:g,textPos:S,textArgs:x}=Ee.useMemo(()=>{const w=t.image,_=(w==null?void 0:w.width)||1,T=(w==null?void 0:w.height)||1,C=_/T,N=.85;let M,P;C>=1?(M=N,P=N/C):(P=N,M=N*C);const $=.08,R=.08,D=.2,L=M+$*2,G=P+R+D,Q=G/2-R-P/2,W=-(G/2)+D/2;return{frameArgs:[L,G,.05],photoArgs:[M,P],photoPos:[0,Q,.03],textPos:[0,W,.03],textArgs:[L,D]}},[t]);return vc((w,_)=>{if(!r.current||!i.current)return;const T=2*_;l.current=Oi(l.current,e,T);const C=l.current;u.lerpVectors(n.chaosPos,n.targetPos,C),r.current.position.copy(u),c.lerpVectors(n.chaosScale,n.targetScale,C);const{width:N}=w.viewport,M=N<22,P=M?.6:1;c.multiplyScalar(P);const $=1-C;if(C<.99){r.current.getWorldPosition(h);const R=h.distanceTo(w.camera.position),D=M?1.1:1.5,G=Qu.mapLinear(R,10,60,D,.6),Q=Oi(1,G,$);if(c.multiplyScalar(Q),o.current){const W=Qu.mapLinear(R,12,50,.9,.2);o.current.emissiveIntensity=Math.max(.2,W)*$}}else o.current&&(o.current.emissiveIntensity=.25);r.current.scale.copy(c),C>.8?(r.current.lookAt(0,r.current.position.y,0),r.current.rotateY(Math.PI),i.current.rotation.z=Oi(i.current.rotation.z,0,T)):(r.current.lookAt(w.camera.position),i.current.rotation.z=Oi(i.current.rotation.z,n.chaosTilt,T))}),Ae.jsx("group",{ref:r,children:Ae.jsxs("group",{ref:i,children:[Ae.jsxs("mesh",{children:[Ae.jsx("boxGeometry",{args:f}),Ae.jsx("meshStandardMaterial",{ref:a,color:"#ffffff",roughness:1,metalness:0,emissive:"#ffffff",emissiveIntensity:.6,toneMapped:!1})]}),Ae.jsxs("mesh",{position:g,children:[Ae.jsx("planeGeometry",{args:p}),Ae.jsx("meshStandardMaterial",{ref:o,map:t,emissiveMap:t,roughness:.4,metalness:0,color:"white",emissive:"white",emissiveIntensity:.25,toneMapped:!1})]}),s&&Ae.jsxs("mesh",{position:S,children:[Ae.jsx("planeGeometry",{args:x}),Ae.jsx("meshBasicMaterial",{map:s,transparent:!0,opacity:.85,depthWrite:!1})]})]})})},u7=({item:n,mixFactor:e})=>{const t=Ee.useRef(null),s=Ee.useRef(1),r=Ee.useMemo(()=>new re,[]),i=Ee.useMemo(()=>new re,[]),{ribbonColor:o,ribbonMaterial:a}=Ee.useMemo(()=>{const l=n.color,u=.299*l.r+.587*l.g+.114*l.b;let c="#FFD700";return l.b>l.r+.2&&l.b>l.g+.2?c="#E0E0E0":u>.6&&(c="#AA0000"),{ribbonColor:new vt(c),ribbonMaterial:new pb({color:c,roughness:.2,metalness:.8,emissive:c,emissiveIntensity:.2})}},[n.color]);return vc((l,u)=>{if(!t.current)return;const c=2*u;s.current=Oi(s.current,e,c);const h=s.current;r.lerpVectors(n.chaosPos,n.targetPos,h),t.current.position.copy(r),i.lerpVectors(n.chaosScale,n.targetScale,h),t.current.scale.copy(i),t.current.rotation.copy(n.rotation),h<.5&&(t.current.rotation.x+=u*.5,t.current.rotation.y+=u*.5)}),Ae.jsxs("group",{ref:t,children:[Ae.jsxs("mesh",{castShadow:!0,receiveShadow:!0,children:[Ae.jsx("boxGeometry",{args:[1,1,1]}),Ae.jsx("meshStandardMaterial",{color:n.color,roughness:.4,metalness:.1})]}),Ae.jsx("mesh",{scale:[.2,1.01,1.01],material:a,children:Ae.jsx("boxGeometry",{args:[1,1,1]})}),Ae.jsx("mesh",{scale:[1.01,1.01,.2],material:a,children:Ae.jsx("boxGeometry",{args:[1,1,1]})}),Ae.jsx("mesh",{position:[0,.5,0],rotation:[0,Math.PI/4,0],material:a,scale:[.35,.35,.35],children:Ae.jsx("torusKnotGeometry",{args:[.6,.15,64,8,2,3]})})]})},c7=()=>{const n=document.createElement("canvas");n.width=256,n.height=320;const e=n.getContext("2d");return e&&(e.fillStyle="#000000",e.fillRect(0,0,256,320)),new I0(n)},h7=({item:n,mixFactor:e,url:t,signatureTexture:s})=>{const r=zI(LO,t);return Ae.jsx(vF,{item:n,mixFactor:e,texture:r,signatureTexture:s})},d7=n=>Ae.jsx(Ju.Suspense,{fallback:Ae.jsx("group",{position:n.item.targetPos,children:Ae.jsxs("mesh",{scale:n.item.targetScale,children:[Ae.jsx("boxGeometry",{args:[1,1.2,.05]}),Ae.jsx("meshStandardMaterial",{color:"#eee"})]})}),children:Ae.jsx(h7,{...n})}),f7=n=>{switch(n){case"BALL":return 0;case"BOX":return 1;case"STAR":return 2;case"CANDY":return 3;case"CRYSTAL":return 4;case"PHOTO":return 5;default:return 0}},Rm=({mixFactor:n,type:e,count:t,colors:s,scale:r=1,userImages:i=[],signatureText:o})=>{const a=Ee.useRef(null),l=Ee.useMemo(()=>new zn,[]),u=Ee.useRef(1),c=Ee.useMemo(()=>e==="CANDY"?a7():null,[e]),h=Ee.useMemo(()=>e==="PHOTO"&&o?l7(o):null,[e,o]),f=Ee.useMemo(()=>{switch(e){case"CANDY":return o7();case"CRYSTAL":return FD(6,1,.3,.1);case"STAR":return FD(5,1,.5,.2);case"BALL":return new Ag(1,16,16);case"BOX":default:return new Kh(1,1,1)}},[e]),p=Ee.useMemo(()=>{const S=[],x=Math.PI*(3-Math.sqrt(5)),w=18,_=7.5,T=9,N=f7(e)*(Math.PI*2/6);for(let M=0;M<t;M++){const P=Math.sqrt((M+1)/t)*.9,$=P*_,R=T-P*w,D=M*x+N,L=$*Math.cos(D),G=$*Math.sin(D),Q=new re(L,R,G),W=e==="STAR"||e==="PHOTO"?1.15:1.08;Q.multiplyScalar(W);let H,J=0;if(e==="PHOTO"){const ue=(M/t-.5)*12,fe=M*x;H=new re(18*Math.cos(fe),ue,18*Math.sin(fe)),J=(M%5-2)*.15}else H=BI(25);const ie=s?s[Math.floor(Math.random()*s.length)]:"#ffffff",V=new re(1,1,1),Y=Math.random()*.4+.8;e==="CANDY"?V.setScalar(.7):e==="CRYSTAL"?V.setScalar(.6):e==="STAR"?V.setScalar(.7):e==="BOX"&&V.set(1+Math.random()*.3,.7+Math.random()*.4,1+Math.random()*.3);const B=V.clone().multiplyScalar(r*Y);let K=B.clone();if(e==="PHOTO"){const se=3.5+Math.random()*1.5;K.multiplyScalar(se)}S.push({chaosPos:H,targetPos:Q,rotation:new Cg(Math.random()*Math.PI,Math.random()*Math.PI,0),color:new vt(ie),targetScale:B,chaosScale:K,chaosTilt:J})}return S},[t,e,s,r]),g=Ee.useMemo(()=>e!=="PHOTO"?[]:[c7()],[e]);return Ee.useLayoutEffect(()=>{!a.current||e==="PHOTO"||e==="BOX"||(p.forEach((S,x)=>{const w=e==="CANDY"?new vt("#ffffff"):S.color;a.current.setColorAt(x,w),l.position.copy(S.targetPos),l.scale.copy(S.targetScale),l.rotation.copy(S.rotation),l.updateMatrix(),a.current.setMatrixAt(x,l.matrix)}),a.current.instanceColor&&(a.current.instanceColor.needsUpdate=!0),a.current.instanceMatrix.needsUpdate=!0)},[p,e,l]),vc((S,x)=>{if(!a.current||e==="PHOTO"||e==="BOX")return;const w=2*x;u.current=Oi(u.current,n,w);const _=u.current,T=new re,C=new re;p.forEach((N,M)=>{T.lerpVectors(N.chaosPos,N.targetPos,_),l.position.copy(T),e==="STAR"&&_>.8?(l.lookAt(0,T.y,0),l.rotateZ(Math.PI/2)):e==="CRYSTAL"&&_>.8?l.lookAt(0,T.y,0):(l.rotation.copy(N.rotation),_<.5&&(l.rotation.x+=x*.5,l.rotation.y+=x*.5)),C.lerpVectors(N.chaosScale,N.targetScale,_),l.scale.copy(C),l.updateMatrix(),a.current.setMatrixAt(M,l.matrix)}),a.current.instanceMatrix.needsUpdate=!0}),e==="PHOTO"?Ae.jsx("group",{children:p.map((S,x)=>{let w;i&&i.length>0&&x<i.length&&(w=i[x]);const _=g[x%g.length];return w?Ae.jsx(d7,{item:S,mixFactor:n,url:w,signatureTexture:h},x):Ae.jsx(vF,{item:S,mixFactor:n,texture:_,signatureTexture:h},x)})}):e==="BOX"?Ae.jsx("group",{children:p.map((S,x)=>Ae.jsx(u7,{item:S,mixFactor:n},x))}):Ae.jsx("instancedMesh",{ref:a,args:[f,void 0,t],children:Ae.jsx("meshStandardMaterial",{map:c,roughness:e==="CANDY"?.2:e==="BALL"?.1:.15,metalness:e==="CRYSTAL"?.9:e==="BALL"?.7:.5,emissive:e==="CRYSTAL"?"#112244":e==="BALL"?"#ffffff":"#000000",emissiveIntensity:e==="CRYSTAL"?.2:e==="BALL"?.35:0,envMapIntensity:e==="BALL"?2:1})})},p7=({mixFactor:n})=>{const t=Ee.useRef(null),s=Ee.useMemo(()=>new zn,[]),r=Ee.useRef(1),{target:i,chaos:o}=Ee.useMemo(()=>n7(300,19,7.5,9),[]);return Ee.useLayoutEffect(()=>{if(!t.current)return;const a=new vt("#fffae0");for(let l=0;l<300;l++)t.current.setColorAt(l,a),s.position.set(i[l*3],i[l*3+1],i[l*3+2]),s.scale.setScalar(.15),s.updateMatrix(),t.current.setMatrixAt(l,s.matrix);t.current.instanceColor&&(t.current.instanceColor.needsUpdate=!0),t.current.instanceMatrix.needsUpdate=!0},[i,s]),vc((a,l)=>{if(!t.current)return;const u=2*l;r.current=Oi(r.current,n,u);const c=r.current,h=a.clock.elapsedTime;for(let f=0;f<300;f++){const p=i[f*3],g=i[f*3+1],S=i[f*3+2],x=o[f*3],w=o[f*3+1],_=o[f*3+2],T=Oi(x,p,c),C=Oi(w,g,c),N=Oi(_,S,c);s.position.set(T,C,N);const M=Math.sin(h*3+f*.1)*.05+.15;s.scale.setScalar(M),s.updateMatrix(),t.current.setMatrixAt(f,s.matrix)}t.current.instanceMatrix.needsUpdate=!0}),Ae.jsxs("instancedMesh",{ref:t,args:[void 0,void 0,300],children:[Ae.jsx("sphereGeometry",{args:[1,8,8]}),Ae.jsx("meshBasicMaterial",{color:"#fffae0",toneMapped:!1})]})},m7=`
  precision highp float;
  uniform float uTime; // Global Time
  uniform float uMix;  // Still used for drift amplitude
  
  attribute float aScale;
  attribute vec3 aVelocity;
  
  varying float vAlpha;

  void main() {
    vec3 pos = position;
    
    // Physics
    // Fall down based on Global Time.
    float fallSpeed = aVelocity.y; 
    
    pos.y = mod(pos.y - uTime * fallSpeed + 15.0, 30.0) - 15.0; // Wrap Y (-15 to 15)
    
    // Side drift
    // uMix still controls the Amplitude of the drift (Chaos = wider drift)
    float drift = sin(uTime * aVelocity.x + pos.y) * (0.5 + (1.0 - uMix) * 2.0);
    pos.x += drift;
    pos.z += cos(uTime * aVelocity.z + pos.x) * 0.5;

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    
    // Size
    gl_PointSize = aScale * (15.0 / -mvPosition.z);
    
    // Fade at edges of box
    vAlpha = 1.0 - smoothstep(12.0, 15.0, abs(pos.y));
  }
`,g7=`
  precision highp float;
  varying float vAlpha;

  void main() {
    vec2 coord = gl_PointCoord - vec2(0.5);
    float dist = length(coord);
    if (dist > 0.5) discard;
    
    float alpha = (1.0 - smoothstep(0.3, 0.5, dist)) * vAlpha * 0.8;
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
  }
`,y7=({mixFactor:n})=>{const t=Ee.useRef(null),s=Ee.useRef(null),r=Ee.useRef(1),{camera:i}=dF(),{positions:o,scales:a,velocities:l}=Ee.useMemo(()=>{const c=new Float32Array(9e3),h=new Float32Array(3e3),f=new Float32Array(3e3*3);for(let p=0;p<3e3;p++)c[p*3]=(Math.random()-.5)*50,c[p*3+1]=(Math.random()-.5)*30,c[p*3+2]=(Math.random()-.5)*40,h[p]=Math.random()*2+1,f[p*3]=Math.random()*.5+.2,f[p*3+1]=Math.random()*2+1,f[p*3+2]=Math.random()*.5+.2;return{positions:c,scales:h,velocities:f}},[3e3]),u=Ee.useMemo(()=>({uTime:{value:0},uMix:{value:1}}),[]);return vc((c,h)=>{s.current&&t.current&&(r.current=Oi(r.current,n,h*2),s.current.uniforms.uTime.value=c.clock.elapsedTime,s.current.uniforms.uMix.value=r.current,t.current.position.x=i.position.x,t.current.position.y=i.position.y)}),Ae.jsxs("points",{ref:t,frustumCulled:!1,children:[Ae.jsxs("bufferGeometry",{children:[Ae.jsx("bufferAttribute",{attach:"attributes-position",count:3e3,array:o,itemSize:3}),Ae.jsx("bufferAttribute",{attach:"attributes-aScale",count:3e3,array:a,itemSize:1}),Ae.jsx("bufferAttribute",{attach:"attributes-aVelocity",count:3e3,array:l,itemSize:3})]}),Ae.jsx("shaderMaterial",{ref:s,vertexShader:m7,fragmentShader:g7,uniforms:u,transparent:!0,depthWrite:!1})]})},x7=(n,e,t)=>{const s=new lc,r=Math.PI*2/(t*2);s.moveTo(0,n);for(let i=0;i<t*2;i++){const o=i%2===0?n:e,l=i*r+Math.PI/2;s.lineTo(Math.cos(l)*o,Math.sin(l)*o)}return s.closePath(),s},v7=({mixFactor:n})=>{const e=Ee.useRef(null),t=Ee.useRef(null),s=Ee.useRef(null),r=Ee.useRef(1),i=Ee.useMemo(()=>{const o=x7(1.2,.6,5),a=new Ng(o,{depth:.4,bevelEnabled:!0,bevelThickness:.1,bevelSize:.1,bevelSegments:4});return a.center(),a},[]);return vc((o,a)=>{if(!e.current||!t.current||!s.current)return;const l=2*a;r.current=Oi(r.current,n,l);const u=r.current,f=Oi(13,9.2,u);if(e.current.position.set(0,f,0),s.current.rotation.y+=a*.5,u<.9){const p=(1-u)*.5;e.current.rotation.z=Math.sin(o.clock.elapsedTime)*p,e.current.rotation.x=Math.cos(o.clock.elapsedTime*.8)*p}else e.current.rotation.z=Oi(e.current.rotation.z,0,l),e.current.rotation.x=Oi(e.current.rotation.x,0,l);t.current.scale.setScalar(1)}),Ae.jsxs("group",{ref:e,children:[Ae.jsx("group",{ref:t,children:Ae.jsx("mesh",{ref:s,geometry:i,children:Ae.jsx("meshStandardMaterial",{color:"#FFD700",emissive:"#FFD700",emissiveIntensity:2,roughness:.1,metalness:.9,toneMapped:!1})})}),Ae.jsx("pointLight",{color:"#ffeebf",intensity:3,distance:15,decay:2})]})},w7=["#FF1744","#FF5252","#4CAF50","#00E676","#FFD700","#FFC107","#2196F3","#00BCD4","#3F51B5","#9C27B0","#E91E63","#FF5722","#FFEB3B","#00E5FF","#7C4DFF","#FF4081","#18FFFF","#FF6F00"],S7=["#E53935","#43A047","#FFD700","#FFFFFF","#7B1FA2","#546E7A","#00ACC1","#FF8F00","#E91E63","#3F51B5","#00BCD4","#FF5722"],b7=["#FFD700","#FFC107","#FFEB3B","#FFF59D","#FFE082"],_7=["#E0F7FA","#B2EBF2","#80DEEA","#4DD0E1","#26C6DA","#00BCD4","#00ACC1"],T7=["#FFFFFF"],C7=({inputRef:n,groupRef:e})=>{const{camera:t,gl:s}=dF(),r=Ee.useMemo(()=>new re,[]),i=Ee.useRef(32),o=Ee.useRef(!1),a=Ee.useRef(0),l=Ee.useRef(null),u=Ee.useRef(.002),c=Ee.useRef(!1),h=Ee.useRef(0),f=Ee.useRef({x:0,y:0});return Ee.useEffect(()=>{const p=s.domElement;p.style.touchAction="none";const g=N=>{N.preventDefault(),i.current+=N.deltaY*.02,i.current=Qu.clamp(i.current,12,55)},S=N=>{N.isPrimary&&N.button===0&&(o.current=!0,a.current=N.clientX,p.setPointerCapture(N.pointerId),u.current=0)},x=N=>{N.isPrimary&&(o.current=!1,p.releasePointerCapture(N.pointerId))},w=N=>{if(N.isPrimary&&o.current&&e.current&&l.current===null){const M=N.clientX-a.current;a.current=N.clientX;const P=M*.005;e.current.rotation.y+=P,u.current=P}},_=N=>{if(N.touches.length===2){const M=N.touches[0].clientX-N.touches[1].clientX,P=N.touches[0].clientY-N.touches[1].clientY;l.current=Math.sqrt(M*M+P*P)}},T=N=>{if(N.touches.length===2){N.cancelable&&N.preventDefault();const M=N.touches[0].clientX-N.touches[1].clientX,P=N.touches[0].clientY-N.touches[1].clientY,$=Math.sqrt(M*M+P*P);if(l.current!==null){const R=l.current-$,D=.15;i.current+=R*D,i.current=Qu.clamp(i.current,12,55)}l.current=$}},C=()=>{l.current=null};return p.addEventListener("wheel",g,{passive:!1}),p.addEventListener("pointerdown",S),p.addEventListener("pointerup",x),p.addEventListener("pointermove",w),p.addEventListener("pointerleave",x),p.addEventListener("pointercancel",x),p.addEventListener("touchstart",_,{passive:!1}),p.addEventListener("touchmove",T,{passive:!1}),p.addEventListener("touchend",C),p.addEventListener("touchcancel",C),()=>{p.removeEventListener("wheel",g),p.removeEventListener("pointerdown",S),p.removeEventListener("pointerup",x),p.removeEventListener("pointermove",w),p.removeEventListener("pointerleave",x),p.removeEventListener("pointercancel",x),p.removeEventListener("touchstart",_),p.removeEventListener("touchmove",T),p.removeEventListener("touchend",C),p.removeEventListener("touchcancel",C)}},[s,e]),vc((p,g)=>{const S=Math.min(g,.1),x=n.current.x,w=n.current.y,_=!!n.current.isDetected,T=4*S;f.current.x=Qu.lerp(f.current.x,x,T),f.current.y=Qu.lerp(f.current.y,w,T);const C=f.current.x*4,N=f.current.y*2,M=i.current+Math.abs(f.current.x)*2;if(t.position.lerp(r.set(C,N,M),4*S),t.lookAt(0,0,0),e.current){if(_){const P=Math.PI*1.2,$=f.current.x*P;c.current||(h.current=e.current.rotation.y-$,u.current=0);const R=$+h.current,D=6*S,L=e.current.rotation.y;e.current.rotation.y=Qu.lerp(L,R,D),u.current=e.current.rotation.y-L,c.current=!0}else if(c.current&&(Math.abs(u.current)<1e-4&&(u.current=.002),c.current=!1),!o.current){e.current.rotation.y+=u.current;const P=.002;u.current=Qu.lerp(u.current,P,S*.5)}}}),null},E7=({mixFactor:n,colors:e,inputRef:t,userImages:s,signatureText:r})=>{const i=Ee.useRef(null),o=Math.min(s&&s.length>0?s.length:10,10);return Ae.jsxs(Ae.Fragment,{children:[Ae.jsx(C7,{inputRef:t,groupRef:i}),Ae.jsx("ambientLight",{intensity:.7}),Ae.jsx("ambientLight",{intensity:.3,color:"#fff8e1"}),Ae.jsx("spotLight",{position:[20,20,20],angle:.4,penumbra:1,intensity:2.5,color:"#fff5d0",castShadow:!1}),Ae.jsx("pointLight",{position:[-10,5,-10],intensity:1.5,color:"#ffffff"}),Ae.jsx("pointLight",{position:[10,-5,10],intensity:1.5,color:"#ffffff"}),Ae.jsx("pointLight",{position:[0,10,10],intensity:1,color:"#ffffff"}),Ae.jsx("pointLight",{position:[0,15,0],intensity:.8,color:"#fff5d0"}),Ae.jsx("pointLight",{position:[-15,8,-15],intensity:.6,color:"#e3f2fd"}),Ae.jsx("pointLight",{position:[15,8,-15],intensity:.6,color:"#fce4ec"}),Ae.jsx(Q9,{radius:100,depth:50,count:3e3,factor:4,saturation:0,fade:!0,speed:1}),Ae.jsx(y7,{mixFactor:n}),Ae.jsxs("group",{ref:i,position:[0,0,0],children:[Ae.jsx(v7,{mixFactor:n}),Ae.jsx(i7,{mixFactor:n,colors:e}),Ae.jsx(p7,{mixFactor:n}),Ae.jsx(Rm,{mixFactor:n,type:"BALL",count:60,scale:.5,colors:w7}),Ae.jsx(Rm,{mixFactor:n,type:"BOX",count:30,scale:.6,colors:S7}),Ae.jsx(Rm,{mixFactor:n,type:"STAR",count:25,scale:.5,colors:b7}),Ae.jsx(Rm,{mixFactor:n,type:"CRYSTAL",count:40,scale:.4,colors:_7}),Ae.jsx(Rm,{mixFactor:n,type:"CANDY",count:40,scale:.8,colors:T7}),Ae.jsx(Rm,{mixFactor:n,type:"PHOTO",count:o,userImages:s,signatureText:r})]})]})},wF=Ju.forwardRef((n,e)=>{const[t,s]=Ju.useState(null);Ju.useImperativeHandle(e,()=>({getPhotoPositions:()=>[]}));const r=Ju.useCallback(a=>{console.error("WebGL Error:",a),s("WebGL ")},[]),i=Ju.useCallback(a=>{a.preventDefault(),console.warn("WebGL Context Lost"),s("WebGL ...")},[]),o=Ju.useCallback(()=>{console.log("WebGL Context Restored"),s(null),window.location.reload()},[]);return Ju.useEffect(()=>(window.addEventListener("webglcontextlost",i),window.addEventListener("webglcontextrestored",o),window.addEventListener("error",r),()=>{window.removeEventListener("webglcontextlost",i),window.removeEventListener("webglcontextrestored",o),window.removeEventListener("error",r)}),[i,o,r]),t?Ae.jsx("div",{className:"absolute inset-0 flex items-center justify-center bg-black/90 text-white z-50",children:Ae.jsxs("div",{className:"text-center p-8",children:[Ae.jsx("div",{className:"text-2xl mb-4",children:""}),Ae.jsx("div",{className:"text-lg mb-4",children:t}),Ae.jsx("button",{onClick:()=>window.location.reload(),className:"px-6 py-2 bg-white/20 hover:bg-white/30 rounded border border-white/40 transition-colors",children:""})]})}):Ae.jsx(q9,{dpr:[1,1.25],camera:{position:[0,0,32],fov:45,near:5,far:80},gl:{antialias:!1,toneMapping:GS,toneMappingExposure:1,powerPreference:"high-performance",preserveDrawingBuffer:!1,failIfMajorPerformanceCaveat:!1,precision:"lowp"},onCreated:({gl:a})=>{console.log("Canvas created, WebGL context initialized");const l=a.domElement,u=l.getContext("webgl2")||l.getContext("webgl");if(u){const S=u.getExtension("WEBGL_debug_renderer_info");if(S){const _=u.getParameter(S.UNMASKED_VENDOR_WEBGL),T=u.getParameter(S.UNMASKED_RENDERER_WEBGL);console.log("WebGL Vendor:",_),console.log("WebGL Renderer:",T)}const x=u.getParameter(u.MAX_TEXTURE_SIZE),w=u.getParameter(u.MAX_TEXTURE_IMAGE_UNITS);console.log("Max Texture Size:",x),console.log("Max Texture Units:",w),x<4096&&console.warn("Low-end GPU detected, using reduced quality settings")}const c=setInterval(()=>{var S;if(a.info){console.log("GPU Memory - Programs:",((S=a.info.programs)==null?void 0:S.length)||0);try{const x=a.info;x.geometries!==void 0&&console.log("GPU Memory - Geometries:",x.geometries),x.textures!==void 0&&console.log("GPU Memory - Textures:",x.textures)}catch{}}},3e4),h=S=>{S.preventDefault(),console.error("WebGL Context Lost in Canvas"),s("WebGL ");try{a.setPixelRatio(.75),console.log("Reduced pixel ratio to prevent further context loss")}catch(x){console.error("Failed to adjust render quality:",x)}},f=()=>{console.log("WebGL Context Restored in Canvas"),s(null),setTimeout(()=>window.location.reload(),1e3)};l.addEventListener("webglcontextlost",h),l.addEventListener("webglcontextrestored",f);const g=setInterval(()=>{u&&u.isContextLost()&&(console.error("WebGL context is lost"),s("WebGL "))},5e3);return()=>{l.removeEventListener("webglcontextlost",h),l.removeEventListener("webglcontextrestored",f),clearInterval(g),clearInterval(c)}},shadows:!0,style:{touchAction:"none"},children:Ae.jsx(E7,{...n})})});wF.displayName="Experience";var Hw={exports:{}},I7=Hw.exports,$D;function N7(){return $D||($D=1,(function(n,e){(function(s,r){n.exports=r(J0())})(I7,function(t){return(function(s){var r={};function i(o){if(r[o])return r[o].exports;var a=r[o]={i:o,l:!1,exports:{}};return s[o].call(a.exports,a,a.exports,i),a.l=!0,a.exports}return i.m=s,i.c=r,i.d=function(o,a,l){i.o(o,a)||Object.defineProperty(o,a,{enumerable:!0,get:l})},i.r=function(o){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})},i.t=function(o,a){if(a&1&&(o=i(o)),a&8||a&4&&typeof o=="object"&&o&&o.__esModule)return o;var l=Object.create(null);if(i.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:o}),a&2&&typeof o!="string")for(var u in o)i.d(l,u,(function(c){return o[c]}).bind(null,u));return l},i.n=function(o){var a=o&&o.__esModule?function(){return o.default}:function(){return o};return i.d(a,"a",a),a},i.o=function(o,a){return Object.prototype.hasOwnProperty.call(o,a)},i.p="",i(i.s="./src/react-webcam.tsx")})({"./src/react-webcam.tsx":(function(s,r,i){i.r(r);var o=i("react"),a=(function(){var f=function(p,g){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(S,x){S.__proto__=x}||function(S,x){for(var w in x)x.hasOwnProperty(w)&&(S[w]=x[w])},f(p,g)};return function(p,g){f(p,g);function S(){this.constructor=p}p.prototype=g===null?Object.create(g):(S.prototype=g.prototype,new S)}})(),l=function(){return l=Object.assign||function(f){for(var p,g=1,S=arguments.length;g<S;g++){p=arguments[g];for(var x in p)Object.prototype.hasOwnProperty.call(p,x)&&(f[x]=p[x])}return f},l.apply(this,arguments)},u=function(f,p){var g={};for(var S in f)Object.prototype.hasOwnProperty.call(f,S)&&p.indexOf(S)<0&&(g[S]=f[S]);if(f!=null&&typeof Object.getOwnPropertySymbols=="function")for(var x=0,S=Object.getOwnPropertySymbols(f);x<S.length;x++)p.indexOf(S[x])<0&&Object.prototype.propertyIsEnumerable.call(f,S[x])&&(g[S[x]]=f[S[x]]);return g};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(p){var g=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return g?new Promise(function(S,x){g.call(navigator,p,S,x)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function c(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var h=(function(f){a(p,f);function p(g){var S=f.call(this,g)||this;return S.canvas=null,S.ctx=null,S.requestUserMediaId=0,S.unmounted=!1,S.state={hasUserMedia:!1},S}return p.prototype.componentDidMount=function(){var g=this,S=g.state,x=g.props;if(this.unmounted=!1,!c()){x.onUserMediaError("getUserMedia not supported");return}S.hasUserMedia||this.requestUserMedia(),x.children&&typeof x.children!="function"&&console.warn("children must be a function")},p.prototype.componentDidUpdate=function(g){var S=this.props;if(!c()){S.onUserMediaError("getUserMedia not supported");return}var x=JSON.stringify(g.audioConstraints)!==JSON.stringify(S.audioConstraints),w=JSON.stringify(g.videoConstraints)!==JSON.stringify(S.videoConstraints),_=g.minScreenshotWidth!==S.minScreenshotWidth,T=g.minScreenshotHeight!==S.minScreenshotHeight;(w||_||T)&&(this.canvas=null,this.ctx=null),(x||w)&&(this.stopAndCleanup(),this.requestUserMedia())},p.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},p.stopMediaStream=function(g){g&&(g.getVideoTracks&&g.getAudioTracks?(g.getVideoTracks().map(function(S){g.removeTrack(S),S.stop()}),g.getAudioTracks().map(function(S){g.removeTrack(S),S.stop()})):g.stop())},p.prototype.stopAndCleanup=function(){var g=this.state;g.hasUserMedia&&(p.stopMediaStream(this.stream),g.src&&window.URL.revokeObjectURL(g.src))},p.prototype.getScreenshot=function(g){var S=this,x=S.state,w=S.props;if(!x.hasUserMedia)return null;var _=this.getCanvas(g);return _&&_.toDataURL(w.screenshotFormat,w.screenshotQuality)},p.prototype.getCanvas=function(g){var S=this,x=S.state,w=S.props;if(!this.video||!x.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var _=this.video.videoWidth,T=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var C=_/T;_=w.minScreenshotWidth||this.video.clientWidth,T=_/C,w.minScreenshotHeight&&T<w.minScreenshotHeight&&(T=w.minScreenshotHeight,_=T*C)}this.canvas=document.createElement("canvas"),this.canvas.width=(g==null?void 0:g.width)||_,this.canvas.height=(g==null?void 0:g.height)||T,this.ctx=this.canvas.getContext("2d")}var N=this,M=N.ctx,P=N.canvas;return M&&P&&(P.width=(g==null?void 0:g.width)||P.width,P.height=(g==null?void 0:g.height)||P.height,w.mirrored&&(M.translate(P.width,0),M.scale(-1,1)),M.imageSmoothingEnabled=w.imageSmoothing,M.drawImage(this.video,0,0,(g==null?void 0:g.width)||P.width,(g==null?void 0:g.height)||P.height),w.mirrored&&(M.scale(-1,1),M.translate(-P.width,0))),P},p.prototype.requestUserMedia=function(){var g=this,S=this.props,x=function(T,C){var N={video:typeof C<"u"?C:!0};S.audio&&(N.audio=typeof T<"u"?T:!0),g.requestUserMediaId++;var M=g.requestUserMediaId;navigator.mediaDevices.getUserMedia(N).then(function(P){g.unmounted||M!==g.requestUserMediaId?p.stopMediaStream(P):g.handleUserMedia(null,P)}).catch(function(P){g.handleUserMedia(P)})};if("mediaDevices"in navigator)x(S.audioConstraints,S.videoConstraints);else{var w=function(T){return{optional:[{sourceId:T}]}},_=function(T){var C=T.deviceId;return typeof C=="string"?C:Array.isArray(C)&&C.length>0?C[0]:typeof C=="object"&&C.ideal?C.ideal:null};MediaStreamTrack.getSources(function(T){var C=null,N=null;T.forEach(function($){$.kind==="audio"?C=$.id:$.kind==="video"&&(N=$.id)});var M=_(S.audioConstraints);M&&(C=M);var P=_(S.videoConstraints);P&&(N=P),x(w(C),w(N))})}},p.prototype.handleUserMedia=function(g,S){var x=this.props;if(g||!S){this.setState({hasUserMedia:!1}),x.onUserMediaError(g);return}this.stream=S;try{this.video&&(this.video.srcObject=S),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(S)})}x.onUserMedia(S)},p.prototype.render=function(){var g=this,S=this,x=S.state,w=S.props,_=w.audio;w.forceScreenshotSourceSize;var T=w.disablePictureInPicture;w.onUserMedia,w.onUserMediaError,w.screenshotFormat,w.screenshotQuality,w.minScreenshotWidth,w.minScreenshotHeight,w.audioConstraints,w.videoConstraints,w.imageSmoothing;var C=w.mirrored,N=w.style,M=N===void 0?{}:N,P=w.children,$=u(w,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),R=C?l(l({},M),{transform:(M.transform||"")+" scaleX(-1)"}):M,D={getScreenshot:this.getScreenshot.bind(this)};return o.createElement(o.Fragment,null,o.createElement("video",l({autoPlay:!0,disablePictureInPicture:T,src:x.src,muted:!_,playsInline:!0,ref:function(L){g.video=L},style:R},$)),P&&P(D))},p.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},p})(o.Component);r.default=h}),react:(function(s,r){s.exports=t})}).default})})(Hw)),Hw.exports}var A7=N7();const M7=Z0(A7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k7=1e-7,R7=1e-4;class SF{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class VI{refCount(e){return To("refCount")}incRef(e){return To("incRef")}timerAvailable(){return!0}time(e){return To("time")}read(e){return To("read")}readSync(e){return To("readSync")}readToGPU(e,t){return To("readToGPU")}numDataIds(){return To("numDataIds")}disposeData(e,t){return To("disposeData")}write(e,t,s){return To("write")}move(e,t,s,r,i){return To("move")}createTensorFromGPUData(e,t,s){return To("createTensorFromGPUData")}memory(){return To("memory")}floatPrecision(){return To("floatPrecision")}epsilon(){return this.floatPrecision()===32?k7:R7}dispose(){return To("dispose")}}function To(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,zm(n,e,t)}function Df(n,e,t){return Math.max(n,Math.min(e,t))}function WI(n){return n%2===0?n:n+1}function zm(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function P7(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function q(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Vo(n,e,t=""){q(Mn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function kg(n){q(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Oe(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function L7(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Mn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function cg(n){return n%1===0}function JE(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function Ym(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function zD(n,e=r=>0,t,s){return new Promise((r,i)=>{let o=0;const a=()=>{if(n()){r();return}o++;const l=e(o);if(t!=null&&o>=t){i();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function bF(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function Cn(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),q(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),q(n.every(s=>cg(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Jh(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:Cn(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Yr(n,e){return Gs(n,e)}function Gs(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function O7(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function F7(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function _F(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function fS(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function $7(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function dx(n){return typeof n=="string"||n instanceof String}function z7(n){return typeof n=="boolean"}function QE(n){return typeof n=="number"}function Rg(n){return Array.isArray(n)?Rg(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":QE(n)?"float32":dx(n)?"string":z7(n)?"bool":"float32"}function e2(n){return!!(n&&n.constructor&&n.call&&n.apply)}function t2(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Wt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function TF(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<i;l++)r[l]=TF(n+l*a,o,t,s)}return r}function Ra(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return TF(0,n,e,t)}function U7(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function GI(n,e){const t=gi(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function gi(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function CF(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return Ra(n,new Float32Array(t));if(e==="int32")return Ra(n,new Int32Array(t));if(e==="bool")return Ra(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function ua(n){n.forEach(e=>{q(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function lu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Dg(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Pf(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD="tfjsflags";class B7{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=V7,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Te().getBool("IS_TEST")||Te().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];Te().getBool("IS_TEST")||Te().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Pf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);UD in e&&e[UD].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=G7(r,i)})}}function V7(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(W7(e,s[0],s[1]),s.join("="))),e}function W7(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function G7(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Te(){return EF}let EF=null;function H7(n){EF=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UC;function IF(){if(UC==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");UC=n}return UC}function j7(){const n=IF();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function HI(n,e){const t=j7();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const gb="Abs",fx="Acos",px="Acosh",Pg="Add",yb="AddN",jI="All",XI="Any",xb="ArgMax",vb="ArgMin",mx="Asin",gx="Asinh",yx="Atan",xx="Atanh",vx="Atan2",wb="AvgPool",qI="AvgPoolGrad",Sb="AvgPool3D",KI="AvgPool3DGrad",bb="BatchMatMul",_b="BatchToSpaceND",YI="Bincount",Tb="BitwiseAnd",X7="BroadcastTo",ZI="BroadcastArgs",wx="Cast",Sx="Ceil",bx="ClipByValue",JI="Complex",Cb="ComplexAbs",Eb="Concat",Ib="Conv2D",QI="Conv2DBackpropFilter",Nb="Conv2DBackpropInput",Ab="Conv3D",eN="Conv3DBackpropFilterV2",tN="Conv3DBackpropInputV2",_x="Cos",Tx="Cosh",nN="Cumprod",Mb="Cumsum",sN="CropAndResize",rN="DenseBincount",iN="DepthToSpace",kb="DepthwiseConv2dNative",oN="DepthwiseConv2dNativeBackpropFilter",aN="DepthwiseConv2dNativeBackpropInput",lN="Diag",Rb="Dilation2D",n2="Dilation2DBackpropInput",s2="Dilation2DBackpropFilter",q7="Draw",Cx="RealDiv",uN="Einsum",Ex="Elu",cN="EluGrad",Ix="Erf",Db="Equal",Nx="Exp",Pb="ExpandDims",Ax="Expm1",hN="FFT",dN="Fill",fN="FlipLeftRight",Mx="Floor",kx="FloorDiv",Lb="FusedBatchNorm",Ob="GatherV2",pN="GatherNd",Fb="Greater",Rx="GreaterEqual",Dx="Identity",mN="IFFT",gN="Imag",Px="IsFinite",Lx="IsInf",Ox="IsNan",$b="LeakyRelu",zb="Less",Ub="LessEqual",yN="LinSpace",Fx="Log",$x="Log1p",Bb="LogicalAnd",Vb="LogicalNot",Wb="LogicalOr",K7="LogSoftmax",Gb="LRN",xN="LRNGrad",Hb="Max",zx="Maximum",jb="MaxPool",vN="MaxPoolGrad",Xb="MaxPool3D",wN="MaxPool3DGrad",SN="MaxPoolWithArgmax",qb="Mean",Kb="Min",Ux="Minimum",Yb="MirrorPad",Bx="Mod",bN="Multinomial",Vx="Multiply",Zb="Neg",Jb="NotEqual",_N="NonMaxSuppressionV3",TN="NonMaxSuppressionV4",CN="NonMaxSuppressionV5",Qb="OnesLike",e_="OneHot",t_="Pack",n_="PadV2",Wx="Pow",s_="Prelu",r_="Prod",EN="RaggedGather",IN="RaggedRange",NN="RaggedTensorToTensor",AN="Range",MN="Real",Gx="Reciprocal",Hx="Relu",i_="Reshape",o_="ResizeNearestNeighbor",kN="ResizeNearestNeighborGrad",a_="ResizeBilinear",RN="ResizeBilinearGrad",jx="Relu6",l_="Reverse",Xx="Round",qx="Rsqrt",DN="ScatterNd",PN="TensorScatterUpdate",LN="SearchSorted",u_="Select",Kx="Selu",c_="Slice",Yx="Sin",Zx="Sinh",Jx="Sign",Qx="Sigmoid",ev="Softplus",tv="Sqrt",h_="Sum",d_="SpaceToBatchND",f_="SplitV",p_="Softmax",ON="SparseFillEmptyRows",FN="SparseReshape",$N="SparseSegmentMean",zN="SparseSegmentSum",UN="SparseToDense",nv="SquaredDifference",BN="Square",m_="StaticRegexReplace",VN="StridedSlice",WN="StringNGrams",GN="StringSplit",HN="StringToHashBucketFast",sv="Sub",rv="Tan",iv="Tanh",ov="Tile",jN="TopK",XN="Transform",Zm="Transpose",qN="Unique",g_="Unpack",y_="UnsortedSegmentSum",x_="ZerosLike",av="Step",r2="FromPixels",KN="RotateWithOffset",pS="_FusedMatMul",mS="FusedConv2D",gS="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(...n){Te().getBool("IS_TEST")||Te().getBool("PROD")||console.warn(...n)}function Y7(...n){Te().getBool("IS_TEST")||Te().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yS=HI("kernelRegistry",()=>new Map),i2=HI("gradRegistry",()=>new Map);function o2(n,e){const t=AF(n,e);return yS.get(t)}function BD(n){return i2.get(n)}function VD(n){const e=yS.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&t.push(o)}return t}function NF(n){const{kernelName:e,backendName:t}=n,s=AF(e,t);yS.has(s)&&ra(`The kernel '${e}' for backend '${t}' is already registered`),yS.set(s,n)}function Z7(n){const{kernelName:e}=n;i2.has(e)&&Te().getBool("DEBUG")&&ra(`Overriding the gradient for '${e}'`),i2.set(e,n)}function AF(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var BC,WD;function J7(){if(WD)return BC;WD=1,BC=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(D,L,G){this.low=D|0,this.high=L|0,this.unsigned=!!G}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(D){return(D&&D.__isLong__)===!0}e.isLong=t;var s={},r={};function i(D,L){var G,Q,W;return L?(D>>>=0,(W=0<=D&&D<256)&&(Q=r[D],Q)?Q:(G=a(D,(D|0)<0?-1:0,!0),W&&(r[D]=G),G)):(D|=0,(W=-128<=D&&D<128)&&(Q=s[D],Q)?Q:(G=a(D,D<0?-1:0,!1),W&&(s[D]=G),G))}e.fromInt=i;function o(D,L){if(isNaN(D))return L?_:w;if(L){if(D<0)return _;if(D>=g)return P}else{if(D<=-S)return $;if(D+1>=S)return M}return D<0?o(-D,L).neg():a(D%p|0,D/p|0,L)}e.fromNumber=o;function a(D,L,G){return new e(D,L,G)}e.fromBits=a;var l=Math.pow;function u(D,L,G){if(D.length===0)throw Error("empty string");if(D==="NaN"||D==="Infinity"||D==="+Infinity"||D==="-Infinity")return w;if(typeof L=="number"?(G=L,L=!1):L=!!L,G=G||10,G<2||36<G)throw RangeError("radix");var Q;if((Q=D.indexOf("-"))>0)throw Error("interior hyphen");if(Q===0)return u(D.substring(1),L,G).neg();for(var W=o(l(G,8)),H=w,J=0;J<D.length;J+=8){var ie=Math.min(8,D.length-J),V=parseInt(D.substring(J,J+ie),G);if(ie<8){var Y=o(l(G,ie));H=H.mul(Y).add(o(V))}else H=H.mul(W),H=H.add(o(V))}return H.unsigned=L,H}e.fromString=u;function c(D,L){return typeof D=="number"?o(D,L):typeof D=="string"?u(D,L):a(D.low,D.high,typeof L=="boolean"?L:D.unsigned)}e.fromValue=c;var h=65536,f=1<<24,p=h*h,g=p*p,S=g/2,x=i(f),w=i(0);e.ZERO=w;var _=i(0,!0);e.UZERO=_;var T=i(1);e.ONE=T;var C=i(1,!0);e.UONE=C;var N=i(-1);e.NEG_ONE=N;var M=a(-1,2147483647,!1);e.MAX_VALUE=M;var P=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=P;var $=a(0,-2147483648,!1);e.MIN_VALUE=$;var R=e.prototype;return R.toInt=function(){return this.unsigned?this.low>>>0:this.low},R.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},R.toString=function(L){if(L=L||10,L<2||36<L)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq($)){var G=o(L),Q=this.div(G),W=Q.mul(G).sub(this);return Q.toString(L)+W.toInt().toString(L)}else return"-"+this.neg().toString(L);for(var H=o(l(L,6),this.unsigned),J=this,ie="";;){var V=J.div(H),Y=J.sub(V.mul(H)).toInt()>>>0,B=Y.toString(L);if(J=V,J.isZero())return B+ie;for(;B.length<6;)B="0"+B;ie=""+B+ie}},R.getHighBits=function(){return this.high},R.getHighBitsUnsigned=function(){return this.high>>>0},R.getLowBits=function(){return this.low},R.getLowBitsUnsigned=function(){return this.low>>>0},R.getNumBitsAbs=function(){if(this.isNegative())return this.eq($)?64:this.neg().getNumBitsAbs();for(var L=this.high!=0?this.high:this.low,G=31;G>0&&(L&1<<G)==0;G--);return this.high!=0?G+33:G+1},R.isZero=function(){return this.high===0&&this.low===0},R.eqz=R.isZero,R.isNegative=function(){return!this.unsigned&&this.high<0},R.isPositive=function(){return this.unsigned||this.high>=0},R.isOdd=function(){return(this.low&1)===1},R.isEven=function(){return(this.low&1)===0},R.equals=function(L){return t(L)||(L=c(L)),this.unsigned!==L.unsigned&&this.high>>>31===1&&L.high>>>31===1?!1:this.high===L.high&&this.low===L.low},R.eq=R.equals,R.notEquals=function(L){return!this.eq(L)},R.neq=R.notEquals,R.ne=R.notEquals,R.lessThan=function(L){return this.comp(L)<0},R.lt=R.lessThan,R.lessThanOrEqual=function(L){return this.comp(L)<=0},R.lte=R.lessThanOrEqual,R.le=R.lessThanOrEqual,R.greaterThan=function(L){return this.comp(L)>0},R.gt=R.greaterThan,R.greaterThanOrEqual=function(L){return this.comp(L)>=0},R.gte=R.greaterThanOrEqual,R.ge=R.greaterThanOrEqual,R.compare=function(L){if(t(L)||(L=c(L)),this.eq(L))return 0;var G=this.isNegative(),Q=L.isNegative();return G&&!Q?-1:!G&&Q?1:this.unsigned?L.high>>>0>this.high>>>0||L.high===this.high&&L.low>>>0>this.low>>>0?-1:1:this.sub(L).isNegative()?-1:1},R.comp=R.compare,R.negate=function(){return!this.unsigned&&this.eq($)?$:this.not().add(T)},R.neg=R.negate,R.add=function(L){t(L)||(L=c(L));var G=this.high>>>16,Q=this.high&65535,W=this.low>>>16,H=this.low&65535,J=L.high>>>16,ie=L.high&65535,V=L.low>>>16,Y=L.low&65535,B=0,K=0,se=0,te=0;return te+=H+Y,se+=te>>>16,te&=65535,se+=W+V,K+=se>>>16,se&=65535,K+=Q+ie,B+=K>>>16,K&=65535,B+=G+J,B&=65535,a(se<<16|te,B<<16|K,this.unsigned)},R.subtract=function(L){return t(L)||(L=c(L)),this.add(L.neg())},R.sub=R.subtract,R.multiply=function(L){if(this.isZero())return w;if(t(L)||(L=c(L)),n){var G=n.mul(this.low,this.high,L.low,L.high);return a(G,n.get_high(),this.unsigned)}if(L.isZero())return w;if(this.eq($))return L.isOdd()?$:w;if(L.eq($))return this.isOdd()?$:w;if(this.isNegative())return L.isNegative()?this.neg().mul(L.neg()):this.neg().mul(L).neg();if(L.isNegative())return this.mul(L.neg()).neg();if(this.lt(x)&&L.lt(x))return o(this.toNumber()*L.toNumber(),this.unsigned);var Q=this.high>>>16,W=this.high&65535,H=this.low>>>16,J=this.low&65535,ie=L.high>>>16,V=L.high&65535,Y=L.low>>>16,B=L.low&65535,K=0,se=0,te=0,ue=0;return ue+=J*B,te+=ue>>>16,ue&=65535,te+=H*B,se+=te>>>16,te&=65535,te+=J*Y,se+=te>>>16,te&=65535,se+=W*B,K+=se>>>16,se&=65535,se+=H*Y,K+=se>>>16,se&=65535,se+=J*V,K+=se>>>16,se&=65535,K+=Q*B+W*Y+H*V+J*ie,K&=65535,a(te<<16|ue,K<<16|se,this.unsigned)},R.mul=R.multiply,R.divide=function(L){if(t(L)||(L=c(L)),L.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&L.low===-1&&L.high===-1)return this;var G=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,L.low,L.high);return a(G,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?_:w;var Q,W,H;if(this.unsigned){if(L.unsigned||(L=L.toUnsigned()),L.gt(this))return _;if(L.gt(this.shru(1)))return C;H=_}else{if(this.eq($)){if(L.eq(T)||L.eq(N))return $;if(L.eq($))return T;var J=this.shr(1);return Q=J.div(L).shl(1),Q.eq(w)?L.isNegative()?T:N:(W=this.sub(L.mul(Q)),H=Q.add(W.div(L)),H)}else if(L.eq($))return this.unsigned?_:w;if(this.isNegative())return L.isNegative()?this.neg().div(L.neg()):this.neg().div(L).neg();if(L.isNegative())return this.div(L.neg()).neg();H=w}for(W=this;W.gte(L);){Q=Math.max(1,Math.floor(W.toNumber()/L.toNumber()));for(var ie=Math.ceil(Math.log(Q)/Math.LN2),V=ie<=48?1:l(2,ie-48),Y=o(Q),B=Y.mul(L);B.isNegative()||B.gt(W);)Q-=V,Y=o(Q,this.unsigned),B=Y.mul(L);Y.isZero()&&(Y=T),H=H.add(Y),W=W.sub(B)}return H},R.div=R.divide,R.modulo=function(L){if(t(L)||(L=c(L)),n){var G=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,L.low,L.high);return a(G,n.get_high(),this.unsigned)}return this.sub(this.div(L).mul(L))},R.mod=R.modulo,R.rem=R.modulo,R.not=function(){return a(~this.low,~this.high,this.unsigned)},R.and=function(L){return t(L)||(L=c(L)),a(this.low&L.low,this.high&L.high,this.unsigned)},R.or=function(L){return t(L)||(L=c(L)),a(this.low|L.low,this.high|L.high,this.unsigned)},R.xor=function(L){return t(L)||(L=c(L)),a(this.low^L.low,this.high^L.high,this.unsigned)},R.shiftLeft=function(L){return t(L)&&(L=L.toInt()),(L&=63)===0?this:L<32?a(this.low<<L,this.high<<L|this.low>>>32-L,this.unsigned):a(0,this.low<<L-32,this.unsigned)},R.shl=R.shiftLeft,R.shiftRight=function(L){return t(L)&&(L=L.toInt()),(L&=63)===0?this:L<32?a(this.low>>>L|this.high<<32-L,this.high>>L,this.unsigned):a(this.high>>L-32,this.high>=0?0:-1,this.unsigned)},R.shr=R.shiftRight,R.shiftRightUnsigned=function(L){if(t(L)&&(L=L.toInt()),L&=63,L===0)return this;var G=this.high;if(L<32){var Q=this.low;return a(Q>>>L|G<<32-L,G>>>L,this.unsigned)}else return L===32?a(G,0,this.unsigned):a(G>>>L-32,0,this.unsigned)},R.shru=R.shiftRightUnsigned,R.shr_u=R.shiftRightUnsigned,R.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},R.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},R.toBytes=function(L){return L?this.toBytesLE():this.toBytesBE()},R.toBytesLE=function(){var L=this.high,G=this.low;return[G&255,G>>>8&255,G>>>16&255,G>>>24,L&255,L>>>8&255,L>>>16&255,L>>>24]},R.toBytesBE=function(){var L=this.high,G=this.low;return[L>>>24,L>>>16&255,L>>>8&255,L&255,G>>>24,G>>>16&255,G>>>8&255,G&255]},e.fromBytes=function(L,G,Q){return Q?e.fromBytesLE(L,G):e.fromBytesBE(L,G)},e.fromBytesLE=function(L,G){return new e(L[0]|L[1]<<8|L[2]<<16|L[3]<<24,L[4]|L[5]<<8|L[6]<<16|L[7]<<24,G)},e.fromBytesBE=function(L,G){return new e(L[4]<<24|L[5]<<16|L[6]<<8|L[7],L[0]<<24|L[1]<<16|L[2]<<8|L[3],G)},BC}var kF=J7();const RF=Z0(kF),Q7=KW({__proto__:null,default:RF},[kF]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hf=RF||Q7;function v_(n){return hf.fromString(n,!0,16)}const DF=v_("c3a5c85c97cb3127"),uf=v_("b492b66fbe98f273"),Di=v_("9ae16a3b2f90404f");function a2(n){return n.xor(n.shru(47))}function PF(n,e,t){const s=n.slice(e,e+t);return hf.fromBytes(Array.from(s),!0,!0)}function hs(n,e){return PF(n,e,8)}function GD(n,e){return PF(n,e,4)}function Rr(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Ih(n,e,t=v_("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function eK(n,e,t,s,r,i){r=r.add(n),i=Rr(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),i=i.add(Rr(r,44)),[r.add(s),i.add(o)]}function bw(n,e,t,s){return eK(hs(n,e),hs(n,e+8),hs(n,e+16),hs(n,e+24),t,s)}function tK(n,e=n.length){if(e>=8){const t=Di.add(e*2),s=hs(n,0).add(Di),r=hs(n,e-8),i=Rr(r,37).mul(t).add(s),o=Rr(s,25).add(r).mul(t);return Ih(i,o,t)}if(e>=4){const t=Di.add(e*2),s=GD(n,0);return Ih(s.shl(3).add(e),GD(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),o=e+(r<<2);return a2(Di.mul(i).xor(DF.mul(o))).mul(Di)}return Di}function nK(n,e=n.length){const t=Di.add(e*2),s=hs(n,0).mul(uf),r=hs(n,8),i=hs(n,e-8).mul(t),o=hs(n,e-16).mul(Di);return Ih(Rr(s.add(r),43).add(Rr(i,30)).add(o),s.add(Rr(r.add(Di),18)).add(i),t)}function sK(n,e=n.length){const t=Di.add(e*2),s=hs(n,0).mul(Di),r=hs(n,8),i=hs(n,e-8).mul(t),o=hs(n,e-16).mul(Di),a=Rr(s.add(r),43).add(Rr(i,30)).add(o),l=Ih(a,s.add(Rr(r.add(Di),18)).add(i),t),u=hs(n,16).mul(t),c=hs(n,24),h=a.add(hs(n,e-32)).mul(t),f=l.add(hs(n,e-24)).mul(t);return Ih(Rr(u.add(c),43).add(Rr(h,30)).add(f),u.add(Rr(c.add(s),18)).add(h),t)}function rK(n,e=n.length){const t=hf.fromNumber(81,!0);if(e<=32)return e<=16?tK(n,e):nK(n,e);if(e<=64)return sK(n,e);let s=t,r=t.mul(uf).add(113),i=a2(r.mul(Di).add(113)).mul(Di),o=[hf.UZERO,hf.UZERO],a=[hf.UZERO,hf.UZERO];s=s.mul(Di).add(hs(n,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do s=Rr(s.add(r).add(o[0]).add(hs(n,l+8)),37).mul(uf),r=Rr(r.add(o[1]).add(hs(n,l+48)),42).mul(uf),s=s.xor(a[1]),r=r.add(o[0]).add(hs(n,l+40)),i=Rr(i.add(a[0]),33).mul(uf),o=bw(n,l,o[1].mul(uf),s.add(a[0])),a=bw(n,l+32,i.add(a[1]),r.add(hs(n,l+16))),[i,s]=[s,i],l+=64;while(l!==u);const h=uf.add(i.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=Rr(s.add(r).add(o[0]).add(hs(n,l+8)),37).mul(h),r=Rr(r.add(o[1]).add(hs(n,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(hs(n,l+40))),i=Rr(i.add(a[0]),33).mul(h),o=bw(n,l,o[1].mul(h),s.add(a[0])),a=bw(n,l+32,i.add(a[1]),r.add(hs(n,l+16))),[i,s]=[s,i],Ih(Ih(o[0],a[0],h).add(a2(r).mul(DF)).add(i),Ih(o[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(n,e){return e==="string"?Nh(n):Kf([n],e)}function iK(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Kf(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Lf(n)),Te().getBool("DEBUG")&&O7(n,e),iK(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Ji(){return Te().platform.now()}function oK(n,e){return Te().platform.fetch(n,e)}function Nh(n,e="utf-8"){return e=e||"utf-8",Te().platform.encode(n,e)}function Ph(n,e="utf-8"){return e=e||"utf-8",Te().platform.decode(n,e)}function Pa(n){return Te().platform.isTypedArray!=null?Te().platform.isTypedArray(n):MF(n)}function Lf(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Pf(n)||n==null||Pa(n)&&t)e.push(n);else if(Array.isArray(n)||Pa(n))for(let s=0;s<n.length;++s)Lf(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Lf(n[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aK{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new uK)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let o;const a=Ji();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const u of r)u.dataSync();o=Promise.resolve({kernelMs:Ji()-a})}if(Te().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(h=>{lK(h,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function lK(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class uK{logKernelProfile(e,t,s,r,i,o){const a=typeof r=="number"?Ym(`${r}ms`,9):r.error,l=Ym(e,25),u=t.rank,c=t.size,h=Ym(t.shape.toString(),14);let f="";for(const p in i){const g=i[p];if(g!=null){const S=g.shape||t.shape,x=S.length;f+=`${p}: ${x}D ${x>0?S:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cK(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const f=c[h];let p=!1;for(let g=0;g<e.length;g++)if(s[f.id]){u.outputs.forEach(S=>s[S.id]=!0),p=!0,r[u.id]=!0;break}if(p)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(i[u.outputs[h].id]){for(const f in c)i[c[f].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&o[u.id]){const c={};for(const f in u.inputs){const p=u.inputs[f];s[p.id]&&(c[f]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function hK(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(l=>{const u=n[l.id];u!=null?o.push(u):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=i.inputs[l];if(!Mn(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=s(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HD=20,Zy=3,VC=7;function dK(n,e,t,s){const r=Wt(e),i=fK(n,e,t,r),o=e.length,a=jw(n,e,t,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function fK(n,e,t,s){const r=Oe(e),i=s[s.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?s0(n):n;if(a>1)for(let u=0;u<r/i;u++){const c=u*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],n0(l[c+h],0,t).length)}return o}function n0(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(VC))} + ${parseFloat(n[1].toFixed(VC))}j`:dx(n)?s=`'${n}'`:t==="bool"?s=LF(n):s=parseFloat(n.toFixed(VC)).toString(),Ym(s,e)}function LF(n){return n===0?"false":"true"}function jw(n,e,t,s,r,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const S=s0(n);return[n0(S[0],0,t)]}return t==="bool"?[LF(n[0])]:[n[0].toString()]}if(l===1){if(a>HD){const x=Zy*o;let w=Array.from(n.slice(0,x)),_=Array.from(n.slice((a-Zy)*o,a*o));return t==="complex64"&&(w=s0(w),_=s0(_)),["["+w.map((T,C)=>n0(T,r[C],t)).join(", ")+", ..., "+_.map((T,C)=>n0(T,r[a-Zy+C],t)).join(", ")+"]"]}return["["+(t==="complex64"?s0(n):Array.from(n)).map((x,w)=>n0(x,r[w],t)).join(", ")+"]"]}const u=e.slice(1),c=s.slice(1),h=s[0]*o,f=[];if(a>HD){for(let S=0;S<Zy;S++){const x=S*h,w=x+h;f.push(...jw(n.slice(x,w),u,t,c,r,!1))}f.push("...");for(let S=a-Zy;S<a;S++){const x=S*h,w=x+h;f.push(...jw(n.slice(x,w),u,t,c,r,S===a-1))}}else for(let S=0;S<a;S++){const x=S*h,w=x+h;f.push(...jw(n.slice(x,w),u,t,c,r,S===a-1))}const p=l===2?",":"";f[0]="["+(a>0?f[0]+p:"");for(let S=1;S<f.length-1;S++)f[S]=" "+f[S]+p;let g=`,
`;for(let S=2;S<l;S++)g+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":g),f}function s0(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wr{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Oe(e),s!=null){const r=s.length;q(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Gs(t,this.size),this.strides=Wt(e)}set(e,...t){t.length===0&&(t=[0]),q(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return gl().makeTensor(this.values,this.shape,this.dtype)}}let gl=null,Um=null;function pK(n){gl=n}function mK(n){Um=n}class gs{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Oe(e),this.strides=Wt(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Um.buffer(this.shape,this.dtype,e)}bufferSync(){return Um.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Ra(this.shape,e,this.dtype==="complex64")}arraySync(){return Ra(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=gl().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Ph(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),gl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=gl().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ph(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await gl().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),gl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Um.print(this,e)}clone(){return this.throwIfDisposed(),Um.clone(this)}toString(e=!1){const t=this.dataSync();return dK(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Um.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),gl().makeVariable(this,e,t,s)}}Object.defineProperty(gs,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Ue(){return HI("Tensor",()=>gs)}Ue();class xS extends gs{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Mn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);gl().disposeTensor(this),this.dataId=e.dataId,gl().incRef(this,null)}dispose(){gl().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(xS,Symbol.hasInstance,{value:n=>n instanceof gs&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jD;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(jD||(jD={}));var l2;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(l2||(l2={}));var u2;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(u2||(u2={}));var c2;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(c2||(c2={}));var h2;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(h2||(h2={}));const gK={float32:c2,int32:l2,bool:u2,complex64:h2};function Lo(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return gK[n][e]}function YN(n){return Lo(n,"int32")}function OF(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function FF(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(n,e){if(n.dtype===e.dtype)return[n,e];const t=Lo(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function yK(n,e){q(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function $F(n){const e=[];return zF(n,e,new Set),e}function zF(n,e,t){if(n==null)return;if(n instanceof gs){e.push(n);return}if(!xK(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),zF(i,e,t))}}function xK(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n){return n.kernelName!=null}class XD{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class hg{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new XD}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(ra(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new aK(this.backendInstance),!0}setupRegisteredKernels(){VD(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){VD(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof VI)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ra(`Initialization of backend ${e} failed`),ra(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return ra(`Initialization of backend ${e} failed`),ra(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return hg.nextTensorId++}nextVariableId(){return hg.nextVariableId++}clone(e){const t=he.runKernel(Dx,{x:e}),s={x:e},r=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return he.runKernel(wx,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(o2(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=WC(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(WC(e)){const{kernelName:g,inputs:S,attrs:x}=e;this.backendName==null&&this.backend;const w=o2(g,this.backendName);q(w!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const _=this.backend.numDataIds();l=w.kernelFunc({inputs:S,attrs:x,backend:this.backend});const T=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,_,T);const C=T.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(r){const N=this.getTensorsForGradient(g,S,C);s=this.saveTensorsForBackwardMode(N)}return C}}else{const{forwardFunc:g}=e,S=x=>{r&&(s=x.map(w=>this.keep(this.clone(w))))};a=()=>{const x=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,S));const w=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,x,w),w}}const{inputs:c,attrs:h}=e,f=WC(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(u,c,t,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=BD(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(q(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=i.map(u=>t[u]);const l=s.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&dx(e[0])&&(i=e.map(l=>Nh(l)));const o=r.write(i,t,s),a=new gs(t,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),u=$7(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,o=new gs(r,i,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new xS(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*fS(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof xS||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*fS(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},l=BD(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const f=s[h],p=gi(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return c}),r(u.length>1?u:u[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=$F(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(q(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));q(i instanceof gs,()=>"The result y returned by f() must be a tensor.");const o=cK(this.state.activeTape,t,i);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s??vK(i.shape),hK(a,o,u=>this.tidy(u),wK);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return q(e2(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{q(t.every(a=>a instanceof gs),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=e(...t,l),q(s.value instanceof gs,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),q(e2(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const u=s.gradFunc(a,l),c=Array.isArray(u)?u:[u];q(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),q(c.every(f=>f instanceof gs),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((f,p)=>{h[p]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Ji(),s=await this.backend.time(e);return s.wallMs=Ji()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new XD;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}hg.nextTensorId=0;hg.nextVariableId=0;function vK(n){const e=GI(Oe(n),"float32");return he.makeTensor(e,n,"float32")}function UF(){const n=IF();if(n._tfengine==null){const e=new B7(n);n._tfengine=new hg(e)}return H7(n._tfengine.ENV),pK(()=>n._tfengine),n._tfengine}const he=UF();function wK(n,e){const t={a:n,b:e};return he.runKernel(Pg,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SK(){return typeof navigator<"u"&&navigator!=null}function BF(n){if(n||SK()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function VF(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro=Te();ro.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ro.registerFlag("IS_BROWSER",()=>VF());ro.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ro.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ro.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ro.registerFlag("PROD",()=>!1);ro.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ro.getBool("DEBUG"));ro.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ro.registerFlag("IS_TEST",()=>!1);ro.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ro.getBool("DEBUG"));ro.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ro.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ro.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ed(n,e){let t=n;if(Pa(n))return e==="string"?[]:[n.length];if(OF(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(FF(n))return[n.buffer.size/(e==null?4:fS(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Pa(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&Te().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&WF(n,s,[]),s}function WF(n,e,t){if(t=t||[],!Array.isArray(n)&&!Pa(n)){q(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}q(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),q(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)WF(n[r],s,t.concat(r))}function qD(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function Z(n,e,t,s="numeric"){if(n instanceof Ue())return qD(s,n.dtype,e,t),n;let r=Rg(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),qD(s,r,e,t),n==null||!Pa(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=ed(n,r);!Pa(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?Kf(n,r):Lf(n,[],!0);return he.makeTensor(a,i,r)}function vS(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>Z(i,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GF="__op";function ce(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+GF;const r=(...i)=>{he.startScope(t);try{const o=s(...i);return Pf(o)&&console.error("Cannot return a Promise inside of tidy."),he.endScope(o),o}catch(o){throw he.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(n,e){const t=Z(n,"real","complex"),s=Z(e,"imag","complex");Vo(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return he.runKernel(JI,r)}const Lh=ce({complex_:bK});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function td(n,e,t,s){if(s==null)s=Rg(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(FF(n)||OF(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return he.backend.createTensorFromGPUData(n,e||t,s)}if(!Pa(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){ua(e);const r=Oe(e),i=Oe(t);q(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Oe(e.slice(o)):!0;q(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Pa(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Kf(n,s):Lf(n,[],!0),he.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(n,e,t){const s=ed(n,t);return td(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Of={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class kl{static join(e){return new kl(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>Pa(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),o=new Uint8Array(i);let a=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],h=e+a-u.start,f=a,g=Math.min(t,u.end)-u.start,S=new Uint8Array(u.buffer,h,g-h);if(o.set(S,f),a+=S.length,t<u.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=_K(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function _K(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(){return he}function KD(){return he.memory()}function be(n,e){return he.tidy(n,e)}function Tn(n){$F(n).forEach(t=>t.dispose())}function Pr(n){return he.keep(n)}function TK(){return he.ready()}function ZN(){return he.backendName}function HF(n,e,t=1){return he.registerBackend(n,e,t)}function jF(){return he.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oh=4;async function d2(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const a=r[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const f=await l.bytes(),p=f.reduce((x,w)=>x+w.length,0)+Oh*f.length,g=new Uint8Array(p);let S=0;for(let x=0;x<f.length;x++){const w=f[x],_=new Uint8Array(new Uint32Array([w.length]).buffer);g.set(_,S),S+=Oh,g.set(w,S),S+=w.length}h(g)});s.push(c)}else s.push(l.data());e!=null&&(u.group=e),t.push(u)}const i=await Promise.all(s);return{data:IK(i),specs:t}}function XF(n,e){const t=new kl(n),s={};let r=0;for(const i of e){const o=CK(i,(a,l)=>t.slice(r+a,r+l));s[i.name]=qF(i,t.slice(r,r+o)),r+=o}return s}function CK(n,e){const t=Oe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Of[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Oh+new Uint32Array(e(r,r+Oh))[0];return r}else s=Of[n.dtype];return t*s}async function EK(n,e){const t=Oe(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Of[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Oh+new Uint32Array(await e(r,r+Oh))[0];return r}else s=Of[n.dtype];return t*s}function qF(n,e){const t=n.name,s=n.dtype,r=n.shape,i=Oe(r);let o,a=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=Of[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(c.length);for(let h=0;h<c.length;h++){const f=c[h];o[h]=f*l.scale+l.min}}else if(l.dtype==="float16")o=DK()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(c.length);for(let h=0;h<c.length;h++){const f=c[h];o[h]=Math.round(f*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=i*u}else if(s==="string"){const l=Oe(n.shape);o=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(a,a+Oh))[0];a+=Oh;const h=new Uint8Array(e.slice(a,a+c));o.push(h),a+=c}}else{const l=Of[s];if(s==="float32")o=new Float32Array(e);else if(s==="int32")o=new Int32Array(e);else if(s==="bool")o=new Uint8Array(e);else if(s==="complex64"){o=new Float32Array(e);const u=new Float32Array(o.length/2),c=new Float32Array(o.length/2);for(let g=0;g<u.length;g++)u[g]=o[g*2],c[g]=o[g*2+1];const h=wl(u,r,"float32"),f=wl(c,r,"float32"),p=Lh(h,f);return h.dispose(),f.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);a+=i*l}return wl(o,r,s)}async function YD(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:i}=await n.read();if(r&&i==null){const a=t-s.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const o=new Uint8Array(s.length+i.byteLength);o.set(s,0),o.set(new Uint8Array(i),s.length),s=o}return s.buffer}async function KF(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of e){const o=await EK(i,async(u,c)=>(r=await YD(s,r,c),r.slice(u,c)));r=await YD(s,r,o);const a=r.slice(0,o);r=r.slice(o);const l=qF(i,a);if(t[i.name]=l,ZN()==="webgpu"){const u=jF();"uploadToGPU"in u&&Oe(l.shape)>=Te().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}function IK(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const JN=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function ZD(n){return JN?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function NK(n){if(JN)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function AK(n){if(JN){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function YF(n){return kl.join(n)}function JD(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function ZF(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function JF(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function QN(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),JF(n,t,s)}function lv(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:ZD(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:ZD(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new kl(n.weightData).byteLength}}function f2(n){const e=[];for(const t of n)e.push(...t.weights);return e}function MK(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function kK(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function RK(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function DK(){const n=MK(),e=kK(),t=RK();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const a=s[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class As{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return As.instance==null&&(As.instance=new As),As.instance}static registerSaveRouter(e){As.getInstance().saveRouters.push(e)}static registerLoadRouter(e){As.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return As.getHandlers(e,"save")}static getLoadHandlers(e,t){return As.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?As.getInstance().loadRouters:As.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&r.push(a)}),r}}const PK=n=>As.registerSaveRouter(n),LK=n=>As.registerLoadRouter(n),QF=n=>As.getSaveHandlers(n),OK=(n,e)=>As.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2="tensorflowjs",m2=1,wf="models_store",Sh="model_info_store";function e$(){if(!Te().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function g2(n){const e=n.result;e.createObjectStore(wf,{keyPath:"modelPath"}),e.createObjectStore(Sh,{keyPath:"modelPath"})}class Ff{constructor(e){if(this.indexedDB=e$(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(p2,m2);i.onupgradeneeded=()=>g2(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(wf,"readonly"),u=a.objectStore(wf).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=c=>(o.close(),r(u.error)),a.oncomplete=()=>o.close()}else{t.weightData=kl.join(t.weightData);const a=lv(t),l=o.transaction(Sh,"readwrite");let u=l.objectStore(Sh),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return r(f)}let h;c.onsuccess=()=>{h=o.transaction(wf,"readwrite");const f=h.objectStore(wf);let p;try{p=f.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(g){return r(g)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=g=>{u=l.objectStore(Sh);const S=u.delete(this.modelPath);S.onsuccess=()=>(o.close(),r(p.error)),S.onerror=x=>(o.close(),r(p.error))}},c.onerror=f=>(o.close(),r(c.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Ff.URL_SCHEME="indexeddb://";const t$=n=>Te().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ff.URL_SCHEME)?FK(n.slice(Ff.URL_SCHEME.length)):null;As.registerSaveRouter(t$);As.registerLoadRouter(t$);function FK(n){return new Ff(n)}function $K(n){return n.startsWith(Ff.URL_SCHEME)?n.slice(Ff.URL_SCHEME.length):n}class zK{constructor(){this.indexedDB=e$()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(p2,m2);s.onupgradeneeded=()=>g2(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Sh,"readonly"),a=i.objectStore(Sh).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),t(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=$K(e),new Promise((t,s)=>{const r=this.indexedDB.open(p2,m2);r.onupgradeneeded=()=>g2(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Sh,"readwrite"),a=o.objectStore(Sh),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=i.transaction(wf,"readwrite");const p=u.objectStore(wf).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=g=>s(l.error)};c.onsuccess=h,c.onerror=f=>(h(),i.close(),s(l.error))}},l.onerror=c=>(i.close(),s(l.error)),o.oncomplete=()=>{u==null?i.close():u.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rc="/",Bm="tensorflowjs_models",n$="info",UK="model_topology",BK="weight_specs",VK="weight_data",WK="model_metadata";function s$(n){return{info:[Bm,n,n$].join(rc),topology:[Bm,n,UK].join(rc),weightSpecs:[Bm,n,BK].join(rc),weightData:[Bm,n,VK].join(rc),modelMetadata:[Bm,n,WK].join(rc)}}function r$(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function GK(n){const e=n.split(rc);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(rc)}function HK(n){return n.startsWith($f.URL_SCHEME)?n.slice($f.URL_SCHEME.length):n}class $f{constructor(e){if(!Te().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=s$(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=lv(e),i=kl.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,NK(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw r$(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=AK(o),t}}$f.URL_SCHEME="localstorage://";const i$=n=>Te().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith($f.URL_SCHEME)?jK(n.slice($f.URL_SCHEME.length)):null;As.registerSaveRouter(i$);As.registerLoadRouter(i$);function jK(n){return new $f(n)}class XK{constructor(){q(Te().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),q(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Bm+rc,s=rc+n$;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const o=GK(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=HK(e);const t=s$(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return r$(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jm="://";class Ri{constructor(){this.managers={}}static getInstance(){return Ri.instance==null&&(Ri.instance=new Ri),Ri.instance}static registerManager(e,t){q(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Jm)&&(e=e.slice(0,e.indexOf(Jm))),q(e.length>0,()=>"scheme must not be an empty string.");const s=Ri.getInstance();q(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=Ri.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ri.getInstance().managers)}}function Xw(n){if(n.indexOf(Jm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ri.getSchemes().join(",")}`);return{scheme:n.split(Jm)[0],path:n.split(Jm)[1]}}async function o$(n,e,t=!1){q(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=As.getLoadHandlers(n);q(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),q(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=As.getSaveHandlers(e);q(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),q(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const o=i[0],a=Xw(n).scheme,l=Xw(n).path,u=a===Xw(n).scheme,c=await r.load();t&&u&&await Ri.getManager(a).removeModel(l);const h=await o.save(c);return t&&!u&&await Ri.getManager(a).removeModel(l),h.modelArtifactsInfo}async function qK(){const n=Ri.getSchemes(),e={};for(const t of n){const s=await Ri.getManager(t).listModels();for(const r in s){const i=t+Jm+r;e[i]=s[r]}}return e}async function KK(n){const e=Xw(n);return Ri.getManager(e.scheme).removeModel(e.path)}async function YK(n,e){return o$(n,e,!1)}async function ZK(n,e){return o$(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JK{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Te().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return MF(e)}}if(Te().get("IS_BROWSER")){Te().setPlatform("browser",new JK);try{Ri.registerManager($f.URL_SCHEME,new XK)}catch{}try{Ri.registerManager(Ff.URL_SCHEME,new zK)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QK={importFetch:()=>require("node-fetch")};let GC;class eY{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Te().global.fetch!=null?Te().global.fetch(e,t):(GC==null&&(GC=QK.importFetch()),GC(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Te().get("IS_NODE")&&!Te().get("IS_BROWSER")&&Te().setPlatform("node",new eY);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(n,e="float32",t){return e=e||"float32",ua(n),new wr(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(n,e){const t=Z(n,"x","cast");if(!F7(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return he.runKernel(wx,s,r)}const gt=ce({cast_:tY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nY(n){const t={x:Z(n,"x","clone","string_or_numeric")};return he.runKernel(Dx,t)}const uc=ce({clone_:nY});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */UF();const sY={buffer:yn,cast:gt,clone:uc,print:a$};mK(sY);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(n,e){let t=Z(n,"a","add"),s=Z(e,"b","add");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(Pg,r)}const Ze=ce({add_:rY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iY(n,e){let t=Z(n,"a","floorDiv"),s=Z(e,"b","floorDiv");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(kx,r)}const eA=ce({floorDiv_:iY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oY(n,e){let t=Z(n,"a","div"),s=Z(e,"b","div");if([t,s]=zs(t,s),t.dtype==="int32"&&s.dtype==="int32")return eA(t,s);const r={a:t,b:s},i={};return he.runKernel(Cx,r,i)}const Rt=ce({div_:oY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(n,e){let t=Z(n,"a","mul"),s=Z(e,"b","mul");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(Vx,r)}const de=ce({mul_:aY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(n){const e=Z(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return he.runKernel(Cb,t)}else{const t={x:e};return he.runKernel(gb,t)}}const gr=ce({abs_:lY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uY(n){const t={x:Z(n,"x","acos")};return he.runKernel(fx,t)}const l$=ce({acos_:uY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(n){const t={x:Z(n,"x","acosh")};return he.runKernel(px,t)}const u$=ce({acosh_:cY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(n){q(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),q(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>Z(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Mn(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return he.runKernel(yb,s)}const dY=ce({addN_:hY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fY(n,e=null,t=!1){const r={x:Z(n,"x","all","bool")},i={axis:e,keepDims:t};return he.runKernel(jI,r,i)}const tA=ce({all_:fY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pY(n,e=null,t=!1){const r={x:Z(n,"x","any","bool")},i={axis:e,keepDims:t};return he.runKernel(XI,r,i)}const wS=ce({any_:pY});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mY(n,e=0){const s={x:Z(n,"x","argMax")},r={axis:e};return he.runKernel(xb,s,r)}const dg=ce({argMax_:mY});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gY(n,e=0){const s={x:Z(n,"x","argMin")},r={axis:e};return he.runKernel(vb,s,r)}const c$=ce({argMin_:gY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yY(n){const t={x:Z(n,"x","asin")};return he.runKernel(mx,t)}const h$=ce({asin_:yY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xY(n){const t={x:Z(n,"x","asinh")};return he.runKernel(gx,t)}const d$=ce({asinh_:xY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vY(n){const t={x:Z(n,"x","atan")};return he.runKernel(yx,t)}const f$=ce({atan_:vY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wY(n,e){let t=Z(n,"a","atan2"),s=Z(e,"b","atan2");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(vx,r)}const p$=ce({atan2_:wY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SY(n){const t={x:Z(n,"x","atanh")};return he.runKernel(xx,t)}const m$=ce({atanh_:SY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uv(n,e,t,s,r="NHWC",i){const o=n[3],a=[...e,o],l=Sc(r);return $r(n,a,t,i,s,null,null,l)}function Fa(n,e,t,s,r,i,o="channelsLast"){const[a,l]=O0(e);let u;if(o==="channelsLast")u=[a,l,n[3],n[3]];else if(o==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return $r(n,u,t,s,r,i,!1,o)}function wc(n,e,t,s,r,i,o="NDHWC"){const[a,l,u]=y2(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[a,l,u,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",c=[a,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return nd(n,c,t,s,r,!1,h,i)}function $r(n,e,t,s,r,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=n;else if(a==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[f,p,,g]=e,[S,x]=O0(t),[w,_]=O0(s),T=Qm(f,w),C=Qm(p,_),{padInfo:N,outHeight:M,outWidth:P}=TY(r,u,c,S,x,T,C,i,a),$=o?g*h:g;let R;return a==="channelsFirst"?R=[l,$,M,P]:a==="channelsLast"&&(R=[l,M,P,$]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:M,outWidth:P,outChannels:$,padInfo:N,strideHeight:S,strideWidth:x,filterHeight:f,filterWidth:p,effectiveFilterHeight:T,effectiveFilterWidth:C,dilationHeight:w,dilationWidth:_,inShape:n,outShape:R,filterShape:e}}function nd(n,e,t,s,r,i=!1,o="channelsLast",a){let[l,u,c,h,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h,f]=n;else if(o==="channelsFirst")[l,f,u,c,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,S,,x]=e,[w,_,T]=y2(t),[C,N,M]=y2(s),P=Qm(p,C),$=Qm(g,N),R=Qm(S,M),{padInfo:D,outDepth:L,outHeight:G,outWidth:Q}=CY(r,u,c,h,w,_,T,P,$,R,a),W=i?x*f:x;let H;return o==="channelsFirst"?H=[l,W,L,G,Q]:o==="channelsLast"&&(H=[l,L,G,Q,W]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:f,outDepth:L,outHeight:G,outWidth:Q,outChannels:W,padInfo:D,strideDepth:w,strideHeight:_,strideWidth:T,filterDepth:p,filterHeight:g,filterWidth:S,effectiveFilterDepth:P,effectiveFilterHeight:$,effectiveFilterWidth:R,dilationDepth:C,dilationHeight:N,dilationWidth:M,inShape:n,outShape:H,filterShape:e}}function bY(n,e,t,s,r){s==null&&(s=nA(n,e,t));const i=n[0],o=n[1],a=F0((i-e+2*s)/t+1,r),l=F0((o-e+2*s)/t+1,r);return[a,l]}function _Y(n,e,t,s,r,i){r==null&&(r=nA(n,e[0],s[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*r>=e[a]&&(o[a]=F0((n[a]-e[a]+2*r)/s[a]+1,i));return o}function nA(n,e,t,s=1){const r=Qm(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function O0(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function y2(n){return typeof n=="number"?[n,n,n]:n}function Qm(n,e){return e<=1?n:n+(n-1)*(e-1)}function TY(n,e,t,s,r,i,o,a,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=bY([e,t],i,s,n,a);c=p[0],h=p[1]}else if(n==="same"){c=Math.ceil(e/s),h=Math.ceil(t/r);const f=Math.max(0,(c-1)*s+i-e),p=Math.max(0,(h-1)*r+o-t),g=Math.floor(f/2),S=f-g,x=Math.floor(p/2),w=p-x;u={top:g,bottom:S,left:x,right:w,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/s),h=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const f=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],g=l==="channelsLast"?n[2][0]:n[3][0],S=l==="channelsLast"?n[2][1]:n[3][1];u={top:f,bottom:p,left:g,right:S,type:f===0&&p===0&&g===0&&S===0?"VALID":"EXPLICIT"},c=F0((e-i+f+p)/s+1,a),h=F0((t-o+g+S)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function CY(n,e,t,s,r,i,o,a,l,u,c){let h,f,p,g;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const x=_Y([e,t,s,1],[a,l,u],1,[r,i,o],n,c);f=x[0],p=x[1],g=x[2]}else if(n==="same"){f=Math.ceil(e/r),p=Math.ceil(t/i),g=Math.ceil(s/o);const S=(f-1)*r+a-e,x=(p-1)*i+l-t,w=(g-1)*o+u-s,_=Math.floor(S/2),T=S-_,C=Math.floor(x/2),N=x-C,M=Math.floor(w/2),P=w-M;h={top:C,bottom:N,left:M,right:P,front:_,back:T,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:f,outHeight:p,outWidth:g}}function F0(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Fh(n){const[e,t,s]=O0(n);return e===1&&t===1&&s===1}function Zr(n,e){return Fh(n)||Fh(e)}function zf(n){return O0(n).every(e=>e>0)}function Sc(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function zi(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")q(cg(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{q(cg(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EY(n,e){const s={x:Z(n,"x","reshape","string_or_numeric")},r={shape:e};return he.runKernel(i_,s,r)}const pe=ce({reshape_:EY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IY(n,e,t,s,r){const i=Z(n,"x","avgPool","float32"),o=1;q(Zr(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),q(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),zi("avgPool",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let h=he.runKernel(wb,u,c);return h=gt(h,i.dtype),l?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const w_=ce({avgPool_:IY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NY(n,e,t,s,r,i="NDHWC"){const o=Z(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),q(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),q(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),q(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),zi("avgPool3d",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let h=he.runKernel(Sb,u,c);return h=gt(h,a.dtype),l?pe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const g$=ce({avgPool3d_:NY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AY(n,e=0){q(n.length>=1,()=>"Pass at least one tensor to concat");const t=vS(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return uc(t[0]);const s=t,r={axis:e};return he.runKernel(Eb,s,r)}const ir=ce({concat_:AY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MY(n,e,t=!1,s=!1){let r=Z(n,"a","matMul"),i=Z(e,"b","matMul");[r,i]=zs(r,i);const o={a:r,b:i},a={transposeA:t,transposeB:s};return he.runKernel(bb,o,a)}const In=ce({matMul_:MY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(n){const t={x:Z(n,"x","sigmoid","float32")};return he.runKernel(Qx,t)}const Sl=ce({sigmoid_:kY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RY(n,e,t){const s=Z(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return he.runKernel(c_,r,i)}const mn=ce({slice_:RY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DY(n){const t={x:Z(n,"x","tanh","float32")};return he.runKernel(iv,t)}const fg=ce({tanh_:DY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PY(n,e,t,s,r,i){const o=Z(n,"forgetBias","basicLSTMCell"),a=Z(e,"lstmKernel","basicLSTMCell"),l=Z(t,"lstmBias","basicLSTMCell"),u=Z(s,"data","basicLSTMCell"),c=Z(r,"c","basicLSTMCell"),h=Z(i,"h","basicLSTMCell"),f=ir([u,h],1),p=In(f,a),g=Ze(p,l),S=g.shape[0],x=g.shape[1]/4,w=[S,x],_=mn(g,[0,0],w),T=mn(g,[0,x],w),C=mn(g,[0,x*2],w),N=mn(g,[0,x*3],w),M=Ze(de(Sl(_),fg(T)),de(c,Sl(Ze(o,C)))),P=de(fg(M),Sl(N));return[M,P]}const LY=ce({basicLSTMCell_:PY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OY(n,e,t){const s=Z(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);q(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),q(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),q(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:t};return he.runKernel(_b,i,o)}const S_=ce({batchToSpaceND_:OY});function FY(n){let e;return n.rank===0||n.rank===1?e=pe(n,[1,1,1,n.size]):n.rank===2?e=pe(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=pe(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Y(n,e,t,s,r,i){i==null&&(i=.001);const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let u;r!=null&&(u=Z(r,"scale","batchNorm"));let c;s!=null&&(c=Z(s,"offset","batchNorm")),q(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:FY(o),scale:u,offset:c,mean:a,variance:l},p={varianceEpsilon:i},g=he.runKernel(Lb,f,p);return pe(g,o.shape)}const cv=ce({batchNorm_:$Y});function zY(n,e,t,s,r,i){const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let u;r!=null&&(u=Z(r,"scale","batchNorm"));let c;return s!=null&&(c=Z(s,"offset","batchNorm")),q(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),q(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),q(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),cv(o,a,l,c,u,i)}const y$=ce({batchNorm2d_:zY});function UY(n,e,t,s,r,i){const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let u;r!=null&&(u=Z(r,"scale","batchNorm"));let c;return s!=null&&(c=Z(s,"offset","batchNorm")),q(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),q(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),q(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),cv(o,a,l,c,u,i)}const x$=ce({batchNorm3d_:UY});function BY(n,e,t,s,r,i){const o=Z(n,"x","batchNorm"),a=Z(e,"mean","batchNorm"),l=Z(t,"variance","batchNorm");let u;r!=null&&(u=Z(r,"scale","batchNorm"));let c;return s!=null&&(c=Z(s,"offset","batchNorm")),q(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),q(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),q(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&q(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&q(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),cv(o,a,l,c,u,i)}const v$=ce({batchNorm4d_:BY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VY(n,e,t){const s=Z(n,"x","bincount"),r=Z(e,"weights","bincount");q(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),q(t>=0,()=>`size must be non-negative, but got ${t}.`),q(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:t};return he.runKernel(YI,i,o)}const w$=ce({bincount_:VY});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WY(n,e){const t=Z(n,"x","bitwiseAnd"),s=Z(e,"y","bitwiseAnd");if(!Mn(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return he.runKernel(Tb,r)}const GY=ce({bitwiseAnd_:WY});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HY(n,e){const t=Z(n,"s0","broadcastArgs","int32"),s=Z(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return he.runKernel(ZI,r)}const jY=ce({broadcastArgs_:HY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XY(n,e){let t=Z(n,"broadcastTo","x");const s=t.shape;if(ua(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=pe(t,u)}const r=t.shape,i=Array.from(e);for(let u=e.length-1;u>=0;u--)if(r[u]===e[u])i[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return uc(t);const a={x:t},l={reps:i};return he.runKernel(ov,a,l)}const eg=ce({broadcastTo_:XY});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qY(n){const t={x:Z(n,"x","ceil","float32")};return he.runKernel(Sx,t)}const S$=ce({ceil_:qY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lg(n,e,t){ua(n),t=t||Rg(e);const s={shape:n,value:e,dtype:t};return he.runKernel(dN,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KY(n,e,t){const s=Z(n,"x","clipByValue");if(q(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Lg(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return he.runKernel(bx,r,i)}const Oo=ce({clipByValue_:KY});function YY(n){return ir(n,0)}const b$=ce({concat1d_:YY});function ZY(n,e){return ir(n,e)}const sA=ce({concat2d_:ZY});function JY(n,e){return ir(n,e)}const _$=ce({concat3d_:JY});function QY(n,e){return ir(n,e)}const T$=ce({concat4d_:QY});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZ(n,e,t,s,r="NHWC",i=[1,1],o){const a=Z(n,"x","conv2d","float32"),l=Z(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),q(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),q(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),zi("conv2d",s,o);const h=r==="NHWC"?u.shape[3]:u.shape[1];q(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),q(Zr(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),q(zf(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),q(zf(t),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},g=he.runKernel(Ib,f,p);return c?pe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const $h=ce({conv2d_:eZ});function tZ(n,e,t,s,r="NWC",i=1,o){const a=Z(n,"x","conv1d"),l=Z(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=pe(a,[1,a.shape[0],a.shape[1]])),q(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),q(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),zi("conv1d",s,o),q(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),q(Zr(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),q(zf(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),q(zf(t),()=>"Error in conv1D: Stride should be larger than 0."),q(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=pe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=pe(u,[u.shape[0],1,u.shape[1],u.shape[2]]),x=$h(f,h,[1,t],s,"NHWC",[1,i],o);return c?pe(x,[x.shape[2],x.shape[3]]):pe(x,[x.shape[0],x.shape[2],x.shape[3]])}const rA=ce({conv1d_:tZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(n,e,t,s,r,i="NHWC",o){q(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,u=!1;e.rank===3&&(u=!0,l=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),q(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),q(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),q(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];q(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),q(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),zi("conv2dDerInput",r,o);const f={dy:l,filter:t},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},g=he.runKernel(Nb,f,p);return u?pe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const iA=ce({conv2DBackpropInput_:nZ});function sZ(n,e,t,s,r,i){const o=Z(n,"x","conv2dTranspose"),a=Z(e,"filter","conv2dTranspose");return iA(t,o,a,s,r,"NHWC",i)}const oA=ce({conv2dTranspose_:sZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(n,e,t,s,r="NDHWC",i=[1,1,1]){const o=Z(n,"x","conv3d"),a=Z(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),q(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),q(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),q(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),q(Zr(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),q(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),q(zf(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),q(zf(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:s,dataFormat:r,dilations:i},f=he.runKernel(Ab,c,h);return u?pe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const C$=ce({conv3d_:rZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iZ(n,e,t,s,r){q(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=pe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],u=o.shape[4];q(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),q(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),q(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),q(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),q(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:o,filter:t},h={pad:r,strides:s,inputShape:i},f=he.runKernel(tN,c,h);return a?pe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const E$=ce({conv3DBackpropInput_:iZ});function oZ(n,e,t,s,r){const i=Z(n,"x","conv3dTranspose"),o=Z(e,"filter","conv3dTranspose");return E$(t,i,o,s,r)}const I$=ce({conv3dTranspose_:oZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aZ(n){const t={x:Z(n,"x","cos","float32")};return he.runKernel(_x,t)}const b_=ce({cos_:aZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lZ(n){const t={x:Z(n,"x","cosh","float32")};return he.runKernel(Tx,t)}const aA=ce({cosh_:lZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(n,e=0,t=!1,s=!1){const i={x:Z(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return he.runKernel(nN,i,o)}const SS=ce({cumprod_:uZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZ(n,e=0,t=!1,s=!1){const i={x:Z(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return he.runKernel(Mb,i,o)}const lA=ce({cumsum_:cZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(n,e,t,s=!1){const r=Z(n,"x","denseBincount"),i=Z(e,"weights","denseBincount");q(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),q(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),q(t>=0,()=>`size must be non-negative, but got ${t}.`),q(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:t,binaryOutput:s};return he.runKernel(rN,o,a)}const x2=ce({denseBincount_:hZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(n,e,t="NHWC"){const s=Z(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];q(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),q(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),q(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),q(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return he.runKernel(iN,a,l)}const N$=ce({depthToSpace_:dZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZ(n,e,t,s,r="NHWC",i=[1,1],o){const a=Z(n,"x","depthwiseConv2d","float32"),l=Z(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),q(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),q(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=r==="NHWC"?u.shape[3]:u.shape[1];q(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),zi("depthwiseConv2d",s,o);const f={x:u,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},g=he.runKernel(kb,f,p);return c?pe(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const hv=ce({depthwiseConv2d_:fZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ(n){const t={x:Z(n,"x","diag")};return he.runKernel(lN,t)}const mZ=ce({diag_:pZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(n,e,t,s,r=[1,1],i="NHWC"){const o=Z(n,"x","dilation2d"),a=Z(e,"filter","dilation2d");q(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),q(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),q(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;o.rank===3&&(l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),q(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:s,dilations:r},f=he.runKernel(Rb,c,h);return u?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const A$=ce({dilation2d_:gZ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pg(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,o=n[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function _r(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&t.unshift(i)}return t}function dn(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)s[t-r-1]=o;else if(o===1)s[t-r-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-r-1]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZ(n,e){let t=Z(n,"a","equal","string_or_numeric"),s=Z(e,"b","equal","string_or_numeric");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Db,r)}const Cl=ce({equal_:yZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(n,e,t){const s=Z(e,"a","where"),r=Z(t,"b","where"),i=Z(n,"condition","where","bool"),o=dn(dn(i.shape,s.shape),r.shape),a=eg(i,o),l=eg(s,o),u=eg(r,o),c={condition:a,t:l,e:u};return he.runKernel(u_,c)}const mi=ce({where_:xZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(n){const t={x:Z(n,"x","zerosLike")};return he.runKernel(x_,t)}const Pn=ce({zerosLike_:vZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(n,e){let t=Z(n,"a","div"),s=Z(e,"b","div");[t,s]=zs(t,s);const r=Rt(t,s),i=Pn(r),o=Cl(s,i);return mi(o,i,r)}const M$=ce({divNoNan_:wZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SZ(n,e){const t=Z(n,"t1","dot"),s=Z(e,"t2","dot");q((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(q(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const o=pe(t,[1,-1]),a=pe(s,[-1,1]),l=In(o,a);return pe(l,[])}else if(t.rank===1&&s.rank===2){const o=pe(t,[1,-1]),a=pe(s,[s.shape[0],s.shape[1]]),l=In(o,a);return pe(l,[l.size])}else if(t.rank===2&&s.rank===1){const o=pe(s,[-1,1]),a=In(t,o);return pe(a,[a.size])}else{const o=pe(s,[s.shape[0],s.shape[1]]);return In(t,o)}}const k$=ce({dot_:SZ});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bZ(n,...e){const t=e.map((r,i)=>Z(r,`tensors${i}`,"einsum")),s={equation:n};return he.runKernel(uN,t,s)}const Vm=ce({einsum_:bZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Z(n){const t={x:Z(n,"x","elu","float32")};return he.runKernel(Ex,t)}const dv=ce({elu_:_Z});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TZ(n,e){const t=Z(n,"x","ensureShape","string_or_numeric");if(!L7(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const CZ=ce({ensureShape_:TZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(n){let e=Z(n,"x","erf");q(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=gt(e,"float32"));const t={x:e};return he.runKernel(Ix,t)}const R$=ce({erf_:EZ});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function D$(n,e,t){const s=n.length+e.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[i++]):r.push(e[o++]);return r}function zr(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function js(n,e){const t=e.map(s=>1);return D$(n,t,e)}function Jr(n,e,t){q(uA(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function ks(n,e){if(uA(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function sd(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Xs(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(n,e=null,t=!1){const r={x:Z(n,"x","max")},i={reductionIndices:e,keepDims:t};return he.runKernel(Hb,r,i)}const Da=ce({max_:IZ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(n,e=null,t=!1){const r={x:Z(n,"x","min")},i={axis:e,keepDims:t};return he.runKernel(Kb,r,i)}const $0=ce({min_:NZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AZ(n,e){let t=Z(n,"base","pow"),s=Z(e,"exp","pow");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(Wx,r)}const zh=ce({pow_:AZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(n,e){if((Pa(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Pa(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return td(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MZ(n){const t={x:Z(n,"x","sqrt","float32")};return he.runKernel(tv,t)}const yi=ce({sqrt_:MZ});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(n){const e=Z(n,"x","square"),t={};return he.runKernel("Square",{x:e},t)}const os=ce({square_:kZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZ(n,e=null,t=!1){let s=Z(n,"x","sum");s.dtype==="bool"&&(s=gt(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return he.runKernel(h_,r,i)}const kt=ce({sum_:RZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(n,e="euclidean",t=null,s=!1){n=Z(n,"x","norm");const r=P$(n,e,t);let i=r.shape;if(s){const o=Cn(t,n.shape);i=js(r.shape,o)}return pe(r,i)}function P$(n,e,t=null){if(n.rank===0)return gr(n);if(n.rank!==1&&t===null)return P$(pe(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return kt(gr(n),t);if(e===1/0)return Da(gr(n),t);if(e===-1/0)return $0(gr(n),t);if(e==="euclidean"||e===2)return yi(kt(zh(gr(n),Ht(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Da(kt(gr(n),t[0]),t[1]-1);if(e===1/0)return Da(kt(gr(n),t[1]),t[0]);if(e===-1/0)return $0(kt(gr(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return yi(kt(os(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const fv=ce({norm_:DZ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PZ(n,e=null,t=!1){return fv(n,"euclidean",e,t)}const L$=ce({euclideanNorm_:PZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZ(n){const t={x:Z(n,"x","exp")};return he.runKernel(Nx,t)}const Fo=ce({exp_:LZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OZ(n,e=0){const t=Z(n,"x","expandDims","string_or_numeric");q(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return he.runKernel(Pb,s,r)}const pi=ce({expandDims_:OZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(n){const t={x:Z(n,"x","expm1")};return he.runKernel(Ax,t)}const O$=ce({expm1_:FZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n,e){const t=Z(n,"x","tile","string_or_numeric");q(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return he.runKernel(ov,s,r)}const Aa=ce({tile_:$Z});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(n,e,t,s="float32"){e==null&&(e=n);const r=yn([n,e],s),i=n<=e?n:e;for(let a=0;a<i;++a)r.set(1,a,a);const o=pe(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Aa(pi(o,0),[t[0],1,1]);if(t.length===2)return Aa(pi(pi(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Aa(pi(pi(pi(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const cA=ce({eye_:zZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UZ(n){const t={x:Z(n,"x","floor","float32")};return he.runKernel(Mx,t)}const pv=ce({floor_:UZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(n,e,t=0,s=0){const r=Z(n,"x","gather"),i=Z(e,"indices","gather","int32"),o={x:r,indices:i},a={axis:t,batchDims:s};return he.runKernel(Ob,o,a)}const mv=ce({gather_:BZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(n,e){let t=Z(n,"a","greater","string_or_numeric"),s=Z(e,"b","greater","string_or_numeric");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Fb,r)}const Wo=ce({greater_:VZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WZ(n,e){let t=Z(n,"a","greaterEqual","string_or_numeric"),s=Z(e,"b","greaterEqual","string_or_numeric");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Rx,r)}const rd=ce({greaterEqual_:WZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GZ(n){const t={input:Z(n,"input","imag")};return he.runKernel(gN,t)}const __=ce({imag_:GZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HZ(n){const t={x:Z(n,"x","isFinite")};return he.runKernel(Px,t)}const F$=ce({isFinite_:HZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZ(n){const t={x:Z(n,"x","isInf")};return he.runKernel(Lx,t)}const $$=ce({isInf_:jZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XZ(n){const t={x:Z(n,"x","isNaN")};return he.runKernel(Ox,t)}const z$=ce({isNaN_:XZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZ(n,e=.2){const s={x:Z(n,"x","leakyRelu")},r={alpha:e};return he.runKernel($b,s,r)}const T_=ce({leakyRelu_:qZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KZ(n,e){let t=Z(n,"a","less","string_or_numeric"),s=Z(e,"b","less","string_or_numeric");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(zb,r)}const z0=ce({less_:KZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YZ(n,e){let t=Z(n,"a","lessEqual","string_or_numeric"),s=Z(e,"b","lessEqual","string_or_numeric");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Ub,r)}const Yf=ce({lessEqual_:YZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZ(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return he.runKernel(yN,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JZ(n,e=5,t=1,s=1,r=.5){const i=Z(n,"x","localResponseNormalization");q(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),q(cg(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},u={depthRadius:e,bias:t,alpha:s,beta:r},c=he.runKernel(Gb,l,u);return a?pe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const U$=ce({localResponseNormalization_:JZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QZ(n){const t={x:Z(n,"x","log","float32")};return he.runKernel(Fx,t)}const aa=ce({log_:QZ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n){const t={x:Z(n,"x","log1p")};return he.runKernel($x,t)}const C_=ce({log1p_:eJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJ(n,e){q(e2(n),()=>"The f passed in variableGrads(f) must be a function"),q(e==null||Array.isArray(e)&&e.every(u=>u instanceof xS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in he.registeredVariables)e.push(he.registeredVariables[u])}const s=t?e.filter(u=>!u.trainable):null,r=e.length;e=e.filter(u=>u.trainable),q(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:a}=he.gradients(n,e,null,i);q(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),q(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),s!=null&&s.forEach(u=>l[u.name]=null),{value:o,grads:l}}function pc(n){return he.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n){const t={x:Z(n,"x","neg")};return he.runKernel(Zb,t)}const ys=ce({neg_:nJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sJ(n){const t={x:Z(n,"x","softplus")};return he.runKernel(ev,t)}const Og=ce({softplus_:sJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n){const e=Z(n,"x","logSigmoid");return pc(s=>({value:ys(Og(ys(s))),gradFunc:o=>de(o,Sl(ys(s)))}))(e)}const B$=ce({logSigmoid_:rJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(n,e){let t=Z(n,"a","sub"),s=Z(e,"b","sub");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(sv,r)}const Tt=ce({sub_:iJ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(n,e=-1){const t=Z(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return pc((r,i)=>{const a=Da(r,e,!0),l=Tt(r,a),u=Tt(gt(l,"float32"),aa(kt(Fo(l),e,!0)));return i([u]),{value:u,gradFunc:(h,f)=>{const[p]=f,g=!0,S=Fo(p);return Tt(h,de(kt(h,e,g),S))}}})(t)}const hA=ce({logSoftmax_:oJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aJ(n,e=null,t=!1){const s=Z(n,"x","logSumExp"),r=Cn(e,s.shape),i=Da(s,r,!0),o=Tt(s,i),a=Fo(o),l=kt(a,r),u=aa(l),c=Ze(pe(i,u.shape),u);if(t){const h=js(c.shape,r);return pe(c,h)}return c}const E_=ce({logSumExp_:aJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(n,e){const t=Z(n,"a","logicalAnd","bool"),s=Z(e,"b","logicalAnd","bool");dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Bb,r)}const fu=ce({logicalAnd_:lJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uJ(n){const t={x:Z(n,"x","logicalNot","bool")};return he.runKernel(Vb,t)}const I_=ce({logicalNot_:uJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cJ(n,e){const t=Z(n,"a","logicalOr","bool"),s=Z(e,"b","logicalOr","bool");dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Wb,r)}const dA=ce({logicalOr_:cJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(n,e){const t=Z(n,"a","logicalXor","bool"),s=Z(e,"b","logicalXor","bool");return dn(t.shape,s.shape),fu(dA(n,e),I_(fu(n,e)))}const V$=ce({logicalXor_:hJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _w=2147483648;function dJ(n,e,t="left"){const s=Z(n,"sortedSequence","searchSorted"),r=Z(e,"values","searchSorted"),i=s.shape[s.shape.length-1],o=r.shape[r.shape.length-1],a=pe(s,[-1,i]),l=pe(r,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Oe(l.shape)>=_w)throw new Error(`values tensor size must less than ${_w}`);if(a.shape[1]>=_w)throw new Error(`trailing dim_size must less than ${_w} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:t};return he.runKernel(LN,u,c)}const fA=ce({searchSorted_:dJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fJ(n,e){return fA(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pJ(n,e,t,s,r){const i=Z(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),q(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),q(Zr(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),zi("maxPool",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r},h=he.runKernel(jb,u,c);return l?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const N_=ce({maxPool_:pJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(n,e=[1,1,1],t,s,r,i="NDHWC"){const o=Z(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),q(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),q(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),zi("maxPool3d",s,r);const u={x:a},c={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},h=he.runKernel(Xb,u,c);return l?pe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const W$=ce({maxPool3d_:mJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJ(n,e,t,s,r=!1){const o={x:Z(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=he.runKernel(SN,o,a);return{result:l[0],indexes:l[1]}}const yJ=ce({maxPoolWithArgmax_:gJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(n,e){let t=Z(n,"a","maximum"),s=Z(e,"b","maximum");[t,s]=zs(t,s),t.dtype==="bool"&&(t=gt(t,"int32"),s=gt(s,"int32")),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(zx,r)}const bc=ce({maximum_:xJ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vJ(n,e=null,t=!1){const r={x:Z(n,"x","mean")},i={axis:e,keepDims:t};return he.runKernel(qb,r,i)}const $s=ce({mean_:vJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr(n,e="float32"){if(ua(n),e==="complex64"){const s=yr(n,"float32"),r=yr(n,"float32");return Lh(s,r)}const t=gi(Oe(n),e);return he.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ko(n,e="float32"){if(ua(n),e==="complex64"){const s=ko(n,"float32"),r=yr(n,"float32");return Lh(s,r)}const t=GI(Oe(n),e);return he.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wJ(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=Z(n,"x","meshgrid",n instanceof gs?n.dtype:"float32");if(e===void 0)return[s];let r=Z(e,"y","meshgrid",e instanceof gs?e.dtype:"float32");const i=Oe(s.shape),o=Oe(r.shape);return t==="xy"?(s=pe(s,[1,-1]),r=pe(r,[-1,1]),[In(ko([o,1],s.dtype),s),In(r,ko([1,i],r.dtype))]):(s=pe(s,[-1,1]),r=pe(r,[1,-1]),[In(s,ko([1,o],s.dtype)),In(ko([i,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SJ(n,e){let t=Z(n,"a","minimum"),s=Z(e,"b","minimum");[t,s]=zs(t,s),t.dtype==="bool"&&(t=gt(t,"int32"),s=gt(s,"int32")),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Ux,r)}const Uf=ce({minimum_:SJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(n,e,t){q(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=Z(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");q(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)q(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),q(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},o={x:s};return he.runKernel(Yb,o,i)}const G$=ce({mirrorPad_:bJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _J(n,e){let t=Z(n,"a","mod"),s=Z(e,"b","mod");[t,s]=zs(t,s);const r={a:t,b:s};return he.runKernel(Bx,r)}const H$=ce({mod_:_J});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TJ(n,e=null,t=!1){n=Z(n,"x","moments");const s=Cn(e,n.shape),r=$s(n,s,t);let i=r.shape;t||(i=js(r.shape,s));const o=os(Tt(gt(n,"float32"),pe(r,i))),a=$s(o,s,t);return{mean:r,variance:a}}const A_=ce({moments_:TJ});function CJ(n,e,t,s){const r=Z(e,"data","multiRNNCell"),i=vS(t,"c","multiRNNCell"),o=vS(s,"h","multiRNNCell");let a=r;const l=[];for(let h=0;h<n.length;h++){const f=n[h](a,i[h],o[h]);l.push(f[0]),l.push(f[1]),a=f[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const EJ=ce({multiRNNCell_:CJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IJ(n,e,t,s=!1){const r=Z(n,"logits","multinomial"),i=r.size,o=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?pe(r,[1,-1]):r},u={numSamples:e,seed:t,normalized:s},c=he.runKernel(bN,l,u);return o===1?pe(c,[c.size]):c}const NJ=ce({multinomial_:IJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n,e){let t=Z(n,"a","notEqual","string_or_numeric"),s=Z(e,"b","notEqual","string_or_numeric");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s};return he.runKernel(Jb,r)}const mg=ce({notEqual_:AJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJ(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:Z(n,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:t,offValue:s};return he.runKernel(e_,o,a)}const pA=ce({oneHot_:MJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kJ(n){const t={x:Z(n,"x","onesLike")};return he.runKernel(Qb,t)}const la=ce({onesLike_:kJ});function RJ(n,e){const t=Z(n,"v1","outerProduct"),s=Z(e,"v2","outerProduct");q(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=pe(t,[-1,1]),i=pe(s,[1,-1]);return In(r,i)}const DJ=ce({outerProduct_:RJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(n,e,t=0){const s=Z(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return he.runKernel(n_,i,r)}const id=ce({pad_:PJ});function LJ(n,e,t=0){return q(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),id(n,[e],t)}const OJ=ce({pad1d_:LJ});function FJ(n,e,t=0){return q(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),id(n,e,t)}const $J=ce({pad2d_:FJ});function zJ(n,e,t=0){return q(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),id(n,e,t)}const UJ=ce({pad3d_:zJ});function BJ(n,e,t=0){return q(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),id(n,e,t)}const VJ=ce({pad4d_:BJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n,e,t){const s=Z(n,"x","spaceToBatchND");q(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),q(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),q(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return he.runKernel(d_,r,i)}const M_=ce({spaceToBatchND_:WJ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(n,e,t,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const a=Z(n,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),q(Zr(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const c=Fa(l.shape,e,i,r,s),h=[c.dilationHeight,c.dilationWidth];let f;s==="same"?f=jJ([c.filterHeight,c.filterWidth],h):f=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[g,S]=HJ([c.inHeight,c.inWidth],h,f),x=p?s:"valid",w=p?l:M_(l,h,g),T=(t==="avg"?()=>w_(w,e,i,x,o):()=>N_(w,e,i,x,o))(),C=p?T:S_(T,h,S);return u?pe(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function HJ(n,e,t){const s=t.map(c=>c[0]),r=t.map(c=>c[1]),i=n.concat(s,r),o=e.map((c,h)=>(c-i[h]%c)%c),a=r.map((c,h)=>c+o[h]),l=e.map((c,h)=>[s[h],a[h]]),u=e.map((c,h)=>[0,o[h]]);return[l,u]}function jJ(n,e){const s=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,a)=>o-r[a]);return s.map((o,a)=>[r[a],i[a]])}const j$=ce({pool_:GJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(n,e){const t=Z(n,"x","prelu"),s=Z(e,"alpha","prelu"),r={x:t,alpha:s};return he.runKernel(s_,r)}const k_=ce({prelu_:XJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n,e=null,t=!1){let s=Z(n,"x","prod");s.dtype==="bool"&&(s=gt(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return he.runKernel(r_,r,i)}const X$=ce({prod_:qJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(n,e,t,s){const r=n.map((c,h)=>Z(c,`tensors${h}`,"raggedGather","int32")),i=Z(e,"paramsDenseValues","raggedGather"),o=Z(t,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:i,indices:o},l={outputRaggedRank:s},u=he.runKernel(EN,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const YJ=ce({raggedGather_:KJ});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(n,e,t){const s=Z(n,"starts","raggedRange"),r=Z(e,"limits","raggedRange",s.dtype),i=Z(t,"deltas","raggedRange",s.dtype),o={starts:s,limits:r,deltas:i},a=he.runKernel(IN,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const JJ=ce({raggedRange_:ZJ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QJ(n,e,t,s,r){const i=Z(n,"shape","raggedTensorToTensor","int32"),o=Z(e,"values","raggedTensorToTensor"),a=Z(t,"defaultValue","raggedTensorToTensor",o.dtype),l=s.map((h,f)=>Z(h,`tensors${f}`,"raggedTensorToTensor","int32")),u={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:r};return he.runKernel(NN,u,c)}const eQ=ce({raggedTensorToTensor_:QJ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tQ(n,e,t){ua(n);const s=Oe(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<s;i++)r[i]=e();return he.makeTensor(r,n,t)}const nQ=ce({rand_:tQ});var qw={exports:{}},sQ=qw.exports,QD;function rQ(){return QD||(QD=1,(function(n){(function(e,t,s){function r(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function i(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var c=new r(l),h=u&&u.state,f=c.next;return f.int32=function(){return c.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&i(h,c),f.state=function(){return i(c,{})}),f}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=o:this.alea=o})(sQ,n)})(qw)),qw.exports}var Kw={exports:{}},iQ=Kw.exports,eP;function oQ(){return eP||(eP=1,(function(n){(function(e,t,s){function r(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(f+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xor128=o})(iQ,n)})(Kw)),Kw.exports}var Yw={exports:{}},aQ=Yw.exports,tP;function lQ(){return tP||(tP=1,(function(n){(function(e,t,s){function r(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(f+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xorwow=o})(aQ,n)})(Yw)),Yw.exports}var Zw={exports:{}},uQ=Zw.exports,nP;function cQ(){return nP||(nP=1,(function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var c=l.x,h=l.i,f,p;return f=c[h],f^=f>>>7,p=f^f<<24,f=c[h+1&7],p^=f^f>>>10,f=c[h+3&7],p^=f^f>>>3,f=c[h+4&7],p^=f^f<<7,f=c[h+7&7],f=f^f<<13,p^=f^f<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var f,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,f=0;f<h.length;++f)p[f&7]=p[f&7]<<15^h.charCodeAt(f)+p[f+1&7]<<13;for(;p.length<8;)p.push(0);for(f=0;f<8&&p[f]===0;++f);for(f==8?p[7]=-1:p[f],c.x=p,c.i=0,f=256;f>0;--f)c.next()}u(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(f+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.x&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xorshift7=o})(uQ,n)})(Zw)),Zw.exports}var Jw={exports:{}},hQ=Jw.exports,sP;function dQ(){return sP||(sP=1,(function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var c=l.w,h=l.X,f=l.i,p,g;return l.w=c=c+1640531527|0,g=h[f+34&127],p=h[f=f+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,g=h[f]=g^p,l.i=f,g+(c^c>>>16)|0};function u(c,h){var f,p,g,S,x,w=[],_=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,_=Math.max(_,h.length)),g=0,S=-32;S<_;++S)h&&(p^=h.charCodeAt((S+32)%h.length)),S===0&&(x=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,S>=0&&(x=x+1640531527|0,f=w[S&127]^=p+x,g=f==0?g+1:0);for(g>=128&&(w[(h&&h.length||0)&127]=-1),g=127,S=512;S>0;--S)p=w[g+34&127],f=w[g=g+1&127],p^=p<<13,f^=f<<17,p^=p>>>15,f^=f>>>12,w[g]=p^f;c.w=x,c.X=w,c.i=g}u(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(f+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.X&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xor4096=o})(hQ,n)})(Jw)),Jw.exports}var Qw={exports:{}},fQ=Qw.exports,rP;function pQ(){return rP||(rP=1,(function(n){(function(e,t,s){function r(a){var l=this,u="";l.next=function(){var h=l.b,f=l.c,p=l.d,g=l.a;return h=h<<25^h>>>7^f,f=f-p|0,p=p<<24^p>>>8^g,g=g-h|0,l.b=h=h<<20^h>>>12^f,l.c=f=f-p|0,l.d=p<<16^f>>>16^g,l.a=g-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new r(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var f=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(f+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.tychei=o})(fQ,n)})(Qw)),Qw.exports}var eS={exports:{}};const mQ={},gQ=Object.freeze(Object.defineProperty({__proto__:null,default:mQ},Symbol.toStringTag,{value:"Module"})),yQ=YW(gQ);var xQ=eS.exports,iP;function vQ(){return iP||(iP=1,(function(n){(function(e,t,s){var r=256,i=6,o=52,a="random",l=s.pow(r,i),u=s.pow(2,o),c=u*2,h=r-1,f;function p(C,N,M){var P=[];N=N==!0?{entropy:!0}:N||{};var $=w(x(N.entropy?[C,T(t)]:C??_(),3),P),R=new g(P),D=function(){for(var L=R.g(i),G=l,Q=0;L<u;)L=(L+Q)*r,G*=r,Q=R.g(1);for(;L>=c;)L/=2,G/=2,Q>>>=1;return(L+Q)/G};return D.int32=function(){return R.g(4)|0},D.quick=function(){return R.g(4)/4294967296},D.double=D,w(T(R.S),t),(N.pass||M||function(L,G,Q,W){return W&&(W.S&&S(W,R),L.state=function(){return S(R,{})}),Q?(s[a]=L,G):L})(D,$,"global"in N?N.global:this==s,N.state)}function g(C){var N,M=C.length,P=this,$=0,R=P.i=P.j=0,D=P.S=[];for(M||(C=[M++]);$<r;)D[$]=$++;for($=0;$<r;$++)D[$]=D[R=h&R+C[$%M]+(N=D[$])],D[R]=N;(P.g=function(L){for(var G,Q=0,W=P.i,H=P.j,J=P.S;L--;)G=J[W=h&W+1],Q=Q*r+J[h&(J[W]=J[H=h&H+G])+(J[H]=G)];return P.i=W,P.j=H,Q})(r)}function S(C,N){return N.i=C.i,N.j=C.j,N.S=C.S.slice(),N}function x(C,N){var M=[],P=typeof C,$;if(N&&P=="object")for($ in C)try{M.push(x(C[$],N-1))}catch{}return M.length?M:P=="string"?C:C+"\0"}function w(C,N){for(var M=C+"",P,$=0;$<M.length;)N[h&$]=h&(P^=N[h&$]*19)+M.charCodeAt($++);return T(N)}function _(){try{var C;return f&&(C=f.randomBytes)?C=C(r):(C=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(C)),T(C)}catch{var N=e.navigator,M=N&&N.plugins;return[+new Date,e,M,e.screen,T(t)]}}function T(C){return String.fromCharCode.apply(0,C)}if(w(s.random(),t),n.exports){n.exports=p;try{f=yQ}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:xQ,[],Math)})(eS)),eS.exports}var HC,oP;function wQ(){if(oP)return HC;oP=1;var n=rQ(),e=oQ(),t=lQ(),s=cQ(),r=dQ(),i=pQ(),o=vQ();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=s,o.xor4096=r,o.tychei=i,HC=o,HC}var R_=wQ();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mA{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=R_.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class SQ{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const i=r||Math.random();this.randu=R_.alea(i.toString()),this.randn=new mA(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,i,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<t||Math.log(i)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class bQ{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=R_.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(n,e,t=1,s="float32",r){if(ua(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new SQ(e,t,s,r),o=yn(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const TQ=ce({randomGamma_:_Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CQ(n,e=0,t=1,s,r){if(ua(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new mA(e,t,s,!1,r),o=yn(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const gA=ce({randomNormal_:CQ});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return gA(n,0,1,e,t)}const IQ=ce({randomStandardNormal_:EQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(n,e=0,t=1,s="float32",r){ua(n);const i=yn(n,s),o=new bQ(e,t,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Zf=ce({randomUniform_:NQ});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AQ(n,e,t,s){return Zf(n,e,t,"int32",s)}const MQ=ce({randomUniformInt_:AQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gg(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return he.runKernel(AN,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(n){const t={input:Z(n,"input","real")};return he.runKernel(MN,t)}const U0=ce({real_:kQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(n){const t={x:Z(n,"x","reciprocal")};return he.runKernel(Gx,t)}const q$=ce({reciprocal_:RQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQ(n){const t={x:Z(n,"x","relu")};return he.runKernel(Hx,t)}const yu=ce({relu_:DQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PQ(n){const t={x:Z(n,"x","relu6")};return he.runKernel(jx,t)}const yA=ce({relu6_:PQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQ(n,e){const s={x:Z(n,"x","reverse")},r={dims:e};return he.runKernel(l_,s,r)}const La=ce({reverse_:LQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(n){const e=Z(n,"x","reverse");return q(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),La(e,0)}const FQ=ce({reverse1d_:OQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(n,e){const t=Z(n,"x","reverse");return q(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),La(t,e)}const zQ=ce({reverse2d_:$Q});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UQ(n,e){const t=Z(n,"x","reverse");return q(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),La(t,e)}const BQ=ce({reverse3d_:UQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VQ(n,e){const t=Z(n,"x","reverse");return q(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),La(t,e)}const WQ=ce({reverse4d_:VQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GQ(n){const t={x:Z(n,"x","round")};return he.runKernel(Xx,t)}const xA=ce({round_:GQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQ(n){const t={x:Z(n,"x","rsqrt","float32")};return he.runKernel(qx,t)}const vA=ce({rsqrt_:HQ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(n){const t={x:Z(n,"x","selu")};return he.runKernel(Kx,t)}const wA=ce({selu_:jQ});function XQ(n,e,t,s,r,i=[1,1],o="NHWC"){const a=Z(n,"x","separableConv2d"),l=Z(e,"depthwiseFilter","separableConv2d"),u=Z(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");q(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),q(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),q(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),q(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),q(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const f=l.shape[2],p=l.shape[3];q(u.shape[2]===f*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*p}, but got ${u.shape[2]}.`);const g=hv(c,l,s,r,o,i),x=$h(g,u,1,"valid",o);return h?pe(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const SA=ce({separableConv2d_:XQ});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function qQ(n,e){const t=Z(n,"x","setdiff1d"),s=Z(e,"y","setdiff1d");q(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),q(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),q(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),o=new Set(i);let a=0;for(let c=0;c<r.length;c++)o.has(r[c])||a++;const l=new wr([a],t.dtype),u=new wr([a],"int32");for(let c=0,h=0;c<r.length;c++)o.has(r[c])||(l.values[h]=r[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const KQ=qQ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YQ(n){const t={x:Z(n,"x","sign")};return he.runKernel(Jx,t)}const K$=ce({sign_:YQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZQ(n){const t={x:Z(n,"x","sin","float32")};return he.runKernel(Yx,t)}const bA=ce({sin_:ZQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JQ(n){const t={x:Z(n,"x","sinh")};return he.runKernel(Zx,t)}const _A=ce({sinh_:JQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(n,e,t){const s=Z(n,"x","slice1d");return q(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),mn(s,[e],[t])}const D_=ce({slice1d_:QQ});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eee(n,e,t){const s=Z(n,"x","slice2d");return q(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),mn(s,e,t)}const TA=ce({slice2d_:eee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tee(n,e,t){const s=Z(n,"x","slice3d");return q(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),mn(s,e,t)}const P_=ce({slice3d_:tee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nee(n,e,t){const s=Z(n,"x","slice4d");return q(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),mn(s,e,t)}const B0=ce({slice4d_:nee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function see(n,e=-1){const t=Z(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return he.runKernel(p_,s,r)}const L_=ce({softmax_:see});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ree(n){q(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return he.runKernel(hN,e)}const O_=ce({fft_:ree});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iee(n){q(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return he.runKernel(mN,e)}const V0=ce({ifft_:iee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oee(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=pe(n,[t,e]);s=V0(r)}else{const r=[t,2*(e-1)],i=pe(U0(n),[t,e]),o=pe(__(n),[t,e]),a=La(mn(i,[0,1],[t,e-2]),1),l=de(La(mn(o,[0,1],[t,e-2]),1),Ht(-1)),u=ir([i,a],1),c=ir([o,l],1),h=pe(Lh(u,c),[r[0],r[1]]);s=V0(h)}if(s=U0(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=pe(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const CA=ce({irfft_:oee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aee(n,e,t=0){const r={x:Z(n,"x","split")},i={numOrSizeSplits:e,axis:t};return he.runKernel(f_,r,i)}const Po=ce({split_:aee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lee(n,e){q(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const g=n.shape.map(x=>0),S=n.shape.map(x=>x);S[n.shape.length-1]=e,r=mn(n,g,S),t=e}else if(e!=null&&e>t){const g=n.shape.map(S=>S);g[n.shape.length-1]=e-t,r=ir([n,yr(g)],n.shape.length-1),t=e}else r=n;const i=Pn(r),o=pe(Lh(r,i),[s,t]),a=O_(o),l=Math.floor(t/2)+1,u=U0(a),c=__(a),h=Po(u,[l,t-l],u.shape.length-1),f=Po(c,[l,t-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,pe(Lh(h[0],f[0]),p)}const F_=ce({rfft_:lee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uee(n,e){let t=Z(n,"a","squaredDifference"),s=Z(e,"b","squaredDifference");[t,s]=zs(t,s),dn(t.shape,s.shape);const r={a:t,b:s},i={};return he.runKernel(nv,r,i)}const EA=ce({squaredDifference_:uee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cee(n,e){const t=Z(n,"x","squeeze","string_or_numeric");return pe(t,Jh(t.shape,e).newShape)}const mc=ce({squeeze_:cee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hee(n,e=0){const t=vS(n,"tensors","stack","string_or_numeric");q(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&q(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return he.runKernel(t_,s,r)}const $o=ce({stack_:hee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dee(n,e=0){const s={x:Z(n,"x","step")},r={alpha:e};return he.runKernel(av,s,r)}const Fg=ce({step_:dee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fee(n,e,t,s,r=0,i=0,o=0,a=0,l=0){const c={x:Z(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return he.runKernel(VN,c,h)}const Y$=ce({stridedSlice_:fee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pee(n){const t={x:Z(n,"x","tan","float32")};return he.runKernel(rv,t)}const Z$=ce({tan_:pee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(n,e){kg(n);const t=ed(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return td(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tg(n,e,t){if(kg(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=ed(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return td(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n,e,t){if(kg(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ed(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return td(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mee(n,e,t){if(kg(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ed(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return td(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gee(n,e,t){if(kg(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ed(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return td(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yee(n,e,t){if(kg(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ed(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,td(n,e,s,t)}function Q$(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function IA(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Q$(t,e,n)}function Jf(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let o=1;for(let h=r;h<i;++h)o*=t[h];const a=r<1?1:r,l=Oe(e.shape)/a,u=[...Wt(t.slice(0,r)),1],c=Oe(t);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xee(n,e,t){const s=Z(n,"tensor","tensorScatterupdate"),r=Z(e,"indices","tensorScatterupdate","int32"),i=Z(t,"updates","tensorScatterupdate");if(IA(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const o={tensor:s,indices:r,updates:i},a={};return he.runKernel(PN,o,a)}const vee=ce({tensorScatterUpdate_:xee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wee(n,e=1,t=!0){const s=Z(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:t},[a,l]=he.runKernel(jN,i,o);return{values:a,indices:l}}const ez=ce({topk_:wee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function See(n,e=0,t=1,s,r){if(ua(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new mA(e,t,s,!0,r),o=yn(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const NA=ce({truncatedNormal_:See});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bee(n,e=0){const t=Z(n,"x","unique","string_or_numeric");q(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,o]=he.runKernel(qN,s,r);return{values:i,indices:o}}const tz=ce({unique_:bee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ee(n,e,t){const s=Z(n,"x","unsortedSegmentSum"),r=Z(e,"segmentIds","unsortedSegmentSum","int32");q(cg(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:t};return he.runKernel(y_,i,o)}const AA=ce({unsortedSegmentSum_:_ee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tee(n,e=0){const t=Z(n,"x","unstack","string_or_numeric");q(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return he.runKernel(g_,s,r)}const Oa=ce({unstack_:Tee});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cee(n,e){return fA(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nz(n,e=!0,t,s){return he.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=yn(n,"int32"),r=yn([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=s.indexToLoc(t[i]),a=i*n.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Eee(n){const e=Z(n,"condition","whereAsync","bool"),t=await e.data(),s=MA(e.shape,t);return n!==e&&e.dispose(),s}const sz=Eee;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Iee(n,e,t){const s=Z(n,"tensor","boolMask"),r=Z(e,"mask","boolMask","bool"),i=t??0,o=r.rank,a=s.shape;q(o>0,()=>"mask cannot be scalar"),Vo(a.slice(i,i+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let S=i;S<i+o;S++)l*=a[S];const u=a.slice(0,i).concat([l],a.slice(i+o)),c=pe(s,u),h=pe(r,[-1]),f=await sz(h),p=mc(f,[1]),g=mv(c,p,i);return n!==s&&s.dispose(),e!==r&&r.dispose(),p.dispose(),c.dispose(),h.dispose(),f.dispose(),g}const Nee=Iee;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aee(n,e,t){const s=Z(n,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),q(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{q(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?be(()=>{let o=U0(s),a=__(s);return o=he.runKernel(Zm,{x:o},i),a=he.runKernel(Zm,{x:a},i),t&&(a=ys(a)),Lh(o,a)}):he.runKernel(Zm,r,i)}const Dn=ce({transpose_:Aee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mee(n,e,t,s,r=!0){const i=Z(n,"v","movingAverage"),o=Z(e,"x","movingAverage"),a=Z(t,"decay","movingAverage");yK(i,o),q(Mn(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Ht(1),u=Tt(l,a);let c=de(Tt(o,i),u);if(r){q(s!=null,()=>"When using zeroDebias: true, step is required.");const h=Z(s,"step","movingAverage");c=Rt(c,Tt(l,zh(a,h)))}return Ze(i,c)}const kee=ce({movingAverage_:Mee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ree(n,e,t){ua(t);const s=Z(n,"indices","scatterND","int32"),r=Z(e,"updates","scatterND");IA(r,s,t);const i={indices:s,updates:r},o={shape:t};return he.runKernel(DN,i,o)}const Dee=ce({scatterND_:Ree});function Pee(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lee(n,e,t,s=0){ua(t);const r=Z(n,"sparseIndices","sparseToDense","int32"),i=Z(e,"sparseValues","sparseToDense","string_or_numeric"),o=Z(s,"defaultValue","sparseToDense",i.dtype);Pee(r,i,t,o);const a={sparseIndices:r,sparseValues:i,defaultValue:o},l={outputShape:t};return he.runKernel(UN,a,l)}const Oee=ce({sparseToDense_:Lee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fee(n,e){const t=Z(e,"indices","gatherND","int32"),r={params:Z(n,"x","gatherND","string_or_numeric"),indices:t};return he.runKernel(pN,r)}const $ee=ce({gatherND_:Fee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zee(n,e){if(e==null)return n.shape.slice();if(Mn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uee(n,e,t,s){const r=Z(n,"x","dropout");if(q(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),q(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof gs?r.clone():r;const i=zee(r,t),o=1-e,a=Rt(pv(Ze(Zf(i,0,1,"float32",s),o)),o);return de(r,a)}const rz=ce({dropout_:Uee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iz(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function kA(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(o)}return Kr(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Bee(n,e,t=1){const s=Z(n,"predictions","inTopK"),r=Z(e,"targets","inTopK");q(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),q(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Vo(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];q(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const o=await s.data(),a=await r.data(),[l,u]=[o.length/i,i],c=Yr("bool",l);for(let h=0;h<l;h++){const f=h*u,p=o.subarray(f,f+u),g=[];for(let S=0;S<p.length;S++)g.push({value:p[S],index:S});g.sort((S,x)=>x.value-S.value),c[h]=0;for(let S=0;S<t;S++)if(g[S].index===a[h]){c[h]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),wl(c,r.shape,"bool")}const Vee=Bee;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wee(n,e,t,s,r,i="NHWC",o){let a=n;n.rank===3&&(a=pe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),q(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),q(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),q(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=i==="NHWC"?a.shape[3]:a.shape[1],c=i==="NHWC"?l.shape[3]:l.shape[1];q(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),q(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),zi("conv2dDerFilter",r,o);const h={x:a,dy:l},f={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:t};return he.runKernel(QI,h,f)}const RA=ce({conv2DBackpropFilter_:Wee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return de(n,Fg(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function z_(n,e){let t=e;const s=_r(n.shape,e.shape);return s.length>0&&(t=kt(t,s)),pe(t,n.shape)}function U_(n,e,t,s){if(e==="linear")return n;if(e==="relu")return yu(n);if(e==="elu")return dv(n);if(e==="relu6")return yA(n);if(e==="prelu")return k_(n,t);if(e==="leakyrelu")return T_(n,s);if(e==="sigmoid")return Sl(n);throw new Error(`Unknown fused activation ${e}.`)}const B_=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",B_(he.state.gradientDepth,l)===!1){q(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let M=$h(n,e,t,s,r,i,o);return a!=null&&(M=Ze(M,a)),U_(M,l,u,c)}const h=Z(n,"x","conv2d","float32"),f=Z(e,"filter","conv2d","float32");let p=h,g=!1;h.rank===3&&(g=!0,p=pe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),q(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),q(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),zi("fused conv2d",s,o);const S=r==="NHWC"?p.shape[3]:p.shape[1];q(f.shape[2]===S,()=>`Error in conv2d: depth of input (${S}) must match input depth for filter ${f.shape[2]}.`),q(Zr(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const x=$r(p.shape,f.shape,t,i,s,o);let w;a!=null&&(w=Z(a,"bias","fused conv2d"),[w]=zs(w,h),r==="NHWC"?dn(x.outShape,w.shape):(q(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),q(w.shape.length===0||w.shape[0]===x.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let _;if(u!=null){const M=u.shape;if(q(M.length<=1||M.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${M.length}.`),M.length===1)q(M[0]===1||M[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the number of output channels (${x.outChannels}).`);else if(M.length===3)try{dn(M,x.outShape)}catch{const $=`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error($)}_=Z(u,"prelu weights","fused conv2d")}const T=(M,P)=>{q(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[$,R,D,L]=P,G=$_(M,D,l);q(Fh(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Q=iA(R.shape,G,$,t,s),W=RA(R,G,$.shape,t,s),H=[Q,W];if(L!=null){const J=z_(L,G);H.push(J)}return H},C={x:p,filter:f,bias:w,preluActivationWeights:_},N={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?pc((P,$,R)=>{let D=he.runKernel(mS,C,N);return R([$,P,D]),g&&(D=pe(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:T}})(p,f):pc((P,$,R,D)=>{let L=he.runKernel(mS,C,N);return D([$,P,L,R]),g&&(L=pe(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:T}})(p,f,w)}const oz=ce({fusedConv2d_:Gee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hee(n,e,t,s,r,i=[1,1],o){let a=n;n.rank===3&&(a=pe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:t};return he.runKernel(oN,u,c)}const az=ce({depthwiseConv2dNativeBackpropFilter_:Hee});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jee(n,e,t,s,r,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},h=he.runKernel(aN,u,c);return l?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const lz=ce({depthwiseConv2dNativeBackpropInput_:jee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(B_(he.state.gradientDepth,l)===!1){let N=hv(n,e,t,s,r,i,o);return a!=null&&(N=Ze(N,a)),U_(N,l,u,c)}const h=Z(n,"x","depthwiseConv2d","float32"),f=Z(e,"filter","depthwiseConv2d","float32");let p=h,g=!1;h.rank===3&&(g=!0,p=pe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),q(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),q(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),q(p.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),i==null&&(i=[1,1]),q(Zr(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),zi("fused depthwiseConv2d",s,o);const S=$r(p.shape,f.shape,t,i,s,o,!0);let x;a!=null&&(x=Z(a,"bias","fused conv2d"),[x]=zs(x,h),dn(S.outShape,x.shape));let w;u!=null&&(w=Z(u,"prelu weights","fused depthwiseConv2d"));const _=(N,M)=>{q(Fh(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[P,$,R,D]=M,L=$_(N,R,l),G=lz($.shape,L,P,t,s,i,o),Q=az($,L,P.shape,t,s,i,o);if(D!=null){const W=z_(x,L);return[G,Q,W]}return[G,Q]},T={x:p,filter:f,bias:x,preluActivationWeights:w},C={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?pc((M,P,$)=>{let R=he.runKernel(gS,T,C);return $([P,M,R]),g&&(R=pe(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:_}})(p,f):pc((M,P,$,R)=>{let D=he.runKernel(gS,T,C);return R([P,M,D,$]),g&&(D=pe(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:_}})(p,f,x)}const qee=ce({fusedDepthwiseConv2d_:Xee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kee({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(B_(he.state.gradientDepth,i)===!1){let L=In(n,e,t,s);return r!=null&&(L=Ze(L,r)),U_(L,i,o,a)}let l=Z(n,"a","fused matMul"),u=Z(e,"b","fused matMul");[l,u]=zs(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?u.shape[u.rank-1]:u.shape[u.rank-2],f=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),S=u.shape.slice(0,-2),x=Oe(g),w=Oe(S);q(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${s} must match.`);const T=dn(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([f,p]),C=t?pe(l,[x,c,f]):pe(l,[x,f,c]),N=s?pe(u,[w,p,h]):pe(u,[w,h,p]);let M;r!=null&&(M=Z(r,"bias","fused matMul"),[M]=zs(M,l),dn(T,M.shape));let P;o!=null&&(P=Z(o,"prelu weights","fused matMul"));const $=(L,G)=>{const[Q,W,H,J]=G,ie=$_(pe(L,H.shape),H,i);let V,Y;if(!t&&!s?(V=In(ie,W,!1,!0),Y=In(Q,ie,!0,!1)):!t&&s?(V=In(ie,W,!1,!1),Y=In(ie,Q,!0,!1)):t&&!s?(V=In(W,ie,!1,!0),Y=In(Q,ie,!1,!1)):(V=In(W,ie,!0,!0),Y=In(ie,Q,!0,!0)),r!=null){const B=z_(J,ie);return[V,Y,B]}else return[V,Y]},R={a:C,b:N,bias:M,preluActivationWeights:P},D={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?pc((G,Q,W)=>{const H=he.runKernel(pS,R,D);return W([G,Q,H]),{value:pe(H,T),gradFunc:$}})(C,N):pc((G,Q,W,H)=>{const J=he.runKernel(pS,R,D);return H([G,Q,J,W]),{value:pe(J,T),gradFunc:$}})(C,N,M)}const v2=ce({fusedMatMul_:Kee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yee=Object.freeze(Object.defineProperty({__proto__:null,conv2d:oz,depthwiseConv2d:qee,matMul:v2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zee(n){return kA(n,.54,.46)}const Jee=ce({hammingWindow_:Zee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qee(n){return kA(n,.5,.5)}const uz=ce({hannWindow_:Qee});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ete(n,e,t,s=!1,r=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(mn(n,i,e)),i+=t;if(s)for(;i<n.size;){const a=i+e-n.size,l=ir([mn(n,i,e-a),Lg([a],r)]);o.push(l),i+=t}return o.length===0?tg([],[0,e]):pe(ir(o),[o.length,e])}const cz=ce({frame_:ete});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tte(n,e,t,s,r=uz){s==null&&(s=iz(e));const i=cz(n,e,t),o=de(i,r(e));return F_(o,s)}const nte=ce({stft_:tte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ste(n,e,t,s,r="bilinear",i=0){const o=Z(n,"image","cropAndResize"),a=Z(e,"boxes","cropAndResize","float32"),l=Z(t,"boxInd","cropAndResize","int32"),u=a.shape[0];q(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),q(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),q(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),q(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),q(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),q(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:o,boxes:a,boxInd:l},h={method:r,extrapolationValue:i,cropSize:s};return he.runKernel(sN,c,h)}const rte=ce({cropAndResize_:ste});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ite(n){const e=Z(n,"image","flipLeftRight","float32");q(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return he.runKernel(fN,t,{})}const ote=ce({flipLeftRight_:ite});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ate(n){const e=Z(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];q(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),q(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Aa(e,r)}const lte=ce({grayscaleToRGB_:ate});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(n){const e=Z(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];q(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),q(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=gt(e,"float32"),o=Kr([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Vm("ij,j->i",i,o);break;case 3:a=Vm("ijk,k->ij",i,o);break;case 4:a=Vm("ijkl,l->ijk",i,o);break;case 5:a=Vm("ijklm,m->ijkl",i,o);break;case 6:a=Vm("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=pi(a,-1),gt(a,r)}const cte=ce({rgbToGrayscale_:ute});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hte(n,e,t=0,s=.5){const r=Z(n,"image","rotateWithOffset","float32");q(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:t,center:s};return he.runKernel(KN,i,o)}const dte=ce({rotateWithOffset_:hte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $g(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),q(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),q(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),q(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),q(e.rank===1,()=>"scores must be a 1D tensor"),q(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),q(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=Z(n,"boxes","nonMaxSuppression","float32"),o=Z(e,"scores","nonMaxSuppression","float32"),a=$g(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return he.runKernel(_N,{boxes:i,scores:o},l)}const pte=ce({nonMaxSuppression_:fte});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(n,e,t){const s=gte(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function gte(n,e,t){return xte(n,e,t||yte)}function yte(n,e){return n>e?1:n<e?-1:0}function xte(n,e,t){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=t(e,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DA(n,e,t,s,r){return OA(n,e,t,s,r,0)}function PA(n,e,t,s,r,i){return OA(n,e,t,s,r,0,!1,i,!0)}function LA(n,e,t,s,r,i){return OA(n,e,t,s,r,i,!0)}function OA(n,e,t,s,r,i,o=!1,a=!1,l=!1){const u=[];for(let x=0;x<e.length;x++)e[x]>r&&u.push({score:e[x],boxIndex:x,suppressBeginIndex:0});u.sort(aP);const c=i>0?-.5/i:0,h=[],f=[];for(;h.length<t&&u.length>0;){const x=u.pop(),{score:w,boxIndex:_,suppressBeginIndex:T}=x;if(w<r)break;let C=!1;for(let N=h.length-1;N>=T;--N){const M=vte(n,_,h[N]);if(M>=s){C=!0;break}if(x.score=x.score*wte(s,c,M),x.score<=r)break}x.suppressBeginIndex=h.length,C||(x.score===w?(h.push(_),f.push(x.score)):x.score>r&&mte(u,x,aP))}const p=h.length,g=t-p;a&&g>0&&(h.push(...new Array(g).fill(0)),f.push(...new Array(g).fill(0)));const S={selectedIndices:h};return o&&(S.selectedScores=f),l&&(S.validOutputs=p),S}function vte(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),f=Math.max(r[1],r[3]),p=(a-i)*(l-o),g=(h-u)*(f-c);if(p<=0||g<=0)return 0;const S=Math.max(i,u),x=Math.max(o,c),w=Math.min(a,h),_=Math.min(l,f),T=Math.max(w-S,0)*Math.max(_-x,0);return T/(p+g-T)}function wte(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function aP(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ste(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=Z(n,"boxes","nonMaxSuppressionAsync"),o=Z(e,"scores","nonMaxSuppressionAsync"),a=$g(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:h}=DA(u,c,t,s,r);return i!==n&&i.dispose(),o!==e&&o.dispose(),Kr(h,"int32")}const bte=Ste;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _te(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=Z(n,"boxes","nonMaxSuppression"),a=Z(e,"scores","nonMaxSuppression"),l=$g(o,a,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},h=he.runKernel(CN,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const Tte=ce({nonMaxSuppressionWithScore_:_te});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Cte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=Z(n,"boxes","nonMaxSuppressionAsync"),a=Z(e,"scores","nonMaxSuppressionAsync"),l=$g(o,a,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:f,selectedScores:p}=LA(c,h,t,s,r,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Kr(f,"int32"),selectedScores:Kr(p)}}const Ete=Cte;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ite(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=Z(n,"boxes","nonMaxSuppression"),a=Z(e,"scores","nonMaxSuppression"),l=$g(o,a,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,f={boxes:o,scores:a},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:i},g=he.runKernel(TN,f,p);return{selectedIndices:g[0],validOutputs:g[1]}}const Nte=ce({nonMaxSuppressionPadded_:Ite});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ate(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=Z(n,"boxes","nonMaxSuppressionAsync"),a=Z(e,"scores","nonMaxSuppressionAsync"),l=$g(o,a,t,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[f,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:S}=PA(f,p,u,c,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Kr(g,"int32"),validOutputs:Ht(S,"int32")}}const Mte=Ate;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kte(n,e,t=!1,s=!1){const r=Z(n,"images","resizeBilinear");q(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),q(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),q(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},u=he.runKernel(a_,a,l);return o?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const hz=ce({resizeBilinear_:kte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte(n,e,t=!1,s=!1){const r=Z(n,"images","resizeNearestNeighbor");q(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),q(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),q(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),q(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},u=he.runKernel(o_,a,l);return o?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const dz=ce({resizeNearestNeighbor_:Rte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(n,e="binary",t=!1,s=.5){const r=Z(n,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let u=de(Kr([s]),255),c,h,f,p;if(q(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),q(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),q(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),q(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,f]=Po(r,[1,1,1],-1);const x=de(c,i),w=de(h,o),_=de(f,a);p=Ze(Ze(x,w),_)}else p=n;if(e==="otsu"){const x=w$(gt(xA(p),"int32"),wl([]),256);u=Pte(x,l)}const g=t?Yf(p,u):Wo(p,u);return gt(de(g,255),"int32")}function Pte(n,e){let t=Kr([-1]),s=Kr([0]),r=Kr([0]),i,o,a,l,u,c;for(let h=0;h<n.size-1;h++){i=mn(n,0,h+1),o=mn(n,h+1),u=Rt(kt(i),e),c=Rt(kt(o),e);const f=kt(de(i,gg(0,i.size)));a=Rt(f,kt(i));const p=Lg(o.shape,i.size),g=Ze(gg(0,o.size),p),S=de(o,g);l=Rt(kt(S),kt(o));const x=Tt(a,l),w=Tt(a,l),_=de(u,c);r=de(de(_,x),w);const T=Wo(r,s);s=mi(T,r,s),t=mi(T,Kr([h]),t)}return t}const Lte=ce({threshold_:Dte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ote(n,e,t="nearest",s="constant",r=0,i){const o=Z(n,"image","transform","float32"),a=Z(e,"transforms","transform","float32");q(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),q(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),q(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},u={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return he.runKernel(XN,l,u)}const Fte=ce({transform_:Ote});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $te(n,e,t){const s=Z(n,"a","bandPart");q(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let a,l;typeof e=="number"?(q(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),q(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=Z(e<0?i:e,"numLower","bandPart")):(q(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=mi(z0(e,0),i,Uf(e,i))),typeof t=="number"?(q(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),q(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=Z(t<0?o:t,"numUpper","bandPart")):(q(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=mi(z0(t,0),o,Uf(t,o)));const u=pe(gg(0,i,1,"int32"),[-1,1]),c=gg(0,o,1,"int32"),h=Tt(u,c),f=fu(Yf(h,a),rd(h,ys(l))),p=yr([i,o],s.dtype);return pe($o(Oa(pe(s,[-1,i,o])).map(g=>mi(f,g,p))),r)}const zte=ce({bandPart_:$te});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ute(n){let e;if(Array.isArray(n)){e=!1,q(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)q(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=Po(n,n.shape[0],0).map(r=>mc(r,[0]));q(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(he.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=de(kt(de(t[o],i)),t[o]);i=Tt(i,a)}return Rt(i,fv(i,"euclidean"))}));return e?$o(t,0):t}const Bte=ce({gramSchmidt_:Ute});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vte(n,e=!1){if(q(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return lP(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),s=Oa(pe(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[u,c]=lP(l,e);r.push(u),i.push(c)});const o=pe($o(r,0),n.shape),a=pe($o(i,0),n.shape);return[o,a]}}function lP(n,e=!1){return he.tidy(()=>{q(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=cA(t),i=uc(n);const o=tg([[1]],[1,1]);let a=uc(o);const l=t>=s?s:t;for(let u=0;u<l;++u){const c=i,h=a,f=r;[a,i,r]=he.tidy(()=>{const p=mn(i,[u,u],[t-u,1]),g=fv(p),S=mn(i,[u,u],[1,1]),x=mi(Wo(S,0),tg([[-1]]),tg([[1]])),w=Tt(S,de(x,g)),_=Rt(p,w);_.shape[0]===1?a=uc(o):a=ir([o,mn(_,[1,0],[_.shape[0]-1,_.shape[1]])],0);const T=ys(Rt(In(x,w),g)),C=mn(i,[u,0],[t-u,s]),N=de(T,a),M=Dn(a);if(u===0)i=Tt(C,In(N,In(M,C)));else{const R=Tt(C,In(N,In(M,C)));i=ir([mn(i,[0,0],[u,s]),R],0)}const P=Dn(N),$=mn(r,[0,u],[t,r.shape[1]-u]);if(u===0)r=Tt($,In(In($,a),P));else{const R=Tt($,In(In($,a),P));r=ir([mn(r,[0,0],[t,u]),R],1)}return[a,i,r]}),Tn([c,h,f])}return!e&&t>s&&(r=mn(r,[0,0],[t,s]),i=mn(i,[0,0],[s,s])),[r,i]})}const Wte=ce({qr_:Vte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var to;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(to||(to={}));function Gte(n,e,t=to.SUM_BY_NONZERO_WEIGHTS){const s=Z(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=Z(e,"weights","computeWeightedLoss"));const i=r==null?s:de(s,r);if(t===to.NONE)return i;if(t===to.SUM)return kt(i);if(t===to.MEAN){if(r==null)return $s(i);{const o=s.size/r.size,a=Rt(kt(i),kt(r));return o>1?Rt(a,Ht(o)):a}}if(t===to.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Rt(kt(i),Ht(s.size));{const o=de(r,ko(s.shape)),a=gt(kt(mg(o,Ht(0))),"float32");return Rt(kt(i),a)}}throw Error(`Unknown reduction: ${t}`)}const _c=ce({computeWeightedLoss_:Gte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hte(n,e,t,s=to.SUM_BY_NONZERO_WEIGHTS){const r=Z(n,"labels","absoluteDifference"),i=Z(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=Z(t,"weights","absoluteDifference")),Vo(r.shape,i.shape,"Error in absoluteDifference: ");const a=gr(Tt(r,i));return _c(a,o,s)}const jte=ce({absoluteDifference_:Hte});function Xte(n,e,t,s,r=to.SUM_BY_NONZERO_WEIGHTS){const i=Z(n,"labels","cosineDistance"),o=Z(e,"predictions","cosineDistance");let a=null;s!=null&&(a=Z(s,"weights","cosineDistance")),Vo(i.shape,o.shape,"Error in cosineDistance: ");const l=Ht(1),u=Tt(l,kt(de(i,o),t,!0));return _c(u,a,r)}const qte=ce({cosineDistance_:Xte});function Kte(n,e,t,s=to.SUM_BY_NONZERO_WEIGHTS){let r=Z(n,"labels","hingeLoss");const i=Z(e,"predictions","hingeLoss");let o=null;t!=null&&(o=Z(t,"weights","hingeLoss")),Vo(r.shape,i.shape,"Error in hingeLoss: ");const a=Ht(1);r=Tt(de(Ht(2),r),a);const l=yu(Tt(a,de(r,i)));return _c(l,o,s)}const Yte=ce({hingeLoss_:Kte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zte(n,e,t,s=1,r=to.SUM_BY_NONZERO_WEIGHTS){const i=Z(n,"labels","huberLoss"),o=Z(e,"predictions","huberLoss");let a=null;t!=null&&(a=Z(t,"weights","huberLoss")),Vo(i.shape,o.shape,"Error in huberLoss: ");const l=Ht(s),u=gr(Tt(o,i)),c=Uf(u,l),h=Tt(u,c),f=Ze(de(Ht(.5),os(c)),de(l,h));return _c(f,a,r)}const Jte=ce({huberLoss_:Zte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(n,e,t,s=1e-7,r=to.SUM_BY_NONZERO_WEIGHTS){const i=Z(n,"labels","logLoss"),o=Z(e,"predictions","logLoss");let a=null;t!=null&&(a=Z(t,"weights","logLoss")),Vo(i.shape,o.shape,"Error in logLoss: ");const l=Ht(1),u=Ht(s),c=ys(de(i,aa(Ze(o,u)))),h=de(Tt(l,i),aa(Ze(Tt(l,o),u))),f=Tt(c,h);return _c(f,a,r)}const ene=ce({logLoss_:Qte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tne(n,e,t,s=to.SUM_BY_NONZERO_WEIGHTS){const r=Z(n,"labels","meanSquaredError"),i=Z(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=Z(t,"weights","meanSquaredError")),Vo(r.shape,i.shape,"Error in meanSquaredError: ");const a=EA(r,i);return _c(a,o,s)}const nne=ce({meanSquaredError_:tne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sne(n,e){const t=Z(n,"labels","sigmoidCrossEntropyWithLogits"),s=Z(e,"logits","sigmoidCrossEntropyWithLogits");Vo(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=yu(s),i=de(s,t),o=C_(Fo(ys(gr(s))));return Ze(Tt(r,i),o)}function rne(n,e,t,s=0,r=to.SUM_BY_NONZERO_WEIGHTS){let i=Z(n,"multiClassLabels","sigmoidCrossEntropy");const o=Z(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=Z(t,"weights","sigmoidCrossEntropy")),Vo(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const u=Ht(s),c=Ht(1),h=Ht(.5);i=Ze(de(i,Tt(c,u)),de(h,u))}const l=sne(i,o);return _c(l,a,r)}const ine=ce({sigmoidCrossEntropy_:rne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return pc((r,i,o)=>{const l=E_(i,[t],!0),u=Tt(gt(i,"float32"),l);o([r,u]);const c=ys(de(u,r));return{value:kt(c,[t]),gradFunc:(p,g)=>{const[S,x]=g,w=js(p.shape,[t]);return[de(pe(p,w),Tt(gt(S,"float32"),Fo(x))),de(pe(p,w),Tt(Fo(x),gt(S,"float32")))]}}})(n,e)}function ane(n,e,t,s=0,r=to.SUM_BY_NONZERO_WEIGHTS){let i=Z(n,"onehotLabels","softmaxCrossEntropy");const o=Z(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=Z(t,"weights","softmaxCrossEntropy")),Vo(i.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const u=Ht(s),c=Ht(1),h=Ht(i.shape[1]);i=Ze(de(i,Tt(c,u)),Rt(u,h))}const l=one(i,o);return _c(l,a,r)}const lne=ce({softmaxCrossEntropy_:ane});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(n,e,t,s){const r=Z(n,"indices","sparseFillEmptyRows","int32"),i=Z(e,"values","sparseFillEmptyRows"),o=Z(t,"denseShape","sparseFillEmptyRows","int32"),a=Z(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:i,denseShape:o,defaultValue:a},u=he.runKernel(ON,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const cne=ce({sparseFillEmptyRows_:une});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hne(n,e,t){const s=Z(n,"inputIndices","sparseReshape","int32"),r=Z(e,"inputShape","sparseReshape","int32"),i=Z(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:s,inputShape:r,newShape:i},a=he.runKernel(FN,o);return{outputIndices:a[0],outputShape:a[1]}}const dne=ce({sparseReshape_:hne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(n,e,t){const s=Z(n,"data","sparseSegmentMean"),r=Z(e,"indices","sparseSegmentMean","int32"),i=Z(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return he.runKernel($N,o)}const pne=ce({sparseSegmentMean_:fne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(n,e,t){const s=Z(n,"data","sparseSegmentSum"),r=Z(e,"indices","sparseSegmentSum","int32"),i=Z(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return he.runKernel(zN,o)}const gne=ce({sparseSegmentSum_:mne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(n,e,t,s,r,i,o,a){const l=Z(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=Z(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:u},f=he.runKernel(WN,h,c);return{nGrams:f[0],nGramsSplits:f[1]}}const xne=ce({stringNGrams_:yne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vne(n,e,t=!0){const s=Z(n,"input","stringSplit","string"),r=Z(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},o={input:s,delimiter:r},a=he.runKernel(GN,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const wne=ce({stringSplit_:vne});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(n,e){const t=Z(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return he.runKernel(HN,r,s)}const bne=ce({stringToHashBucketFast_:Sne});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ne(n,e,t,s=!0){const r=Z(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:s};return he.runKernel(m_,{x:r},i)}const Tne=ce({staticRegexReplace_:_ne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cne={fft:O_,ifft:V0,rfft:F_,irfft:CA},Ene={hammingWindow:Jee,hannWindow:uz,frame:cz,stft:nte},Ro={flipLeftRight:ote,grayscaleToRGB:lte,resizeNearestNeighbor:dz,resizeBilinear:hz,rgbToGrayscale:cte,rotateWithOffset:dte,cropAndResize:rte,nonMaxSuppression:pte,nonMaxSuppressionAsync:bte,nonMaxSuppressionWithScore:Tte,nonMaxSuppressionWithScoreAsync:Ete,nonMaxSuppressionPadded:Nte,nonMaxSuppressionPaddedAsync:Mte,threshold:Lte,transform:Fte},fz={bandPart:zte,gramSchmidt:Bte,qr:Wte},Ine={absoluteDifference:jte,computeWeightedLoss:_c,cosineDistance:qte,hingeLoss:Yte,huberLoss:Jte,logLoss:ene,meanSquaredError:nne,sigmoidCrossEntropy:ine,softmaxCrossEntropy:lne},Nne={sparseFillEmptyRows:cne,sparseReshape:dne,sparseSegmentMean:pne,sparseSegmentSum:gne},Ane={stringNGrams:xne,stringSplit:wne,stringToHashBucketFast:bne,staticRegexReplace:Tne};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mne=new Map,kne=new Map;class zg{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Na{constructor(){this.classNameMap={}}static getMap(){return Na.instance==null&&(Na.instance=new Na),Na.instance}static register(e){Na.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function tt(n,e,t){q(n.className!=null,()=>"Class being registered does not have the static className property defined."),q(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),q(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return Na.register(n),Mne.set(r,n),kne.set(n,r),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class od extends zg{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Tn(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return tJ(e,t)}dispose(){this.iterations_!=null&&Tn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ht(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(od,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pz extends od{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=he.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=he.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:be(()=>Pn(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:be(()=>Pn(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;be(()=>{const c=Ze(de(l,this.rho),de(os(a),1-this.rho)),h=de(Rt(yi(Ze(u,this.epsilon)),yi(Ze(l,this.epsilon))),a),f=Ze(de(u,this.rho),de(os(h),1-this.rho));l.assign(c),u.assign(f);const p=Ze(de(h,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Tn(this.accumulatedGrads.map(e=>e.variable)),Tn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mz extends od{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=he.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:be(()=>Lg(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[r].variable;be(()=>{const l=Ze(a,os(o));a.assign(l);const u=Ze(de(Rt(o,yi(Ze(l,he.backend.epsilon()))),-this.learningRate),i);i.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Tn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gz extends od{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],be(()=>{this.accBeta1=Ht(t).variable(),this.accBeta2=Ht(s).variable()}),r==null&&(this.epsilon=he.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);be(()=>{const s=Tt(1,this.accBeta1),r=Tt(1,this.accBeta2);t.forEach((i,o)=>{const a=he.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:be(()=>Pn(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:be(()=>Pn(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=Ze(de(c,this.beta1),de(u,1-this.beta1)),p=Ze(de(h,this.beta2),de(os(u),1-this.beta2)),g=Rt(f,s),S=Rt(p,r);c.assign(f),h.assign(p);const x=Ze(de(Rt(g,Ze(yi(S),this.epsilon)),-this.learningRate),a);a.assign(x)}),this.accBeta1.assign(de(this.accBeta1,this.beta1)),this.accBeta2.assign(de(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Tn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Tn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),be(()=>{this.accBeta1.assign(zh(this.beta1,this.iterations_+1)),this.accBeta2.assign(zh(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yz extends od{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],be(()=>{this.iteration=Ht(0).variable(),this.accBeta1=Ht(t).variable()}),r==null&&(this.epsilon=he.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);be(()=>{const s=Tt(1,this.accBeta1),r=Rt(-this.learningRate,Ze(de(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=he.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Pn(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Pn(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=Ze(de(c,this.beta1),de(u,1-this.beta1)),p=de(h,this.beta2),g=gr(u),S=bc(p,g);c.assign(f),h.assign(S);const x=Ze(de(Rt(r,s),Rt(f,Ze(S,this.epsilon))),a);a.assign(x)}),this.iteration.assign(Ze(this.iteration,1)),this.accBeta1.assign(de(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Tn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Tn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FA extends od{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=he.registeredVariables[s];be(()=>{const a=Ze(de(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Pr(Ht(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xz extends FA{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Ht(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=he.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:be(()=>Pn(i).variable(!1))});const o=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&be(()=>{let l;const u=Ze(de(this.m,o),a);this.useNesterov?l=Ze(de(this.c,Ze(a,de(u,this.m))),i):l=Ze(de(this.c,u),i),o.assign(u),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Tn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vz extends od{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=he.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=he.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:be(()=>Pn(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:be(()=>Pn(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:be(()=>Pn(i).variable(o))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;be(()=>{const c=Ze(de(l,this.decay),de(os(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,f=Ze(de(h,this.decay),de(a,1-this.decay)),p=Rt(de(a,this.learningRate),yi(Tt(c,Ze(os(f),this.epsilon)))),g=Ze(de(u,this.momentum),p);l.assign(c),h.assign(f),u.assign(g);const S=Tt(i,g);i.assign(S)}else{const h=Ze(de(l,this.decay),de(os(a),1-this.decay)),f=Ze(de(u,this.momentum),Rt(de(a,this.learningRate),yi(Ze(h,this.epsilon))));l.assign(h),u.assign(f);const p=Tt(i,f);i.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Tn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Tn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Tn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rne=[pz,mz,gz,yz,xz,vz,FA];function Dne(){for(const n of Rne)tt(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pne="model",Lne=".json",One=".weights.bin";function uP(n){return new Promise(e=>setTimeout(e)).then(n)}class Bf{constructor(e){if(!Te().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Bf.URL_SCHEME)&&(e=e.slice(Bf.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Pne),this.modelJsonFileName=e+Lne,this.weightDataFileName=e+One}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=kl.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=ZF(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await uP(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await uP(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:lv(e)}}}}Bf.URL_SCHEME="downloads://";class Fne{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),o=i.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=QN(i,u=>this.loadWeights(u));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const o of e)t.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(e),i=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(i).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((s,r)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;s(a)},i.onerror=o=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(i=>JD(i.name)),r={};for(const i of e)i.paths.forEach(o=>{const a=JD(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const $ne=n=>Te().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Bf.URL_SCHEME)?zne(n.slice(Bf.URL_SCHEME.length)):null;As.registerSaveRouter($ne);function zne(n="model"){return new Bf(n)}function Une(n){return new Fne(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cP(n,e,t,s){o(n),t=t??0,s=s??1,a(t,s);let r=0;const i=l=>(l.then(u=>{const c=t+ ++r/n.length*(s-t);return e(c),u}),l);function o(l){q(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){q(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),q(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),q(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function wz(n,e){e==null&&(e={});const t=e.fetchFunc==null?Te().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(s):await cP(s,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(a):await cP(a,e.onProgress,.5,1)}function Bne(n,e){var t;const s=e.fetchFunc==null?Te().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var a;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await i.read();if(l){r++,i=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,r/n.length);continue}o.enqueue(u);return}o.close()}})}async function Vne(n,e="",t,s){return Sz(o=>wz(o,{requestInit:s}))(n,e,t)}function Sz(n){return async(e,t="",s)=>{const r=e.map(()=>!1),i={},o=s!=null?s.map(()=>!1):[],a=[];if(e.forEach((p,g)=>{let S=0;p.weights.forEach(x=>{const w="quantization"in x?x.quantization.dtype:x.dtype,_=Of[w]*Oe(x.shape),T=()=>{r[g]=!0,i[g]==null&&(i[g]=[]),i[g].push({manifestEntry:x,groupOffset:S,sizeBytes:_})};s!=null?s.forEach((C,N)=>{C===x.name&&(T(),o[N]=!0)}):T(),a.push(x.name),S+=_})}),!o.every(p=>p)){const p=s.filter((g,S)=>!o[S]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,g,S)=>(g&&p.push(S),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(g=>{const S=t+(t.endsWith("/")?"":"/")+g;u.push(S)})});const c=await n(u),h={};let f=0;return l.forEach(p=>{const g=e[p].paths.length,S=new kl(c.slice(f,f+g));i[p].forEach(w=>{const _=S.slice(w.groupOffset,w.groupOffset+w.sizeBytes),T=XF(_,[w.manifestEntry]);for(const C in T)h[C]=T[C]}),f+=g}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wne="application/octet-stream",Gne="application/json";class $A{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(q(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Te().platform.fetch,q(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&q(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=ZF(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Gne}),"model.json"),e.weightData!=null){const o=kl.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:Wne}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:lv(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return QN(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=f2(e.weightsManifest),r=()=>Bne(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=Hne(t),i=this.weightPathPrefix||s,o=[],a=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(u)):o.push(i+u+r);return this.weightUrlConverter&&o.push(...await Promise.all(a)),o}async loadWeights(e){const t=await this.getWeightUrls(e),s=f2(e),r=await wz(t,this.loadOptions);return[s,r]}}$A.URL_SCHEME_REGEX=/^https?:\/\//;function Hne(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function w2(n){return n.match($A.URL_SCHEME_REGEX)!=null}const bz=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>w2(s)):t=w2(n),t)return zA(n,e)}return null};As.registerSaveRouter(bz);As.registerLoadRouter(bz);function zA(n,e){return new $A(n,e)}function jne(n,e){return zA(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jC{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class _z{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Xne{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function qne(n,e,t,s){const r=arguments;return new Xne(Tz(...r))}function Tz(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new jC(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new jC({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new jC({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function Kne(n){return new _z(n)}function Yne(n){return new _z(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cz=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:kl,browserFiles:Une,browserHTTPRequest:jne,concatenateArrayBuffers:YF,copyModel:YK,decodeWeights:XF,decodeWeightsStream:KF,encodeWeights:d2,fromMemory:qne,fromMemorySync:Tz,getLoadHandlers:OK,getModelArtifactsForJSON:QN,getModelArtifactsForJSONSync:JF,getModelArtifactsInfoForJSON:lv,getSaveHandlers:QF,getWeightSpecs:f2,http:zA,isHTTPScheme:w2,listModels:qK,loadWeights:Vne,moveModel:ZK,registerLoadRouter:LK,registerSaveRouter:PK,removeModel:KK,weightsLoaderFactory:Sz,withSaveHandler:Kne,withSaveHandlerSync:Yne},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sf;function Zne(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(o2(r2,he.backendName)!=null){const g={pixels:n},S={numChannels:e};return he.runKernel(r2,g,S)}const[u,c]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,u,c).data;else if(s||t)h=n.data;else if(i||r||a){if(sf==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")sf=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else sf=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});sf.canvas.width=u,sf.canvas.height=c,sf.drawImage(n,0,0,u,c),h=sf.getImageData(0,0,u,c).data}let f;if(e===4)f=new Int32Array(h);else{const g=u*c;f=new Int32Array(g*e);for(let S=0;S<g;S++)for(let x=0;x<e;++x)f[S*e+x]=h[S*4+x]}return J$(f,[c,u,e],"int32")}const Jne=ce({fromPixels_:Zne});function UA(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Oe(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=n.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<t;++h)u*=a[h],l.push(a[h]);const c=[...Wt(n.shape).map(h=>h/u),1].slice(0,i);return[l,o,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2=-2,Qne=-1;function BA(n,e,t){const s=n.shape.length;q(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),q(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)q(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function ese(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function VA(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function Ez(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Iz(n,e,t){return t<=n?t:t-(e-1)}function Nz(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function tse(n,e,t,s,r,i,o,a,l){const u=n.length;let c=new Array(u),h=new Array(u),f=new Array(u);if(e.length&&t>0){const p=e[0],g=t+1;c=Az(o,p,g,s,n),h=Mz(a,p,g,r,n),f=Ez(i,p,g,n)}else for(let p=0;p<u;p++)c[p]=Rz(o,s,i,n,p,l),h[p]=Dz(a,r,i,n,p,l),f[p]=kz(i,p,l);return{begin:c,end:h,strides:f}}function Az(n,e,t,s,r){const i=[...r],o=Nz(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=Iz(e,t,a);let u=s[l];n&1<<l&&(u=0),i[a]=u}return i}function Mz(n,e,t,s,r){const i=[...r],o=Nz(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=Iz(e,t,a);let u=s[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),i[a]=u}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=Df(0,i[a],r[a])}return i}function kz(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function Rz(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=Df(0,o,l-1),o}function Dz(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),a>0?o=Df(0,o,l):o=Df(-1,o,l-1),o}function WA(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function GA(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function V_(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{q(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(q(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}function HA(n,e,t,s,r,i,o,a,l){let u;if(s==null?(u=new Array(e.length),u.fill(1)):u=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let T=0;T<h.dims;T++)c&&(1<<T&a)!==0&&h.numAddAxisAfterEllipsis++,1<<T&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};nse(h,f);let p=!0,g=!0,S=!0;const x=[],w=[];for(let T=0;T<n.length;++T){if(f.strides[T]===0)throw Error(`strides[${T}] must be non-zero`);const C=!!(f.shrinkAxisMask&1<<T),N=n[T];if(N===-1){x.push(C?1:-1);continue}const M=[f.beginMask&1<<T,f.endMask&1<<T],P=[f.strides[T]>0?0:-1,f.strides[T]>0?N:N-1];if(C&&f.strides[T]<=0)throw Error("only stride 1 allowed on non-range indexing.");S=S&&f.strides[T]===1;const $=!!(f.beginMask&1<<T&&f.endMask&1<<T);if(f.beginValid&&f.endValid){if(C){const G=f.begin[T]<0?N+f.begin[T]:f.begin[T];if(f.begin[T]=G,f.end[T]=f.begin[T]+1,G<0||G>=N)throw Error(`slice index ${f.begin[T]} of dimension ${T} out of bounds.`)}else f.begin[T]=hP(f.begin[T],0,f.strides[T],N,M,P),f.end[T]=hP(f.end[T],1,f.strides[T],N,M,P);const L=f.strides[T]===1&&f.begin[T]===0&&f.end[T]===N;p=p&&L,g=g&&(T===0&&f.strides[T]===1||L)}else p=p&&f.strides[T]===1&&$,g=g&&(T===0&&f.strides[T]===1||$);let R,D=!1;if(f.beginValid&&f.endValid?(R=f.end[T]-f.begin[T],D=!0):C?(R=1,D=!0):$&&N>=0&&(f.strides[T]<0?R=-N:R=N,D=!0),D){let L;R===0||R<0!=f.strides[T]<0?L=0:L=Math.trunc(R/f.strides[T])+(R%f.strides[T]!==0?1:0),x.push(L)}else x.push(-1)}for(let T=0;T<f.finalShapeGatherIndices.length;++T){const C=f.finalShapeGatherIndices[T];C>=0?w.push(x[C]):C===S2&&w.push(1)}return{finalShapeSparse:w.filter((T,C)=>f.finalShapeGatherIndices[C]!==S2),finalShape:w,isIdentity:p,sliceDim0:g,isSimpleSlice:S,begin:f.begin,end:f.end,strides:f.strides}}function nse(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(S2),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(Qne),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function hP(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const sse=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:BA,computeFlatOffset:GA,computeOutShape:VA,getNormalizedAxes:tse,isSliceContinous:WA,maskToAxes:ese,parseSliceParams:V_,sliceInfo:HA,startForAxis:Rz,startIndicesWithElidedDims:Az,stopForAxis:Dz,stopIndicesWithElidedDims:Mz,stridesForAxis:kz,stridesWithElidedDims:Ez},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rse{static sgd(e){return new FA(e)}static momentum(e,t,s=!1){return new xz(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new vz(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new gz(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new pz(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new yz(e,t,s,r,i)}static adagrad(e,t=.1){return new mz(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dm=rse;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ise=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function Pz(){return new Promise(n=>ise(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(n,e){const t=n[0].length;n.forEach((r,i)=>{q(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),q(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<t;o++)q(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function uu(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yl;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(yl||(yl={}));function Lz(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],o=s[s.length-t.length+r],a=s[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${a}`)}else s[o]=i}return s}function Oz(n){const e={FIRST_DIM_SIZE:yl.FIRST_DIM_SIZE,VALUE_ROWIDS:yl.VALUE_ROWIDS,ROW_LENGTHS:yl.ROW_LENGTHS,ROW_SPLITS:yl.ROW_SPLITS,ROW_LIMITS:yl.ROW_LIMITS,ROW_STARTS:yl.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function Fz(n){return n.length===0?0:n[0]===yl.FIRST_DIM_SIZE?n.length-1:n.length}function $z(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],o=e[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XA=30;function W_(n){return n<=XA?n:t2(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(i+1))}return r}function yv(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function xv(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function KA(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function YA(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G_=1.7580993408473768,H_=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZA=.3275911,JA=.254829592,QA=-.284496736,eM=1.421413741,tM=-1.453152027,nM=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function zz(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function Uz(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Bz(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function sM(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function Vz(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function Wz(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function Gz(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XC="->",ose=/->/g,dP=",",fP="...";function rM(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(ose,"").length)/XC.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${XC}").`);const[s,r]=n.split(XC);q(s.indexOf(fP)===-1,()=>`The ellipsis notation ("${fP}") is not supported yet.`);const i=s.split(dP),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<r.length;++f){const p=r[f];if(!i.some(g=>g.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let f=0;f<s.length;++f){const p=s[f];a.indexOf(p)===-1&&p!==dP&&a.push(p)}const l=new Array(i.length);for(let f=0;f<o;++f){if(new Set(i[f].split("")).size!==i[f].length)throw new Error(`Found duplicate axes in input component ${i[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let p=0;p<i[f].length;++p)l[f].push(a.indexOf(i[f][p]))}const u=a.length,c=r.length,h=[];for(let f=c;f<u;++f)h.push(f);return{allDims:a,summedDims:h,idDims:l}}function iM(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function oM(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:q(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function aM(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=ase(e,a);for(const u of l)i.indexOf(u)===-1&&(s[o].push(u),i.push(u))}return{path:t,steps:s}}function lM(n){return n.every((e,t)=>e===t)}function ase(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function uM(n,e,t=0){let s=[];if(typeof e=="number")q(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);q(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}q(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function jz(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Xz(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qz(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Kz(n,e){return`size ${n} must be non-negative, not ${e}`}function Yz(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Zz(n,e){const t=Oe(n),s=Oe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function Jz(n,e){const t=Oe(n),s=Oe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b2(){return"segment ids must be >= 0"}function Qz(){return"segment ids are not increasing"}function eU(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function tU(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n,e){let t=!1,s;for(n<=XA?(s=n,t=!0):s=t2(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=t2(n,s+1);return s}function sU(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function cM(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)a.push(n.shape[h]),u*=n.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=t+1;h<i;h++)a.push(n.shape[h]),c*=n.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}const lse=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:cM,computeOutShape:sU,segOpComputeOptimalWindowSize:nU},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yc(n){try{return n.map(e=>Ph(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function rU(n){return n.map(e=>Nh(e))}const use=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:JA,ERF_A2:QA,ERF_A3:eM,ERF_A4:tM,ERF_A5:nM,ERF_P:ZA,PARALLELIZE_THRESHOLD:XA,get RowPartitionType(){return yl},SELU_SCALE:H_,SELU_SCALEALPHA:G_,applyActivation:U_,assertAndGetBroadcastShape:dn,assertAxesAreInnerMostDims:Jr,assertParamsConsistent:jA,assignToTypedArray:Vz,axesAreInnerMostDims:uA,calculateShapes:Jf,checkEinsumDimSizes:oM,checkPadOnDimRoundingMode:zi,combineLocations:D$,combineRaggedTensorToTensorShapes:Lz,complexWithEvenIndex:Uz,complexWithOddIndex:Bz,computeConv2DInfo:$r,computeConv3DInfo:nd,computeDefaultPad:nA,computeDilation2DInfo:uv,computeOptimalWindowSize:W_,computeOutAndReduceShapes:zr,computeOutShape:uu,computePool2DInfo:Fa,computePool3DInfo:wc,convertConv2DDataFormat:Sc,decodeEinsumEquation:rM,eitherStridesOrDilationsAreOne:Zr,expandShapeToKeepDim:js,exponent:Gz,exponents:Wz,fromStringArrayToUint8:rU,fromUint8ToStringArray:yc,getAxesPermutation:ks,getBroadcastDims:pg,getComplexWithIndex:sM,getEinsumComputePath:aM,getEinsumPermutation:iM,getFusedBiasGradient:z_,getFusedDyActivation:$_,getImageCenter:qA,getInnerMostAxes:Xs,getPermuted:yv,getRaggedRank:Fz,getReductionAxes:_r,getReshaped:gv,getReshapedPermuted:xv,getRowPartitionTypesHelper:Oz,getSliceBeginCoords:KA,getSliceSize:YA,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Hz,getSparseFillEmptyRowsNegativeIndexErrorMessage:jz,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Xz,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Yz,getSparseReshapeInputOutputMismatchErrorMessage:Jz,getSparseReshapeInputOutputMultipleErrorMessage:Zz,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:qz,getSparseReshapeNegativeOutputDimErrorMessage:Kz,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:tU,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:b2,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Qz,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:eU,getUndoAxesPermutation:sd,isIdentityPermutation:lM,log:Y7,mergeRealAndImagArrays:gc,prepareAndValidate:UA,prepareSplitSize:uM,segment_util:lse,shouldFuse:B_,slice_util:sse,splitRealAndImagArrays:zz,stridesOrDilationsArePositive:zf,tupleValuesAreOne:Fh,upcastType:Lo,validateDefaultValueShape:$z,validateInput:IA,validateUpdateShape:Q$,warn:ra},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dne();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iU={kernelName:gb,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,Fg(gt(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cse={kernelName:fx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=os(gt(t,"float32")),r=yi(Tt(Ht(1),s));return ys(Rt(n,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hse={kernelName:px,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=yi(Tt(os(gt(t,"float32")),1));return Rt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dse={kernelName:Pg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{let a=n;const l=_r(t.shape,r);return l.length>0&&(a=kt(a,l)),pe(a,t.shape)},b:()=>{let a=n;const l=_r(s.shape,r);return l.length>0&&(a=kt(a,l)),pe(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fse={kernelName:yb,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pse={kernelName:xb,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pn(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mse={kernelName:vb,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Pn(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gse={kernelName:mx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,yi(Tt(Ht(1),os(gt(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yse={kernelName:gx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=yi(Ze(Ht(1),os(gt(t,"float32"))));return Rt(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xse={kernelName:vx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{const a=Ze(os(t),os(s));let l=de(n,Rt(s,a));const u=_r(t.shape,r);return u.length>0&&(l=kt(l,u)),pe(l,t.shape)},b:()=>{const a=Ze(os(t),os(s));let l=ys(de(n,Rt(t,a)));const u=_r(s.shape,r);return u.length>0&&(l=kt(l,u)),pe(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vse={kernelName:yx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,Ze(os(gt(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wse={kernelName:xx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,Tt(Ht(1),os(gt(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(n,e,t,s,r,i){const o=Z(n,"dy","avgPool3dGrad"),a=Z(e,"input","avgPool3dGrad");let l=o,u=a,c=!1;a.rank===4&&(c=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),q(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),q(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),zi("avgPool3dGrad",r,i);const h={dy:l,input:u},f={filterSize:t,strides:s,pad:r,dimRoundingMode:i},p=he.runKernel(KI,h,f);return c?pe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const bse=ce({avgPool3dGrad_:Sse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _se={kernelName:Sb,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>bse(n,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tse(n,e,t,s,r){const i=Z(n,"dy","avgPoolGrad"),o=Z(e,"input","avgPoolGrad");q(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;o.rank===3&&(u=!0,a=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),q(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),q(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:t,strides:s,pad:r},f=he.runKernel(qI,c,h);return u?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Cse=ce({avgPoolGrad_:Tse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ese={kernelName:wb,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:o}=t;return{x:()=>Cse(n,s,r,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ise={kernelName:bb,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>In(n,r,!1,!0),b:()=>In(s,n,!0,!1)}:!i&&o?{a:()=>In(n,r,!1,!1),b:()=>In(n,s,!0,!1)}:i&&!o?{a:()=>In(r,n,!1,!0),b:()=>In(s,n,!1,!1)}:{a:()=>In(r,n,!0,!0),b:()=>In(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nse={kernelName:_b,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>M_(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ase={kernelName:X7,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,o=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])o[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>kt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mse={kernelName:wx,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kse={kernelName:Sx,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rse={kernelName:bx,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>mi(fu(rd(s,r),Yf(s,i)),n,Pn(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dse={kernelName:Cb,inputsToSave:["x"],gradFunc:iU.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pse={kernelName:Eb,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,i=Cn(r,e[0].shape)[0],o=s.map(l=>l[i]);return Po(n,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lse={kernelName:Ib,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=t;return q(Fh(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>iA(s.shape,n,r,o,a,l),filter:()=>RA(s,n,r.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ose={kernelName:Nb,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>$h(n,r,i,o,a,1,l),filter:()=>RA(n,s,r.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fse(n,e,t,s,r){let i=n;n.rank===4&&(i=pe(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=pe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),q(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),q(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),q(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),q(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),q(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},l={strides:s,pad:r,filterShape:t};return he.runKernel(eN,a,l)}const $se=ce({conv3DBackpropFilter_:Fse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zse={kernelName:Ab,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;q(Fh(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>E$(o.shape,n,a,r,i),filter:()=>$se(o,n,a.shape,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Use={kernelName:_x,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(ys(bA(gt(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bse={kernelName:Tx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(_A(gt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vse={kernelName:Mb,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:o}=t;return{x:()=>{const a=ks([r],s.rank);let l=lA(n,r,i,!o);return a!=null&&(l=Dn(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wse={kernelName:kb,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=t,a=s??[1,1];q(Fh(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return q(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),q(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),q(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),q(Zr(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),zi("depthwiseConv2d",i,o),{x:()=>lz(l.shape,n,u,r,i,a,o),filter:()=>az(l,n,u.shape,r,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gse={kernelName:Rb,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>he.runKernel(n2,i,t),filter:()=>he.runKernel(s2,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hse={kernelName:Ex,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>he.runKernel(cN,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jse={kernelName:Ix,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=de(Fo(ys(os(t))),2/Math.sqrt(Math.PI));return{x:()=>de(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xse={kernelName:Nx,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qse={kernelName:Pb,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>pe(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kse={kernelName:Ax,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,Fo(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yse={kernelName:Mx,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zse={kernelName:kx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{const a=Rt(n,gt(s,"float32")),l=_r(t.shape,r);return l.length>0?pe(kt(a,l),t.shape):a},b:()=>{let a=de(n,gt(t,"float32"));const l=_r(s.shape,r);l.length>0&&(a=pe(kt(a,l),s.shape));const u=os(s);return ys(Rt(a,gt(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jse={kernelName:Lb,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,o,a]=e,l=a??Ht(1),u=_r(i.shape,r.shape),c=[];if(i.rank===1){for(let C=0;C<r.shape.length-1;++C)c.push(r.shape[C]);c.push(1)}const h=Tt(r,i),f=de(n,l),p=vA(Ze(o,Ht(s))),g=de(de(de(p,p),p),Ht(-.5));return{x:()=>i.rank===1?pe(de(de(n,Aa(pe(p,[1,1,1,i.shape[0]]),c)),l),r.shape):pe(de(de(n,p),l),r.shape),mean:()=>{let C=de(de(p,Ht(-1)),f);return i.rank===1&&(C=kt(C,u)),pe(C,i.shape)},variance:()=>{let C=de(de(g,h),f);return i.rank===1&&(C=kt(C,u)),pe(C,i.shape)},scale:()=>{const C=de(h,p);let N=de(n,C);return i.rank===1&&(N=kt(N,u)),pe(N,i.shape)},offset:()=>{let C=n;return i.rank===1&&(C=kt(C,u)),pe(C,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qse={kernelName:Ob,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:o}=t,a=Cn(i,s.shape)[0],l=(u,c,h)=>()=>{const f=u.shape,p=c.size,g=f.slice(0,a),S=g.length,x=f.slice(i,f.length).slice(1),w=x.length,_=pP(0,S),T=pP(S+1,S+1+w),C=mP([g,[p],x]),N=pe(h,C),M=pe(c,[p]),P=mP([[S],_,T]),$=Dn(N,P);let R=AA($,M,u.shape[a]);const D=sd(P);return R=Dn(R,D),R};if(o===1){const u=s.shape[0],c=s.split(u,0);return{x:()=>$o(c.map((p,g)=>l(p,r.slice(g,1),n.slice(g,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function pP(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function mP(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ere={kernelName:Rx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Pn(t),b:()=>Pn(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tre={kernelName:Dx,gradFunc:n=>({x:()=>gt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nre={kernelName:Px,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sre={kernelName:Lx,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rre={kernelName:Ox,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ire={kernelName:$b,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=Wo(s,0);return{x:()=>mi(i,n,de(n,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ore={kernelName:$x,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,Ze(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const are={kernelName:Fx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,gt(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lre={kernelName:K7,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const o=Fo(s);return Tt(n,de(kt(n,r,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ure(n,e,t,s=5,r=1,i=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:i,beta:o};return he.runKernel(xN,a,l)}const cre=ce({localResponseNormalizationBackprop_:ure});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hre={kernelName:Gb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=t;return{x:()=>cre(s,r,n,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oU(n,e,t,s){return e.rank<t.rank&&(e=pe(e,js(e.shape,s))),n.rank<t.rank&&(n=pe(n,js(n.shape,s))),{x:()=>de(n,gt(Cl(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gP={kernelName:Hb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],o=e[1],a=Cn(r,i.shape),l=oU(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dre={kernelName:zx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>de(n,gt(rd(t,s),"float32")),b:()=>de(n,gt(z0(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fre(n,e,t,s,r,i,o){const a=Z(n,"dy","maxPool3dGrad"),l=Z(e,"input","maxPool3dGrad"),u=Z(t,"output","maxPool3dGrad");let c=a,h=l,f=u,p=!1;l.rank===4&&(p=!0,c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=pe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=pe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),q(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),q(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),q(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),zi("maxPool3dGrad",i,o);const g={dy:c,input:h,output:f},S={filterSize:s,strides:r,pad:i,dimRoundingMode:o},x=he.runKernel(wN,g,S);return p?pe(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const pre=ce({maxPool3dGrad_:fre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mre={kernelName:Xb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>pre(n,s,r,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gre(n,e,t,s,r,i,o){const a=Z(n,"dy","maxPoolGrad"),l=Z(e,"input","maxPoolGrad"),u=Z(t,"output","maxPoolGrad");q(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),q(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),q(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),zi("maxPoolGrad",i,o);const c={dy:a,input:l,output:u},h={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return he.runKernel(vN,c,h)}const yre=ce({maxPoolGrad_:gre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xre={kernelName:jb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>yre(n,s,r,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vre={kernelName:qb,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=Cn(r,s.shape),a=zr(s.shape,i)[1],l=Oe(a);return{x:()=>{const c=s.shape.slice();i.forEach(p=>{c[p]=1});const h=pe(n,c);return Rt(de(h,ko(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wre={kernelName:Kb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,o]=e,a=Cn(r,i.shape),l=oU(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sre={kernelName:Ux,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>de(n,gt(Yf(t,s),"float32")),b:()=>de(n,gt(Wo(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bre={kernelName:Yb,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>mn(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _re={kernelName:Bx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{const a=_r(t.shape,r);return a.length>0?pe(kt(n,a),t.shape):n},b:()=>{const a=de(n,ys(pv(Rt(t,s)))),l=_r(s.shape,r);return l.length>0?pe(kt(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tre={kernelName:Vx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{const a=de(n,gt(s,"float32")),l=_r(t.shape,r);return l.length>0?pe(kt(a,l),t.shape):a},b:()=>{const a=de(n,gt(t,"float32")),l=_r(s.shape,r);return l.length>0?pe(kt(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cre={kernelName:Zb,gradFunc:n=>({x:()=>ys(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ere={kernelName:e_,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>yr(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ire={kernelName:Qb,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nre={kernelName:t_,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Oa(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP={kernelName:n_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(o=>o[0]);return{x:()=>mn(n,i,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Are={kernelName:Wx,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,o=s,a=dn(i.shape,o.shape);return{a:()=>{const c=gt(o,"float32");let h=de(n,de(c,zh(i,Tt(c,Ht(1)))));const f=_r(i.shape,a);return f.length>0&&(h=kt(h,f)),pe(h,i.shape)},b:()=>{const c=Wo(i,0),h=mi(c,aa(i),Pn(i));let f=de(n,de(r,h));const p=_r(o.shape,a);return p.length>0&&(f=kt(f,p)),pe(f,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mre={kernelName:s_,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=Wo(t,0);return{x:()=>mi(r,n,de(n,s)),alpha:()=>{let i=mi(r,Pn(n),de(n,t));const o=_r(s.shape,n.shape);return o.length>0&&(i=kt(i,o)),pe(i,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kre(n,e,t){const s=n.shape.slice();s[t]=1;const r=pe(e,s),i=SS(n,t,!0,!1),o=SS(n,t,!0,!0),a=de(i,o);return de(r,a)}function Rre(n,e,t){const s=n.shape.length,r=s-t.length,i=ks(t,s);let o=n;i!=null&&(o=Dn(n,i));const a=o.shape.slice(),u=a.splice(s-t.length,t.length).reduce((f,p)=>f*p,1);a.push(u);const c=o.reshape(a);let h=kre(c,e,r);if(h=h.reshape(o.shape),i!=null){const f=sd(i);h=Dn(h,f)}return h}const Dre={kernelName:r_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((o,a)=>a):typeof r=="number"?i=[r]:i=r,{x:()=>Rre(s,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pre={kernelName:Cx,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{const a=Rt(n,gt(s,"float32")),l=_r(t.shape,r);return l.length>0?pe(kt(a,l),t.shape):a},b:()=>{let a=de(n,gt(t,"float32"));const l=_r(s.shape,r);l.length>0&&(a=pe(kt(a,l),s.shape));const u=os(s);return ys(Rt(a,gt(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lre={kernelName:Gx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,ys(os(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ore={kernelName:jx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=de(Yf(t,6),Fg(t));return{x:()=>de(n,gt(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fre={kernelName:Hx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,gt(Fg(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $re={kernelName:i_,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>pe(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zre={kernelName:a_,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>he.runKernel(RN,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ure={kernelName:o_,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>he.runKernel(kN,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bre={kernelName:l_,gradFunc:(n,e,t)=>{const{dims:s}=t,r=Cn(s,n.shape);return{x:()=>La(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vre={kernelName:Xx,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wre={kernelName:qx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ys(Rt(n,de(zh(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gre={kernelName:u_,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>gt(Pn(t),"float32"),t:()=>de(n,gt(t,n.dtype)),e:()=>de(n,gt(I_(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hre={kernelName:Kx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Wo(t,Ht(0)),r=Ht(G_),i=Ht(H_),o=de(n,i),a=de(de(n,r),Fo(gt(t,"float32")));return mi(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jre={kernelName:Qx,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,de(t,Tt(Ht(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xre={kernelName:Jx,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qre={kernelName:Yx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(b_(gt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kre={kernelName:Zx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(aA(gt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yre={kernelName:c_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,o=s.shape,[a,l]=V_(s,r,i),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>id(n,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zre={kernelName:p_,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,o=de(n,s);return{logits:()=>Tt(o,de(kt(o,[r],i),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jre={kernelName:ev,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,Sl(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP={kernelName:d_,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>S_(n,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP={kernelName:f_,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>ir(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qre={kernelName:tv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,de(yi(gt(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eie={kernelName:BN,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(n,de(gt(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tie={kernelName:nv,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ht(2);return{a:()=>de(n,de(r,Tt(t,s))),b:()=>de(n,de(r,Tt(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nie={kernelName:av,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sie={kernelName:sv,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=dn(t.shape,s.shape);return{a:()=>{let a=n;const l=_r(t.shape,r);return l.length>0&&(a=kt(a,l)),pe(a,t.shape)},b:()=>{let a=n;const l=_r(s.shape,r);return l.length>0&&(a=kt(a,l)),pe(ys(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rie={kernelName:h_,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;Cn(i,s.shape).forEach(u=>{r[u]=1});const a=pe(n,r),l=de(a,ko(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iie={kernelName:rv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(n,os(b_(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oie={kernelName:iv,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>de(Tt(Ht(1),os(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aie={kernelName:ov,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let o=Pn(s);if(s.rank===1)for(let a=0;a<r[0];++a)o=Ze(o,mn(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)o=Ze(o,mn(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)o=Ze(o,mn(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)o=Ze(o,mn(n,[a*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lie={kernelName:Zm,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=sd(r);return{x:()=>Dn(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uie={kernelName:g_,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>$o(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cie={kernelName:y_,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hie(n,t)}}};function hie(n,e){const t=bc(e,Pn(e)),s=mv(n,t);let r=rd(e,Ht(0,"int32"));const i=s.rank-r.rank;for(let a=0;a<i;++a)r=pi(r,a+1);r=fu(r,ko(s.shape,"bool"));const o=Pn(s);return mi(r,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const die={kernelName:x_,gradFunc:n=>({x:()=>Pn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fie=[iU,cse,hse,dse,fse,pse,mse,gse,yse,xse,vse,wse,_se,Ese,Ise,Nse,Ase,Mse,kse,Rse,Dse,Pse,Ose,Lse,zse,Use,Bse,Vse,Wse,Gse,Pre,Hse,jse,Xse,qse,Kse,Zse,Yse,Jse,Qse,ere,tre,nre,sre,rre,ire,ore,are,lre,hre,gP,gP,dre,mre,xre,vre,wre,Sre,bre,_re,Tre,Cre,Ere,Ire,Nre,yP,yP,Are,Mre,Dre,Lre,Ore,Fre,$re,zre,Ure,Bre,Vre,Wre,Gre,Hre,jre,Xre,qre,Kre,Yre,Zre,Jre,xP,xP,vP,vP,Qre,tie,eie,nie,sie,rie,iie,oie,aie,lie,uie,cie,die];for(const n of fie)Z7(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.abs=function(){return this.throwIfDisposed(),gr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.acos=function(){return this.throwIfDisposed(),l$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.acosh=function(){return this.throwIfDisposed(),u$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.add=function(n){return this.throwIfDisposed(),Ze(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.all=function(n,e){return this.throwIfDisposed(),tA(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.any=function(n,e){return this.throwIfDisposed(),wS(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.argMax=function(n){return this.throwIfDisposed(),dg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.argMin=function(n){return this.throwIfDisposed(),c$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.asScalar=function(){return this.throwIfDisposed(),q(this.size===1,()=>"The array must have only 1 element."),pe(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.asType=function(n){return this.throwIfDisposed(),gt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.as1D=function(){return this.throwIfDisposed(),pe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.as2D=function(n,e){return this.throwIfDisposed(),pe(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),pe(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),pe(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),pe(this,[n,e,t,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.asin=function(){return this.throwIfDisposed(),h$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.asinh=function(){return this.throwIfDisposed(),d$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.atan=function(){return this.throwIfDisposed(),f$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.atan2=function(n){return this.throwIfDisposed(),p$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.atanh=function(){return this.throwIfDisposed(),m$(this)};Ue().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),w_(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),S_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),cv(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.broadcastTo=function(n){return this.throwIfDisposed(),eg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.cast=function(n){return this.throwIfDisposed(),gt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.ceil=function(){return this.throwIfDisposed(),S$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Oo(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof gs&&(n=[n]),ir([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),rA(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),oA(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),$h(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.cos=function(){return this.throwIfDisposed(),b_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.cosh=function(){return this.throwIfDisposed(),aA(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),SS(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),lA(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),N$(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),hv(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),A$(this,n,e,t,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.divNoNan=function(n){return this.throwIfDisposed(),M$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.div=function(n){return this.throwIfDisposed(),Rt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.dot=function(n){return this.throwIfDisposed(),k$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.elu=function(){return this.throwIfDisposed(),dv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.equal=function(n){return this.throwIfDisposed(),Cl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.erf=function(){return this.throwIfDisposed(),R$(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),L$(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.exp=function(){return this.throwIfDisposed(),Fo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.expandDims=function(n){return this.throwIfDisposed(),pi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.expm1=function(){return this.throwIfDisposed(),O$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.fft=function(){return this.throwIfDisposed(),O_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.flatten=function(){return this.throwIfDisposed(),pe(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.floor=function(){return this.throwIfDisposed(),pv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.floorDiv=function(n){return this.throwIfDisposed(),eA(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.gather=function(n,e,t){return this.throwIfDisposed(),mv(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.greaterEqual=function(n){return this.throwIfDisposed(),rd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.greater=function(n){return this.throwIfDisposed(),Wo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.ifft=function(){return this.throwIfDisposed(),V0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.irfft=function(){return this.throwIfDisposed(),CA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.isFinite=function(){return this.throwIfDisposed(),F$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.isInf=function(){return this.throwIfDisposed(),$$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.isNaN=function(){return this.throwIfDisposed(),z$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.leakyRelu=function(n){return this.throwIfDisposed(),T_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.lessEqual=function(n){return this.throwIfDisposed(),Yf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.less=function(n){return this.throwIfDisposed(),z0(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),U$(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logSigmoid=function(){return this.throwIfDisposed(),B$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logSoftmax=function(n){return this.throwIfDisposed(),hA(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),E_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.log=function(){return this.throwIfDisposed(),aa(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.log1p=function(){return this.throwIfDisposed(),C_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logicalAnd=function(n){return this.throwIfDisposed(),fu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logicalNot=function(){return this.throwIfDisposed(),I_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logicalOr=function(n){return this.throwIfDisposed(),dA(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.logicalXor=function(n){return this.throwIfDisposed(),V$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),In(this,n,e,t)};Ue().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),N_(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.max=function(n,e){return this.throwIfDisposed(),Da(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.maximum=function(n){return this.throwIfDisposed(),bc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.mean=function(n,e){return this.throwIfDisposed(),$s(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.min=function(n,e){return this.throwIfDisposed(),$0(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.minimum=function(n){return this.throwIfDisposed(),Uf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),G$(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.mod=function(n){return this.throwIfDisposed(),H$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.mul=function(n){return this.throwIfDisposed(),de(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.neg=function(){return this.throwIfDisposed(),ys(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.norm=function(n,e,t){return this.throwIfDisposed(),fv(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.notEqual=function(n){return this.throwIfDisposed(),mg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),pA(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.onesLike=function(){return this.throwIfDisposed(),la(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.pad=function(n,e){return this.throwIfDisposed(),id(this,n,e)};Ue().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),j$(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.pow=function(n){return this.throwIfDisposed(),zh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.prelu=function(n){return this.throwIfDisposed(),k_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.prod=function(n,e){return this.throwIfDisposed(),X$(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.reciprocal=function(){return this.throwIfDisposed(),q$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.relu=function(){return this.throwIfDisposed(),yu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.relu6=function(){return this.throwIfDisposed(),yA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.reshapeAs=function(n){return this.throwIfDisposed(),pe(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.reshape=function(n){return this.throwIfDisposed(),pe(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),hz(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),dz(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.reverse=function(n){return this.throwIfDisposed(),La(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.rfft=function(){return this.throwIfDisposed(),F_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.round=function(){return this.throwIfDisposed(),xA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.rsqrt=function(){return this.throwIfDisposed(),vA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.selu=function(){return this.throwIfDisposed(),wA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),SA(this,n,e,t,s,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sigmoid=function(){return this.throwIfDisposed(),Sl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sign=function(){return this.throwIfDisposed(),K$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sin=function(){return this.throwIfDisposed(),bA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sinh=function(){return this.throwIfDisposed(),_A(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.slice=function(n,e){return this.throwIfDisposed(),mn(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.softmax=function(n){return this.throwIfDisposed(),L_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.softplus=function(){return this.throwIfDisposed(),Og(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),M_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.split=function(n,e){return this.throwIfDisposed(),Po(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sqrt=function(){return this.throwIfDisposed(),yi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.square=function(){return this.throwIfDisposed(),os(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.squaredDifference=function(n){return this.throwIfDisposed(),EA(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.squeeze=function(n){return this.throwIfDisposed(),mc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof gs?[this,n]:[this,...n];return $o(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.step=function(n){return this.throwIfDisposed(),Fg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.stridedSlice=function(n,e,t,s,r,i,o,a){return this.throwIfDisposed(),Y$(this,n,e,t,s,r,i,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sub=function(n){return this.throwIfDisposed(),Tt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.sum=function(n,e){return this.throwIfDisposed(),kt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.tan=function(){return this.throwIfDisposed(),Z$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.tanh=function(){return this.throwIfDisposed(),fg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.tile=function(n){return this.throwIfDisposed(),Aa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.toBool=function(){return this.throwIfDisposed(),gt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.toFloat=function(){return this.throwIfDisposed(),gt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.toInt=function(){return this.throwIfDisposed(),gt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.topk=function(n,e){return this.throwIfDisposed(),ez(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.transpose=function(n){return this.throwIfDisposed(),Dn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.unique=function(n){return this.throwIfDisposed(),tz(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),AA(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.unstack=function(n){return this.throwIfDisposed(),Oa(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.where=function(n,e){return this.throwIfDisposed(),mi(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ue().prototype.zerosLike=function(){return this.throwIfDisposed(),Pn(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eu extends Error{constructor(e){super(e),Object.setPrototypeOf(this,eu.prototype)}}class Ma extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ma.prototype)}}class ye extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ye.prototype)}}class gn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,gn.prototype)}}class hM extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hM.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class aU{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vf(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function tu(n,e){if(!n)throw new hM(e)}function wP(n,e){let t=0;for(const s of n)s===e&&t++;return t}function Qi(n){return n.length===1?n[0]:n}function Xn(n){return Array.isArray(n)?n:[n]}function ec(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function df(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Ta={};function dM(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function _2(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>_2(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:_2(s))}}}function vv(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in Ta)o=Ta[i];else if(o=e[i],o==null)throw new ye(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new ye(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in t?[a,l]=t[o]:o in Ta?[a,l]=Ta.className:o in e&&([a,l]=e[o]),a==null)throw new ye(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(Ta))u[p]=Ta[p];for(const p of Object.keys(t))u[p]=t[p];const c=i.config;c.customObjects=u;const h=Object.assign({},Ta);for(const p of Object.keys(t))Ta[p]=t[p];_2(i.config);const f=l(a,i.config,t,r);return Ta=Object.assign({},h),f}else{const u=Object.assign({},Ta);for(const h of Object.keys(t))Ta[h]=t[h];const c=new a(i.config);return Ta=Object.assign({},u),c}}}function pie(n,e){return n<e?-1:n>e?1:0}function Tw(n,e){return-1*pie(n,e)}function Ah(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function mie(n){if(n==null)throw new ye(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Qf(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new ye(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function fM(n,e,t=0,s=1/0){return tu(t>=0),tu(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Lr(n,e){Array.isArray(n)?(q(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Lr(t,`element ${s+1} of ${e}`))):q(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${lU(n)}.`)}function lU(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>lU(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function gie(n,e,t){let s=t!=null?t():Ji(),r;return(...o)=>{const a=t!=null?t():Ji();return a-s<e||(s=a,r=n(...o)),r}}function uU(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let yie=0;function cU(){return yie++}const Cw={};function j_(n=""){return n in Cw||(Cw[n]=0),Cw[n]+=1,n+Cw[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const xie=["channelsFirst","channelsLast"],vie=["nearest","bilinear"],wie=["valid","same","causal"],Sie=["max","avg"],bie=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Pm=new Map;function qs(n){Qf(xie,"DataFormat",n)}function _ie(n){Qf(vie,"InterpolationFormat",n)}function ca(n){Qf(wie,"PaddingMode",n)}function hU(n){Qf(Sie,"PoolMode",n)}const p0=[],SP="/";function If(n,e){p0.push(n);try{const t=e();return p0.pop(),t}catch(t){throw p0.pop(),t}}function Tie(){return p0.length===0?"":p0.join(SP)+SP}function dU(n){if(!pU(n))throw new Error("Not a valid tensor name: '"+n+"'");return Tie()+n}function fU(n){if(!pU(n))throw new Error("Not a valid tensor name: '"+n+"'");Pm.has(n)||Pm.set(n,0);const e=Pm.get(n);if(Pm.set(n,Pm.get(n)+1),e>0){const t=`${n}_${e}`;return Pm.set(t,1),t}else return n}const Cie=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function pU(n){return!!n.match(Cie)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Eie(n){return n===parseInt(n.toString(),10)}function Mh(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function yg(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Uh(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function El(n,e){if(e<n)throw new ye(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let qC;function xr(){return qC==null&&(qC=jF().epsilon()),qC}function Il(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cu(n,e){return gt(n,e)}function wv(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),pe(n,t)}function Iie(n,e){return be(()=>{if(n.shape.length!==2)throw new ye(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=wv(n,1);return T2(t,[1,e,1])})}function Nie(n){const e=[Mh(n.shape)];return pe(n,e)}function Aie(n){if(n.rank<=1)throw new ye(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Mh(n.shape,1)];return pe(n,e)}function Nf(n,e,t){return be(()=>{switch(n.rank){case 1:return D_(n,e,t);case 2:return TA(n,[e,0],[t,n.shape[1]]);case 3:return P_(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return B0(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return mn(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return mn(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ye(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function KC(n,e,t){return be(()=>{switch(n.rank){case 1:return D_(n,e,t);case 2:return TA(n,[0,e],[n.shape[0],t]);case 3:return P_(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return B0(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new ye(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ew(n,e,t,s){return be(()=>{switch(n.rank){case 1:return D_(n,e,t);case 2:switch(s){case 1:return Nf(n,e,t);case 2:return KC(n,e,t);default:throw new ye(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Nf(n,e,t);case 2:return P_(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return KC(n,e,t);default:throw new ye(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Nf(n,e,t);case 2:return B0(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return B0(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return KC(n,e,t);default:throw new ye(`The axis is not within the rank of the tensor ${s}`)}default:throw new ye(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function pM(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),ir(n,e)}function bP(n,e){switch(n.rank){case 1:return b$([n,e]);case 2:return sA([n,e],0);case 3:return _$([n,e],0);case 4:return T$([n,e],0);default:throw new ye(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function T2(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new ye(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Aa(n,e)}function X_(n,e=0,t=1,s,r){return gA(n,e,t,s,r)}function hu(n,e,t,s){if(n.rank<2||e.rank<2)throw new gn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new gn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return v2({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?C2(n.rank,s,Il()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=pe(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(g,S)=>S===0?e.rank-2:S<=e.rank-2?S-1:S);e=pe(Dn(e,c),[l,-1]);const h=[...r,...u];return pe(v2({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?C2(n.rank,s,Il()):null,activation:t}),h)}}function mU(n,e,t){return be(()=>(Array.isArray(e)?e=Kr(e,"int32"):e=gt(e,"int32"),mv(n,e,t)))}function Sv(n){return de(n,n)}function C2(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new ye(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?pe(e,[1,s[0],1,1,1]):pe(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?pe(e,[1,1,1,1,s[0]]):pe(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?pe(e,[1,s[0],1,1]):pe(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?pe(e,[1,1,1,s[0]]):pe(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?pe(e,[1,s[0],1]):pe(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?pe(e,[1,1,s[0]]):pe(e,[1].concat(s))}else if(n<3)return e;throw new ye(`Unsupported input rank by biasAdd: ${e.rank}`)}function Rl(n,e,t){return be(()=>(t==null&&(t=Il()),qs(t),Ze(n,C2(n.rank,e,t))))}function Mie(n,e=1){if(e!==1)throw new gn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return dv(n)}function kie(n){return be(()=>Rt(n,Ze(gr(n),1)))}function gU(n,e,t,s){return be(()=>rz(n,e,t,s))}function Rie(n){return be(()=>{const e=Ze(.5,de(.2,n));return Oo(e,0,1)})}function bv(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Die=["fanIn","fanOut","fanAvg"],Pie=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lie(n){Qf(Die,"FanMode",n)}function Oie(n){Qf(Pie,"Distribution",n)}class $a extends zg{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class yU extends $a{apply(e,t){return yr(e,t)}}yU.className="Zeros";tt(yU);class mM extends $a{apply(e,t){return ko(e,t)}}mM.className="Ones";tt(mM);class xU extends $a{constructor(e){if(super(),typeof e!="object")throw new ye(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ye(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return be(()=>de(Ht(this.value),ko(e,t)))}getConfig(){return{value:this.value}}}xU.className="Constant";tt(xU);class vU extends $a{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Zf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}vU.className="RandomUniform";tt(vU);class wU extends $a{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new gn(`randomNormal does not support dType ${t}.`);return X_(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}wU.className="RandomNormal";tt(wU);class SU extends $a{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new gn(`truncatedNormal does not support dType ${t}.`);return NA(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}SU.className="TruncatedNormal";tt(SU);class bU extends $a{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return be(()=>{if(e.length!==2||e[0]!==e[1])throw new ye("Identity matrix initializer can only be used for 2D square matrices.");return de(this.gain,cA(e[0]))})}getConfig(){return{gain:this.gain}}}bU.className="Identity";tt(bU);function Fie(n,e="channelsLast"){let t,s;if(qs(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Mh(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Mh(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Mh(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class zo extends $a{constructor(e){if(super(),e.scale<0)throw new ye(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Lie(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Oie(this.distribution),this.seed=e.seed}apply(e,t){const s=Fie(e),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new gn(`${this.getClassName()} does not support dType ${t}.`);return NA(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Zf(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}zo.className="VarianceScaling";tt(zo);class gM extends zo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return zo.className}}gM.className="GlorotUniform";tt(gM);class yM extends zo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return zo.className}}yM.className="GlorotNormal";tt(yM);class xM extends zo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return zo.className}}xM.className="HeNormal";tt(xM);class vM extends zo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return zo.className}}vM.className="HeUniform";tt(vM);class wM extends zo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return zo.className}}wM.className="LeCunNormal";tt(wM);class SM extends zo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return zo.className}}SM.className="LeCunUniform";tt(SM);class _U extends $a{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return be(()=>{if(e.length<2)throw new gn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=Oe(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],a=X_(o,0,1,t,this.seed),l=fz.qr(a,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return u=de(u,h.sign()),s<r&&(u=u.transpose()),de(Ht(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}_U.className="Orthogonal";tt(_U);const _P={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function TP(n,e={}){return vv(n,Na.getMap().classNameMap,e,"initializer")}function Ms(n){return dM(n)}function _s(n){if(typeof n=="string"){const e=n in _P?_P[n]:n;if(e==="GlorotNormal")return new yM;if(e==="GlorotUniform")return new gM;if(e==="HeNormal")return new xM;if(e==="HeUniform")return new vM;if(e==="LeCunNormal")return new wM;if(e==="LeCunUniform")return new SM;{const t={};return t.className=e,t.config={},TP(t)}}else return n instanceof $a?n:TP(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function E2(n){return Array.isArray(n)&&Array.isArray(n[0])}function bS(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function tn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new ye(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Un(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ye(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _S(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const CP="Variable";class $ie{constructor(e,t="float32",s=CP,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=cU(),s=s??CP,this.originalName=dU(s),this.name=fU(this.originalName),this.trainable_=r,this.constraint=i,this.val=nz(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),zie(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function zie(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function I2(n){return n.map(e=>e.read())}function bM(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class vr{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class pu{constructor(e,t,s,r,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=a,this.id=cU(),o!=null&&(this.originalName=dU(o),this.name=fU(this.originalName)),this.rank=t.length}}let Uie=0;class q_{constructor(e,t){this.callArgs=t,this.id=Uie++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Bie=0;class En extends zg{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Bie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=ec(s)+"_"+j_(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Ma(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ye(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Qi(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Qi(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new eu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new eu(`Layer ${this.name} is not connected, no input to return.`);return Qi(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new eu(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new eu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Qi(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Xn(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Xn(this.inputSpec);if(t.length!==s.length)throw new ye(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],o=s[r];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new ye(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const u in o.axes){const c=Number(u),h=o.axes[u],f=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(f)===-1)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const u=o.shape[l],c=i.shape[l];if(u!=null&&c!=null&&u!==c)throw new ye(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Xn(e),r=Gie(e),i=Hie(e);if(r===i)throw new ye("Arguments to apply() must be all SymbolicTensors or all Tensors");return If(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Xn(e))o.push(a.shape);this.build(Qi(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Xn(o),l=[];for(let u of a)s.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(o=Qi(l),this.activityRegularizer!=null)throw new gn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=Vie(e),a=this.computeOutputShape(o);let l;const u=Wie(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new pu(u,c,this,Xn(e),t,this.name,h)):l=new pu(u,a,this,Xn(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new gn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new eu(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new eu(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ma(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return _S(this.weights)}build(e){this.built=!0}getWeights(e=!1){return I2(e?this.trainableWeights:this.weights)}setWeights(e){be(()=>{const t=this.weights;if(t.length!==e.length)throw new ye(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=I2(t);for(let i=0;i<r.length;++i){const o=r[i],a=t[i],l=e[i];if(!Mn(o.shape,l.shape))throw new ye(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}bM(s)})}addWeight(e,t,s,r,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new ye(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():_s("zeros"));const u=r.apply(t,s),c=new $ie(u,s,e,o,a);return u.dispose(),i!=null&&this.addLoss(()=>i.apply(c.read())),o==null&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Xn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=Xn(t),o=Xn(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(e,t,s,r,i,o,a=null){const l=Xn(e);t=Xn(t),s=Xn(s),r=Xn(r),i=bS(i),o=bS(o);const u=[],c=[],h=[];for(const f of l)u.push(f.sourceLayer),c.push(f.nodeIndex),h.push(f.tensorIndex);new q_({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},a);for(let f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Vie(n){n=Xn(n);const e=[];for(const t of n)e.push(t.shape);return Qi(e)}function Wie(n){return"float32"}function TU(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],a=s.inboundLayers[i],l=s.nodeIndices[i],u=TU(o,a,l);for(const c of u)r.indexOf(c)===-1&&r.push(c)}return r}}}function Gie(n){let e=!0;for(const t of Xn(n))if(!(t instanceof pu)){e=!1;break}return e}function Hie(n){let e=!0;for(const t of Xn(n))if(t instanceof pu){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _v extends En{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:j_("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ye("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ye("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ye("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new pu(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new q_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ye(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}_v.className="InputLayer";tt(_v);function jie(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ye("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new _v({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xie(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return gt(e,n.dtype)}catch{throw new ye(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class bh{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof bh)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Xie(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ye(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof pu){if(this.id2Value[e.id]==null)throw new ye(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ye(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof pu){if(this.id2Value[e.id]==null)throw new ye(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new ye(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Tn(this.id2Mask)}}const TS=new aU,CS=new aU;function qie(n){TS!=null&&TS.setMaxEntries(n),CS!=null&&CS.setMaxEntries(n)}function r0(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(g=>g.name),l=[],u=e.names();for(const g of a)u.indexOf(g)!==-1?l.push(e.getValue(g)):l.push(null);const c=a.join(",")+"|"+e.names().sort().join(",");let h=TS.get(c),f;if(h==null){const g=Kie(o,e);h=g.sorted,f=g.recipientCounts,TS.put(c,h),CS.put(c,f)}f={},r||Object.assign(f,CS.get(c));const p=new bh(e);for(let g=0;g<h.length;++g){const S=h[g],x=S.sourceLayer;if(x instanceof _v)continue;const w=[],_=[],T=[];let C=!1;for(const R of S.inputs){const D=p.getValue(R),L=p.getMask(R);w.push(D),_.push(L),L!=null&&(C=!0),r||(f[R.name]--,f[R.name]===0&&!e.hasKey(R)&&a.indexOf(R.name)===-1&&!D.isDisposed&&R.sourceLayer.stateful!==!0&&T.push(D))}C&&(t=t||{},t.mask=_[0]);const N=Xn(x.apply(w,t));let M=null;x.supportsMasking&&(M=x.computeMask(w,_));const P=Zie(S),$=Array.isArray(P)?P:[P];for(let R=0;R<$.length;++R){p.hasKey($[R])||p.add($[R],N[R],Array.isArray(M)?M[0]:M);const D=a.indexOf($[R].name);D!==-1&&(l[D]=N[R])}r||Tn(T)}return p.disposeMasks(),i?l:l[0]}function Kie(n,e){q(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=EP(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:a}=EP(i,e);for(const l of o)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(u=>s[l].add(u))}}return{sorted:t,recipientCounts:Yie(s)}}function Yie(n){const e={};for(const t in n)e[t]=n[t].size;return e}function EP(n,e){const t=new Set,s=[],r={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),s.push(a),t.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const u of a.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(a.name),!t.has(u.name)&&i.push(u)}}return{sorted:s,recipientMap:r}}function Zie(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jie=Te();Jie.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,qie);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _M(n,e){return be(()=>yi(kt(de(n,n),e,!0)))}class Tv extends zg{getConfig(){return{}}}class CU extends Tv{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>{const t=_M(e,this.axis),s=Oo(t,0,this.maxValue);return de(e,Rt(s,Ze(xr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}CU.className="MaxNorm";tt(CU);class EU extends Tv{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>Rt(e,Ze(xr(),_M(e,this.axis))))}getConfig(){return{axis:this.axis}}}EU.className="UnitNorm";tt(EU);class IU extends Tv{apply(e){return yu(e)}}IU.className="NonNeg";tt(IU);class NU extends Tv{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return be(()=>{const t=_M(e,this.axis),s=Ze(de(this.rate,Oo(t,this.minValue,this.maxValue)),de(1-this.rate,t));return de(e,Rt(s,Ze(xr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}NU.className="MinMaxNorm";tt(NU);const IP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Sr(n){return dM(n)}function NP(n,e={}){return vv(n,Na.getMap().classNameMap,e,"constraint")}function br(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in IP?IP[n]:n,config:{}};return NP(t)}else return n instanceof Tv?n:NP(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function rf(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(r),s.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];Tn(s)}}function AU(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var AP;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(AP||(AP={}));const Qie=125;class W0{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class eoe{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class toe extends W0{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const a=be(()=>Ze(this.totals[r],de(i,s)));this.totals[r]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:be(()=>{const r=de(Rt(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),Pr(t[s])}))}}class noe extends W0{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(i),s.push(a)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class soe extends W0{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Pz,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Qie),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");QE(this.yieldEvery)&&(this.maybeWait=gie(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await rf(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await rf(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await rf(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await rf(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await rf(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):QE(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await rf(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await rf(e),await this.trainEnd(e))}}function MU(n,e){return n==null&&(n={}),n instanceof W0?[n]:Array.isArray(n)&&n[0]instanceof W0?n:Xn(n).map(s=>new soe(s,e))}class Ea{constructor(){}static registerCallbackConstructor(e,t){q(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ea.checkForDuplicate(t),Ea.constructors[e]==null&&(Ea.constructors[e]=[]),Ea.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Ea.constructors)Ea.constructors[+t].forEach(r=>{if(r===e)throw new ye("Duplicate callback constructor.")})}static clear(){Ea.constructors={}}static createCallbacks(e){const t=[];for(const s in Ea.constructors){const r=+s;e>=r&&t.push(...Ea.constructors[r])}return t.map(s=>new s)}}Ea.constructors={};function kU(n,e,t,s,r,i,o,a,l){const u=new noe,c=[new toe,...Ea.createCallbacks(e)];n!=null&&c.push(...n),c.push(u);const h=new eoe(c);return h.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cc(n,e={},t=!1){return vv(n,Na.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ES(n,e){return be(()=>{n.dtype!=="float32"&&(n=gt(n,"float32"));const t=kt(Sv(n),e,!0),s=Lg(t.shape,xr()),r=yi(bc(t,s));return Rt(n,r)})}function K_(n,e){return be(()=>$s(Sv(Tt(e,n)),-1))}function TM(n,e){return be(()=>$s(gr(Tt(e,n)),-1))}function CM(n,e){return be(()=>{const t=Tt(n,e),s=Oo(gr(n),xr(),Number.MAX_VALUE),r=gr(Rt(t,s));return de(100,$s(r,-1))})}function roe(n,e){return be(()=>{const t=Oo(e,xr(),Number.MAX_VALUE),s=aa(Ze(1,t)),r=Oo(n,xr(),Number.MAX_VALUE),i=aa(Ze(1,r));return $s(Sv(Tt(s,i)),-1)})}function ioe(n,e){return be(()=>{const t=bc(0,Tt(1,de(n,e)));return $s(Sv(t),-1)})}function ooe(n,e){return be(()=>{const t=bc(0,Tt(1,de(n,e)));return $s(t,-1)})}function aoe(n,e){return be(()=>{const t=kt(de(n,e),-1),s=Da(de(Tt(1,n),e),-1);return bc(0,Ze(1,Tt(s,t)))})}function loe(n,e){return be(()=>{const t=Math.log(2),s=Tt(e,n),r=Tt(Ze(s,Og(de(-2,s))),t);return $s(r,-1)})}function G0(n,e,t=!1){return be(()=>{if(t)e=L_(e);else{const s=kt(e,e.shape.length-1,!0);e=Rt(e,s)}return e=Oo(e,xr(),1-xr()),ys(kt(de(gt(n,"float32"),aa(e)),e.shape.length-1))})}function IS(n,e,t=!1){return be(()=>{const s=gt(pv(Nie(n)),"int32");e=Oo(e,xr(),1-xr());const r=e.shape,i=pe(pA(s,r[r.length-1]),r);return G0(i,e,t)})}function uoe(n,e){if(!Mn(n.shape,e.shape))throw new ye(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return be(()=>{const t=yu(e),s=ys(gr(e));return Ze(Tt(t,de(e,n)),C_(Fo(s)))})}function Y_(n,e){return be(()=>{let t;return t=Oo(e,xr(),1-xr()),t=aa(Rt(t,Tt(1,t))),$s(uoe(n,t),-1)})}function coe(n,e){return be(()=>{const t=Oo(n,xr(),1),s=Oo(e,xr(),1);return kt(de(n,aa(Rt(t,s))),-1)})}function hoe(n,e){return be(()=>{const t=aa(Ze(xr(),e));return $s(Tt(e,de(n,t)),-1)})}function RU(n,e){return be(()=>{const t=ES(n,-1),s=ES(e,-1),r=de(t,s);return ys(kt(r,-1))})}const NS={meanSquaredError:K_,meanAbsoluteError:TM,meanAbsolutePercentageError:CM,meanSquaredLogarithmicError:roe,squaredHinge:ioe,hinge:ooe,categoricalHinge:aoe,logcosh:loe,categoricalCrossentropy:G0,sparseCategoricalCrossentropy:IS,binaryCrossentropy:Y_,kullbackLeiblerDivergence:coe,poisson:hoe,cosineProximity:RU};function YC(n){if(typeof n=="string"){if(n in NS)return NS[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ye(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DU(n,e){return be(()=>{const t=de(.5,la(e)),s=cu(Wo(e,t),n.dtype);return $s(Cl(n,s),-1)})}function PU(n,e){return be(()=>cu(Cl(dg(n,-1),dg(e,-1)),"float32"))}function doe(n,e){return be(()=>gt(kt(fu(Cl(n,1),Cl(e,1))),"float32"))}function foe(n,e){return be(()=>gt(kt(fu(Cl(n,0),Cl(e,1))),"float32"))}function poe(n,e){return be(()=>{const t=doe(n,e),s=foe(n,e),r=Ze(t,s);return gt(mi(Wo(r,0),Rt(t,r),0),"float32")})}function moe(n,e){return Y_(n,e)}function goe(n,e){return n.rank===e.rank&&(n=mc(n,[n.rank-1])),e=dg(e,-1),e.dtype!==n.dtype&&(e=gt(e,n.dtype)),gt(Cl(n,e),"float32")}const yoe=K_,xoe=K_,voe=TM,woe=TM,Soe=CM,boe=CM,LU=G0,_oe=RU,OU=IS,AS={binaryAccuracy:DU,categoricalAccuracy:PU,precision:poe,categoricalCrossentropy:LU,sparseCategoricalCrossentropy:OU,mse:yoe,MSE:xoe,mae:voe,MAE:woe,mape:Soe,MAPE:boe,cosine:_oe};function Toe(n){if(typeof n=="string"&&n in AS)return AS[n];if(typeof n!="string"&&n!=null)return n;throw new ye(`Unknown metric ${n}`)}function Iw(n){if(tu(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(NS))if(NS[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(AS))if(AS[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Coe(n){const e={Adagrad:()=>Dm.adagrad(.01),Adadelta:()=>Dm.adadelta(1,.95,xr()),Adam:()=>Dm.adam(.001,.9,.999,xr()),Adamax:()=>Dm.adamax(.002,.9,.999,xr(),0),RMSProp:()=>Dm.rmsprop(.001,.9,0,xr()),SGD:()=>Dm.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new ye(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const MP=1*1024*1024;function kP(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!N2(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>MP&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MP}.`)}}function N2(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!N2(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!N2(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Eoe(n,e,t,s=console.log){const r=Noe(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let o;if(!r){i.push("Receives inputs"),o=[];for(const c in n.nodesByDepth)o.push(...n.nodesByDepth[c])}s("_".repeat(e)),MS(i,t,s),s("=".repeat(e));const a=n.layers;for(let c=0;c<a.length;++c)r?Aoe(a[c],t,s):Moe(a[c],t,o,s),s((c===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Ioe(n),u=_S(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(e))}function Ioe(n){let e;return n.collectedTrainableWeights!=null?e=_S(n.collectedTrainableWeights):e=_S(n.trainableWeights),e}function Noe(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function MS(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function Aoe(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,r,s,n.countParams().toString()];MS(a,e,t)}function Moe(n,e,t,s){let r,i;try{i=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let f=0;f<h.inboundLayers.length;++f){const p=h.inboundLayers[f].name,g=h.nodeIndices[f],S=h.tensorIndices[f];o.push(`${p}[${g}][${S}]`)}const a=n.name,l=n.getClassName(),u=o.length===0?"":o[0],c=[`${a} (${l})`,i,r,n.countParams().toString(),u];MS(c,e,s);for(let h=1;h<o.length;++h)MS(["","","","",o[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FU(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function A2(n,e){if(n===null)return null;if(typeof n=="string")return df(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];FU(e,r,i)?t.push(i):t.push(A2(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=df(s);t[i]=A2(r,i)}}return t}}function M2(n,e){if(n==null)return null;if(typeof n=="string")return ec(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];FU(e,r,i)?t.push(i):t.push(M2(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=ec(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=M2(r,s)}return t}}/** @license See the LICENSE file. */const $U="4.17.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const koe=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class fl extends En{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const _=this.getClassName().toLowerCase();this.name=j_(_)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ah(this.inputs).length!==this.inputs.length)throw new ye(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(_=>_.name)}`);Ah(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(_=>_.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const _ of this.outputs){const T=_.sourceLayer,C=_.nodeIndex,N=_.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(N)}for(const _ of this.inputs){const T=_.sourceLayer,C=_.nodeIndex,N=_.tensorIndex;tu(C===0,"input layer has >1 nodes"),tu(N===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(N)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let _=0;_<this.inputLayers.length;_++){const T=this.inputLayers[_];if(!(T instanceof _v))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${_} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(const _ of this.outputLayers)this.outputNames.push(_.name);this.internalInputShapes=this.inputs.map(_=>_.shape),this.internalOutputShapes=this.outputs.map(_=>_.shape);const t={},s={},r={},i={},o={},a=[],l=(_,T,C,N,M,P)=>{(N==null||M==null||P==null)&&(N=_.sourceLayer,M=_.nodeIndex,P=_.tensorIndex);const $=N.inboundNodes[M];if(C.indexOf($)!==-1)throw new Ma(`The tensor ${_.name} at layer "${N.name}" is part of a cycle.`);if(T.indexOf($)!==-1)return;this.containerNodes.add(fl.nodeKey(N,M)),N.id in o||(o[N.id]=Object.keys(o).length),C.indexOf($)===-1&&C.push($);const R=$.inboundLayers.length;for(let D=0;D<R;D++){const L=$.inputTensors[D],G=$.inboundLayers[D],Q=$.nodeIndices[D],W=$.tensorIndices[D];l(L,T,C,G,Q,W)}for(T.push($);C.indexOf($)>=0;)C.splice(C.indexOf($),1);a.push($)},u=[],c=[];for(const _ of this.outputs)l(_,u,c);const h=a.slice().reverse();for(const _ of h){s[_.id]=_,_.id in t||(t[_.id]=0);let T=t[_.id];const C=r[_.outboundLayer.id]==null?0:r[_.outboundLayer.id];T=Math.max(T,C),r[_.outboundLayer.id]=T,i[_.outboundLayer.id]=_.outboundLayer,t[_.id]=T;for(let N=0;N<_.inboundLayers.length;N++){const M=_.inboundLayers[N],P=_.nodeIndices[N],$=M.inboundNodes[P],R=t[$.id]==null?0:t[$.id];t[$.id]=Math.max(T+1,R),s[$.id]=$}}const f={};for(const _ in t){const T=t[_];T in f||(f[T]=[]),f[T].push(s[_])}const p={};for(const _ in r){const T=r[_];T in p||(p[T]=[]),p[T].push(i[_])}let g=Object.keys(p).map(_=>parseInt(_,10)).sort(Tw);this.layers=[];for(const _ of g){const T=p[_];T.sort((C,N)=>{const M=o[C.id],P=o[N.id];return M<P?-1:M>P?1:0});for(const C of T)C instanceof fl&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=p,g=Object.keys(f).map(_=>parseInt(_,10)).sort(Tw);const S=this.inputs.slice(),x=[];for(const _ of g)for(const T of f[_]){const C=T.outboundLayer;if(C!=null){for(const N of T.inputTensors)if(S.indexOf(N)===-1)throw new Ma(`Graph disconnected: cannot obtain value for tensor ${N} at layer "${C.name}". The following previous layers were accessed without issue: ${x}`);for(const N of T.outputTensors)S.push(N);x.push(C.name)}}this.nodesByDepth=f;const w=this.layers.map(_=>_.name);for(const _ of w){const T=w.filter(C=>C===_).length;if(T!==1)throw new Ma(`The name "${_}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(w))}this.outboundNodes=[],this.inboundNodes=[],new q_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(_=>null),outputMasks:this.outputs.map(_=>null),inputShapes:this.inputs.map(_=>_.shape),outputShapes:this.outputs.map(_=>_.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ye("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=koe(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=i?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(s[c]!=null)throw new ye(`Duplicate weight name: ${c}`);s[c]=u,r++}const o=[];for(const a in e){let l=a;if(s[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],e[a]]);else if(t)throw new ye(`Provided weight data has no target variable: ${a}`);delete s[l]}if(t){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new ye(`${a.length} of ${r} weights are not set: ${a}`)}bM(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${$U}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=M2(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return be(()=>{e=Xn(e);const s=new bh;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return r0(this.outputs,s,t)})}computeMask(e,t){return be(()=>{e=Xn(e);let s;return t==null?s=Vf(null,e.length):s=Xn(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=bS(e);if(t.length!==this.inputLayers.length)throw new ye(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],u=t[a],c=l.name+"_0_0";s[c]=u}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Tw);if(r.length>1)for(const a of r){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(S=>S.id).indexOf(c.id)!==-1)continue;const h=[];for(let S=0;S<u.inboundLayers.length;S++){const x=u.inboundLayers[S],w=u.nodeIndices[S],_=u.tensorIndices[S],T=`${x.name}_${w}_${_}`,C=s[T];h.push(C)}const f=c.computeOutputShape(Qi(h)),p=bS(f),g=c.inboundNodes.indexOf(u);for(let S=0;S<p.length;S++){const x=`${c.name}_${g}_${S}`;s[x]=p[S]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];tu(l in s),i.push(s[l])}return Qi(i)}runInternalGraph(e,t){t==null&&(t=Vf(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=t[l];s[u.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Tw);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,f=c.inputTensors,p=c.outputTensors,g=new Array;for(const S of f)S.id in s&&g.push(s[S.id]);if(g.length===f.length){let S={},x,w,_,T;if(c.callArgs!=null&&(S=c.callArgs),g.length===1){const[C,N]=g[0];S.mask==null&&(S.mask=N),_=Xn(h.call(C,S)),T=Xn(h.computeMask(C,N)),x=[C],w=[N]}else x=g.map(C=>C[0]),w=g.map(C=>C[1]),S.mask==null&&(S.mask=w),_=Xn(h.call(x,S)),T=Xn(h.computeMask(x,w));if(h.activityRegularizer)throw new gn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<p.length;++C){const N=p[C],M=_[C],P=T[C];s[N.id]=[M,P]}}}}const i=[],o=[],a=[];for(const l of this.outputs){tu(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];a.push(u.shape),i.push(u),o.push(c)}return[i,o,a]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof fl?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=fl.nodeKey(r,i);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new ye("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new ye(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new ye(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return be(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=fl.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),u=[];for(let h=0;h<o.inboundNodes.length;h++){const f=o.inboundNodes[h],p=fl.nodeKey(o,h);let g={};if(this.containerNodes.has(p)){if(f.callArgs)try{JSON.stringify(f.callArgs),g=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(f.inboundLayers.length>0){const S=[];for(let x=0;x<f.inboundLayers.length;x++){const w=f.inboundLayers[x],_=f.nodeIndices[x],T=f.tensorIndices[x],C=fl.nodeKey(w,_);let N=t[C];N==null&&(N=0),S.push([w.name,N,T,g])}u.push(S)}}}const c={};c.name=o.name,c.className=a,c.config=l,c.inboundNodes=u,s.push(c)}e.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],u=fl.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[o];r.push([a.name,c,h])}e.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],u=fl.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,c,h])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},o={};function a(x,w){x.name in o?o[x.name].push(w):o[x.name]=[w]}function l(x,w){const _=[];let T;for(const C of w){const N=C[0],M=C[1],P=C[2];if(T=C[3]==null?{}:C[3],!(N in i)){a(x,w);return}const $=i[N];if($.inboundNodes.length<=M){a(x,w);return}const R=$.inboundNodes[M];_.push(R.outputTensors[P])}_.length>0&&x.apply(Qi(_),T)}function u(x){const w=x.name,_=cc(x,t.customObjects!=null?t.customObjects:{});_.setFastWeightInitDuringBuild(r),i[w]=_,x.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new ye(`Corrupted configuration, expected array for nodeData: ${C}`);a(_,C)})}const c=t.name,h=t.layers;for(const x of h)u(x);for(;!mie(o);)for(const x of h){const w=i[x.name];if(w.name in o){const _=o[w.name];delete o[w.name];for(const T of _)l(w,T)}}const f=[],p=[],g=t.inputLayers;for(const x of g){const w=x[0],_=x[1],T=x[2];tu(w in i);const N=i[w].inboundNodes[_].outputTensors;f.push(N[T])}const S=t.outputLayers;for(const x of S){const w=x[0],_=x[1],T=x[2];tu(w in i);const N=i[w].inboundNodes[_].outputTensors;p.push(N[T])}return new e({inputs:f,outputs:p,name:c})}get stateful(){if(this._stateful)throw new ye("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){be(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Roe(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function zU(n,e){return Roe(n,e,"classWeight")}async function UU(n,e,t,s){if(t!=null){const r=be(()=>{if(n.shape.length===1)return uc(n);if(n.shape.length===2){if(n.shape[1]>1)return dg(n,1);if(n.shape[1]===1)return pe(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Tn(r);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Kr(o,"float32")}else return null}function Doe(n,e){return de(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Poe=32;function BU(n,e){let t,s;const r=e;t=r.xs,s=r.ys,q(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=RP("input",n.inputNames,t),o=RP("output",n.outputNames,s),a=i[0].shape[0];q(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),q(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)q(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)q(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function RP(n,e,t){if(t instanceof gs)return[t];if(Array.isArray(t))return q(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new ye(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function Loe(n){if(n.length===3)throw new gn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Ooe(n,e,t){const s=t.batchesPerEpoch!=null;if(q(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),q(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),q(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),q(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),q(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,o;if(r)if(DP(t.validationData))q(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const x=Loe(t.validationData);i=x.xs,o=x.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;r?u=l.slice().concat(l.map(x=>"val_"+x)):u=l.slice();const c=MU(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:f,history:p}=kU(c,h,t.epochs,null,null,Foe(e,t),null,r,u);f.setModel(n),n.history=p,await f.onTrainBegin(),n.stopTraining_=!1;let g=t.initialEpoch==null?0:t.initialEpoch,S=await e.iterator();for(;g<t.epochs;){const x={};await f.onEpochBegin(g);let w=0,_=0;for(s||(S=await e.iterator());!s||w<t.batchesPerEpoch;){const T=await S.next();if(s&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${w} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){const{xs:C,ys:N}=BU(n,T.value),M={};M.batch=_,M.size=C[0].shape[0],await f.onBatchBegin(_,M);const P=[];if(t.classWeight!=null){const D=zU(t.classWeight,n.outputNames);for(let L=0;L<D.length;++L)P.push(await UU(N[L],null,D[L]))}const $=C.concat(N).concat(P),R=a($);Tn($);for(let D=0;D<l.length;++D){const L=l[D],G=R[D];M[L]=G,Pr(G)}await f.onBatchEnd(_,M),AU(M),_++,w++}if(s?w>=t.batchesPerEpoch:T.done){if(r){let C;DP(t.validationData)?C=Xn(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):C=Xn(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?Poe:t.validationBatchSize,verbose:0}));for(let N=0;N<n.metricsNames.length;++N)x[`val_${n.metricsNames[N]}`]=C[N]}break}if(n.stopTraining_)break}if(await f.onEpochEnd(g,x),g++,n.stopTraining_)break}return await f.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Foe(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function DP(n){return typeof n.iterator=="function"}function $oe(n){return typeof n.next=="function"}async function zoe(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new gn("Verbose mode is not implemented yet.");q(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=$oe(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const u=await o.next();if(i=be(()=>{if(u.value){const{xs:c,ys:h}=BU(n,u.value),f=c.concat(h),p=be(()=>r(f));if(Tn(f),l===0)for(let S=0;S<p.length;++S)i.push(Ht(0));const g=f[0].shape[0];for(let S=0;S<p.length;++S){const x=p[S],w=i[S];i[S]=be(()=>Ze(i[S],de(g,x))),l>0&&Tn(w)}Tn(p),a+=g,++l}return i}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const c=i[u];i[u]=Rt(i[u],a),Tn(c)}return Qi(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ZC(n){q(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Jy(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Nf(s,e,t-e)):Nf(n,e,t-e)}function k2(n,e){return be(()=>n==null?null:Array.isArray(n)?n.map(t=>k2(t,e)):mU(n,e.dtype==="int32"?e:gt(e,"int32")))}function JC(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function VU(n){const e=[];n instanceof gs&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(wv(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function dl(n,e){if(n==null)return;const t=[];if(e instanceof gs)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof gs)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uoe(n){return n instanceof gs}function R2(n){return Array.isArray(n)}function PP(n){return!Uoe(n)&&!R2(n)}function LP(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(R2(n)&&n.length>0)o=!0;else if(PP(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new ye(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(PP(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new ye(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(R2(n)){if(n=n,n.length!==e.length)throw new ye(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new ye(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=VU(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new ye(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=t[o][l];if(c!=null&&c>=0&&u!==c)throw new ye(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function Boe(n,e,t){const s=Ah(n.map(i=>i.shape[0]));s.sort();const r=Ah(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new ye(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new ye(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!Mn(s,r))throw new ye(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function Voe(n,e,t){const s=[K_,Y_,G0];for(let r=0;r<n.length;++r){const i=n[r],o=e[r],a=t[r];if(o!=null){if(o===G0&&i.shape[i.shape.length-1]===1)throw new ye(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=i.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],f=u[c];if(f!=null&&h!==f)throw new ye(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function OP(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new ye(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new ye(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new ye(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const u=a.shape[l],c=t[o][l];if(c!=null&&c!==u)throw new ye(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Woe(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const Goe="layers-model";class ng extends fl{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new ye("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Eoe(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Coe(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof od))throw new ye("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new ye(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(YC(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ye(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>YC(a))}else{const o=YC(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],If("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=Woe(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};If("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=r[o];(u=>{let h,f,p;for(const g of u){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){const x=this.internalOutputShapes[o];x[x.length-1]===1||this.lossFunctions[o]===Y_?["accuracy","acc"].indexOf(g)!==-1?f=DU:["crossentropy","ce"].indexOf(g)!==-1&&(f=moe):this.lossFunctions[o]===IS?["accuracy","acc"].indexOf(g)!==-1?f=goe:["crossentropy","ce"].indexOf(g)!==-1&&(f=OU):["accuracy","acc"].indexOf(g)!==-1?f=PU:["crossentropy","ce"].indexOf(g)!==-1&&(f=LU);let w;["accuracy","acc"].indexOf(g)!==-1?w="acc":["crossentropy","ce"].indexOf(g)!==-1&&(w="ce"),p=f,h=""+w}else p=Toe(g),h=""+Iw(g);let S;If(h,()=>{S=p}),i(o,h,S)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;ZC(r);const o=this.standardizeUserDataXY(e,t,!0,r);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,r,s.verbose,s.steps);return Qi(u)}finally{dl(o[0],e),dl(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),zoe(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new ye(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new ye(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ye("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),o=new bh;if(e instanceof gs&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ye(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new ye(`No value is provided for the model's input ${l.name}`);o.add(l,u)}const a=r0(i,o);return s?a:a[0]}retrieveSymbolicTensors(e){const t=Vf(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,o)=>{i==null&&r.push(e[o])}),new ye(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return be(()=>{const r=this.checkNumSamples(e);if(s)throw new gn("Verbose predictLoop() is not implemented yet.");const i=JC(r,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)be(()=>{const u=i[a][0],c=i[a][1],h=Jy(e,u,c),f=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)f.push({key:this.inputs[g],value:h[g]});else f.push({key:this.inputs[0],value:h});const p=new bh(f);return r0(this.outputs,p)}).forEach((u,c)=>o[c].push(u));return Qi(o.map(a=>ir(a,0)))})}predict(e,t={}){const s=VU(e);OP(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return ZC(r),this.predictLoop(s,r)}finally{dl(s,e)}}predictOnBatch(e){OP(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new Ma("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===IS?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=LP(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=LP(t,this.feedOutputNames,i,!1,"target"),Boe(e,t),Voe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new ye(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let u=null;if(r!=null){const c=zU(r,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await UU(l[h],null,c[h]))}return[a,l,u]}testLoop(e,t,s,r=0,i){return be(()=>{const o=this.checkNumSamples(t,s,i,"steps"),a=[];if(r>0)throw new gn("Verbose mode is not implemented yet.");if(i!=null)throw new gn("steps mode in testLoop() is not implemented yet");{const l=JC(o,s),u=Kr(El(0,o));for(let c=0;c<l.length;++c){const h=l[c][0],f=l[c][1],p=Nf(u,h,f-h),g=k2(t,p),S=e(g);if(c===0)for(let x=0;x<S.length;++x)a.push(Ht(0));for(let x=0;x<S.length;++x){const w=S[x];a[x]=Ze(a[x],de(f-h,w))}}for(let c=0;c<a.length;++c)a[c]=Rt(a[c],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(wP(e,r)>1){const o=wP(e.slice(0,s),r);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let S=0;S<this.inputs.length;++S)h.push({key:this.inputs[S],value:s[S]});const f=new bh(h),p=r0(this.outputs,f,{training:!0});let g;for(let S=0;S<this.lossFunctions.length;++S){const x=this.lossFunctions[S];let w=x(r[S],p[S]);i[S]!=null&&(w=Doe(w,i[S]));const _=$s(w);t.push(_),S===0?g=w:g=Ze(g,w)}for(let S=0;S<this.metricsTensors.length;++S){let x;if(this.outputs.length>1&&S<this.outputs.length)x=t[S];else{const w=this.metricsTensors[S][0],_=this.metricsTensors[S][1];x=$s(w(r[_],p[_]))}Pr(x),o.push(x)}return g=$s(g),this.calculateLosses().forEach(S=>{g=Ze(g,S)}),g},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>be(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let u=0;u<this.inputs.length;++u)o.push({key:this.inputs[u],value:r[u]});const a=new bh(o),l=r0(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=$s(c(i[u],l[u]));u===0?s=h:s=Ze(s,h),t.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],f=$s(c(i[h],l[h]));t.push(f)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,a,l,u,c,h,f;try{const p=s.batchSize==null?32:s.batchSize;ZC(p);const S=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);r=S[0],i=S[1],f=S[2];let x=!1,w;if(s.validationData!=null&&s.validationData.length>0){if(x=!0,s.validationData.length===2)l=s.validationData[0],u=s.validationData[1];else throw s.validationData.length===3?new gn("validationData including sample weights is not supported yet."):new ye(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const D=await this.standardizeUserData(l,u,null,null,!0,p);c=D[0],h=D[1],w=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){x=!0;const R=Math.floor(r[0].shape[0]*(1-s.validationSplit)),D=r[0].shape[0];c=Jy(r,R,D),o=r,r=Jy(r,0,R),h=Jy(i,R,D),a=i,i=Jy(i,0,R),w=c.concat(h)}else s.validationSteps!=null&&(x=!0);const _=r.concat(i).concat(f);this.checkTrainableWeightsConsistency();const T=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let N,M;x?(this.makeTestFunction(),N=this.testFunction,M=C.slice().concat(C.map(R=>"val_"+R))):(N=null,w=[],M=C.slice());const P=MU(s.callbacks,s.yieldEvery);return await this.fitLoop(T,_,C,p,s.epochs,s.verbose,P,N,w,s.shuffle,M,s.initialEpoch,null,null)}finally{this.isTraining=!1,dl(r,e),dl(i,t),dl(o,e),dl(a,t),dl(c,l),dl(h,u),f!=null&&Tn(f)}}async fitLoop(e,t,s,r,i,o,a,l,u,c,h,f,p,g){r==null&&(r=32),i==null&&(i=1),c==null&&(c=!0),f==null&&(f=0);let S=!1;if(l!=null&&u!=null&&(S=!0),g!=null&&(S=!0,p==null))throw new ye("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const x=this.checkNumSamples(t,r,p,"steps_per_epoch");let w;x!=null&&(w=El(0,x)),o==null&&(o=1);const{callbackList:_,history:T}=kU(a,o,i,f,x,p,r,S,h);_.setModel(this),this.history=T,await _.onTrainBegin(),this.stopTraining_=!1;for(let C=f;C<i;++C){await _.onEpochBegin(C);const N={};if(p!=null)throw new gn("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new gn("batch shuffling is not implemneted yet");c&&D7(w);const M=Kr(w),P=JC(x,r);for(let $=0;$<P.length;++$){const R={};if(await _.onBatchBegin($,R),be(()=>{const D=P[$][0],L=P[$][1],G=Nf(M,D,L-D);R.batch=$,R.size=L-D;const Q=k2(t,G),W=e(Q);for(let H=0;H<s.length;++H){const J=s[H],ie=W[H];R[J]=ie,Pr(ie)}if($===P.length-1&&S){const H=this.testLoop(l,u,r);for(let J=0;J<s.length;++J){const ie=s[J],V=H[J];Pr(V),N["val_"+ie]=V}}}),await _.onBatchEnd($,R),AU(R),this.stopTraining_)break}M.dispose()}if(await _.onEpochEnd(C,N),this.stopTraining_)break}return await _.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Ooe(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],a=this.makeTrainFunction()(r.concat(i)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return Tn(a),dl(s[0],e),dl(s[1],t),Qi(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||t.push({name:r[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=KD().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-KD().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ec(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ec(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=ec(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ec(Iw(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ec(Iw(e)));{const e={};for(const t in this.metrics)e[t]=ec(Iw(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=A2(e.optimizer_config),s=cc(t);let r;if(typeof e.loss=="string")r=df(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>df(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=df(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>df(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=df(e.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const u=QF(e);if(u.length===0)throw new ye(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new ye(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new ye("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await d2(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:Goe,generatedBy:`TensorFlow.js tfjs-layers v${$U}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await d2(await this.optimizer.getWeights(),u);s.specs.push(...h),s.data=YF([s.data,c])}return this.userDefinedMetadata!=null&&(kP(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){kP(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}ng.className="Model";tt(ng);class WU extends ng{}WU.className="Functional";tt(WU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class H0 extends ng{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:j_("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ye(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof H0||e instanceof ng;let s;if(t){if(s=e,s.outputs.length!==1)throw new ye("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ye("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ye("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=jie({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ye(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ye("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=TU(this.outputs[0])}this.inboundNodes=[],new q_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Vf(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Un(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ng({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new Ma("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new Ma("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new Ma("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new Ma("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new ye("Legacy serialization format not supported yet.");i=t}else q(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof H0))throw new gn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const c=cc(l,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new ye("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ye("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}H0.className="Sequential";tt(H0);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ao=class extends zg{getConfig(){return{}}};class GU extends ao{apply(e,t=1){return Mie(e,t)}}GU.className="elu";tt(GU);class HU extends ao{apply(e){return wA(e)}}HU.className="selu";tt(HU);class jU extends ao{apply(e){return yu(e)}}jU.className="relu";tt(jU);class XU extends ao{apply(e){return be(()=>Uf(6,yu(e)))}}XU.className="relu6";tt(XU);class qU extends ao{apply(e){return e}}qU.className="linear";tt(qU);class KU extends ao{apply(e){return Sl(e)}}KU.className="sigmoid";tt(KU);class YU extends ao{apply(e){return Rie(e)}}YU.className="hardSigmoid";tt(YU);class ZU extends ao{apply(e){return Og(e)}}ZU.className="softplus";tt(ZU);class JU extends ao{apply(e){return kie(e)}}JU.className="softsign";tt(JU);class QU extends ao{apply(e){return fg(e)}}QU.className="tanh";tt(QU);let EM=class extends ao{apply(e,t=-1){return L_(e,t)}};EM.className="softmax";tt(EM);class eB extends ao{apply(e,t=-1){return hA(e,t)}}eB.className="logSoftmax";tt(eB);class tB extends ao{apply(e,t=1){return be(()=>de(Sl(de(e,t)),e))}}tB.className="swish";tt(tB);class nB extends ao{apply(e){return be(()=>de(e,fg(Og(e))))}}nB.className="mish";tt(nB);function Bh(n){return n.getClassName()}function QC(n,e={}){return vv(n,Na.getMap().classNameMap,e,"activation")}function Vh(n){if(n==null){const e={};return e.className="linear",e.config={},QC(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},QC(e)}else return n instanceof ao?n:QC(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hoe(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class sB extends zg{}class rB extends sB{constructor(e){super(),Hoe(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return be(()=>{let t=yr([1]);return this.hasL1&&(t=Ze(t,kt(de(this.l1,gr(e))))),this.hasL2&&(t=Ze(t,kt(de(this.l2,Sv(e))))),pe(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}rB.className="L1L2";tt(rB);const FP={l1l2:"L1L2"};function as(n){return dM(n)}function $P(n,e={}){return vv(n,Na.getMap().classNameMap,e,"regularizer")}function Ts(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in FP?FP[n]:n,config:{}};return $P(t)}else return n instanceof sB?n:$P(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class iB extends En{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=tn(e);let s=yu(e);return this.maxValue!=null&&(s=Oo(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}iB.className="ReLU";tt(iB);class oB extends En{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=tn(e);return T_(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}oB.className="LeakyReLU";tt(oB);class aB extends En{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=_s(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ts(e.alphaRegularizer),this.alphaConstraint=br(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ye(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Un(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new vr({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=tn(e),k_(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ms(this.alphaInitializer),alphaRegularizer:as(this.alphaRegularizer),alphaConstraint:Sr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}aB.className="PReLU";tt(aB);let lB=class extends En{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new gn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=tn(e);return dv(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};lB.className="ELU";tt(lB);class uB extends En{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=tn(e);return de(s,gt(Wo(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}uB.className="ThresholdedReLU";tt(uB);class cB extends En{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new EM().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return be(()=>{let s=tn(e);const r=t.mask;if(r!=null){const i=de(Tt(ko(s.shape),gt(r,s.dtype)),Ht(-1e9));s=Ze(s,i)}return this.axis instanceof Array?this.axis.length>1?Fo(Tt(s,E_(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}cB.className="Softmax";tt(cB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sg(n,e,t){if(typeof n=="number")return Vf(n,e);if(n.length!==e)throw new ye(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!Eie(r))throw new ye(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function bl(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function nu(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Uh([t-e,0]);else if(s==="same")n=n*e;else throw new ye(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function IM(n,e){return be(()=>(qs(e),e==="channelsFirst"?Dn(n,[0,2,3,1]):n))}function hB(n,e){return be(()=>(qs(e),e==="channelsFirst"?Dn(n,[0,2,3,4,1]):n))}function joe(n,e,t,s=1,r="valid",i,o=1){return be(()=>{if(i==null&&(i=Il()),qs(i),n.shape.length!==3)throw new ye(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new ye(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new ye(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=Dn(n,[0,2,1])),r==="causal")throw new gn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=rA(n,e,s,r==="same"?"same":"valid","NWC",o);return t!=null&&(a=Rl(a,t)),a})}function zP(n,e,t,s=[1,1],r="valid",i,o,a=null){return be(()=>{if(i==null&&(i=Il()),qs(i),n.rank!==3&&n.rank!==4)throw new ye(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ye(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=IM(n,i);if(r==="causal")throw new gn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=oz({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(l=Dn(l,[0,3,1,2])),l})}function Xoe(n,e,t,s=[1,1,1],r="valid",i,o){return be(()=>{if(i==null&&(i=Il()),qs(i),n.rank!==4&&n.rank!==5)throw new ye(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ye(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=hB(n,i);if(r==="causal")throw new gn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=C$(a,e,s,r==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Rl(a,t)),i==="channelsFirst"&&(a=Dn(a,[0,4,1,2,3])),a})}class Z_ extends En{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Z_.verifyArgs(t),this.rank=e,Lr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new gn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=sg(t.kernelSize,e,"kernelSize"),this.strides=sg(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,ca(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,qs(this.dataFormat),this.activation=Vh(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=_s(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=br(t.biasConstraint),this.biasRegularizer=Ts(t.biasRegularizer),this.activityRegularizer=Ts(t.activityRegularizer),this.dilationRate=sg(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ye(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ye(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ye(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(tu("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!fM(e.kernelSize,"number",1,3))throw new ye(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Bh(this.activation),useBias:this.useBias,biasInitializer:Ms(this.biasInitializer),biasRegularizer:as(this.biasRegularizer),activityRegularizer:as(this.activityRegularizer),biasConstraint:Sr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Ug extends Z_{constructor(e,t){super(e,t),this.kernel=null,Ug.verifyArgs(t),this.filters=t.filters,Lr(this.filters,"filters"),this.kernelInitializer=_s(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=br(t.kernelConstraint),this.kernelRegularizer=Ts(t.kernelRegularizer)}build(e){e=Un(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ye(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return be(()=>{e=tn(e);let s;const r=this.bias==null?null:this.bias.read(),i=uU(this.activation.getClassName());if(i!=null&&this.rank===2)s=zP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=joe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=zP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Xoe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new gn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Un(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const o=bl(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Ms(this.kernelInitializer),kernelRegularizer:as(this.kernelRegularizer),kernelConstraint:Sr(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ye(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Cv extends Ug{constructor(e){super(2,e),Cv.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!fM(e.kernelSize,"number",1,2))throw new ye(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Cv.className="Conv2D";tt(Cv);class Ev extends Ug{constructor(e){super(3,e),Ev.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ye(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Ev.className="Conv3D";tt(Ev);class dB extends Cv{constructor(e){if(super(e),this.inputSpec=[new vr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ye(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Un(e),e.length!==4)throw new ye("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ye("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new vr({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return be(()=>{let s=tn(e);if(s.shape.length!==4)throw new ye(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=r[o],u=r[a],c=this.kernelSize[0],h=this.kernelSize[1],f=this.strides[0],p=this.strides[1],g=nu(l,f,c,this.padding),S=nu(u,p,h,this.padding),x=[i,g,S,this.filters];this.dataFormat!=="channelsLast"&&(s=Dn(s,[0,2,3,1]));let w=oA(s,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Dn(w,[0,3,1,2])),this.bias!=null&&(w=Rl(w,this.bias.read(),this.dataFormat)),this.activation!=null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=Un(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[s]=this.filters,t[r]=nu(t[r],l,o,this.padding),t[i]=nu(t[i],u,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}dB.className="Conv2DTranspose";tt(dB);class fB extends Ev{constructor(e){if(super(e),this.inputSpec=[new vr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ye(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Un(e),e.length!==5)throw new ye("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ye("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new vr({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return be(()=>{let s=tn(e);if(s.shape.length!==5)throw new ye(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const u=r[l],c=r[o],h=r[a],f=this.kernelSize[0],p=this.kernelSize[1],g=this.kernelSize[2],S=this.strides[0],x=this.strides[1],w=this.strides[2],_=nu(u,S,f,this.padding),T=nu(c,x,p,this.padding),C=nu(h,w,g,this.padding),N=[i,_,T,C,this.filters];this.dataFormat!=="channelsLast"&&(s=Dn(s,[0,2,3,4,1]));let M=I$(s,this.kernel.read(),N,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(M=Dn(M,[0,4,1,2,3])),this.bias!==null&&(M=Rl(M,this.bias.read(),this.dataFormat)),this.activation!==null&&(M=this.activation.apply(M)),M})}computeOutputShape(e){e=Un(e);const t=e.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],f=this.strides[2];return t[s]=this.filters,t[r]=nu(t[r],c,a,this.padding),t[i]=nu(t[i],h,l,this.padding),t[o]=nu(t[o],f,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}fB.className="Conv3DTranspose";tt(fB);class pB extends Ug{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ye("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ye("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ye(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=_s(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ts(t.depthwiseRegularizer),this.depthwiseConstraint=br(t.depthwiseConstraint),this.pointwiseInitializer=_s(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ts(t.pointwiseRegularizer),this.pointwiseConstraint=br(t.pointwiseConstraint)}build(e){if(e=Un(e),e.length<this.rank+2)throw new ye(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ye(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new vr({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return be(()=>{e=tn(e);let s;if(this.rank===1)throw new gn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Dn(e,[0,2,3,1])),s=SA(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Rl(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Dn(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ms(this.depthwiseInitializer),e.pointwiseInitializer=Ms(this.pointwiseInitializer),e.depthwiseRegularizer=as(this.depthwiseRegularizer),e.pointwiseRegularizer=as(this.pointwiseRegularizer),e.depthwiseConstraint=Sr(this.depthwiseConstraint),e.pointwiseConstraint=Sr(this.pointwiseConstraint),e}}pB.className="SeparableConv";class mB extends pB{constructor(e){super(2,e)}}mB.className="SeparableConv2D";tt(mB);class J_ extends Ug{constructor(e){super(1,e),J_.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!fM(e.kernelSize,"number",1,1))throw new ye(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}J_.className="Conv1D";tt(J_);class gB extends En{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return be(()=>{if(e=tn(e),this.dataFormat==="channelsLast"){const s=Ew(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ew(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Ew(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ew(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}gB.className="Cropping2D";tt(gB);class yB extends En{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,qs(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,_ie(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return be(()=>{let s=tn(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Dn(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],a=this.interpolation==="nearest"?Ro.resizeNearestNeighbor(s,[i,o]):Ro.resizeBilinear(s,[i,o]);return Dn(a,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Ro.resizeNearestNeighbor(s,[i,o]):Ro.resizeBilinear(s,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}yB.className="UpSampling2D";tt(yB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qoe(n,e,t=[1,1],s="valid",r,i){return be(()=>{r==null&&(r=Il()),qs(r);let o=IM(n,r);if(n.rank!==4)throw new ye(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new ye(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=hv(o,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=Dn(o,[0,3,1,2])),o})}class xB extends Z_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=_s(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=br(e.depthwiseConstraint),this.depthwiseRegularizer=Ts(e.depthwiseRegularizer)}build(e){if(e=Un(e),e.length<4)throw new ye(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ye(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{e=tn(e);let s=qoe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Rl(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Un(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=bl(t,this.kernelSize[0],this.padding,this.strides[0]),o=bl(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,o]:[e[0],i,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ms(this.depthwiseInitializer),e.depthwiseRegularizer=as(this.depthwiseRegularizer),e.depthwiseConstraint=Sr(this.depthwiseRegularizer),e}}xB.className="DepthwiseConv2D";tt(xB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vB(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new ye("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function wB(n,e,t,s=!1,r,i,o=!1,a=!1){return be(()=>{const l=e.shape.length;if(l<3)throw new ye(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(El(2,l));e=Dn(e,u),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=gt(gt(r,"bool"),"float32"),r.rank===l-1&&(r=pi(r,-1)),r=Dn(r,u)),s&&(e=La(e,0),r!=null&&(r=La(r,0)));const c=[];let h,f=t;const p=e.shape[0],g=Oa(e);let S;r!=null&&(S=Oa(r));for(let w=0;w<p;++w){const _=g[w],T=be(()=>n(_,f));if(r==null)h=T[0],f=T[1];else{const C=be(()=>{const N=S[w],M=Tt(la(N),N),P=Ze(de(T[0],N),de(f[0],M)),$=f.map((R,D)=>Ze(de(T[1][D],N),de(R,M)));return{output:P,newStates:$}});h=C.output,f=C.newStates}a&&c.push(h)}let x;return a&&(x=$o(c,1)),[h,x,f]})}class ad extends En{constructor(e){super(e);let t;if(e.cell==null)throw new ye("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new MM({cells:e.cell}):t=e.cell,t.stateSize==null)throw new ye("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new vr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return El(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){E2(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[r].concat(i)}else return r}computeMask(e,t){return be(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new gn("Constants support is not implemented in RNN yet.");E2(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new vr({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Mn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new ye(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new vr({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){be(()=>{if(!this.stateful)throw new eu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ye("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>yr([s,r])):this.states_=[yr([s,this.cell.stateSize])];else if(e==null)Tn(this.states_),this.keptStates!=null&&(Tn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>yr([s,r])):this.states_[0]=yr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ye(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Tn(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,o];if(!Mn(i.shape,a))throw new ye(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>Pr(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=vB(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let o=[],a=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new vr({shape:u.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof pu){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const f=super.apply(u,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return be(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=tn(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new ye(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},u=wB((g,S)=>{const x=this.cell.call([g].concat(S),a);return[x[0],x.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),c=u[0],h=u[1],f=u[2];this.stateful&&this.resetStates(f,r);const p=this.returnSequences?h:c;return this.returnState?[p].concat(f):p})}getInitialState(e){return be(()=>{let t=yr(e.shape);return t=kt(t,[1,2]),t=wv(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?T2(t,[1,s]):t):this.cell.stateSize>1?[T2(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===ad.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=cc(r,s);return new e(Object.assign(t,{cell:i}))}}ad.className="RNN";tt(ad);class Q_ extends En{}class NM extends Q_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Lr(this.units,"units"),this.activation=Vh(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=_s(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_s(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_s(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ts(e.kernelRegularizer),this.recurrentRegularizer=Ts(e.recurrentRegularizer),this.biasRegularizer=Ts(e.biasRegularizer),this.kernelConstraint=br(e.kernelConstraint),this.recurrentConstraint=br(e.recurrentConstraint),this.biasConstraint=br(e.biasConstraint),this.dropout=yg([1,Uh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=yg([1,Uh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Un(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{if(e=e,e.length!==2)throw new ye(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wh({ones:()=>la(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wh({ones:()=>la(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=hu(de(e,o),this.kernel.read()):i=hu(e,this.kernel.read()),this.bias!=null&&(i=Rl(i,this.bias.read())),a!=null&&(s=de(s,a));let l=Ze(i,hu(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Bh(this.activation),useBias:this.useBias,kernelInitializer:Ms(this.kernelInitializer),recurrentInitializer:Ms(this.recurrentInitializer),biasInitializer:Ms(this.biasInitializer),kernelRegularizer:as(this.kernelRegularizer),recurrentRegularizer:as(this.recurrentRegularizer),biasRegularizer:as(this.biasRegularizer),activityRegularizer:as(this.activityRegularizer),kernelConstraint:Sr(this.kernelConstraint),recurrentConstraint:Sr(this.recurrentConstraint),biasConstraint:Sr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}NM.className="SimpleRNNCell";tt(NM);class SB extends ad{constructor(e){e.cell=new NM(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}SB.className="SimpleRNN";tt(SB);class AM extends Q_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ye("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Lr(this.units,"units"),this.activation=Vh(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Vh(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=_s(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_s(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_s(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ts(e.kernelRegularizer),this.recurrentRegularizer=Ts(e.recurrentRegularizer),this.biasRegularizer=Ts(e.biasRegularizer),this.kernelConstraint=br(e.kernelConstraint),this.recurrentConstraint=br(e.recurrentConstraint),this.biasConstraint=br(e.biasConstraint),this.dropout=yg([1,Uh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=yg([1,Uh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Un(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return be(()=>{if(e=e,e.length!==2)throw new ye(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wh({ones:()=>la(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wh({ones:()=>la(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=de(e,i[0]));let c=hu(e,this.kernel.read());this.useBias&&(c=Rl(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=de(r,o[0]));const h=this.recurrentKernel.read(),[f,p]=Po(h,[2*this.units,this.units],h.rank-1),g=hu(r,f),[S,x,w]=Po(c,3,c.rank-1),[_,T]=Po(g,2,g.rank-1);a=this.recurrentActivation.apply(Ze(S,_)),l=this.recurrentActivation.apply(Ze(x,T));const C=hu(de(l,r),p);u=this.activation.apply(Ze(w,C));const N=Ze(de(a,r),de(Ze(1,ys(a)),u));return[N,N]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Bh(this.activation),recurrentActivation:Bh(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ms(this.kernelInitializer),recurrentInitializer:Ms(this.recurrentInitializer),biasInitializer:Ms(this.biasInitializer),kernelRegularizer:as(this.kernelRegularizer),recurrentRegularizer:as(this.recurrentRegularizer),biasRegularizer:as(this.biasRegularizer),activityRegularizer:as(this.activityRegularizer),kernelConstraint:Sr(this.kernelConstraint),recurrentConstraint:Sr(this.recurrentConstraint),biasConstraint:Sr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}AM.className="GRUCell";tt(AM);class bB extends ad{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new AM(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}bB.className="GRU";tt(bB);class eT extends Q_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Lr(this.units,"units"),this.activation=Vh(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Vh(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=_s(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=_s(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=_s(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Ts(e.kernelRegularizer),this.recurrentRegularizer=Ts(e.recurrentRegularizer),this.biasRegularizer=Ts(e.biasRegularizer),this.kernelConstraint=br(e.kernelConstraint),this.recurrentConstraint=br(e.recurrentConstraint),this.biasConstraint=br(e.biasConstraint),this.dropout=yg([1,Uh([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=yg([1,Uh([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Un(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(t=class extends $a{apply(l,u){const c=i.apply([o]),h=new mM().apply([o]),f=i.apply([o*2]);return bP(bP(c,h),f)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return be(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ye(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wh({ones:()=>la(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wh({ones:()=>la(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=de(e,o[0]));let f=hu(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=de(r,a[0])),f=Ze(f,hu(r,this.recurrentKernel.read())),this.useBias&&(f=Rl(f,this.bias.read()));const[p,g,S,x]=Po(f,4,f.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(g),c=Ze(de(u,i),de(l,this.activation.apply(S))),h=this.recurrentActivation.apply(x);const w=de(h,this.activation.apply(c));return[w,w,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Bh(this.activation),recurrentActivation:Bh(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ms(this.kernelInitializer),recurrentInitializer:Ms(this.recurrentInitializer),biasInitializer:Ms(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:as(this.kernelRegularizer),recurrentRegularizer:as(this.recurrentRegularizer),biasRegularizer:as(this.biasRegularizer),activityRegularizer:as(this.activityRegularizer),kernelConstraint:Sr(this.kernelConstraint),recurrentConstraint:Sr(this.recurrentConstraint),biasConstraint:Sr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}eT.className="LSTMCell";tt(eT);class _B extends ad{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new eT(e),super(e)}call(e,t){return be(()=>{this.cell.dropoutMask!=null&&(Tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}_B.className="LSTM";tt(_B);class MM extends Q_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return be(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=r[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,t),i.push(o.slice(1))}s=[];for(const a of i.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){E2(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{If(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(cc(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return I2(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],i[o]])}bM(t)}}MM.className="StackedRNNCells";tt(MM);function Wh(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):gU(e(),t),a=()=>bv(o,e,s);return!r||r<=1?Pr(a().clone()):Array(r).fill(void 0).map(a).map(u=>Pr(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Koe=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class TB extends ad{constructor(e){if(e.unroll)throw new gn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new gn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new vr({ndim:5})]}call(e,t){return be(()=>{if(this.cell.dropoutMask!=null&&(Tn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Tn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ye("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return be(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=yr(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){be(()=>{if(!this.stateful)throw new eu("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new ye("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>yr(i)):this.states_=[yr(i)];else if(e==null)Tn(this.states_),this.keptStates!=null&&(Tn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>yr(i)):this.states_[0]=yr(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ye(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Tn(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],u=i;if(!Mn(l.shape,u))throw new ye(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Pr(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=bl(u,r[0],i,o[0],a[0]),f=bl(c,r[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[s,h,f]:[h,f,s]]}}TB.className="ConvRNN2D";class kM extends eT{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Lr(this.filters,"filters"),this.kernelSize=sg(s,2,"kernelSize"),this.kernelSize.forEach(l=>Lr(l,"kernelSize")),this.strides=sg(r||1,2,"strides"),this.strides.forEach(l=>Lr(l,"strides")),this.padding=i||"valid",ca(this.padding),this.dataFormat=o||"channelsLast",qs(this.dataFormat),this.dilationRate=sg(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Lr(l,"dilationRate"))}build(e){var t;e=Un(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ye(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends $a{apply(f,p){const g=u.apply([c]),S=ko([c]),x=u.apply([c*2]);return pM([g,S,x])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return be(()=>{if(e.length!==3)throw new ye(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wh({ones:()=>la(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(B,K,se)=>!K||!K[se]?B:de(K[se],B);let c=u(r,l,0),h=u(r,l,1),f=u(r,l,2),p=u(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wh({ones:()=>la(i),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let S=u(i,g,0),x=u(i,g,1),w=u(i,g,2),_=u(i,g,3);const T=3,[C,N,M,P]=Po(this.kernel.read(),a,T),[$,R,D,L]=this.useBias?Po(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,C,$,this.padding),h=this.inputConv(h,N,R,this.padding),f=this.inputConv(f,M,D,this.padding),p=this.inputConv(p,P,L,this.padding);const[G,Q,W,H]=Po(this.recurrentKernel.read(),a,T);S=this.recurrentConv(S,G),x=this.recurrentConv(x,Q),w=this.recurrentConv(w,W),_=this.recurrentConv(_,H);const J=this.recurrentActivation.apply(Ze(c,S)),ie=this.recurrentActivation.apply(Ze(h,x)),V=Ze(de(ie,o),de(J,this.activation.apply(Ze(f,w)))),Y=de(this.recurrentActivation.apply(Ze(p,_)),this.activation.apply(V));return[Y,Y,V]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=Koe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=$h(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Rl(i,s,this.dataFormat):i}recurrentConv(e,t){return $h(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}kM.className="ConvLSTM2DCell";tt(kM);class CB extends TB{constructor(e){const t=new kM(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}CB.className="ConvLSTM2D";tt(CB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class RM extends En{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return bv(()=>gU(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}RM.className="Dropout";tt(RM);class EB extends RM{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}EB.className="SpatialDropout1D";tt(EB);class IB extends En{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Lr(this.units,"units"),this.activation=Vh(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=_s(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=_s(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=br(e.kernelConstraint),this.biasConstraint=br(e.biasConstraint),this.kernelRegularizer=Ts(e.kernelRegularizer),this.biasRegularizer=Ts(e.biasRegularizer),this.activityRegularizer=Ts(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Un(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Un(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e),r=uU(this.activation.getClassName());let i;return r!=null?i=hu(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=hu(s,this.kernel.read()),this.bias!=null&&(i=Rl(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Bh(this.activation),useBias:this.useBias,kernelInitializer:Ms(this.kernelInitializer),biasInitializer:Ms(this.biasInitializer),kernelRegularizer:as(this.kernelRegularizer),biasRegularizer:as(this.biasRegularizer),activityRegularizer:as(this.activityRegularizer),kernelConstraint:Sr(this.kernelConstraint),biasConstraint:Sr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}IB.className="Dense";tt(IB);class NB extends En{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Un(e);for(const t of e.slice(1))if(t==null)throw new ye(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Mh(e,1)]}call(e,t){return be(()=>{this.invokeCallHook(e,t);let s=tn(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=Dn(s,r)}return Aie(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}NB.className="Flatten";tt(NB);class AB extends En{constructor(e){super(e),this.supportsMasking=!0,this.activation=Vh(e.activation)}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e);return this.activation.apply(s)})}getConfig(){const e={activation:Bh(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}AB.className="Activation";tt(AB);class MB extends En{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return be(()=>(e=tn(e),Iie(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}MB.className="RepeatVector";tt(MB);class kB extends En{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,o=null;for(let l=0;l<r.length;++l){const u=r[l];if(this.isUnknown(u))if(o===null)o=l;else throw new ye("Can only specifiy one unknown dimension.");else i*=u}const a=Mh(e);if(o!==null){if(i===0||a%i!==0)throw new ye(s);r[o]=a/i}else if(a!==i)throw new ye(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return pe(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}kB.className="Reshape";tt(kB);class RB extends En{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=El(1,e.dims.length+1);if(!Mn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new vr({ndim:this.dims.length+1})]}computeOutputShape(e){e=Un(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return Dn(tn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}RB.className="Permute";tt(RB);class DB extends En{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=tn(e);return wS(mg(s,this.maskValue),-1)}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e),o=wS(mg(s,this.maskValue),-1,!0);return de(s,gt(o,s.dtype))})}}DB.className="Masking";tt(DB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PB extends En{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Xn(e.inputLength))}this.inputDim=e.inputDim,Lr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Lr(this.outputDim,"outputDim"),this.embeddingsInitializer=_s(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ts(e.embeddingsRegularizer),this.activityRegularizer=Ts(e.activityRegularizer),this.embeddingsConstraint=br(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return be(()=>this.maskZero?(e=tn(e),mg(e,Pn(e))):null)}computeOutputShape(e){if(e=Un(e),this.inputLength==null)return[...e,this.outputDim];const t=Xn(this.inputLength);if(t.length!==e.length-1)throw new ye(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],o=e[r+1];if(i!=null&&o!=null&&i!==o)throw new ye(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return be(()=>{this.invokeCallHook(e,t);let s=tn(e);s.dtype!=="int32"&&(s=cu(s,"int32"));const r=mU(this.embeddings.read(),pe(s,[s.size]));return pe(r,Un(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ms(this.embeddingsInitializer),embeddingsRegularizer:as(this.embeddingsRegularizer),activityRegularizer:as(this.activityRegularizer),embeddingsConstraint:Sr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}PB.className="Embedding";tt(PB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ep extends En{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new gn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],o=t[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new ye("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Un(e)]),e=e,e.length<2)throw new ye(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Ah(t),t.length>1)throw new ye(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Ah(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return be(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Uh(r);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=wv(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],f=c.slice(1).concat([h]);let p=pe(l,[h].concat(Mh(c.slice(1))));p=Dn(p,[1,0]),p=pe(p,f),s.push(p),i=!0}else if(u>1){const c=El(1,u).concat([0]);s.push(Dn(l,c)),i=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(i){if(a==null){const l=o.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));o=pe(Dn(pe(o,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat(El(0,a-1));o=Dn(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Ah(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return be(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ye("`mask` should be an Array");if(!Array.isArray(e))throw new ye("`inputs` should be an Array");if(t.length!==e.length)throw new ye(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:pi(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=fu(s,t[r]);return s})}}class LB extends ep{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ze(t,e[s]);return t})}}LB.className="Add";tt(LB);class OB extends ep{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=de(t,e[s]);return t})}}OB.className="Multiply";tt(OB);class FB extends ep{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Ze(t,e[s]);return de(1/e.length,t)})}}FB.className="Average";tt(FB);class $B extends ep{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=bc(t,e[s]);return t})}}$B.className="Maximum";tt($B);class zB extends ep{constructor(e){super(e)}mergeFunction(e){return be(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Uf(t,e[s]);return t})}}zB.className="Minimum";tt(zB);class UB extends ep{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ye("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let o=!1;for(const a of s)if(Mn(a,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new ye("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return be(()=>pM(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ye("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ye("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ye("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ye(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return be(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(gt(la(e[o]),"bool")):t[o].rank<e[o].rank?r.push(pi(t[o],-1)):r.push(t[o]);const i=ir(r,this.axis);return tA(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}UB.className="Concatenate";tt(UB);function Qy(n,e){for(;n<0;)n+=e;return n}function Yoe(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new gn("batchDot is not implemented for tensors of 4D or higher rank yet");if(q(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),q(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new gn("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return be(()=>{let o;if(s>r){o=s-r;const l=[];for(let u=0;u<o;++u)l.push(1);e=pe(e,e.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let u=0;u<o;++u)l.push(1);n=pe(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=kt(de(n,e),i[0]):a=kt(de(Dn(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,u=i[1]===e.shape.length-1;a=In(n,e,l,u)}if(o>0){let l;s>r?l=s+r-3:l=s-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);a=mc(a,u)}return a.shape.length===1&&(a=pi(a,1)),a})}class BB extends ep{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){q(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new gn("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new ye(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ye(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>Qy(i,e[o].shape.length)):r=[Qy(this.axes,t.shape.length),Qy(this.axes,s.shape.length)],this.normalize&&(t=ES(t,r[0]),s=ES(s,r[1])),Yoe(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Qy(this.axes,e.length),Qy(this.axes,t.length)],s}computeOutputShape(e){q(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new gn("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}BB.className="Dot";tt(BB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class VB extends En{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e);return bv(()=>Ze(X_(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}VB.className="GaussianNoise";tt(VB);class WB extends En{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return be(()=>{this.invokeCallHook(e,t);const s=tn(e);return this.rate>0&&this.rate<1?bv(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return de(s,X_(s.shape,1,i))},()=>s,t.training||!1):s})}}WB.className="GaussianDropout";tt(WB);class GB extends En{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||tn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return be(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return bv(()=>{const i=tn(e),a=-1.6732632423543772*1.0507009873554805;let l=rd(Zf(s),this.rate);l=cu(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,h=Ze(de(i,l),de(Ze(l,-1),a));return Ze(de(h,u),c)},()=>tn(e),t.training||!1)}return e})}}GB.className="AlphaDropout";tt(GB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function j0(n,e,t,s,r,i=.001){let o;if(n.rank===2)o=y$(n,e,t,s,r,i);else if(n.rank===3)o=x$(n,e,t,s,r,i);else if(n.rank===4)o=v$(n,e,t,s,r,i);else throw new gn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function Zoe(n,e,t,s,r=.001){return be(()=>{const i=A_(n,s),o=i.mean,a=i.variance;return[j0(n,o,a,t,e,r),o,a]})}function Joe(n,e,t,s,r=.001){return be(()=>{const i=A_(n,s),o=i.mean,a=i.variance,l=[];for(const g of El(0,n.rank))s.indexOf(g)!==-1?l.push(1):l.push(n.shape[g]);const u=pe(o,l),c=pe(a,l),h=e==null?null:pe(e,l),f=t==null?null:pe(t,l);return[j0(n,u,c,f,h,r),o,a]})}function Qoe(n,e,t,s,r=.001){return Mn(s.slice().sort(),El(0,n.rank-1))?Zoe(n,e,t,s,r):Joe(n,e,t,s,r)}class HB extends En{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=_s(e.betaInitializer||"zeros"),this.gammaInitializer=_s(e.gammaInitializer||"ones"),this.movingMeanInitializer=_s(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=_s(e.movingVarianceInitializer||"ones"),this.betaConstraint=br(e.betaConstraint),this.gammaConstraint=br(e.gammaConstraint),this.betaRegularizer=Ts(e.betaRegularizer),this.gammaRegularizer=Ts(e.gammaRegularizer)}build(e){e=Un(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new ye(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new vr({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return be(()=>{const s=t.training==null?!1:t.training,r=tn(e),i=r.shape,o=i.length,a=El(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=Vf(1,o);u[l]=i[l];const c=a.slice();c.sort();const h=!Mn(c,El(0,o).slice(0,o-1)),f=()=>{if(h){const _=pe(this.movingMean.read(),u),T=pe(this.movingVariance.read(),u),C=this.center?pe(this.beta.read(),u):null,N=this.scale?pe(this.gamma.read(),u):null;return j0(r,_,T,C,N,this.epsilon)}else return j0(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return f();const[p,g,S]=Qoe(r,this.gamma.read(),this.beta.read(),a,this.epsilon),x=(_,T,C)=>{be(()=>{const N=1-C,M=_.read(),P=de(Tt(M,T),N);_.write(Tt(M,P))})};return(()=>{x(this.movingMean,g,this.momentum),x(this.movingVariance,S,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ms(this.betaInitializer),gammaInitializer:Ms(this.gammaInitializer),movingMeanInitializer:Ms(this.movingMeanInitializer),movingVarianceInitializer:Ms(this.movingVarianceInitializer),betaRegularizer:as(this.betaRegularizer),gammaRegularizer:as(this.gammaRegularizer),betaConstraint:Sr(this.betaConstraint),gammaConstraint:Sr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}HB.className="BatchNormalization";tt(HB);class jB extends En{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=_s(e.betaInitializer||"zeros"),this.gammaInitializer=_s(e.gammaInitializer||"ones"),this.betaRegularizer=Ts(e.betaRegularizer),this.gammaRegularizer=Ts(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Un(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ah(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=tn(e),r=s.shape,i=r.length;return be(()=>{let{mean:a,variance:l}=A_(s,this.axis,!0);const u=Vf(1,i);for(const S of this.axis)u[S]=r[S];const c=S=>S!=null&&S.shape.length!==i?pe(S,u):S;let h=this.scale?c(this.gamma.read()):null,f=this.center?c(this.beta.read()):null;const p=[],g=[];for(let S=0;S<i;++S)this.axis.indexOf(S)!==-1?(p.push(r[S]),g.push(1)):(p.push(1),g.push(r[S]));return a=Aa(a,p),l=Aa(l,p),h!=null&&(h=Aa(h,g)),f!=null&&(f=Aa(f,g)),j0(s,a,l,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ms(this.betaInitializer),gammaInitializer:Ms(this.gammaInitializer),betaRegularizer:as(this.betaRegularizer),gammaRegularizer:as(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}jB.className="LayerNormalization";tt(jB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eae(n,e,t){return be(()=>{if(n.rank!==4)throw new ye(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ye("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Il()),t!=="channelsLast"&&t!=="channelsFirst")throw new ye(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],id(n,s)})}class XB extends En{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Il():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ye(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ye(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ye(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new vr({ndim:4})]}computeOutputShape(e){e=Un(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return be(()=>eae(tn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}XB.className="ZeroPadding2D";tt(XB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tT(n,e,t,s,r,i){return be(()=>{qs(r),hU(i),ca(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=Il()),i==null&&(i="max"),n=IM(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=N_(n,e,t,a):o=w_(n,e,t,a),r==="channelsFirst"&&(o=Dn(o,[0,3,1,2])),o})}function qB(n,e,t,s,r,i){return be(()=>{qs(r),hU(i),ca(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Il()),i==null&&(i="max"),n=hB(n,r);let o;const a=s==="same"?"same":"valid";return i==="max"?o=W$(n,e,t,a):o=g$(n,e,t,a),r==="channelsFirst"&&(o=Dn(o,[0,4,1,2,3])),o})}class KB extends En{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ye(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Lr(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ye(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Lr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ca(this.padding),this.inputSpec=[new vr({ndim:3})]}computeOutputShape(e){e=Un(e);const t=bl(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return be(()=>{this.invokeCallHook(e,t),e=wv(tn(e),2);const s=this.poolingFunction(tn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return mc(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class YB extends KB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return qs(i),ca(r),tT(e,t,s,r,i,"max")}}YB.className="MaxPooling1D";tt(YB);class ZB extends KB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return qs(i),ca(r),tT(e,t,s,r,i,"avg")}}ZB.className="AveragePooling1D";tt(ZB);class JB extends En{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ye(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Lr(this.poolSize,"poolSize"),Lr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,qs(this.dataFormat),ca(this.padding),this.inputSpec=[new vr({ndim:4})]}computeOutputShape(e){e=Un(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=bl(t,this.poolSize[0],this.padding,this.strides[0]),s=bl(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return be(()=>(this.invokeCallHook(e,t),this.poolingFunction(tn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class QB extends JB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return qs(i),ca(r),tT(e,t,s,r,i,"max")}}QB.className="MaxPooling2D";tt(QB);class e4 extends JB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return qs(i),ca(r),tT(e,t,s,r,i,"avg")}}e4.className="AveragePooling2D";tt(e4);class t4 extends En{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ye(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Lr(this.poolSize,"poolSize"),Lr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,qs(this.dataFormat),ca(this.padding),this.inputSpec=[new vr({ndim:5})]}computeOutputShape(e){e=Un(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=bl(t,this.poolSize[0],this.padding,this.strides[0]),s=bl(s,this.poolSize[1],this.padding,this.strides[1]),r=bl(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return be(()=>(this.invokeCallHook(e,t),this.poolingFunction(tn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class n4 extends t4{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return qs(i),ca(r),qB(e,t,s,r,i,"max")}}n4.className="MaxPooling3D";tt(n4);class s4 extends t4{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return qs(i),ca(r),qB(e,t,s,r,i,"avg")}}s4.className="AveragePooling3D";tt(s4);class r4 extends En{constructor(e){super(e),this.inputSpec=[new vr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new gn}}class i4 extends r4{constructor(e){super(e||{})}call(e,t){return be(()=>{const s=tn(e);return $s(s,1)})}}i4.className="GlobalAveragePooling1D";tt(i4);class o4 extends r4{constructor(e){super(e||{})}call(e,t){return be(()=>{const s=tn(e);return Da(s,1)})}}o4.className="GlobalMaxPooling1D";tt(o4);class a4 extends En{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,qs(this.dataFormat),this.inputSpec=[new vr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new gn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class l4 extends a4{call(e,t){return be(()=>{const s=tn(e);return this.dataFormat==="channelsLast"?$s(s,[1,2]):$s(s,[2,3])})}}l4.className="GlobalAveragePooling2D";tt(l4);class u4 extends a4{call(e,t){return be(()=>{const s=tn(e);return this.dataFormat==="channelsLast"?Da(s,[1,2]):Da(s,[2,3])})}}u4.className="GlobalMaxPooling2D";tt(u4);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class c4 extends En{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=cc(r,s);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class h4 extends c4{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Un(e),e.length<3)throw new ye(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Un(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return be(()=>(e=tn(e),wB((o,a)=>[tn(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}h4.className="TimeDistributed";tt(h4);function tae(n){Qf(bie,"BidirectionalMergeMode",n)}const nae="concat";class d4 extends c4{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=cc(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=cc(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?nae:e.mergeMode,tae(this.mergeMode),e.weights)throw new gn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):Qi(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=vB(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const o=[],a=[];if(s!=null){const u=s.length;if(u%2>0)throw new ye("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const c=s.map(h=>new vr({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(r!=null)throw new gn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof pu;for(const u of o)if(u instanceof pu!==l)throw new ye("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const f=super.apply(u,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return be(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=La(i,1));let a;return this.mergeMode==="concat"?a=pM([r,i]):this.mergeMode==="sum"?a=Ze(r,i):this.mergeMode==="ave"?a=de(.5,Ze(r,i)):this.mergeMode==="mul"?a=de(r,i):this.mergeMode==null&&(a=[r,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){If(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),If(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=cc(t.layer);if(delete t.layer,t.numConstants!=null)throw new gn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}d4.className="Bidirectional";tt(d4);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class f4 extends En{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return be(()=>(e=tn(e),e.dtype!=="float32"&&(e=cu(e,"float32")),Ze(de(e,this.scale),this.offset)))}}f4.className="Rescaling";tt(f4);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:sae,cropAndResize:rae}=Ro;class p4 extends En{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,o,a,l){return be(()=>{let u,c=!1;const h=t/o,f=s/a,p=(r+t)/o,g=(i+s)/a,S=[h,f,p,g],x=[];e.rank===3?(c=!0,u=$o([e])):u=e;for(let N=0;N<u.shape[0];N++)x.push(S);const w=wl(x,[x.length,4]),_=gg(0,x.length,1,"int32"),C=rae(u,w,_,[r,i],"nearest");return cu(c?tn(Oa(C)):C,l)})}upsize(e,t,s,r){return be(()=>{const i=sae(e,[t,s]);return cu(i,r)})}call(e,t){return be(()=>{const s=tn(e),r=s.dtype,i=s.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(s,l,u,this.height,this.width,o,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Un(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}p4.className="CenterCrop";tt(p4);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function iae(n,e,t,s){let r=tn(n);if(r.dtype!=="int32"&&(r=cu(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=pi(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=pi(r,-1)),r.rank>2)throw new ye(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),a=r;let l;if(typeof s<"u"&&e==="count"?l=x2(a,s,t,o):l=x2(a,[],t,o),e!=="tfIdf")return l;if(s)return de(l,s);throw new ye("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class m4 extends En{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Un(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return be(()=>{e=tn(e),e.dtype!=="int32"&&(e=cu(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ye(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=tn(t.countWeights)}const r=Da(e),i=$0(e),o=Wo(this.numTokens,r).bufferSync().get(0),a=rd(i,0).bufferSync().get(0);if(!(o&&a))throw new ye(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return iae(e,this.outputMode,this.numTokens,s)})}}m4.className="CategoryEncoding";tt(m4);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const oae=["bilinear","nearest"],UP=new Set(oae);class g4 extends En{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(UP.has(e.interpolation))this.interpolation=e.interpolation;else throw new ye(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Un(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return be(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Ro.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ro.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...UP]} are supported`)})}}g4.className="Resizing";tt(g4);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class y4{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}y4.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class x4 extends En{constructor(e){super(e),this.randomGenerator=new y4(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}x4.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const aae=["bilinear","nearest"],BP=new Set(aae);class v4 extends x4{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ye(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ye(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ye(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(BP.has(s))this.interpolation=s;else throw new ye(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Un(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return be(()=>{const s=tn(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Zf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Ro.resizeBilinear(e,o);case"nearest":return Ro.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...BP]} are supported`)}})}}v4.className="RandomWidth";tt(v4);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lae=Te();lae.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Eo;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Eo||(Eo={}));var VP;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(VP||(VP={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uae={};function w4(n){return uae[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,u=a<0?e.inputNames.length+a:a;if(i.type==="tensor")return Xr(e.inputNames[u],t,s,r);if(i.type==="tensors"){const f=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((g,S)=>{var x;return((x=f[S])===null||x===void 0?void 0:x.op)!=="NoOp"}).map(g=>Xr(g,t,s,r))}const c=Xr(e.inputNames[u],t,s,r),h=c.dataSync();return i.type==="number"?h[0]:Ra(c.shape,h)}const o=e.attrParams[n];return o&&o.value}function Xr(n,e,t,s){const[r,i]=Io(n,t);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[kS(r,a)]);return o!==void 0?e[kS(r,o)][i]:void 0}function WP(n,e,t){return e[kS(n,t.currentContextId)]}function tc(n,e){const[t,s,r]=Io(n,e);return[kS(t,e&&e.currentContextId),s,r]}function kS(n,e){return e?`${n}-${e}`:n}function Io(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],o=s.length===3?s[1]:void 0,a=Number(s[s.length-1]);r=[i,a,o]}return t&&e.parseNodeNameCache.set(n,r),r}function tS(n,e,t){let s=z("pad",n,e,t);if(s==="explicit"){s=z("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function nc(n){return n.kept?n:uc(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cae=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hae=Object.freeze(Object.defineProperty({__proto__:null,json:cae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dae=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],fae=Object.freeze(Object.defineProperty({__proto__:null,json:dae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pae=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],mae=Object.freeze(Object.defineProperty({__proto__:null,json:pae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gae=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],yae=Object.freeze(Object.defineProperty({__proto__:null,json:gae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xae=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],vae=Object.freeze(Object.defineProperty({__proto__:null,json:xae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wae=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Sae=Object.freeze(Object.defineProperty({__proto__:null,json:wae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bae=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_ae=Object.freeze(Object.defineProperty({__proto__:null,json:bae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tae=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Cae=Object.freeze(Object.defineProperty({__proto__:null,json:Tae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eae=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Iae=Object.freeze(Object.defineProperty({__proto__:null,json:Eae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nae=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Aae=Object.freeze(Object.defineProperty({__proto__:null,json:Nae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mae=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],kae=Object.freeze(Object.defineProperty({__proto__:null,json:Mae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rae=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Dae=Object.freeze(Object.defineProperty({__proto__:null,json:Rae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pae=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Lae=Object.freeze(Object.defineProperty({__proto__:null,json:Pae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oae=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Fae=Object.freeze(Object.defineProperty({__proto__:null,json:Oae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ae=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],zae=Object.freeze(Object.defineProperty({__proto__:null,json:$ae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uae=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Bae=Object.freeze(Object.defineProperty({__proto__:null,json:Uae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vae=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Wae=Object.freeze(Object.defineProperty({__proto__:null,json:Vae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gae=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Hae=Object.freeze(Object.defineProperty({__proto__:null,json:Gae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jae=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Xae=Object.freeze(Object.defineProperty({__proto__:null,json:jae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GP{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[hae,fae,mae,yae,vae,Sae,_ae,Cae,Iae,Aae,kae,Dae,Lae,Fae,zae,Bae,Wae,Hae,Xae],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],o=[],a=s.reduce((S,x)=>(S[x.name]=this.mapNode(x),x.op.startsWith("Placeholder")?r.push(S[x.name]):x.op==="Const"?i.push(S[x.name]):(x.input==null||x.input.length===0)&&o.push(S[x.name]),S),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const f=Object.keys(a);f.forEach(S=>{const x=a[S];x.inputNames.forEach((w,_)=>{const[T,,C]=tc(w),N=a[T];if(N.outputs!=null){const M=N.outputs.indexOf(C);if(M!==-1){const P=`${T}:${M}`;x.inputNames[_]=P}}x.inputs.push(N),N.children.push(x)})}),Object.keys(h).length===0?f.forEach(S=>{const x=a[S];x.children.length===0&&u.push(x)}):Object.keys(h).forEach(S=>{const[x]=tc(S),w=a[x];w!=null&&(w.signatureKey=h[S],u.push(w))}),Object.keys(c).length>0?Object.keys(c).forEach(S=>{const[x]=tc(S),w=a[x];w&&(w.signatureKey=c[S],l.push(w))}):l=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((S,x)=>(S[x.signature.name]=this.mapFunction(x),S),{}));const g={nodes:a,inputs:l,outputs:u,weights:i,placeholders:r,signature:t,functions:p};return o.length>0&&(g.initNodes=o),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=w4(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const o=i.type;let a;switch(i.type){case"string":a=D2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=D2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=U2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=U2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=L2(e.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=L2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=z2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=z2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=P2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=P2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=V2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=V2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=$2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=$2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=B2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=B2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=O2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=O2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=F2(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=F2(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=HP(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=HP(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:a,type:o},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&r.push(h[f.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=tc(h.name),p={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:DM(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,o.push(p),i[f]=p}),Object.keys(i).forEach(h=>{const f=i[h];f.inputNames.forEach((p,g)=>{const[S,,x]=tc(p),w=i[S];if(w.outputs!=null){const _=w.outputs.indexOf(x);if(_!==-1){const T=`${S}:${_}`;f.inputNames[g]=T}}f.inputs.push(w),w.children.push(f)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[f,p]=tc(u[h.name]),g=i[f];g!=null&&(g.defaultOutput=p,a.push(g))});const c=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function qae(n){const e=Te().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function S4(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):qae(n);return e?t:t.toLowerCase()}function D2(n,e,t,s=!1){const r=n[e];return r!=null?S4(r.s,s):t}function P2(n,e,t){const s=n[e];return s?s.b:t}function L2(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function DM(n){switch(typeof n=="string"&&(n=Eo[n]),n){case Eo.DT_FLOAT:case Eo.DT_HALF:return"float32";case Eo.DT_INT32:case Eo.DT_INT64:case Eo.DT_INT8:case Eo.DT_UINT8:return"int32";case Eo.DT_BOOL:return"bool";case Eo.DT_DOUBLE:return"float32";case Eo.DT_STRING:return"string";case Eo.DT_COMPLEX64:case Eo.DT_COMPLEX128:return"complex64";default:return null}}function HP(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function O2(n,e,t){const s=n[e];return s&&s.type?DM(s.type):t}function F2(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>DM(r)):t}function b4(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function $2(n,e,t){const s=n[e];return s&&s.shape?b4(s.shape):t}function z2(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function U2(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>S4(i,s)):t}function B2(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>b4(r)):t}function V2(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kae{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return Xr(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Xr(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return L2(this.node.rawAttrs,e,t);if(s.s!=null)return D2(this.node.rawAttrs,e,t);if(s.b!=null)return P2(this.node.rawAttrs,e,t);if(s.shape!=null)return $2(this.node.rawAttrs,e,t);if(s.type!=null)return O2(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return z2(this.node.rawAttrs,e,t);if(s.list.s!=null)return U2(this.node.rawAttrs,e,t);if(s.list.shape!=null)return B2(this.node.rawAttrs,e,t);if(s.list.b!=null)return V2(this.node.rawAttrs,e,t);if(s.list.type!=null)return F2(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qr=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:GF,abs:gr,acos:l$,acosh:u$,add:Ze,addN:dY,all:tA,any:wS,argMax:dg,argMin:c$,asin:h$,asinh:d$,atan:f$,atan2:p$,atanh:m$,avgPool:w_,avgPool3d:g$,basicLSTMCell:LY,batchNorm:cv,batchNorm2d:y$,batchNorm3d:x$,batchNorm4d:v$,batchToSpaceND:S_,bincount:w$,bitwiseAnd:GY,booleanMaskAsync:Nee,broadcastArgs:jY,broadcastTo:eg,buffer:yn,cast:gt,ceil:S$,clipByValue:Oo,clone:uc,complex:Lh,concat:ir,concat1d:b$,concat2d:sA,concat3d:_$,concat4d:T$,conv1d:rA,conv2d:$h,conv2dTranspose:oA,conv3d:C$,conv3dTranspose:I$,cos:b_,cosh:aA,cosineWindow:kA,cumprod:SS,cumsum:lA,denseBincount:x2,depthToSpace:N$,depthwiseConv2d:hv,diag:mZ,dilation2d:A$,div:Rt,divNoNan:M$,dot:k$,dropout:rz,einsum:Vm,elu:dv,enclosingPowerOfTwo:iz,ensureShape:CZ,equal:Cl,erf:R$,euclideanNorm:L$,exp:Fo,expandDims:pi,expm1:O$,eye:cA,fft:O_,fill:Lg,floor:pv,floorDiv:eA,fused:Yee,gather:mv,gatherND:$ee,greater:Wo,greaterEqual:rd,ifft:V0,imag:__,image:Ro,inTopKAsync:Vee,irfft:CA,isFinite:F$,isInf:$$,isNaN:z$,leakyRelu:T_,less:z0,lessEqual:Yf,linalg:fz,linspace:ZZ,localResponseNormalization:U$,log:aa,log1p:C_,logSigmoid:B$,logSoftmax:hA,logSumExp:E_,logicalAnd:fu,logicalNot:I_,logicalOr:dA,logicalXor:V$,losses:Ine,lowerBound:fJ,matMul:In,max:Da,maxPool:N_,maxPool3d:W$,maxPoolWithArgmax:yJ,maximum:bc,mean:$s,meshgrid:wJ,min:$0,minimum:Uf,mirrorPad:G$,mod:H$,moments:A_,movingAverage:kee,mul:de,multiRNNCell:EJ,multinomial:NJ,neg:ys,norm:fv,notEqual:mg,oneHot:pA,ones:ko,onesLike:la,op:ce,outerProduct:DJ,pad:id,pad1d:OJ,pad2d:$J,pad3d:UJ,pad4d:VJ,pool:j$,pow:zh,prelu:k_,print:a$,prod:X$,raggedGather:YJ,raggedRange:JJ,raggedTensorToTensor:eQ,rand:nQ,randomGamma:TQ,randomNormal:gA,randomStandardNormal:IQ,randomUniform:Zf,randomUniformInt:MQ,range:gg,real:U0,reciprocal:q$,relu:yu,relu6:yA,reshape:pe,reverse:La,reverse1d:FQ,reverse2d:zQ,reverse3d:BQ,reverse4d:WQ,rfft:F_,round:xA,rsqrt:vA,scalar:Ht,scatterND:Dee,searchSorted:fA,selu:wA,separableConv2d:SA,setdiff1dAsync:KQ,sigmoid:Sl,sign:K$,signal:Ene,sin:bA,sinh:_A,slice:mn,slice1d:D_,slice2d:TA,slice3d:P_,slice4d:B0,softmax:L_,softplus:Og,spaceToBatchND:M_,sparse:Nne,sparseToDense:Oee,spectral:Cne,split:Po,sqrt:yi,square:os,squaredDifference:EA,squeeze:mc,stack:$o,step:Fg,stridedSlice:Y$,string:Ane,sub:Tt,sum:kt,tan:Z$,tanh:fg,tensor:wl,tensor1d:Kr,tensor2d:tg,tensor3d:J$,tensor4d:mee,tensor5d:gee,tensor6d:yee,tensorScatterUpdate:vee,tile:Aa,topk:ez,transpose:Dn,truncatedNormal:NA,unique:tz,unsortedSegmentSum:AA,unstack:Oa,upperBound:Cee,variable:nz,where:mi,whereAsync:sz,zeros:yr,zerosLike:Pn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yae=(n,e,t,s=Qr)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(z("a",n,e,t),z("b",n,e,t))];case"AddN":return[s.addN(z("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(z("a",n,e,t),z("b",n,e,t))];case"Mul":return[s.mul(z("a",n,e,t),z("b",n,e,t))];case"RealDiv":case"Div":return[s.div(z("a",n,e,t),z("b",n,e,t))];case"DivNoNan":return[s.divNoNan(z("a",n,e,t),z("b",n,e,t))];case"FloorDiv":return[s.floorDiv(z("a",n,e,t),z("b",n,e,t))];case"Sub":return[s.sub(z("a",n,e,t),z("b",n,e,t))];case"Minimum":return[s.minimum(z("a",n,e,t),z("b",n,e,t))];case"Maximum":return[s.maximum(z("a",n,e,t),z("b",n,e,t))];case"Pow":return[s.pow(z("a",n,e,t),z("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(z("a",n,e,t),z("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zae=(n,e,t,s=Qr)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(z("x",n,e,t))];case"Acos":return[s.acos(z("x",n,e,t))];case"Acosh":return[s.acosh(z("x",n,e,t))];case"Asin":return[s.asin(z("x",n,e,t))];case"Asinh":return[s.asinh(z("x",n,e,t))];case"Atan":return[s.atan(z("x",n,e,t))];case"Atan2":return[s.atan2(z("x",n,e,t),z("y",n,e,t))];case"Atanh":return[s.atanh(z("x",n,e,t))];case"Ceil":return[s.ceil(z("x",n,e,t))];case"Complex":return[s.complex(z("real",n,e,t),z("imag",n,e,t))];case"Cos":return[s.cos(z("x",n,e,t))];case"Cosh":return[s.cosh(z("x",n,e,t))];case"Elu":return[s.elu(z("x",n,e,t))];case"Erf":return[s.erf(z("x",n,e,t))];case"Exp":return[s.exp(z("x",n,e,t))];case"Expm1":return[s.expm1(z("x",n,e,t))];case"Floor":return[s.floor(z("x",n,e,t))];case"Log":return[s.log(z("x",n,e,t))];case"Log1p":return[s.log1p(z("x",n,e,t))];case"Imag":return[s.imag(z("x",n,e,t))];case"Neg":return[s.neg(z("x",n,e,t))];case"Reciprocal":return[s.reciprocal(z("x",n,e,t))];case"Real":return[s.real(z("x",n,e,t))];case"Relu":return[s.relu(z("x",n,e,t))];case"Round":return[s.round(z("x",n,e,t))];case"Selu":return[s.selu(z("x",n,e,t))];case"Sigmoid":return[s.sigmoid(z("x",n,e,t))];case"Sin":return[s.sin(z("x",n,e,t))];case"Sign":return[s.sign(z("x",n,e,t))];case"Sinh":return[s.sinh(z("x",n,e,t))];case"Softplus":return[s.softplus(z("x",n,e,t))];case"Sqrt":return[s.sqrt(z("x",n,e,t))];case"Square":return[s.square(z("x",n,e,t))];case"Tanh":return[s.tanh(z("x",n,e,t))];case"Tan":return[s.tan(z("x",n,e,t))];case"ClipByValue":return[s.clipByValue(z("x",n,e,t),z("clipValueMin",n,e,t),z("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(z("x",n,e,t))];case"Rsqrt":return[s.rsqrt(Xr(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(z("x",n,e,t),z("alpha",n,e,t))];case"Prelu":return[s.prelu(z("x",n,e,t),z("alpha",n,e,t))];case"IsNan":return[s.isNaN(Xr(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(Xr(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(Xr(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){q(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];q(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function jP(n){return!(typeof n=="number"||n.some(e=>e<0))}function e0(n,e,t){let s=W2(n,t);const r=!jP(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=W2(i.shape,s)}),!jP(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function W2(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jae{constructor(e,t,s,r,i,o,a){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Ht(0),Pr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ia(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Pr(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return wl([],[0].concat(this.elementShape));const s=this.readMany(e);return Ia(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),$o(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return wl([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Ia(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ir(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Oa(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,o=[];be(()=>{t=pe(t,[1,s,i]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:r[l-1],0],h=[1,e[l],i];o[l]=pe(mn(t,c,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wf{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);Ia(t,i.shape,"TensorList shape mismatch: "),Pr(i)}),this.idTensor=Ht(0),this.maxNumElements=r,Pr(this.idTensor)}copy(){return new Wf([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Ia(e,this.elementShape,"TensorList shape mismatch: ");const r=e0(this.elementShape,this.tensors,e);return be(()=>{const i=this.tensors.map(o=>pe(o,r));return $o(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=e0(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Ia(r.shape,e,"TensorList shape mismatch: "),pe(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ia(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Pr(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Wf([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ia(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=e0(this.elementShape,this.tensors,t);return pe(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ia(this.elementShape,t.shape,"TensorList shape mismatch: "),Pr(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ia(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=e0(this.elementShape,this.tensors,s);return e.length===0?wl([],[0].concat(r)):be(()=>{const i=e.map(o=>pe(this.tensors[o],r));return $o(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ia(this.elementShape,t,"TensorList shape mismatch: ");const s=e0(this.elementShape,this.tensors,t);return this.size()===0?wl([],[0].concat(s)):be(()=>{const r=this.tensors.map(i=>pe(i,s));return ir(r,0)})}}function Qae(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Ia(r,e,"TensorList shape mismatch: ");const i=Oa(n);return new Wf(i,e,s)}function ele(n,e,t,s){return new Wf([],n,e,s)}function tle(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new Wf([],t,n.dtype,s),o=Oa(n,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function nle(n,e,t){let s=0;const r=e.map(c=>(s+=c,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=W2(i,t),a=s===0?0:n.size/s,l=be(()=>{const c=[];n=pe(n,[1,s,a]);for(let h=0;h<e.length;++h){const p=[0,h===0?0:r[h-1],0],g=[1,e[h],a];c[h]=pe(mn(n,p,g),o)}return n.dispose(),c}),u=new Wf([],t,n.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sle=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=z("thenBranch",n,e,t),r=z("elseBranch",n,e,t),i=z("cond",n,e,t),o=z("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=z("body",n,e,t),r=z("cond",n,e,t),i=z("args",n,e,t),o=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),a=i.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=i;for(;l[0];){const c=u;u=await t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const f=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await f[0].data(),f.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const s=z("pred",n,e,t);return[nc(s)]}case"Switch":{const s=z("pred",n,e,t);let r=z("data",n,e,t);return r.kept||(r=nc(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>Xr(r,e,t)!==void 0);if(s){const r=Xr(s,e,t);return[nc(r)]}return}case"Enter":{const s=z("frameName",n,e,t),r=z("tensor",n,e,t);return t.enterFrame(s),[nc(r)]}case"Exit":{const s=z("tensor",n,e,t);return t.exitFrame(),[nc(s)]}case"NextIteration":{const s=z("tensor",n,e,t);return t.nextIteration(),[nc(s)]}case"TensorArrayV3":{const s=z("size",n,e,t),r=z("dtype",n,e,t),i=z("elementShape",n,e,t),o=z("dynamicSize",n,e,t),a=z("clearAfterRead",n,e,t),l=z("identicalElementShapes",n,e,t),u=z("name",n,e,t),c=new Jae(u,r,s,i,l,o,a);return t.addTensorArray(c),[c.idTensor,Ht(1)]}case"TensorArrayWriteV3":{const s=z("tensorArrayId",n,e,t),r=z("index",n,e,t),i=z("tensor",n,e,t),o=t.getTensorArray(s.id);return o.write(r,i),[o.idTensor]}case"TensorArrayReadV3":{const s=z("tensorArrayId",n,e,t),r=z("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=z("tensorArrayId",n,e,t),r=z("indices",n,e,t),i=z("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=z("tensorArrayId",n,e,t),r=z("indices",n,e,t),i=z("tensor",n,e,t),o=t.getTensorArray(s.id);return o.scatter(r,i),[o.idTensor]}case"TensorArrayConcatV3":{const s=z("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=z("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=z("tensorArrayId",n,e,t),r=z("tensor",n,e,t),i=z("lengths",n,e,t),o=t.getTensorArray(s.id);return o.split(i,r),[o.idTensor]}case"TensorArraySizeV3":{const s=z("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Ht(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=z("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=z("tensorListId",n,e,t),r=z("index",n,e,t),i=z("tensor",n,e,t),o=t.getTensorList(s.id);return o.setItem(r,i),[o.idTensor]}case"TensorListGetItem":{const s=z("tensorListId",n,e,t),r=z("index",n,e,t),i=z("elementShape",n,e,t),o=z("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=z("indices",n,e,t),r=z("tensor",n,e,t),i=z("elementShape",n,e,t),o=z("numElements",n,e,t),a=tle(r,s,i,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=z("elementShape",n,e,t),r=z("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=z(i,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=ele(s,r,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=z("tensorListId",n,e,t),r=z("indices",n,e,t),i=z("elementShape",n,e,t),o=z("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,o,i)]}case"TensorListStack":{const s=z("tensorListId",n,e,t),r=z("elementShape",n,e,t),i=z("elementDType",n,e,t),o=z("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,o)]}case"TensorListFromTensor":{const s=z("tensor",n,e,t),r=z("elementShape",n,e,t),i=z("elementDType",n,e,t),o=Qae(s,r,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=z("tensorListId",n,e,t),r=t.getTensorList(s.id),i=z("dtype",n,e,t),o=z("elementShape",n,e,t);return[r.concat(i,o)]}case"TensorListPushBack":{const s=z("tensorListId",n,e,t),r=z("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=z("tensorListId",n,e,t),r=z("elementShape",n,e,t),i=z("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=z("tensor",n,e,t),r=z("elementShape",n,e,t),i=z("lengths",n,e,t),o=nle(s,i,r);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=z("tensorListId",n,e,t),r=t.getTensorList(s.id);return[Ht(r.size(),"int32")]}case"TensorListResize":{const s=z("tensorListId",n,e,t),r=z("size",n,e,t),o=t.getTensorList(s.id).resize(r);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XP(n,e,t){const[s,r]=z("fusedOps",n,e,t),i=s==="biasadd",o=!i,a=r==="prelu",l=s==="fusedbatchnorm",u=z("numArgs",n,e,t);if(i){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=z("strides",n,e,t),h=tS(n,e,t),f=z("dataFormat",n,e,t).toUpperCase(),p=z("dilations",n,e,t);let[g,S]=z("args",n,e,t);o&&(S=g,g=void 0);const x=z("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:f,dilations:p,biasArg:g,preluArg:S,activationFunc:r,leakyreluAlpha:x}}const rle=(n,e,t,s=Qr)=>{switch(n.op){case"Conv1D":{const r=z("stride",n,e,t),i=z("pad",n,e,t),o=z("dataFormat",n,e,t).toUpperCase(),a=z("dilation",n,e,t);return[s.conv1d(z("x",n,e,t),z("filter",n,e,t),r,i,o,a)]}case"Conv2D":{const r=z("strides",n,e,t),i=tS(n,e,t),o=z("dataFormat",n,e,t).toUpperCase(),a=z("dilations",n,e,t);return[s.conv2d(z("x",n,e,t),z("filter",n,e,t),[r[1],r[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=XP(n,e,t);return[s.fused.conv2d({x:z("x",n,e,t),filter:z("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=XP(n,e,t);return[s.fused.depthwiseConv2d({x:z("x",n,e,t),filter:z("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=z("outputShape",n,e,t),i=z("strides",n,e,t),o=tS(n,e,t);return[s.conv2dTranspose(z("x",n,e,t),z("filter",n,e,t),r,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=z("strides",n,e,t),i=tS(n,e,t),o=z("dilations",n,e,t),a=z("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(z("input",n,e,t),z("filter",n,e,t),[r[1],r[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("dataFormat",n,e,t).toUpperCase(),a=z("dilations",n,e,t);return[s.conv3d(z("x",n,e,t),z("filter",n,e,t),[r[1],r[2],r[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[s.avgPool(z("x",n,e,t),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[s.maxPool(z("x",n,e,t),[o[1],o[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t),a=z("includeBatchInIndex",n,e,t),{result:l,indexes:u}=s.maxPoolWithArgmax(z("x",n,e,t),[o[1],o[2]],[r[1],r[2]],i,a);return[l,u]}case"AvgPool3D":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[s.avgPool3d(z("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[s.maxPool3d(z("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=z("strides",n,e,t),i=z("pad",n,e,t),o=z("dilations",n,e,t),a=r[1],l=r[2],u=o[1],c=o[2];return[s.dilation2d(z("x",n,e,t),z("filter",n,e,t),[a,l],i,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ile=(n,e,t,s=Qr)=>{switch(n.op){case"Fill":{const r=z("shape",n,e,t),i=z("dtype",n,e,t),o=z("value",n,e,t);return[s.fill(r,o,i)]}case"LinSpace":{const r=z("start",n,e,t),i=z("stop",n,e,t),o=z("num",n,e,t);return[s.linspace(r,i,o)]}case"Multinomial":{const r=z("logits",n,e,t),i=z("numSamples",n,e,t),o=z("seed",n,e,t);return[s.multinomial(r,i,o)]}case"OneHot":{const r=z("indices",n,e,t),i=z("depth",n,e,t),o=z("onValue",n,e,t),a=z("offValue",n,e,t),l=z("dtype",n,e,t);return[s.oneHot(r,i,o,a,l)]}case"Ones":return[s.ones(z("shape",n,e,t),z("dtype",n,e,t))];case"OnesLike":return[s.onesLike(z("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(z("shape",n,e,t),z("dtype",n,e,t),z("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(z("shape",n,e,t),z("minval",n,e,t),z("maxval",n,e,t),z("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(z("shape",n,e,t),z("minval",n,e,t),z("maxval",n,e,t),z("seed",n,e,t))];case"Range":{const r=z("start",n,e,t),i=z("stop",n,e,t),o=z("step",n,e,t);return[s.range(r,i,o,z("dtype",n,e,t))]}case"TruncatedNormal":{const r=z("shape",n,e,t),i=z("mean",n,e,t),o=z("stdDev",n,e,t),a=z("seed",n,e,t);return[s.truncatedNormal(r,i,o,z("dtype",n,e,t),a)]}case"Zeros":return[s.zeros(z("shape",n,e,t),z("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(z("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(n,e,t){const s=z("boxes",n,e,t),r=z("scores",n,e,t),i=z("maxOutputSize",n,e,t),o=z("iouThreshold",n,e,t),a=z("scoreThreshold",n,e,t),l=z("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const ole=async(n,e,t,s,r=Qr)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=eE(n,e,t),h=await r.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=eE(n,e,t),c=z("padToMaxOutputSize",n,e,t),h=await r.image.nonMaxSuppressionPaddedAsync(i,o,a,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=eE(n,e,t);return[await r.image.nonMaxSuppressionAsync(i,o,a,l,u)]}case"Where":{const i=r.cast(z("condition",n,e,t),"bool"),o=[await r.whereAsync(i)];return i.dispose(),o}case"ListDiff":return r.setdiff1dAsync(z("x",n,e,t),z("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ale=(n,e,t,s=Qr)=>{switch(n.op){case"LowerBound":{const r=z("sortedSequence",n,e,t),i=z("values",n,e,t);return[s.lowerBound(r,i)]}case"TopKV2":{const r=z("x",n,e,t),i=z("k",n,e,t),o=z("sorted",n,e,t),a=s.topk(r,i,o);return[a.values,a.indices]}case"UpperBound":{const r=z("sortedSequence",n,e,t),i=z("values",n,e,t);return[s.upperBound(r,i)]}case"Unique":{const r=z("x",n,e,t),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=z("x",n,e,t),i=z("axis",n,e,t),o=s.unique(r,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lle=(n,e,t,s=Qr)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=z("default",n,e,t);return[Xr(n.name,e,t)||r];case"Placeholder":return[Xr(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=z("x",n,e,t);return[nc(c)]}case"IdentityN":return z("x",n,e,t).map(c=>nc(c));case"Snapshot":const i=z("x",n,e,t);return[nc(i)];case"Shape":return[s.tensor1d(z("x",n,e,t).shape,"int32")];case"ShapeN":return z("x",n,e,t).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(z("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(z("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=z("x",n,e,t),a=z("data",n,e,t),l=z("message",n,e,t),u=z("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ule{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Ht(0),this.tensorMap=new Map,Pr(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ht(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),be(()=>{const r=Oa(t),i=s.length,o=r.length;q(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=s[a],u=r[a];Pr(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return be(()=>{const r=[];for(let i=0;i<s.length;i++){const o=s[i],a=this.findWithDefault(o,t);r.push(a)}return $o(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cle=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=z("keyDType",n,e,t),o=z("valueDType",n,e,t),a=new ule(i,o);return s.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=z("tableHandle",n,e,t,s),i=z("keys",n,e,t),o=z("values",n,e,t);return[await s.getHashTableById(r.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=z("tableHandle",n,e,t,s),i=z("keys",n,e,t),o=z("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=z("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle=(n,e,t,s=Qr)=>{switch(n.op){case"ResizeBilinear":{const r=z("images",n,e,t),i=z("size",n,e,t),o=z("alignCorners",n,e,t),a=z("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const r=z("images",n,e,t),i=z("size",n,e,t),o=z("alignCorners",n,e,t),a=z("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],o,a)]}case"CropAndResize":{const r=z("image",n,e,t),i=z("boxes",n,e,t),o=z("boxInd",n,e,t),a=z("cropSize",n,e,t),l=z("method",n,e,t),u=z("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,i,o,a,l,u)]}case"ImageProjectiveTransformV3":{const r=z("images",n,e,t),i=z("transforms",n,e,t),o=z("outputShape",n,e,t),a=z("fillValue",n,e,t),l=z("interpolation",n,e,t),u=z("fillMode",n,e,t);return[s.image.transform(r,i,l.toLowerCase(),u.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dle=(n,e,t,s=Qr)=>{switch(n.op){case"Equal":return[s.equal(z("a",n,e,t),z("b",n,e,t))];case"NotEqual":return[s.notEqual(z("a",n,e,t),z("b",n,e,t))];case"Greater":return[s.greater(z("a",n,e,t),z("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(z("a",n,e,t),z("b",n,e,t))];case"Less":return[s.less(z("a",n,e,t),z("b",n,e,t))];case"LessEqual":return[s.lessEqual(z("a",n,e,t),z("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(z("a",n,e,t),z("b",n,e,t))];case"LogicalNot":return[s.logicalNot(z("a",n,e,t))];case"LogicalOr":return[s.logicalOr(z("a",n,e,t),z("b",n,e,t))];case"Select":case"SelectV2":return[s.where(z("condition",n,e,t),z("a",n,e,t),z("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(z("a",n,e,t),z("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fle=(n,e,t,s=Qr)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(z("a",n,e,t),z("b",n,e,t),z("transposeA",n,e,t),z("transposeB",n,e,t))];case"Einsum":return[s.einsum(z("equation",n,e,t),...z("tensors",n,e,t))];case"Transpose":return[s.transpose(z("x",n,e,t),z("perm",n,e,t))];case"_FusedMatMul":const[r,i]=z("fusedOps",n,e,t),o=r==="biasadd",a=i==="prelu",l=z("numArgs",n,e,t),u=z("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=z("args",n,e,t);return[s.fused.matMul({a:z("a",n,e,t),b:z("b",n,e,t),transposeA:z("transposeA",n,e,t),transposeB:z("transposeB",n,e,t),bias:c,activation:i,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[s.linalg.bandPart(z("a",n,e,t),z("numLower",n,e,t),z("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ple=(n,e,t,s=Qr)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(z("x",n,e,t),z("axis",n,e,t),z("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(z("x",n,e,t),z("mean",n,e,t),z("variance",n,e,t),z("offset",n,e,t),z("scale",n,e,t),z("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(z("x",n,e,t),z("mean",n,e,t),z("variance",n,e,t),z("offset",n,e,t),z("scale",n,e,t),z("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(z("x",n,e,t),z("radius",n,e,t),z("bias",n,e,t),z("alpha",n,e,t),z("beta",n,e,t))];case"Softmax":return[s.softmax(z("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(z("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle=(n,e,t,s=Qr)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(z("paramsNestedSplits",n,e,t),z("paramsDenseValues",n,e,t),z("indices",n,e,t),z("outputRaggedRank",n,e,t));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(z("starts",n,e,t),z("limits",n,e,t),z("splits",n,e,t));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(z("shape",n,e,t),z("values",n,e,t),z("defaultValue",n,e,t),z("rowPartitionTensors",n,e,t),z("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gle=(n,e,t,s=Qr)=>{switch(n.op){case"Max":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.max(z("x",n,e,t),a,l)]}case"Mean":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.mean(z("x",n,e,t),a,l)]}case"Min":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.min(z("x",n,e,t),a,l)]}case"Sum":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.sum(z("x",n,e,t),a,l)]}case"All":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.all(z("x",n,e,t),a,l)]}case"Any":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.any(z("x",n,e,t),a,l)]}case"ArgMax":{const a=z("axis",n,e,t);return[s.argMax(z("x",n,e,t),a)]}case"ArgMin":{const a=z("axis",n,e,t);return[s.argMin(z("x",n,e,t),a)]}case"Prod":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[s.prod(z("x",n,e,t),a,l)]}case"Cumprod":{const a=z("axis",n,e,t),l=z("exclusive",n,e,t),u=z("reverse",n,e,t);return[s.cumprod(z("x",n,e,t),a,l,u)]}case"Cumsum":{const a=z("axis",n,e,t),l=z("exclusive",n,e,t),u=z("reverse",n,e,t);return[s.cumsum(z("x",n,e,t),a,l,u)]}case"Bincount":const r=z("x",n,e,t),i=z("weights",n,e,t),o=z("size",n,e,t);return[s.bincount(r,i,o)];case"DenseBincount":{const a=z("x",n,e,t),l=z("weights",n,e,t),u=z("size",n,e,t),c=z("binaryOutput",n,e,t);return[s.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yle=(n,e,t,s=Qr)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=z("n",n,e,t),i=z("axis",n,e,t);let o=z("tensors",n,e,t);return o=o.slice(0,r),[s.concat(o,i)]}case"Gather":{const r=z("x",n,e,t),i=z("indices",n,e,t);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=z("axis",n,e,t),i=z("batchDims",n,e,t),o=z("x",n,e,t),a=z("indices",n,e,t);return[s.gather(o,s.cast(a,"int32"),r,i)]}case"Reverse":{const r=z("dims",n,e,t),i=[];for(let a=0;a<r.length;a++)r[a]&&i.push(a);const o=z("x",n,e,t);return[s.reverse(o,i)]}case"ReverseV2":{const r=z("axis",n,e,t),i=z("x",n,e,t);return[s.reverse(i,r)]}case"Slice":{const r=z("begin",n,e,t),i=z("size",n,e,t);return[s.slice(z("x",n,e,t),r,i)]}case"StridedSlice":{const r=z("begin",n,e,t),i=z("end",n,e,t),o=z("strides",n,e,t),a=z("beginMask",n,e,t),l=z("endMask",n,e,t),u=z("ellipsisMask",n,e,t),c=z("newAxisMask",n,e,t),h=z("shrinkAxisMask",n,e,t),f=z("x",n,e,t);return[s.stridedSlice(f,r,i,o,a,l,u,c,h)]}case"Pack":return be(()=>{const r=z("axis",n,e,t),i=z("tensors",n,e,t),o=i[0].shape,a=s.squeeze(i[0]).shape,l=i.map(u=>{const c=Mn(u.shape,o);if(!c&&!Mn(s.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:s.reshape(u,o)});return[s.stack(l,r)]});case"Unpack":{const r=z("axis",n,e,t),i=z("tensor",n,e,t);return s.unstack(i,r)}case"Tile":{const r=z("reps",n,e,t);return[s.tile(z("x",n,e,t),r)]}case"Split":case"SplitV":{const r=z("axis",n,e,t),i=z("numOrSizeSplits",n,e,t),o=z("x",n,e,t);return s.split(o,i,r)}case"ScatterNd":{const r=z("indices",n,e,t),i=z("values",n,e,t),o=z("shape",n,e,t);return[s.scatterND(r,i,o)]}case"GatherNd":{const r=z("x",n,e,t),i=z("indices",n,e,t);return[s.gatherND(r,i)]}case"SparseToDense":{const r=z("sparseIndices",n,e,t),i=z("outputShape",n,e,t),o=z("sparseValues",n,e,t),a=z("defaultValue",n,e,t);return[s.sparseToDense(r,o,i,o.dtype===a.dtype?a:s.cast(a,o.dtype))]}case"TensorScatterUpdate":{const r=z("indices",n,e,t),i=z("values",n,e,t),o=z("tensor",n,e,t);return[s.tensorScatterUpdate(o,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xle=(n,e,t,s=Qr)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(z("indices",n,e,t),z("values",n,e,t),z("denseShape",n,e,t),z("defaultValue",n,e,t));return[r,i,o,a]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(z("inputIndices",n,e,t),z("inputShape",n,e,t),z("newShape",n,e,t));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(z("data",n,e,t),z("indices",n,e,t),z("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(z("data",n,e,t),z("indices",n,e,t),z("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vle=(n,e,t,s=Qr)=>{switch(n.op){case"FFT":return[s.fft(z("x",n,e,t))];case"IFFT":return[s.ifft(z("x",n,e,t))];case"RFFT":return[s.rfft(z("x",n,e,t))];case"IRFFT":return[s.irfft(z("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wle=(n,e,t,s=Qr)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(z("input",n,e,t),z("pattern",n,e,t),z("rewrite",n,e,t),z("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(z("data",n,e,t),z("dataSplits",n,e,t),z("separator",n,e,t),z("nGramWidths",n,e,t),z("leftPad",n,e,t),z("rightPad",n,e,t),z("padWidth",n,e,t),z("preserveShortSequences",n,e,t));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:o}=s.string.stringSplit(z("input",n,e,t),z("delimiter",n,e,t),z("skipEmpty",n,e,t));return[r,i,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(z("input",n,e,t),z("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sle=(n,e,t,s=Qr)=>{switch(n.op){case"Cast":return[s.cast(z("x",n,e,t),z("dtype",n,e,t))];case"ExpandDims":{const r=z("axis",n,e,t);return[s.expandDims(z("x",n,e,t),r)]}case"Squeeze":{const r=z("axis",n,e,t);return[s.squeeze(z("x",n,e,t),r)]}case"Reshape":return[s.reshape(z("x",n,e,t),z("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(z("x",n,e,t),z("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(z("x",n,e,t),z("padding",n,e,t),z("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(z("x",n,e,t),z("padding",n,e,t),z("constantValue",n,e,t))];case"SpaceToBatchND":{const r=z("blockShape",n,e,t),i=z("paddings",n,e,t);return[s.spaceToBatchND(z("x",n,e,t),r,i)]}case"BatchToSpaceND":{const r=z("blockShape",n,e,t),i=z("crops",n,e,t);return[s.batchToSpaceND(z("x",n,e,t),r,i)]}case"DepthToSpace":{const r=z("blockSize",n,e,t),i=z("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(z("x",n,e,t),r,i)]}case"BroadcastTo":return[s.broadcastTo(z("x",n,e,t),z("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(z("s0",n,e,t),z("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qP(n,e,t,s,r=be){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return r(()=>Yae(o,a,l));case"basic_math":return r(()=>Zae(o,a,l));case"control":return sle(o,a,l);case"convolution":return r(()=>rle(o,a,l));case"creation":return r(()=>ile(o,a,l));case"dynamic":return ole(o,a,l);case"evaluation":return r(()=>ale(o,a,l));case"image":return r(()=>hle(o,a,l));case"graph":return r(()=>lle(o,a,l));case"logical":return r(()=>dle(o,a,l));case"matrices":return r(()=>fle(o,a,l));case"normalization":return r(()=>ple(o,a,l));case"ragged":return r(()=>mle(o,a,l));case"reduction":return r(()=>gle(o,a,l));case"slice_join":return r(()=>yle(o,a,l));case"sparse":return r(()=>xle(o,a,l));case"spectral":return r(()=>vle(o,a,l));case"string":return r(()=>wle(o,a,l));case"transformation":return r(()=>Sle(o,a,l));case"hash_table":return cle(o,a,l,s);case"custom":const u=w4(o.op);if(u&&u.customExecutor)return u.customExecutor(new Kae(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Pf(i)?i.then(o=>[].concat(o)):[].concat(i)}class KP{constructor(e={},t={},s={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YP(n,e,t,s){const r=new Set,i=[];let o=null,a=null;const l=new Set,u=new Set(Object.keys(n).map(f=>Io(f)[0]));s=s||[];const c=new Set(s.map(f=>Io(f.name)[0])),h=[...e];for(;h.length>0;){const f=h.pop();if((ff(f)||Ale(f)||Mle(f))&&o==null&&(o=f,a=o.children.map(p=>p.name).filter(p=>r.has(p))),r.add(f.name),t[f.name]==null&&!u.has(f.name)&&!c.has(f.name)){if(f.inputs.length===0){i.push(f.name);continue}f.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:o,syncInputs:a}}function ble(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(x=>Io(x)[0]).map(x=>n.nodes[x]),i=n.initNodes||[],o=x=>t.has(typeof x=="string"?x:x.name);function a(x){return[...new Map(x.map(w=>[w.name,w])).values()]}const l=a([...r,...n.weights,...i]).filter(o),u=a([...l,...Object.values(n.nodes)]).filter(o),c=new Map(u.map(x=>[x.name,x])),h={};for(const x of u){h[x.name]=h[x.name]||0;for(const w of x.children)o(w)||(h[w.name]=Number.POSITIVE_INFINITY),h[w.name]=(h[w.name]||0)+1}const f=Object.entries(h).filter(([,x])=>x===0).map(([x])=>x),p=[...f];for(;f.length>0;){const x=f.pop(),w=c.get(x);for(const _ of w.children.filter(o))--h[_.name]===0&&(p.push(_.name),f.push(_.name))}const g=p.map(x=>c.get(x)),S=_le(g,l);return Tle(S,l),S}function _le(n,e){const t=new Map(n.map(o=>[o.name,o])),s=e.map(o=>o.name),r=new Set(s);for(;s.length>0;){const o=s.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(o=>r.has(o.name))}class Nw extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Tle(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),s=new Set(e.map(a=>a.name)),r=a=>s.has(typeof a=="string"?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new Nw(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new Nw(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!r(a))for(const l of a.inputs){if(!t.has(l.name))throw new Nw(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new Nw(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function Cle(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((a,l)=>ff(a)?t:l),r=a=>{const l=s[e.get(a.name)];return l??-1},i=n.map((a,l)=>a.children.map(r).reduce((u,c)=>Math.max(u,c),s[l])),o=new Map;for(let a=0;a<n.length;++a){const l=i[a];if(l===t)continue;const u=n[a],c=n[l];o.has(c.name)||o.set(c.name,[]),o.get(c.name).push(u)}return o}const Ele=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Ile=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Nle=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ff(n){return Ele.has(n.op)}function Ale(n){return Ile.has(n.op)}function Mle(n){return Nle.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RS{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new RS(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=YP(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:o}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const u=t.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const a=ble(this.graph,s),l=Cle(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Pr(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(f=>this.graph.nodes[Io(f)[0]]),i=t.map(f=>Io(f)[0]),o=new Set(i);let a=i.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(r,a);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=Te().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const c={},h={};return be(()=>{const f=new KP(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(w=>{const[_,T]=Io(w,f),C=[];C[T]=e[w],p[_]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[_]=this.cloneTensorList(C))});const g=this.getFrozenTensorIds(p),{orderedNodes:S,nodeLiveUntilMap:x}=u;for(const w of S){if(p[w.name])continue;const _=qP(w,p,f,this._resourceManager);if(Pf(_))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);p[w.name]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[w.name]=this.cloneTensorList(_)),this.checkTensorForDisposalWithNodeLiveUntilInfo(w,p,f,g,o,x.get(w.name))}return this.parent==null&&f.dispose(g),t.map(w=>Xr(w,p,f))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,o,a){if(!(ff(t)||o.has(e))){for(const l of s[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(ff(l))continue;const u=WP(l.name,s,r);if(u!=null)for(const c of u){if(!c||c.kept||i.has(c.id))continue;const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,i,o){function a(l){return ff(l)||i.has(l.name)}if(!(ff(e)||o==null))for(const l of o){if(a(l))continue;const u=WP(l.name,t,s);for(const c of u)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Te().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new KP(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,s),l=t.map(f=>Xr(f,a,o)),u=l.map(f=>f.id),c=Object.keys(e).map(f=>e[f].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,s){const r=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),o=i.map(C=>this.graph.nodes[Io(C)[0]]),a=s.map(C=>Io(C)[0]),l=new Set(a);let u=a.map(C=>this.graph.nodes[C]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:f,syncInputs:p}=YP(e,u,this.weightMap,this._initNodes),g=[...o,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:t.currentContext})),S=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{const[N,M]=Io(C),P=[];P[M]=e[C],S[N]=P});const x={},w=this.getFrozenTensorIds(S),_={};for(;g.length>0;){const C=this.processStack(o,g,t,S,_,w,l,x,c);await Promise.all(C)}f==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const T=u.filter(C=>!ff(C)&&!Xr(C.name,S,t)).map(C=>C.name);if(T.length>0){let C="";throw f!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${C}`)}return S}processStack(e,t,s,r,i,o,a,l,u){const c=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&z("isConstant",h.node,r,s)&&([f]=tc(h.node.name,s)),r[h.node.name]==null){const p=qP(h.node,r,s,this._resourceManager);f||([f]=tc(h.node.name,s));const g=s.currentContext;Pf(p)?c.push(p.then(S=>(r[f]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(S)),s.currentContext=g,this.checkTensorForDisposal(f,h.node,r,s,o,a,l),this.processChildNodes(h.node,t,s,r,i,u),S))):(r[f]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(p)),this.checkTensorForDisposal(f,h.node,r,s,o,a,l),this.processChildNodes(h.node,t,s,r,i,u))}else this.processChildNodes(h.node,t,s,r,i,u)}return c}processChildNodes(e,t,s,r,i,o){e.children.forEach(a=>{const[l]=tc(a.name,s);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!Xr(u,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:a})):a.inputNames.every(u=>!!Xr(u,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Io(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===s.shape.length&&s.shape.every((l,u)=>o[u]===-1||o[u]===l);q(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&q(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const i in e){const o=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];o!=null?r[o.name]=e[i]:r[i]=e[i]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Io(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Io(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class kle{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rle="?tfjs-format=file",Dle="model.json";class Ple{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=Cz){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new kle}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Pf(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await KF(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new RS(GP.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=GP.Instance.transformGraph(e.modelInitializer);this.initializer=new RS(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof gs?[e]:e,s={};return t.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof gs)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,o)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||u===void 0?void 0:u.resourceId;return c!=null?i[o]=this.resourceIdToCapturedInput[c]:i[o]=e[r++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const i=s[r],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Tn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function _4(n,e={},t=Cz){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=Lle(n));const s=new Ple(n,e,t);return await s.load(),s}function Lle(n){return n.endsWith("/")||(n=n+"/"),`${n}${Dle}${Rle}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ZP;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(ZP||(ZP={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&q(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ole=MA;class nT extends VI{nextDataId(){return nT.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new SF(this,Ql())}write(e,t,s){this.firstUse&&(this.firstUse=!1,Te().get("IS_NODE")&&ra(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&dx(s[0])){const i=s.map(o=>Nh(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return gc(r,i)}return U7(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ph(r));return yn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return yn(e.shape,e.dtype,t)}makeOutput(e,t,s){return Ql().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Ji();return e(),{kernelMs:Ji()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Dt([e],"where");const t=this.readSync(e.dataId);return Ole(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}nT.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T4(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const Fle=n=>{const{x:e}=n.inputs,t=n.backend;Dt(e,"abs");let s=new Float32Array(Oe(e.shape));const r=t.data.get(e.dataId).values;return s=T4(r),t.makeOutput(s,e.shape,e.dtype)},$le={kernelName:gb,backendName:"cpu",kernelFunc:Fle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n){return(e,t,s,r,i)=>{const o=dn(e,t),a=o.length,l=Wt(o),u=Oe(o),c=Yr(i,u),h=e.length,f=t.length,p=Wt(e),g=Wt(t),S=pg(e,o),x=pg(t,o);if(S.length+x.length===0)for(let w=0;w<c.length;++w)c[w]=n(s[w%s.length],r[w%r.length]);else for(let w=0;w<c.length;++w){const _=Dg(w,a,l),T=_.slice(-h);S.forEach(P=>T[P]=0);const C=lu(T,h,p),N=_.slice(-f);x.forEach(P=>N[P]=0);const M=lu(N,f,g);c[w]=n(s[C],r[M])}return[c,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",o)},a}const zle={kernelName:JI,backendName:"cpu",kernelFunc:Mo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(n,e,t="float32"){if(t==="complex64"){const r=DS(n,e,"float32"),i=DS(n,e,"float32");return Mo({inputs:{real:r,imag:i},backend:n})}const s=gi(Oe(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Ule={kernelName:Dx,backendName:"cpu",kernelFunc:mu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Ble={kernelName:MN,backendName:"cpu",kernelFunc:Gf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Kf([0],t),[i,o]=Ks((a,l)=>a!==l?1:0)(e,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Gh(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return mu({inputs:{x:r},backend:t});const c=DS(t,r.shape,r.dtype),h=Gh({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),f=Mo({inputs:{real:h,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),f}if(r.dtype==="complex64"){const c=Gf({inputs:{input:r},backend:t}),h=Gh({inputs:{x:c},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(c),h}if(!_F(r.dtype,i)){const c=mu({inputs:{x:r},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:i}}const o=t.data.get(r.dataId).values,[a,l,u]=C4(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,l,u)}const Vle={kernelName:wx,backendName:"cpu",kernelFunc:Gh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;Dt([o,a],n);const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=o.dtype==="string"?yc(u):u,f=o.dtype==="string"?yc(c):c,p=s||o.dtype,[g,S]=e(o.shape,a.shape,h,f,p);return l.makeTensorInfo(S,p,g)}:({inputs:r,backend:i})=>{const{a:o,b:a}=r,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const u=Gh({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,f=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,g=l.data.get(f.dataId).values,S=Gh({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),x=l.data.get(S.dataId),w=x.complexTensorInfos.real,_=x.complexTensorInfos.imag,T=l.data.get(w.dataId).values,C=l.data.get(_.dataId).values,[N,M,P]=t(o.shape,a.shape,p,g,T,C),$=l.makeTensorInfo(P,"float32",N),R=l.makeTensorInfo(P,"float32",M),D=Mo({inputs:{real:$,imag:R},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(S),l.disposeIntermediateTensorInfo($),l.disposeIntermediateTensorInfo(R),D}else{const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=s||o.dtype,[f,p]=e(o.shape,a.shape,u,c,h);return l.makeTensorInfo(p,h,f)}}}function PM(n){return(e,t,s,r,i,o)=>{const a=dn(e,t),l=Oe(a),u=a.length,c=Wt(a),h=Yr("float32",l),f=Yr("float32",l),p=pg(e,a),g=pg(t,a),S=gc(s,r),x=gc(i,o),w=e.length,_=Wt(e),T=t.length,C=Wt(t);if(p.length+g.length===0)for(let N=0;N<h.length;N++){const M=N%S.length,P=N%x.length,$=n(S[M*2],S[M*2+1],x[P*2],x[P*2+1]);h[N]=$.real,f[N]=$.imag}else for(let N=0;N<h.length;N++){const M=Dg(N,u,c),P=M.slice(-w);p.forEach(G=>P[G]=0);const $=lu(P,w,_),R=M.slice(-T);g.forEach(G=>R[G]=0);const D=lu(R,T,C),L=n(S[$*2],S[$*2+1],x[D*2],x[D*2+1]);h[N]=L.real,f[N]=L.imag}return[h,f,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E4=Ks(((n,e)=>n+e)),Wle=PM(((n,e,t,s)=>({real:n+t,imag:e+s}))),xg=Tr(Pg,E4,Wle),Gle={kernelName:Pg,backendName:"cpu",kernelFunc:xg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LM(n,e,t,s,r){const i=Oe(s),o=gi(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function I4(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],o=yn([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(s?o.set(1,a,u):e.size>0?o.set(o.get(a,u)+e.get(a,l),a,u):o.set(o.get(a,u)+1,a,u))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N4=Ks(((n,e)=>n&e)),Hle=Tr(Tb,N4),jle={kernelName:Tb,backendName:"cpu",kernelFunc:Hle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xu(n){return(e,t,s)=>{const r=Gs(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qn(n,e,t){const s=xu(e);return ld(n,s,t)}function ld(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;Dt(o,n);const a=i,l=a.data.get(o.dataId).values;let u;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=yc(l)}else u=l;const c=t||o.dtype,h=e(u,c,r);return a.makeTensorInfo(o.shape,c,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A4=xu(n=>Math.ceil(n)),Xle=ld(Sx,A4),qle={kernelName:Sx,backendName:"cpu",kernelFunc:Xle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4(n,e,t,s){const r=Gs(t,Oe(e));if(s&&t!=="string"){let i=0;n.forEach(o=>{const a=Oe(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?yc(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*e[1]+i;for(let h=0;h<o.shape[1];++h)r[c+h]=a[l++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4=Ks((n,e)=>n===e?1:0),R4=Tr(Db,k4,null,"bool"),Kle={kernelName:Db,backendName:"cpu",kernelFunc:R4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4=xu(n=>Math.exp(n)),P4=ld(Nx,D4,"float32"),Yle={kernelName:Nx,backendName:"cpu",kernelFunc:P4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L4=xu(n=>Math.expm1(n)),Zle=ld(Ax,L4),Jle={kernelName:Ax,backendName:"cpu",kernelFunc:Zle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4=xu(n=>Math.floor(n)),Qle=ld(Mx,O4),eue={kernelName:Mx,backendName:"cpu",kernelFunc:Qle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F4=Ks((n,e)=>Math.floor(n/e)),tue=Tr(kx,F4,null,"int32"),nue={kernelName:kx,backendName:"cpu",kernelFunc:tue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $4(n,e,t,s,r,i,o,a,l){const u=yn([s,i],t);for(let c=0;c<s;c++){const h=[];let f=0;for(let p=0;p<r;p++){const g=n[c*r+p];f+=g*o[p],h.push(g)}if(f<0||f>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<i;p++)u.values[c*i+p]=e.get(...e.indexToLoc(f*i+p))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(n,e,t){const s=yn(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],l=o[2],u=e.locToIndex([a,l]);o[2]=e.values[u];const c=n.locToIndex(o);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U4=Ks((n,e)=>n>e?1:0),sue=Tr(Fb,U4,null,"bool"),rue={kernelName:Fb,backendName:"cpu",kernelFunc:sue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B4=Ks((n,e)=>n>=e?1:0),iue=Tr(Rx,B4,null,"bool"),oue={kernelName:Rx,backendName:"cpu",kernelFunc:iue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V4=Ks((n,e)=>n<e?1:0),aue=Tr(zb,V4,null,"bool"),lue={kernelName:zb,backendName:"cpu",kernelFunc:aue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W4=Ks((n,e)=>n<=e?1:0),uue=Tr(Ub,W4,null,"bool"),cue={kernelName:Ub,backendName:"cpu",kernelFunc:uue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(n,e,t){const s=(e-n)/(t-1),r=gi(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H4=xu(n=>Math.log(n)),hue=ld(Fx,H4),due={kernelName:Fx,backendName:"cpu",kernelFunc:hue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(n,e,t,s){const r=Yr(s,Oe(t));for(let i=0;i<r.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const u=n[o+l];(Number.isNaN(u)||u>a)&&(a=u)}r[i]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X4=Ks(((n,e)=>Math.max(n,e))),fue=Tr(zx,X4),pue={kernelName:zx,backendName:"cpu",kernelFunc:fue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q4=Ks(((n,e)=>Math.min(n,e))),mue=Tr(Ux,q4),gue={kernelName:Ux,backendName:"cpu",kernelFunc:mue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OM=Ks(((n,e)=>n*e)),yue=PM(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),sT=Tr(Vx,OM,yue),xue={kernelName:Vx,backendName:"cpu",kernelFunc:sT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(n,e,t){const s=Qh(-1,t);return OM([],e,s,n,t)}function vue(n){const{inputs:e,backend:t}=n,{x:s}=e;Dt(s,"neg");const r=t.data.get(s.dataId).values,[i,o]=K4(r,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,i)}const wue={kernelName:Zb,backendName:"cpu",kernelFunc:vue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y4=Ks(((n,e)=>n!==e?1:0)),Sue=Tr(Jb,Y4,null,"bool"),bue={kernelName:Jb,backendName:"cpu",kernelFunc:Sue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FM(n,e,t,s,r){const i=e.length,o=Oe(e),a=Wt(e),l=Wt(r),u=Yr(t,Oe(r));for(let c=0;c<o;++c){const h=Dg(c,i,a),f=new Array(h.length);for(let g=0;g<f.length;g++)f[g]=h[s[g]];const p=lu(f,i,l);u[p]=n[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function io(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;Dt(r,"transpose");const o=r.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=r.shape[i[h]];const l=s.data.get(r.dataId).values,u=FM(l,r.shape,r.dtype,i,a);return{dataId:s.write(u,a,r.dtype),shape:a,dtype:r.dtype}}const _ue={kernelName:Zm,backendName:"cpu",kernelFunc:io};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z4(n,e,t,s){const[r,i]=zr(n,s),o=Lo(e,"int32"),a=gi(Oe(r),o),l=Oe(i);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let f=0;f<l;++f)h*=t[c+f];a[u]=h}return{outVals:a,outShape:r,outDtype:o}}function Tue(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Dt(r,"prod");const a=r.shape.length,l=Cn(i,r.shape),u=ks(l,a);let c=l,h=r;const f=[];u!=null&&(h=io({inputs:{x:r},backend:t,attrs:{perm:u}}),f.push(h),c=Xs(c.length,a));const p=t.data.get(h.dataId).values,{outVals:g,outShape:S,outDtype:x}=Z4(h.shape,h.dtype,p,c);let w=S;return o&&(w=js(S,l)),f.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.makeTensorInfo(w,x,g)}const Cue={kernelName:r_,backendName:"cpu",kernelFunc:Tue};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eue(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=Dg(r,e.length,Wt(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function Iue(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Nue(n,e,t,s){const r=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);Iue(t,s);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<n.length;++u){let c=n[u],h=n[u]+1;for(let f=0;f<t.length;++f){const p=t[f],g=f+e.length-1;if(g>=0){const S=a[g],x=S[S.length-1]-p[c];for(let w=c;w<h;++w)a[g].push(p[w+1]+x)}c=p[c],h=p[h]}h!==c&&(r.push([c,h]),i+=h-c)}return{outSplits:a,valueSlices:r,numValues:i}}function Aue(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=Gs("int32",s);e.push(r),n[t].forEach((i,o)=>r[o]=i)}return e}function JP(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function Mue(n,e,t,s,r,i){const o=JP(e,2)[1],a=JP(i,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let h=0;h<s;++h)r[l*a+h]=n[c*o+h];++l}}function kue(n,e,t,s,r){const i=e.slice();i[0]=r;const o=Gs(t,Oe(i)),a=n.length,l=a===0?0:a/e[0];return Mue(n,e,s,l,o,i),[o,i]}function J4(n,e,t,s,r,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(Eue(i,o,l),s.length===0)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:h,numValues:f}=Nue(i,o,n,u),p=Aue(c),g=kue(t,s,r,h,f);return[p,g[0],g[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QP=2147483647;function Q4(n,e,t,s,r,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=r.length===0,u=o.length===0,c=[];a||c.push(e[0]),l||c.push(r[0]),u||c.push(o[0]);for(let x=1;x<c.length;++x)if(c[x]!==c[x-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],f=Gs("int32",h+1);f[0]=0;for(let x=0;x<h;++x){const w=a?n[0]:n[x],_=l?s[0]:s[x],T=u?i[0]:i[x];if(T===0)throw new Error("Requires delta != 0");let C;if(T>0&&_<w||T<0&&_>w)C=0;else if(C=Math.ceil(Math.abs((_-w)/T)),C>QP)throw new Error(`Requires ((limit - start) / delta) <= ${QP}`);f[x+1]=f[x]+C}const p=f[h],g=Gs(t,p);let S=0;for(let x=0;x<h;++x){const w=f[x+1]-f[x];let _=a?n[0]:n[x];const T=u?i[0]:i[x];for(let C=0;C<w;++C)g[S++]=_,_+=T}return[f,g]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ca=yl;class PS{constructor(e,t,s,r,i,o,a,l,u,c){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=Oz(c),this.raggedRank=Fz(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ca.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ca.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ca.VALUE_ROWIDS:return PS.getMaxWidthValueRowID(t);case Ca.ROW_SPLITS:return PS.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ca[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==r&&(r=a,i=Math.max(o-s,i),s=o)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return tL(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;$z(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=Lz(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let o=0;for(let a=0;a<r;++a,o+=t)i.push(o);for(let a=r;a<e;++a)i.push(-1);return q(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let u=Math.min(r,l),c=t[a];c===-1&&(u=0);for(let h=0;h<u;++h)o.push(c),c+=s;for(let h=0;h<l-u;++h)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];o.push(u);for(let c=1;c<i;++c){const h=e[c];if(h===l)u>=0&&(++a,a<r?u+=s:u=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Ca.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case Ca.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${Ca[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Ca.FIRST_DIM_SIZE:return e[0];case Ca.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ca.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ca[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=tL(s,!1),o=Gs(this.valuesDType,Oe(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,o=s;let a=r.slice();a=a.slice(e+1);const l=Oe(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const g=this.defaultValueShape;be(()=>{const S=pe(c,g);c=eg(S,a).dataSync()})}let h=0,f=0,p=0;for(let g=0;g<=u;++g){let S=g<u?t[g]:-1;if(S===p){++p;continue}if(f<p){const x=i.subarray(h*l),w=o.subarray(f*l),_=(p-f)*l;eL(w,x,_)}if(g>=u){const x=s.length;S=Math.floor(x/l)}if(S>p)if(this.defaultValue.length===1)o.subarray(p*l,S*l).fill(this.defaultValue[0]),p=S;else for(;S>p;){const x=o.slice(p*l);eL(x,c,l),++p}S<0?(h=g+1,f=p):(h=g,f=p,p=f+1)}}}function eL(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function tL(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function eV(n,e,t,s,r,i,o,a,l,u){return new PS(n,e,t,s,r,i,o,a,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tV(n,e,t,s){const r=n===e,i=n<e&&t<0,o=e<n&&t>1;if(r||i||o)return gi(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=gi(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nV=xu(n=>1/Math.sqrt(n)),Rue=ld(qx,nV),Due={kernelName:qx,backendName:"cpu",kernelFunc:Rue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sf(n,e,t,s,r,i,o,a,l,u){const c=[s/r,r],h=n.values,f=e.values;if(s===0)return yn(t,e.dtype);const p=l instanceof wr?l:yn(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let g=0;g<i;g++){const S=[];let x=0;for(let w=0;w<o;w++){const _=h[g*o+w];S.push(_),x+=_*a[w]}if(x<0||x>=s/r)throw new Error(`Invalid indices: ${S} does not index into ${t}`);for(let w=0;w<r;w++)u?p.values[x*r+w]+=f[g*r+w]:p.values[x*r+w]=e.rank===0?f[0]:f[g*r+w]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pue=xu(n=>1/(1+Math.exp(-n))),sV=qn(Qx,n=>1/(1+Math.exp(-n))),Lue={kernelName:Qx,backendName:"cpu",kernelFunc:sV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rV(n,e,t,s,r){const i=WA(s,e,t),o=Oe(t),a=Wt(s);if(i){const h=GA(e,a);return r==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=r==="string"?yc(n):n,u=yn(s,r,l),c=yn(t,r);for(let h=0;h<c.size;++h){const f=c.indexToLoc(h),p=f.map((g,S)=>g+e[S]);c.set(u.get(...p),...f)}return r==="string"?rU(c.values):c.values}function Hf(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s;Dt(r,"slice");const[a,l]=V_(r,i,o);BA(r,a,l);const u=t.data.get(r.dataId).values,c=rV(u,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,c)}const Oue={kernelName:c_,backendName:"cpu",kernelFunc:Hf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iV(n,e,t,s,r,i,o){const a=e[0],l=i[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(Hz(a));const x=Gs(t,0),w=Gs(r,0);return[x,[0,h],w,u,c]}let f=!0,p=0;const g=new Array(l).fill(0);for(let x=0;x<a;++x){const w=n[x*h];if(w<0)throw new Error(jz(x,w));if(w>=l)throw new Error(Xz(x,w,l));++g[w],f=f&&w>=p,p=w}let S=!0;for(let x=0;x<l;++x){const w=g[x]===0;u[x]=w,S=S&&!w,g[x]=Math.max(g[x],1),x>0&&(g[x]+=g[x-1])}if(S&&f){const x=n,w=s;for(let _=0;_<a;++_)c[_]=_;return[x,[a,h],w,u,c]}else{const x=g[l-1],w=Gs(t,x*h),_=Gs(r,x),T=new Array(l).fill(0);for(let C=0;C<a;++C){const N=n[C*h],M=T[N],P=(N===0?0:g[N-1])+M;T[N]++;for(let $=0;$<h;++$)w[P*h+$]=n[C*h+$];_[P]=s[C],c[C]=P}for(let C=0;C<l;++C)if(T[C]===0){const M=C===0?0:g[C-1];w[M*h+0]=C;for(let P=1;P<h;++P)w[M*h+P]=0;_[M]=o}return[w,[x,h],_,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(n,e,t,s,r){const i=Oe(s),o=e[0],a=r.length,l=[];let u=1,c=-1;for(let x=0;x<a;++x){const w=r[x];if(w===-1){if(c!==-1)throw new Error(qz(c,x));c=x,l.push(1)}else{if(w<0)throw new Error(Kz(x,w));u*=w,l.push(w)}}if(c!==-1){if(u<=0)throw new Error(Yz());const x=Math.trunc(i/u);if(u*x!==i)throw new Error(Zz(s,l));l[c]=x}if(Oe(l)!==i)throw new Error(Jz(s,l));const f=s.length,p=[];if(f>0){p[f-1]=1;for(let x=f-2;x>=0;--x)p[x]=p[x+1]*s[x+1]}const g=[];if(a>0){g[a-1]=1;for(let x=a-2;x>=0;--x)g[x]=g[x+1]*l[x+1]}const S=Gs(t,o*a);for(let x=0;x<o;++x){let w=0;for(let _=0;_<f;++_)w+=n[x*f+_]*p[_];for(let _=0;_<a;++_)S[x*a+_]=Math.trunc(w/g[_]),w%=g[_]}return[S,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $M(n,e,t,s,r,i=!1,o=0){const a=s.length,l=[e[0],n.length/e[0]],u=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(b2());const f=e.slice();f[0]=h;const p=f.reduce((T,C)=>T*C,1),g=Gs(t,p);if(a===0)return h>0&&g.fill(o),[g,f];if(h<=0)throw new Error(b2());let S=0,x=1,w=0,_=r[S];for(;;){let T=0;if(x<a){if(T=r[x],_===T){++x;continue}if(_>=T)throw new Error(Qz())}if(_<0||_>=h)throw new Error(eU(_,h));_>w&&g.fill(o,w*u,_*u);for(let C=S;C<x;++C){const N=s[C];if(N<0||N>=l[0])throw new Error(tU(C,s[C],l[0]));for(let M=0;M<u;M++)g[_*u+M]+=n[N*u+M]}if(i)for(let C=0;C<u;C++)g[_*u+C]/=x-S;if(S=x,++x,w=_+1,_=T,x>a)break}return w<h&&g.fill(o,w*u,h*u),[g,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fue=xu(n=>Math.sqrt(n)),$ue=qn(tv,n=>Math.sqrt(n)),zue={kernelName:tv,backendName:"cpu",kernelFunc:$ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV=Ks(((n,e)=>{const t=n-e;return t*t})),Uue=Tr(nv,aV),Bue={kernelName:nv,backendName:"cpu",kernelFunc:Uue};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lV=xu((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),Vue=ld(m_,lV),Wue={kernelName:m_,backendName:"cpu",kernelFunc:Vue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uV(n,e,t,s){const r=yn(n,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+s[l];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gue{constructor(e,t,s,r,i,o){this.separator=Nh(e),this.nGramWidths=t,this.leftPad=Nh(s),this.rightPad=Nh(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(i-(a+1))),h=o-(u+c),f=t+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let _=0;_<h;++_)p+=e[f+_].length;p+=c*this.rightPad.length;const g=u+c+h-1;p+=g*this.separator.length,s[r+a]=new Uint8Array(p);const S=s[r+a];let x=0;const w=_=>_.forEach(T=>S[x++]=T);for(let _=0;_<u;++_)w(this.leftPad),w(this.separator);for(let _=0;_<h-1;++_)w(e[f+_]),w(this.separator);if(h>0){w(e[f+h-1]);for(let _=0;_<c;++_)w(this.separator),w(this.rightPad)}else{for(let _=0;_<c-1;++_)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=t[u]>=l;if(c=c&&t[u]<=s,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${s}]`);l=t[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=Gs("int32",r);if(s===0||r===0){const l=new Array(s);for(let u=0;u<=i;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[i]);for(let l=0;l<i;++l){const u=t[l];let c=o[l];if(this.nGramWidths.forEach(h=>{const f=t[l+1]-t[l],p=this.getNumNGrams(f,h);this.createNGrams(e,u,a,c,p,h),c+=p}),this.preserveShort&&c===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const f=h+2*this.padWidth;this.createNGrams(e,u,a,c,1,f)}}return[a,o]}}function cV(n,e,t,s,r,i,o,a){return new Gue(t,s,r,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hue(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!t||o.length!==0)&&s.push(o),r=i+1}}function hV(n,e,t){const s=n.length,r=[];let i=0,o=0;const a=new Array(s);for(let f=0;f<s;++f){const p=r.length;Hue(n[f],e,t,r);const g=r.length-p;a[f]=g,i+=g,o=Math.max(o,g)}const l=Gs("int32",i*2),u=new Array(i),c=[s,o];let h=0;for(let f=0;f<s;++f)for(let p=0;p<a[f];++p)l[h*2]=f,l[h*2+1]=p,u[h]=r[h],++h;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dV(n,e){const t=Gs("int32",n.length);for(let s=0;s<n.length;++s)t[s]=rK(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fV=Ks(((n,e)=>n-e)),jue=PM(((n,e,t,s)=>({real:n-t,imag:e-s}))),zM=Tr(sv,fV,jue),Xue={kernelName:sv,backendName:"cpu",kernelFunc:zM};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pV(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=yn(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);s.values[r]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function mV(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),f=Math.max(t,Math.floor(e-l*c/a+h)),p=Math.min(s,Math.floor(e+(a-l)*c/a+h));mV(n,e,f,p)}const r=n[e];let i=t,o=s;for(zm(n,t,e),i0(n[s],r)>0&&zm(n,t,s);i<o;){for(zm(n,i,o),i++,o--;i0(n[i],r)<0;)i=i+1;for(;i0(n[o],r)>0;)o=o-1}i0(n[t],r)===0?zm(n,t,o):(o=o+1,zm(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function gV(n,e,t,s,r){const i=e[e.length-1],[o,a]=[n.length/i,i],l=Yr(t,o*s),u=Yr("int32",o*s);for(let h=0;h<o;h++){const f=h*a,p=n.subarray(f,f+a);let g=new Array(p.length);p.forEach((_,T)=>g[T]={value:_,index:T}),s<g.length&&(mV(g,s),g=g.slice(0,s)),r&&g.sort(i0);const S=h*s,x=l.subarray(S,S+s),w=u.subarray(S,S+s);for(let _=0;_<s;_++)x[_]=g[_].value,w[_]=g[_].index}const c=e.slice();return c[c.length-1]=s,[yn(c,t,l),yn(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yV(n,e,t,s){const r=Cn(e,t)[0],i=[1,t[0],1];for(let g=0;g<r;g++)i[0]*=t[g];i[1]=t[r];for(let g=r+1;g<t.length;g++)i[2]*=t[g];const o=new Map,a=new Int32Array(t[r]),l=new wr(i,s,n),u=[],c=i[0]===1&&i[2]===1;for(let g=0;g<t[r];g++){let S;if(c)S=n[g].toString();else{const w=[];for(let _=0;_<i[0];_++)for(let T=0;T<i[2];T++)w.push(l.get(_,g,T));S=w.join(",")}const x=o.get(S);if(x!=null)a[g]=x;else{const w=o.size;o.set(S,w),a[g]=w,u.push(g)}}const h=i.slice();h[1]=o.size;const f=new wr(h,s);u.forEach((g,S)=>{for(let x=0;x<i[0];x++)for(let w=0;w<i[2];w++)f.set(l.get(x,g,w),x,S,w)});const p=t.slice();return p[r]=h[1],{outputValues:f.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const que=Object.freeze(Object.defineProperty({__proto__:null,addImpl:E4,bincountImpl:LM,bincountReduceImpl:I4,bitwiseAndImpl:N4,castImpl:C4,ceilImpl:A4,concatImpl:M4,equalImpl:k4,expImpl:D4,expm1Impl:L4,floorDivImpl:F4,floorImpl:O4,gatherNdImpl:$4,gatherV2Impl:z4,greaterEqualImpl:B4,greaterImpl:U4,lessEqualImpl:W4,lessImpl:V4,linSpaceImpl:G4,logImpl:H4,maxImpl:j4,maximumImpl:X4,minimumImpl:q4,multiplyImpl:OM,negImpl:K4,notEqualImpl:Y4,prodImpl:Z4,raggedGatherImpl:J4,raggedRangeImpl:Q4,raggedTensorToTensorImpl:eV,rangeImpl:tV,rsqrtImpl:nV,scatterImpl:Sf,sigmoidImpl:Pue,simpleAbsImpl:T4,sliceImpl:rV,sparseFillEmptyRowsImpl:iV,sparseReshapeImpl:oV,sparseSegmentReductionImpl:$M,sqrtImpl:Fue,squaredDifferenceImpl:aV,staticRegexReplaceImpl:lV,stridedSliceImpl:uV,stringNGramsImpl:cV,stringSplitImpl:hV,stringToHashBucketFastImpl:dV,subImpl:fV,tileImpl:pV,topKImpl:gV,transposeImpl:FM,uniqueImpl:yV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */HF("cpu",()=>new nT,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xV=qn(Ex,n=>n>=0?n:Math.exp(n)-1),Kue={kernelName:Ex,backendName:"cpu",kernelFunc:xV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;Dt([r],"leakyRelu");const o=Oe(r.shape),a=t.data.get(r.dataId).values,l=Yr("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?i*a[u]:a[u];return t.makeTensorInfo(r.shape,"float32",l)}const Yue={kernelName:$b,backendName:"cpu",kernelFunc:vV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zue=Ks((n,e)=>n<0?e*n:n);function wV(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;Dt([s,r],"prelu");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,[a,l]=Zue(s.shape,r.shape,i,o,"float32");return t.makeTensorInfo(l,"float32",a)}const Jue={kernelName:s_,backendName:"cpu",kernelFunc:wV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SV=qn(Hx,n=>Math.max(0,n)),Que={kernelName:Hx,backendName:"cpu",kernelFunc:SV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bV=qn(jx,n=>Math.min(Math.max(0,n),6)),ece={kernelName:jx,backendName:"cpu",kernelFunc:bV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(n,e,t,s,r){if(t==="linear")return mu({inputs:{x:e},backend:n});if(t==="relu")return SV({inputs:{x:e},backend:n});if(t==="elu")return xV({inputs:{x:e},backend:n});if(t==="relu6")return bV({inputs:{x:e},backend:n});if(t==="prelu")return wV({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return vV({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return sV({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ds(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=Oe(r.shape),a=bF(i,o),l=Oe(a);q(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const u=t.data.get(r.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const tce={kernelName:i_,backendName:"cpu",kernelFunc:ds};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _V(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;Dt([r,i],"matMul");const l=r.shape.length,u=i.shape.length,c=o?r.shape[l-2]:r.shape[l-1],h=a?i.shape[u-1]:i.shape[u-2],f=o?r.shape[l-1]:r.shape[l-2],p=a?i.shape[u-2]:i.shape[u-1],g=r.shape.slice(0,-2),S=i.shape.slice(0,-2),x=Oe(g),w=Oe(S),T=dn(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([f,p]);q(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const C=o?[x,c,f]:[x,f,c],N=a?[w,p,h]:[w,h,p],M=ds({inputs:{x:r},backend:t,attrs:{shape:C}}),P=ds({inputs:{x:i},backend:t,attrs:{shape:N}}),$=o?M.shape[1]:M.shape[2],R=o?M.shape[2]:M.shape[1],D=a?P.shape[1]:P.shape[2],L=Math.max(x,w),G=t.data.get(M.dataId).values,Q=t.data.get(P.dataId).values,W=Wt(M.shape),H=Wt(P.shape),[J,ie,V]=o?[W[0],1,W[1]]:[W[0],W[1],1],[Y,B,K]=a?[1,H[1],H[0]]:[H[1],1,H[0]],se=R*D,te=yn([L,R,D],M.dtype),ue=te.values,fe=t.blockSize;for(let _e=0;_e<L;_e++){const Ie=_e%x,Ve=_e%w;for(let qe=0;qe<R;qe+=fe){const Ye=Math.min(qe+fe,R);for(let et=0;et<D;et+=fe){const ae=Math.min(et+fe,D);for(let Be=0;Be<$;Be+=fe){const De=Math.min(Be+fe,$);for(let He=qe;He<Ye;He++)for(let Re=et;Re<ae;Re++){let at=0;for(let Qe=Be;Qe<De;Qe++){const ee=G[Ie*J+He*ie+Qe*V],X=Q[Qe*Y+Re*B+Ve*K];at+=ee*X}ue[_e*se+(He*D+Re)]+=at}}}}}return t.disposeIntermediateTensorInfo(M),t.disposeIntermediateTensorInfo(P),t.makeTensorInfo(T,te.dtype,te.values)}const nce={kernelName:bb,backendName:"cpu",kernelFunc:_V};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sce(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let f,p,g;const S=[];f=_V({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:t}),o&&(p=xg({inputs:{a:f,b:o},backend:t}),S.push(f),f=p),c&&(g=LS(t,f,c,a,h),S.push(f),f=g);for(const w of S)t.disposeIntermediateTensorInfo(w);return f}const rce={kernelName:pS,backendName:"cpu",kernelFunc:sce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ice=qn(fx,n=>Math.acos(n)),oce={kernelName:fx,backendName:"cpu",kernelFunc:ice};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ace=qn(px,n=>Math.acosh(n)),lce={kernelName:px,backendName:"cpu",kernelFunc:ace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uce(n){const{inputs:e,backend:t}=n,s=e;Dt(e,"addN");const r=s.map(a=>t.data.get(a.dataId).values),i=yn(s[0].shape,s[0].dtype),o=i.values;for(let a=0;a<s.length;a++){const l=r[a];for(let u=0;u<o.length;u++)o[u]+=l[u]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const cce={kernelName:yb,backendName:"cpu",kernelFunc:uce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Dt(r,"all");const a=Cn(i,r.shape);let l=a;const u=ks(l,r.shape.length);let c=r;u!=null&&(c=io({inputs:{x:r},backend:t,attrs:{perm:u}}),l=Xs(l.length,r.shape.length)),Jr("all",l,c.shape.length);const[h,f]=zr(c.shape,l),p=Oe(f),g=gi(Oe(h),c.dtype),S=t.data.get(c.dataId).values;for(let w=0;w<g.length;++w){const _=w*p;let T=S[_];for(let C=0;C<p;++C){const N=S[_+C];T=T&&N}g[w]=T}u!=null&&t.disposeIntermediateTensorInfo(c);const x=t.makeTensorInfo(h,c.dtype,g);if(o){const w=js(h,a),_=ds({inputs:{x},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(x),_}return x}const dce={kernelName:jI,backendName:"cpu",kernelFunc:hce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Dt(r,"any");const a=Cn(i,r.shape);let l=a;const u=ks(l,r.shape.length);let c=r;u!=null&&(c=io({inputs:{x:r},backend:t,attrs:{perm:u}}),l=Xs(l.length,r.shape.length)),Jr("any",l,c.shape.length);const[h,f]=zr(c.shape,l),p=Oe(f),g=gi(Oe(h),c.dtype),S=t.data.get(c.dataId).values;for(let w=0;w<g.length;++w){const _=w*p;let T=S[_];for(let C=0;C<p;++C){const N=S[_+C];T=T||N}g[w]=T}u!=null&&t.disposeIntermediateTensorInfo(c);const x=t.makeTensorInfo(h,c.dtype,g);if(o){const w=js(h,a),_=ds({inputs:{x},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(x),_}return x}const pce={kernelName:XI,backendName:"cpu",kernelFunc:fce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Dt(r,"argMax");let o=Cn(i,r.shape);const a=ks(o,r.shape.length);let l=r;const u=[];a!=null&&(l=io({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Xs(o.length,l.shape.length)),o=[o[0]],Jr("argMax",o,l.shape.length);const[c,h]=zr(l.shape,o),f=Oe(c),p=gi(f,"int32"),g=Oe(h),S=t.data.get(l.dataId).values;for(let x=0;x<p.length;++x){const w=x*g;let _=S[w],T=0;for(let C=0;C<g;++C){const N=S[w+C];N>_&&(_=N,T=C)}p[x]=T}return u.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(c,"int32",p)}const gce={kernelName:xb,backendName:"cpu",kernelFunc:mce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Dt(r,"argMin");let o=Cn(i,r.shape);const a=ks(o,r.shape.length);let l=r;const u=[];a!=null&&(l=io({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Xs(o.length,l.shape.length)),o=[o[0]],Jr("argMin",o,l.shape.length);const[c,h]=zr(l.shape,o),f=Oe(c),p=gi(f,"int32"),g=Oe(h),S=t.data.get(l.dataId).values;for(let x=0;x<p.length;++x){const w=x*g;let _=S[w],T=0;for(let C=0;C<g;++C){const N=S[w+C];N<_&&(_=N,T=C)}p[x]=T}return u.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(c,"int32",p)}const xce={kernelName:vb,backendName:"cpu",kernelFunc:yce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vce=qn(mx,n=>Math.asin(n)),wce={kernelName:mx,backendName:"cpu",kernelFunc:vce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sce=qn(gx,n=>Math.asinh(n)),bce={kernelName:gx,backendName:"cpu",kernelFunc:Sce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ce=qn(yx,n=>Math.atan(n)),Tce={kernelName:yx,backendName:"cpu",kernelFunc:_ce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cce=Ks((n,e)=>Math.atan2(n,e)),Ece=Tr(vx,Cce),Ice={kernelName:vx,backendName:"cpu",kernelFunc:Ece};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nce=qn(xx,n=>Math.atanh(n)),Ace={kernelName:xx,backendName:"cpu",kernelFunc:Nce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UM(n,e,t,s,r,i){const o=r.strideHeight,a=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,g=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=yn(r.outShape,t),x=S.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3],_=r.outShape[2]*r.outShape[3],T=r.outShape[3];for(let C=0;C<r.batchSize;++C){const N=C*w,M=C*s[0];for(let P=0;P<r.inChannels;++P)for(let $=0;$<r.outHeight;++$){const R=$*o-f,D=Math.max(0,R),L=Math.min(r.inHeight,c+R),G=N+$*_;for(let Q=0;Q<r.outWidth;++Q){const W=Q*a-p,H=Math.max(0,W),J=Math.min(r.inWidth,h+W);let ie=g,V=0,Y=0;for(let K=D;K<L;K+=l){const se=M+K*s[1];for(let te=H;te<J;te+=u){const ue=se+te*s[2],fe=n[ue+P];i==="max"&&fe>ie?ie=fe:i==="avg"&&(V+=fe,Y++)}if(isNaN(ie))break}const B=G+Q*T+P;x[B]=i==="avg"?V/Y:ie}}}return S}function TV(n,e,t,s,r=!1,i=!1){const o=yn(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,f=s.effectiveFilterWidth,p=s.padInfo.top,g=s.padInfo.left,S=yn(e,t,n);for(let x=0;x<s.batchSize;++x)for(let w=0;w<s.inChannels;++w)for(let _=0;_<s.outHeight;++_){const T=_*a-p;let C=T;for(;C<0;)C+=u;const N=Math.min(s.inHeight,h+T);for(let M=0;M<s.outWidth;++M){const P=M*l-g;let $=P;for(;$<0;)$+=c;const R=Math.min(s.inWidth,f+P);let D=Number.NEGATIVE_INFINITY,L=-1;for(let G=C;G<N;G+=u){const Q=G-T;for(let W=$;W<R;W+=c){const H=W-P,J=S.get(x,G,W,w);J>D&&(D=J,r?L=i?((x*s.inHeight+G)*s.inWidth+W)*s.inChannels+w:(G*s.inWidth+W)*s.inChannels+w:L=Q*f+H)}}o.set(L,x,_,M,w)}}return o}function CV(n,e,t,s,r,i){const o=r.strideDepth,a=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,f=r.effectiveFilterDepth,p=r.effectiveFilterHeight,g=r.effectiveFilterWidth,S=r.padInfo.front,x=r.padInfo.top,w=r.padInfo.left,_=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=yn(r.outShape,t),C=T.values,N=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],M=r.outShape[2]*r.outShape[3]*r.outShape[4],P=r.outShape[3]*r.outShape[4],$=r.outShape[4];for(let R=0;R<r.batchSize;++R){const D=R*N,L=R*s[0];for(let G=0;G<r.inChannels;++G)for(let Q=0;Q<r.outDepth;++Q){const W=Q*o-S;let H=W;for(;H<0;)H+=u;const J=Math.min(r.inDepth,f+W),ie=D+Q*M;for(let V=0;V<r.outHeight;++V){const Y=V*a-x;let B=Y;for(;B<0;)B+=c;const K=Math.min(r.inHeight,p+Y),se=ie+V*P;for(let te=0;te<r.outWidth;++te){const ue=te*l-w;let fe=ue;for(;fe<0;)fe+=h;const _e=Math.min(r.inWidth,g+ue),Ie=se+te*$;let Ve=_,qe=0,Ye=0;for(let ae=H;ae<J;ae+=u){const Be=L+ae*s[1];for(let De=B;De<K;De+=c){const He=Be+De*s[2];for(let Re=fe;Re<_e;Re+=h){const at=He+Re*s[3],Qe=n[at+G];if(i==="max"&&Qe>Ve?Ve=Qe:i==="avg"&&(qe+=Qe,Ye++),isNaN(Ve))break}if(isNaN(Ve))break}if(isNaN(Ve))break}const et=Ie+G;C[et]=i==="avg"?qe/Math.max(Ye,1):Ve}}}}return T}function Mce(n,e){const t=yn(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,p=e.padInfo.top,g=e.padInfo.left;for(let S=0;S<e.batchSize;++S)for(let x=0;x<e.inChannels;++x)for(let w=0;w<e.outDepth;++w){const _=w*s-f;let T=_;for(;T<0;)T+=o;const C=Math.min(e.inDepth,u+_);for(let N=0;N<e.outHeight;++N){const M=N*r-p;let P=M;for(;P<0;)P+=a;const $=Math.min(e.inHeight,c+M);for(let R=0;R<e.outWidth;++R){const D=R*i-g;let L=D;for(;L<0;)L+=l;const G=Math.min(e.inWidth,h+D);let Q=Number.NEGATIVE_INFINITY,W=-1;for(let H=T;H<C;H+=o){const J=H-_;for(let ie=P;ie<$;ie+=a){const V=ie-M;for(let Y=L;Y<G;Y+=l){const B=Y-D,K=n.get(S,H,ie,Y,x);K>=Q&&(Q=K,W=J*c*h+V*c+B)}}}t.set(W,S,w,N,R,x)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Dt(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;q(Zr(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Fa(r.shape,i,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Mn(c.inShape,c.outShape))h=mu({inputs:{x:r},backend:t});else{const f=t.data.get(r.dataId).values,p=Wt(r.shape),g=UM(f,r.shape,r.dtype,p,c,"avg");h=t.makeTensorInfo(c.outShape,r.dtype,g.values)}return h}const Rce={kernelName:wb,backendName:"cpu",kernelFunc:kce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;Dt(r,"avgPool3d");const c=wc(r.shape,i,o,1,a,l,u),h=t.data.get(r.dataId).values,f=CV(h,r.shape,r.dtype,Wt(r.shape),c,"avg");return t.makeTensorInfo(f.shape,"float32",f.values)}const Pce={kernelName:Sb,backendName:"cpu",kernelFunc:Dce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;Dt([r,i],"avgPool3DGrad");const c=wc(i.shape,o,a,1,l,u),h=c.strideDepth,f=c.strideHeight,p=c.strideWidth,g=c.filterDepth,S=c.filterHeight,x=c.filterWidth,w=c.dilationDepth,_=c.dilationHeight,T=c.dilationWidth,C=c.effectiveFilterDepth,N=c.effectiveFilterHeight,M=c.effectiveFilterWidth,P=C-1-c.padInfo.front,$=M-1-c.padInfo.left,R=N-1-c.padInfo.top,D=yn(i.shape,"float32"),L=1/(g*S*x),G=t.bufferSync(r);for(let Q=0;Q<c.batchSize;++Q)for(let W=0;W<c.inChannels;++W)for(let H=0;H<c.inDepth;++H)for(let J=0;J<c.inHeight;++J)for(let ie=0;ie<c.inWidth;++ie){const V=H-P,Y=J-R,B=ie-$;let K=0;for(let se=0;se<C;se+=w){const te=(V+se)/h;if(!(te<0||te>=c.outDepth||Math.floor(te)!==te))for(let ue=0;ue<N;ue+=_){const fe=(Y+ue)/f;if(!(fe<0||fe>=c.outHeight||Math.floor(fe)!==fe))for(let _e=0;_e<M;_e+=T){const Ie=(B+_e)/p;if(Ie<0||Ie>=c.outWidth||Math.floor(Ie)!==Ie)continue;const Ve=G.get(Q,te,fe,Ie,W);K+=Ve}}}D.set(K*L,Q,H,J,ie,W)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const Oce={kernelName:KI,backendName:"cpu",kernelFunc:Lce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fce(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;Dt([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Fa(o.shape,a,l,1,u),h=c.strideHeight,f=c.strideWidth,p=c.filterHeight,g=c.filterWidth,S=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterHeight,_=c.effectiveFilterWidth,T=_-1-c.padInfo.left,C=w-1-c.padInfo.top,N=yn(o.shape,"float32"),M=1/(p*g),P=t.data.get(r.dataId).values,$=yn(r.shape,"float32",P);for(let R=0;R<c.batchSize;++R)for(let D=0;D<c.inChannels;++D)for(let L=0;L<c.inHeight;++L)for(let G=0;G<c.inWidth;++G){const Q=L-C,W=G-T;let H=0;for(let J=0;J<w;J+=S){const ie=(Q+J)/h;if(!(ie<0||ie>=c.outHeight||Math.floor(ie)!==ie))for(let V=0;V<_;V+=x){const Y=(W+V)/f;if(Y<0||Y>=c.outWidth||Math.floor(Y)!==Y)continue;const B=$.get(R,ie,Y,D);H+=B}}N.set(H*M,R,L,G,D)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const $ce={kernelName:qI,backendName:"cpu",kernelFunc:Fce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:o,mean:a,variance:l}=e;q(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Dt([r,a,l,i,o],"batchNorm");let{varianceEpsilon:u}=s;u==null&&(u=.001);const c=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,f=t.data.get(l.dataId).values,p=i?t.data.get(i.dataId).values:new Float32Array([1]),g=o?t.data.get(o.dataId).values:new Float32Array([0]),S=new Float32Array(c.length),x=g.length,w=p.length,_=f.length,T=h.length;let C=0,N=0,M=0,P=0;for(let $=0;$<c.length;++$)S[$]=g[C++]+(c[$]-h[N++])*p[M++]/Math.sqrt(f[P++]+u),C>=x&&(C=0),N>=T&&(N=0),M>=w&&(M=0),P>=_&&(P=0);return t.makeTensorInfo(r.shape,r.dtype,S)}const Uce={kernelName:Lb,backendName:"cpu",kernelFunc:zce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;Dt([r],"batchToSpaceND");const a=i.reduce((w,_)=>w*_),l=gv(r.shape,i,a),u=yv(l.length,i.length),c=xv(r.shape,i,a),h=KA(o,i.length),f=YA(c,o,i.length),p=ds({inputs:{x:r},backend:t,attrs:{shape:l}}),g=io({inputs:{x:p},backend:t,attrs:{perm:u}}),S=ds({inputs:{x:g},backend:t,attrs:{shape:c}}),x=Hf({inputs:{x:S},backend:t,attrs:{begin:h,size:f}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(S),x}const Vce={kernelName:_b,backendName:"cpu",kernelFunc:Bce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wce(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,u=LM(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}const Gce={kernelName:YI,backendName:"cpu",kernelFunc:Wce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hce(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,a=dn(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const jce={kernelName:ZI,backendName:"cpu",kernelFunc:Hce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xce=qn(bx,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),qce={kernelName:bx,backendName:"cpu",kernelFunc:Xce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kce=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(Oe(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];s[u]=Math.hypot(c,h)}return t.makeOutput(s,e.shape,"float32")},Yce={kernelName:Cb,backendName:"cpu",kernelFunc:Kce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vg(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Zce={kernelName:gN,backendName:"cpu",kernelFunc:vg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wg(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Cn(r,e[0].shape)[0],o=e.map(S=>S.shape);jA(o,i);let a=uu(e.map(S=>S.shape),i);if(Oe(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(S=>Oe(S.shape)>0);if(l.length===1)return mu({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const S=l.map(C=>Gf({inputs:{input:C},backend:t})),x=l.map(C=>vg({inputs:{input:C},backend:t})),w=wg({inputs:S,backend:t,attrs:{axis:i}}),_=wg({inputs:x,backend:t,attrs:{axis:i}}),T=Mo({inputs:{real:w,imag:_},backend:t});return S.forEach(C=>t.disposeIntermediateTensorInfo(C)),x.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),T}const u=l.map(S=>{const w=[-1,Oe(S.shape.slice(i))];return ds({inputs:{x:S},backend:t,attrs:{shape:w}})}),c=u.map(S=>({vals:t.data.get(S.dataId).values,shape:S.shape}));a=uu(u.map(S=>S.shape),1);const h=u[0].shape[0]===1,f=M4(c,a,e[0].dtype,h),p=uu(l.map(S=>S.shape),i),g=t.makeTensorInfo(p,e[0].dtype,f);return u.forEach(S=>t.disposeIntermediateTensorInfo(S)),g}const Jce={kernelName:Eb,backendName:"cpu",kernelFunc:wg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s;Dt([r,i],"conv2d");const h=Sc(l),f=$r(r.shape,i.shape,o,u,a,c,!1,h),p=f.filterHeight,g=f.filterWidth,S=f.dilationHeight,x=f.dilationWidth,w=f.padInfo.left,_=f.padInfo.top,T=f.dataFormat==="channelsLast",C=new wr(f.outShape,r.dtype),N=Wt(r.shape),M=Wt(i.shape),P=N[0],$=T?N[1]:N[2],R=T?N[2]:1,D=T?1:N[1],L=C.strides[0],G=T?C.strides[1]:C.strides[2],Q=T?C.strides[2]:1,W=T?1:C.strides[1],H=t.data.get(r.dataId).values,J=t.data.get(i.dataId).values,ie=C.values;for(let V=0;V<f.batchSize;++V){const Y=V*P,B=V*L;for(let K=0;K<f.outHeight;++K){const se=B+K*G,te=K*f.strideHeight-_;for(let ue=0;ue<p;++ue){const fe=te+ue*S;if(fe<0||fe>=f.inHeight)continue;const _e=ue*M[0],Ie=Y+fe*$;for(let Ve=0;Ve<f.outWidth;++Ve){const qe=se+Ve*Q,Ye=Ve*f.strideWidth-w;for(let et=0;et<g;++et){const ae=Ye+et*x;if(ae<0||ae>=f.inWidth)continue;const Be=_e+et*M[1],De=Ie+ae*R;let He=Be;for(let Re=0;Re<f.inChannels;++Re){const at=H[De+Re*D];for(let Qe=0;Qe<f.outChannels;++Qe)ie[qe+Qe*W]+=at*J[He+Qe];He+=f.outChannels}}}}}}return t.makeTensorInfo(C.shape,C.dtype,ie)}const Qce={kernelName:Ib,backendName:"cpu",kernelFunc:EV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ehe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;Dt([r,i],"conv2dBackpropFilter");const h=Sc(l),f=$r(r.shape,c,o,1,a,u,!1,h),{strideHeight:p,strideWidth:g,filterHeight:S,filterWidth:x}=f,w=f.dataFormat==="channelsLast",_=new wr(f.filterShape,"float32"),T=f.padInfo.left,C=f.padInfo.top,N=t.data.get(r.dataId).values,M=t.data.get(i.dataId).values,P=new wr(r.shape,r.dtype,N),$=new wr(i.shape,i.dtype,M);for(let R=0;R<S;++R){const D=Math.max(0,Math.ceil((C-R)/p)),L=Math.min(f.outHeight,(f.inHeight+C-R)/p);for(let G=0;G<x;++G){const Q=Math.max(0,Math.ceil((T-G)/g)),W=Math.min(f.outWidth,(f.inWidth+T-G)/g);for(let H=0;H<f.inChannels;++H)for(let J=0;J<f.outChannels;++J){let ie=0;for(let V=0;V<f.batchSize;++V)for(let Y=D;Y<L;++Y){const B=R+Y*p-C;for(let K=Q;K<W;++K){const se=G+K*g-T;w?ie+=P.get(V,B,se,H)*$.get(V,Y,K,J):ie+=P.get(V,H,B,se)*$.get(V,J,Y,K)}}_.set(ie,R,G,H,J)}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const the={kernelName:QI,backendName:"cpu",kernelFunc:ehe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nhe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s;Dt([r,i],"conv2dBackpropInput");const h=Wt(i.shape),f=Wt(r.shape);let p=Sc(u);const g=$r(o,i.shape,a,1,l,c,!1,p),S=new wr(g.inShape,"float32"),x=S.values,w=t.data.get(r.dataId).values,_=t.data.get(i.dataId).values,[T,C,N]=h,{batchSize:M,filterHeight:P,filterWidth:$,inChannels:R,inHeight:D,inWidth:L,outChannels:G,outHeight:Q,outWidth:W,strideHeight:H,strideWidth:J}=g;p=g.dataFormat;const ie=P-1-g.padInfo.top,V=$-1-g.padInfo.left,Y=p==="channelsLast",B=S.strides[0],K=Y?S.strides[1]:S.strides[2],se=Y?S.strides[2]:1,te=Y?1:S.strides[1],ue=f[0],fe=Y?f[1]:f[2],_e=Y?f[2]:1,Ie=Y?1:f[1];for(let Ve=0;Ve<M;++Ve)for(let qe=0;qe<R;++qe)for(let Ye=0;Ye<D;++Ye){const et=Ye-ie,ae=Math.max(0,Math.ceil(et/H)),Be=Math.min(Q,(P+et)/H);for(let De=0;De<L;++De){const He=De-V,Re=Math.max(0,Math.ceil(He/J)),at=Math.min(W,($+He)/J);let Qe=0;for(let X=ae;X<Be;++X){const Se=X*H-et;for(let We=Re;We<at;++We){const Xe=We*J-He,je=ue*Ve+fe*X+_e*We,xt=T*(P-1-Se)+C*($-1-Xe)+N*qe;for(let it=0;it<G;++it){const dt=w[je+Ie*it],It=_[xt+it];Qe+=dt*It}}}const ee=B*Ve+K*Ye+se*De+te*qe;x[ee]=Qe}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const she={kernelName:Nb,backendName:"cpu",kernelFunc:nhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s;Dt([r,i],"conv3d");const u=nd(r.shape,i.shape,o,l,a),{filterDepth:c,filterHeight:h,filterWidth:f,dilationDepth:p,dilationHeight:g,dilationWidth:S,padInfo:x}=u,w=x.front,_=x.left,T=x.top,C=new wr(u.outShape,r.dtype),N=t.data.get(r.dataId).values,M=t.data.get(i.dataId).values,P=C.values,$=Wt(r.shape),R=Wt(i.shape);for(let D=0;D<u.batchSize;++D){const L=D*$[0],G=D*C.strides[0];for(let Q=0;Q<u.outDepth;++Q){const W=G+Q*C.strides[1],H=Q*u.strideDepth-w;for(let J=0;J<c;++J){const ie=H+J*p;if(ie<0||ie>=u.inDepth)continue;const V=J*R[0],Y=L+ie*$[1];for(let B=0;B<u.outHeight;++B){const K=W+B*C.strides[2],se=B*u.strideHeight-T;for(let te=0;te<h;++te){const ue=se+te*g;if(ue<0||ue>=u.inHeight)continue;const fe=V+te*R[1],_e=Y+ue*$[2];for(let Ie=0;Ie<u.outWidth;++Ie){const Ve=K+Ie*u.outChannels,qe=Ie*u.strideWidth-_;for(let Ye=0;Ye<f;++Ye){const et=qe+Ye*S;if(et<0||et>=u.inWidth)continue;const ae=fe+Ye*R[2],Be=_e+et*u.inChannels;let De=ae;for(let He=0;He<u.inChannels;++He){const Re=N[Be+He];for(let at=0;at<u.outChannels;++at)P[Ve+at]+=Re*M[De+at];De+=u.outChannels}}}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const ihe={kernelName:Ab,backendName:"cpu",kernelFunc:rhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ohe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s;Dt([r,i],"conv3dBackpropFilterV2");const u=Wt(r.shape),c=Wt(i.shape),h=nd(r.shape,l,o,1,a),f=h.strideDepth,p=h.strideHeight,g=h.strideWidth,S=h.filterDepth,x=h.filterHeight,w=h.filterWidth,_=new wr(h.filterShape,"float32"),T=_.values,[C,N,M,P]=_.strides,$=t.data.get(i.dataId).values,[R,D,L,G]=c,Q=t.data.get(r.dataId).values,[W,H,J,ie]=u,V=h.padInfo.front,Y=h.padInfo.left,B=h.padInfo.top;for(let K=0;K<S;++K){const se=Math.max(0,Math.ceil((V-K)/f)),te=Math.min(h.outDepth,(h.inDepth+V-K)/f),ue=K*C;for(let fe=0;fe<x;++fe){const _e=Math.max(0,Math.ceil((B-fe)/p)),Ie=Math.min(h.outHeight,(h.inHeight+B-fe)/p),Ve=fe*N+ue;for(let qe=0;qe<w;++qe){const Ye=Math.max(0,Math.ceil((Y-qe)/g)),et=Math.min(h.outWidth,(h.inWidth+Y-qe)/g),ae=qe*M+Ve;for(let Be=0;Be<h.inChannels;++Be){const De=Be*P+ae;for(let He=0;He<h.outChannels;++He){let Re=0;for(let at=0;at<h.batchSize;++at){const Qe=at*W,ee=at*R;for(let X=se;X<te;++X){const We=(K+X*f-V)*H+Qe,Xe=X*D+ee;for(let je=_e;je<Ie;++je){const it=(fe+je*p-B)*J+We,dt=je*L+Xe;for(let It=Ye;It<et;++It){const Ke=(qe+It*g-Y)*ie+it,hn=It*G+dt;Re+=Q[Ke+Be]*$[hn+He]}}}}T[De+He]=Re}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const ahe={kernelName:eN,backendName:"cpu",kernelFunc:ohe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lhe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s;Dt([r],"conv3dBackpropInputV2");const u=Wt(r.shape),c=Wt(i.shape),h=nd(l,i.shape,a,1,o),f=new wr(h.inShape,"float32"),p=f.values,[g,S,x,w]=f.strides,_=t.data.get(r.dataId).values,[T,C,N,M]=u,P=t.data.get(i.dataId).values,[$,R,D,L]=c,{batchSize:G,filterDepth:Q,filterHeight:W,filterWidth:H,inChannels:J,inDepth:ie,inHeight:V,inWidth:Y,outChannels:B,outDepth:K,outHeight:se,outWidth:te,strideDepth:ue,strideHeight:fe,strideWidth:_e}=h,Ie=Q-1-h.padInfo.front,Ve=W-1-h.padInfo.top,qe=H-1-h.padInfo.left;for(let Ye=0;Ye<G;++Ye)for(let et=0;et<J;++et)for(let ae=0;ae<ie;++ae){const Be=ae-Ie,De=Math.max(0,Math.ceil(Be/ue)),He=Math.min(K,(Q+Be)/ue);for(let Re=0;Re<V;++Re){const at=Re-Ve,Qe=Math.max(0,Math.ceil(at/fe)),ee=Math.min(se,(W+at)/fe);for(let X=0;X<Y;++X){const Se=X-qe,We=Math.max(0,Math.ceil(Se/_e)),Xe=Math.min(te,(H+Se)/_e);let je=0;for(let xt=De;xt<He;++xt){const it=xt*ue-Be;for(let dt=Qe;dt<ee;++dt){const It=dt*fe-at;for(let Yt=We;Yt<Xe;++Yt){const Ke=Yt*_e-Se,hn=T*Ye+C*xt+N*dt+M*Yt,un=$*(Q-1-it)+R*(W-1-It)+D*(H-1-Ke)+L*et;for(let qt=0;qt<B;++qt){const Bt=_[hn+qt],yt=P[un+qt];je+=Bt*yt}}}}p[g*Ye+S*ae+x*Re+w*X+et]=je}}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const uhe={kernelName:tN,backendName:"cpu",kernelFunc:lhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const che=qn(_x,n=>Math.cos(n)),hhe={kernelName:_x,backendName:"cpu",kernelFunc:che};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dhe=qn(Tx,n=>Math.cosh(n)),fhe={kernelName:Tx,backendName:"cpu",kernelFunc:dhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function phe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,[c,h,f,p]=r.shape,g=i.shape[0],[S,x]=a,w=yn([g,S,x,p],"float32"),_=t.data.get(i.dataId).values,T=t.data.get(o.dataId).values,C=t.data.get(r.dataId).values,N=Wt(r.shape),M=Wt(w.shape);for(let P=0;P<g;P++){const $=P*4,R=_[$],D=_[$+1],L=_[$+2],G=_[$+3],Q=T[P];if(Q>=c)continue;const W=S>1?(L-R)*(h-1)/(S-1):0,H=x>1?(G-D)*(f-1)/(x-1):0;for(let J=0;J<S;J++){const ie=S>1?R*(h-1)+J*W:.5*(R+L)*(h-1);if(ie<0||ie>h-1){for(let V=0;V<x;V++)for(let Y=0;Y<p;Y++){const B=Y+V*M[2]+J*M[1]+P*M[0];w.values[B]=u}continue}if(l==="bilinear"){const V=Math.floor(ie),Y=Math.ceil(ie),B=ie-V;for(let K=0;K<x;K++){const se=x>1?D*(f-1)+K*H:.5*(D+G)*(f-1);if(se<0||se>f-1){for(let _e=0;_e<p;_e++){const Ie=_e+K*M[2]+J*M[1]+P*M[0];w.values[Ie]=u}continue}const te=Math.floor(se),ue=Math.ceil(se),fe=se-te;for(let _e=0;_e<p;_e++){let Ie=_e+te*N[2]+V*N[1]+Q*N[0];const Ve=C[Ie];Ie=_e+ue*N[2]+V*N[1]+Q*N[0];const qe=C[Ie];Ie=_e+te*N[2]+Y*N[1]+Q*N[0];const Ye=C[Ie];Ie=_e+ue*N[2]+Y*N[1]+Q*N[0];const et=C[Ie],ae=Ve+(qe-Ve)*fe,Be=Ye+(et-Ye)*fe;Ie=_e+K*M[2]+J*M[1]+P*M[0],w.values[Ie]=ae+(Be-ae)*B}}}else for(let V=0;V<x;++V){const Y=x>1?D*(f-1)+V*H:.5*(D+G)*(f-1);if(Y<0||Y>f-1){for(let se=0;se<p;se++){const te=se+V*M[2]+J*M[1]+P*M[0];w.values[te]=u}continue}const B=Math.round(Y),K=Math.round(ie);for(let se=0;se<p;se++){const te=se+B*N[2]+K*N[1]+Q*N[0],ue=se+V*M[2]+J*M[1]+P*M[0];w.values[ue]=C[te]}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const mhe={kernelName:sN,backendName:"cpu",kernelFunc:phe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ghe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;Dt(r,"cumprod");const l=ks([i],r.shape.length);let u=r;l!=null&&(u=io({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=Xs(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Lo(u.dtype,"int32"),f=GI(Oe(u.shape),h),p=t.data.get(u.dataId).values,g=u.shape[u.shape.length-1],S=a?(w,_)=>w+g-_-1:(w,_)=>w+_;for(let w=0;w<p.length;w+=g)for(let _=0;_<g;_++){const T=S(w,_);if(_===0)f[T]=o?1:p[T];else{const C=S(w,_-1);f[T]=o?p[C]*f[C]:p[T]*f[C]}}const x=t.makeTensorInfo(u.shape,h,f);if(l!=null){const w=sd(l),_=io({inputs:{x},backend:t,attrs:{perm:w}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(u),_}return x}const yhe={kernelName:nN,backendName:"cpu",kernelFunc:ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;Dt(r,"cumsum");const l=ks([i],r.shape.length);let u=r;l!=null&&(u=io({inputs:{x:r},backend:t,attrs:{perm:l}}));const c=Xs(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Lo(u.dtype,"int32"),f=gi(Oe(u.shape),h),p=t.data.get(u.dataId).values,g=u.shape[u.shape.length-1],S=a?(w,_)=>w+g-_-1:(w,_)=>w+_;for(let w=0;w<p.length;w+=g)for(let _=0;_<g;_++){const T=S(w,_);if(_===0)f[T]=o?0:p[T];else{const C=S(w,_-1);f[T]=o?p[C]+f[C]:p[T]+f[C]}}const x=t.makeTensorInfo(u.shape,h,f);if(l!=null){const w=sd(l),_=io({inputs:{x},backend:t,attrs:{perm:w}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(u),_}return x}const vhe={kernelName:Mb,backendName:"cpu",kernelFunc:xhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,c=LM(l,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(i),c=I4(l,u,o,a);return t.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const She={kernelName:rN,backendName:"cpu",kernelFunc:whe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s;q(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*i,f=u*i,p=c/(i*i),g=t.data.get(r.dataId).values,S=new Float32Array(a*h*f*p);let x=0;for(let w=0;w<a;++w)for(let _=0;_<h;++_){const T=Math.floor(_/i),C=_%i;for(let N=0;N<f;++N){const M=Math.floor(N/i),P=N%i,$=(C*i+P)*p;for(let R=0;R<p;++R){const L=R+$+c*(M+u*(T+l*w));S[x++]=g[L]}}}return t.makeTensorInfo([a,h,f,p],r.dtype,S)}const _he={kernelName:iN,backendName:"cpu",kernelFunc:bhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;Dt([r,i],"depthwiseConv2DNative");const c=Wt(r.shape),h=Wt(i.shape);let f=l;f==null&&(f=[1,1]),q(Zr(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const p=$r(r.shape,i.shape,o,f,a,u,!0),{filterHeight:g,filterWidth:S,dilationHeight:x,dilationWidth:w,padInfo:_}=p,T=_.left,C=_.top,N=p.outChannels/p.inChannels,M=new wr(p.outShape,r.dtype),P=t.data.get(r.dataId).values,$=t.data.get(i.dataId).values,R=M.values;for(let D=0;D<p.batchSize;++D){const L=D*c[0],G=D*M.strides[0];for(let Q=0;Q<p.outHeight;++Q){const W=G+Q*M.strides[1],H=Q*p.strideHeight-C;for(let J=0;J<g;++J){const ie=H+J*x;if(ie<0||ie>=p.inHeight)continue;const V=J*h[0],Y=L+ie*c[1];for(let B=0;B<p.outWidth;++B){const K=W+B*M.strides[2],se=B*p.strideWidth-T;for(let te=0;te<S;++te){const ue=se+te*w;if(ue<0||ue>=p.inWidth)continue;const fe=V+te*h[1],_e=Y+ue*p.inChannels;let Ie=K,Ve=fe;for(let qe=0;qe<p.inChannels;++qe){const Ye=P[_e+qe];for(let et=0;et<N;++et)R[Ie+et]+=Ye*$[Ve+et];Ie+=N,Ve+=N}}}}}}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const The={kernelName:kb,backendName:"cpu",kernelFunc:IV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Che(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s;Dt([r,i],"depthwiseConv2dNativeBackpropFilter");const h=$r(r.shape,c,o,a,l,u,!0),{strideHeight:f,strideWidth:p,filterHeight:g,filterWidth:S}=h,x=new wr(h.filterShape,"float32"),w=h.padInfo.left,_=h.padInfo.top,T=h.outChannels/h.inChannels,C=t.data.get(r.dataId).values,N=new wr(r.shape,r.dtype,C),M=t.data.get(i.dataId).values,P=new wr(i.shape,i.dtype,M);for(let $=0;$<g;++$){const R=Math.max(0,Math.ceil((_-$)/f)),D=Math.min(h.outHeight,(h.inHeight+_-$)/f);for(let L=0;L<S;++L){const G=Math.max(0,Math.ceil((w-L)/p)),Q=Math.min(h.outWidth,(h.inWidth+w-L)/p);for(let W=0;W<h.outChannels;++W){const H=Math.trunc(W/T),J=W%T;let ie=0;for(let V=0;V<h.batchSize;++V)for(let Y=R;Y<D;++Y){const B=$+Y*f-_;for(let K=G;K<Q;++K){const se=L+K*p-w;ie+=N.get(V,B,se,H)*P.get(V,Y,K,W)}}x.set(ie,$,L,H,J)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const Ehe={kernelName:oN,backendName:"cpu",kernelFunc:Che};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ihe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s;Dt([r,i],"depthwiseConv2DNativeBackpropInput");const h=Wt(r.shape),f=Wt(i.shape),p=$r(c,i.shape,o,a,l,u,!0),g=new wr(p.inShape,"float32"),S=g.values,[x,w,_]=g.strides,T=t.data.get(r.dataId).values,[C,N,M]=h,P=t.data.get(i.dataId).values,[$,R,D]=f,{batchSize:L,filterHeight:G,filterWidth:Q,inChannels:W,inHeight:H,inWidth:J,outChannels:ie,outHeight:V,outWidth:Y,strideHeight:B,strideWidth:K}=p,se=G-1-p.padInfo.top,te=Q-1-p.padInfo.left,ue=ie/W;for(let fe=0;fe<L;++fe)for(let _e=0;_e<W;++_e)for(let Ie=0;Ie<H;++Ie){const Ve=Ie-se,qe=Math.max(0,Math.ceil(Ve/B)),Ye=Math.min(V,(G+Ve)/B);for(let et=0;et<J;++et){const ae=et-te,Be=Math.max(0,Math.ceil(ae/K)),De=Math.min(Y,(Q+ae)/K);let He=0;for(let Re=qe;Re<Ye;++Re){const at=Re*B-Ve;for(let Qe=Be;Qe<De;++Qe){const ee=Qe*K-ae,X=C*fe+N*Re+M*Qe,Se=$*(G-1-at)+R*(Q-1-ee)+D*_e;for(let We=0;We<ue;++We){const Xe=_e*ue+We,je=T[X+Xe],xt=P[Se+We];He+=je*xt}}}S[x*fe+w*Ie+_*et+_e]=He}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const Nhe={kernelName:aN,backendName:"cpu",kernelFunc:Ihe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ahe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=Oe(s.shape),i=t.data.get(s.dataId).values,o=yn([r,r],s.dtype),a=o.values;for(let u=0;u<i.length;u++)a[u*r+u]=i[u];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const Mhe={kernelName:lN,backendName:"cpu",kernelFunc:Ahe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const khe={kernelName:Rb,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:a}=t,l=e,u=l.data.get(s.dataId).values,c=s.shape.length,h=l.data.get(r.dataId).values,f=r.shape.length,{batchSize:p,inHeight:g,inWidth:S,inChannels:x,outHeight:w,outWidth:_,padInfo:T,strideHeight:C,strideWidth:N,filterHeight:M,filterWidth:P,dilationHeight:$,dilationWidth:R,outShape:D}=uv(s.shape,r.shape,i,o,"NHWC",a),L=Oe(D),G=D.length,Q=Gs(s.dtype,L);for(let H=0;H<p;++H)for(let J=0;J<w;++J){const ie=J*C-T.top;for(let V=0;V<_;++V){const Y=V*N-T.left;for(let B=0;B<x;++B){let K=Number.MIN_SAFE_INTEGER;for(let te=0;te<M;++te){const ue=ie+te*$;if(ue>=0&&ue<g)for(let fe=0;fe<P;++fe){const _e=Y+fe*R;if(_e>=0&&_e<S){const Ie=lu([H,ue,_e,B],c,Wt(s.shape)),Ve=lu([te,fe,B],f,Wt(r.shape)),qe=u[Ie]+h[Ve];qe>K&&(K=qe)}}}const se=lu([H,J,V,B],G,Wt(D));Q[se]=K}}}return{dataId:l.write(Kf(Q,s.dtype),D,s.dtype),shape:D,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rhe={kernelName:s2,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=t,u=e,c=Ra(s.shape,u.data.get(s.dataId).values),h=Ra(r.shape,u.data.get(r.dataId).values),{batchSize:f,inHeight:p,inWidth:g,inChannels:S,outHeight:x,outWidth:w,padInfo:_,strideHeight:T,strideWidth:C,filterHeight:N,filterWidth:M,dilationHeight:P,dilationWidth:$,outShape:R}=uv(s.shape,r.shape,o,a,"NHWC",l);q(i.rank===R.length,()=>`Error in ${s2}, dy must have the same rank as output ${R.length}, but got ${i.rank}`);const D=Ra(R,u.data.get(i.dataId).values),L=CF(r.shape,r.dtype);for(let Q=0;Q<f;++Q)for(let W=0;W<x;++W){const H=W*T-_.top;for(let J=0;J<w;++J){const ie=J*C-_.left;for(let V=0;V<S;++V){let Y=Number.MIN_SAFE_INTEGER,B=0,K=0;for(let se=0;se<N;++se){const te=H+se*P;if(te>=0&&te<p)for(let ue=0;ue<M;++ue){const fe=ie+ue*$;if(fe>=0&&fe<g){const _e=c[Q][te][fe][V]+h[se][ue][V];_e>Y&&(Y=_e,B=se,K=ue)}}}L[B][K][V]+=D[Q][W][J][V]}}}return{dataId:u.write(Kf(L,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dhe={kernelName:n2,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:a,dilations:l}=t,u=e,c=Ra(s.shape,u.data.get(s.dataId).values),h=Ra(r.shape,u.data.get(r.dataId).values),{batchSize:f,inHeight:p,inWidth:g,inChannels:S,outHeight:x,outWidth:w,padInfo:_,strideHeight:T,strideWidth:C,filterHeight:N,filterWidth:M,dilationHeight:P,dilationWidth:$,outShape:R}=uv(s.shape,r.shape,o,a,"NHWC",l);q(i.rank===R.length,()=>`Error in ${n2}, dy must have the same rank as output ${R.length}, but got ${i.rank}`);const D=Ra(R,u.data.get(i.dataId).values),L=CF(s.shape,s.dtype);for(let Q=0;Q<f;++Q)for(let W=0;W<x;++W){const H=W*T-_.top;for(let J=0;J<w;++J){const ie=J*C-_.left;for(let V=0;V<S;++V){let Y=Number.MIN_SAFE_INTEGER,B=H<0?0:H,K=ie<0?0:ie;for(let se=0;se<N;++se){const te=H+se*P;if(te>=0&&te<p)for(let ue=0;ue<M;++ue){const fe=ie+ue*$;if(fe>=0&&fe<g){const _e=c[Q][te][fe][V]+h[se][ue][V];_e>Y&&(Y=_e,B=te,K=fe)}}}L[Q][B][K][V]+=D[Q][W][J][V]}}}return{dataId:u.write(Kf(L,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Phe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:o}=s,{contextOptions:a,imageOptions:l}=o||{},u=(l==null?void 0:l.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[f,p]=r.shape.slice(0,2),g=r.shape.length===2?1:r.shape[2],S=t.data.get(r.dataId).values,x=r.dtype==="float32"?255:1,w=new Uint8ClampedArray(p*f*4);for(let T=0;T<f*p;++T){const C=[0,0,0,255*u];for(let M=0;M<g;M++){const P=S[T*g+M];if(r.dtype==="float32"){if(P<0||P>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${P}.`)}else if(r.dtype==="int32"&&(P<0||P>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${P}.`);g===1?(C[0]=P*x,C[1]=P*x,C[2]=P*x):C[M]=P*x}const N=T*4;w[N+0]=Math.round(C[0]),w[N+1]=Math.round(C[1]),w[N+2]=Math.round(C[2]),w[N+3]=Math.round(C[3])}i.width=p,i.height=f;const _=new ImageData(w,p,f);return h.putImageData(_,0,0),r}const Lhe={kernelName:q7,backendName:"cpu",kernelFunc:Phe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Dt(r,"sum");let a;r.dtype==="bool"?a=Gh({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):a=mu({inputs:{x:r},backend:t});const l=a.shape.length,u=Cn(i,a.shape),c=ks(u,l);let h=u,f=a;c!=null&&(f=io({inputs:{x:a},backend:t,attrs:{perm:c}}),h=Xs(h.length,l)),Jr("sum",h,f.shape.length);const[p,g]=zr(f.shape,h),S=Lo(f.dtype,"int32");let x=DS(t,p,S);const w=Oe(g),_=t.data.get(x.dataId).values,T=t.data.get(f.dataId).values;for(let C=0;C<_.length;++C){const N=C*w;let M=0;for(let P=0;P<w;++P)M+=T[N+P];_[C]=M}if(o){const C=js(x.shape,u),N=x;x=ds({inputs:{x},backend:t,attrs:{shape:C}}),t.disposeIntermediateTensorInfo(N)}return t.disposeIntermediateTensorInfo(a),c!=null&&t.disposeIntermediateTensorInfo(f),x}const Ohe={kernelName:h_,backendName:"cpu",kernelFunc:Iv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fhe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=rM(r,i.length);oM(o.length,l,i);const{path:u,steps:c}=aM(a,l),h=c.length;let f=null,p=o.length;const g=[];for(let S=0;S<h;++S){for(const x of c[S]){const{permutationIndices:w,expandDims:_}=iM(p,l[x]);let T;lM(w)?T=i[x]:(T=io({inputs:{x:i[x]},backend:t,attrs:{perm:w}}),g.push(T));const C=T.shape.slice();for(let N=0;N<_.length;++N)C.splice(_[N],0,1);Mn(T.shape,C)||(T=ds({inputs:{x:T},backend:t,attrs:{shape:C}}),g.push(T)),f===null?f=T:(f=sT({inputs:{a:T,b:f},backend:t}),g.push(f))}S<h-1&&(u[S]>=0&&(f=Iv({inputs:{x:f},backend:t,attrs:{axis:u[S]-(o.length-p),keepDims:!1}}),g.push(f)),p--)}for(const S of g)S!==f&&t.disposeIntermediateTensorInfo(S);return f}const $he={kernelName:uN,backendName:"cpu",kernelFunc:Fhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zhe(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;Dt([s,r],"eluGrad");const i=new Float32Array(Oe(r.shape)),o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];u>=0?i[l]=a[l]:i[l]=a[l]*(u+1)}return t.makeTensorInfo(r.shape,"float32",i)}const Uhe={kernelName:cN,backendName:"cpu",kernelFunc:zhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bhe=ZA,Vhe=JA,Whe=QA,Ghe=eM,Hhe=tM,jhe=nM,Xhe=qn(Ix,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Bhe*t);return e*(1-((((jhe*s+Hhe)*s+Ghe)*s+Whe)*s+Vhe)*s*Math.exp(-t*t))}),qhe={kernelName:Ix,backendName:"cpu",kernelFunc:Xhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(q(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),ds({inputs:{x:r},backend:t,attrs:{shape:a}})}const Khe={kernelName:Pb,backendName:"cpu",kernelFunc:OS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yhe=Ks((n,e)=>n/e),BM=Tr(Cx,Yhe),G2={kernelName:Cx,backendName:"cpu",kernelFunc:BM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NV(n,e,t){const s=n.shape,r=s[0],i=s[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,i],c=Oe(u),h=Yr("float32",c),f=Yr("float32",c);for(let x=0;x<r;x++){const w=Hf({inputs:{x:a},backend:t,attrs:{begin:[x,0],size:[1,i]}}),_=Hf({inputs:{x:l},backend:t,attrs:{begin:[x,0],size:[1,i]}}),T=Mo({inputs:{real:w,imag:_},backend:t}),{real:C,imag:N}=Zhe(T,e,t),M=gc(C,N);for(let P=0;P<i;P++){const $=sM(M,P);h[x*i+P]=$.real,f[x*i+P]=$.imag}t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(T)}const p=t.makeTensorInfo(u,"float32",h),g=t.makeTensorInfo(u,"float32",f),S=Mo({inputs:{real:p,imag:g},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),S}function Zhe(n,e,t){const s=Oe(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(Jhe(s)){const a=H2(i,o,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",a.real),c=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Qh(s,"float32")),f=mu({inputs:{x:h},backend:t}),p=G2.kernelFunc({inputs:{a:u,b:h},backend:t}),g=G2.kernelFunc({inputs:{a:c,b:f},backend:t}),S=t.data.get(p.dataId).values,x=t.data.get(g.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),{real:S,imag:x}}return a}else{const a=gc(i,o),l=Qhe(a,s,e);return zz(l)}}function Jhe(n){return(n&n-1)===0}function H2(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=gc(n,e),o=t/2,a=Uz(i),l=a.real,u=a.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),f=r.makeTensorInfo(c,"float32",u),p=Mo({inputs:{real:h,imag:f},backend:r}),g=Bz(i),S=g.real,x=g.imag,w=[S.length],_=r.makeTensorInfo(w,"float32",S),T=r.makeTensorInfo(w,"float32",x),C=Mo({inputs:{real:_,imag:T},backend:r}),N=H2(l,u,o,s,r),M=N.real,P=N.imag,$=[M.length],R=r.makeTensorInfo($,"float32",M),D=r.makeTensorInfo($,"float32",P),L=Mo({inputs:{real:R,imag:D},backend:r}),G=H2(S,x,o,s,r),Q=G.real,W=G.imag,H=[Q.length],J=r.makeTensorInfo(H,"float32",Q),ie=r.makeTensorInfo(H,"float32",W),V=Mo({inputs:{real:J,imag:ie},backend:r}),Y=Wz(t,s),B=[Y.real.length],K=r.makeTensorInfo(B,"float32",Y.real),se=r.makeTensorInfo(B,"float32",Y.imag),te=Mo({inputs:{real:K,imag:se},backend:r}),ue=sT({inputs:{a:te,b:V},backend:r}),fe=xg({inputs:{a:L,b:ue},backend:r}),_e=zM({inputs:{a:L,b:ue},backend:r}),Ie=Gf({inputs:{input:fe},backend:r}),Ve=Gf({inputs:{input:_e},backend:r}),qe=vg({inputs:{input:fe},backend:r}),Ye=vg({inputs:{input:_e},backend:r}),et=wg({inputs:[Ie,Ve],backend:r,attrs:{axis:0}}),ae=wg({inputs:[qe,Ye],backend:r,attrs:{axis:0}}),Be=r.data.get(et.dataId).values,De=r.data.get(ae.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(ue),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(_e),r.disposeIntermediateTensorInfo(Ie),r.disposeIntermediateTensorInfo(qe),r.disposeIntermediateTensorInfo(Ve),r.disposeIntermediateTensorInfo(Ye),r.disposeIntermediateTensorInfo(et),r.disposeIntermediateTensorInfo(ae),{real:Be,imag:De}}function Qhe(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,o=0;for(let a=0;a<e;a++){const l=Gz(r*a,e,t),u=sM(n,a);i+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}t&&(i/=e,o/=e),Vz(s,i,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ede(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Oe(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=ds({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),l=NV(a,!1,t),u=ds({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const tde={kernelName:hN,backendName:"cpu",kernelFunc:ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VM(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,o=i||Rg(r),a=Gs(o,Oe(s));return sde(a,r,o),e.makeTensorInfo(s,o,a)}const nde={kernelName:dN,backendName:"cpu",kernelFunc:VM};function sde(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rde={kernelName:fN,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=Yr(s.dtype,Oe(s.shape)),[o,a,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let f=0;f<o;f++){const p=f*l*a*u;for(let g=0;g<a;g++){const S=g*(l*u);for(let x=0;x<l;x++){const w=x*u;for(let _=0;_<u;_++){const T=Math.round(l-x-1),C=p+S+w+_;let N=c[C];if(T>=0&&T<l){const M=T*u,P=p+S+M+_;N=c[P]}i[C]=N}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=s;let S=EV({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f}});if(o){const x=S;if(c==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const w=ds({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});S=xg({inputs:{a:S,b:w},backend:t}),t.disposeIntermediateTensorInfo(w)}else S=xg({inputs:{a:S,b:o},backend:t});t.disposeIntermediateTensorInfo(x)}if(p){const x=S;if(c==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const w=ds({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});S=LS(t,S,p,w,g),t.disposeIntermediateTensorInfo(w)}else S=LS(t,S,p,a,g);t.disposeIntermediateTensorInfo(x)}return S}const ode={kernelName:mS,backendName:"cpu",kernelFunc:ide};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=s;let S=IV({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f}});if(o){const x=S;S=xg({inputs:{a:S,b:o},backend:t}),t.disposeIntermediateTensorInfo(x)}if(p){const x=S;S=LS(t,S,p,a,g),t.disposeIntermediateTensorInfo(x)}return S}const lde={kernelName:gS,backendName:"cpu",kernelFunc:ade};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ude(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=Oe(s.shape),o=r.shape,a=o[o.length-1],[l,u,c,h]=UA(s,r);if(u===0)return t.makeTensorInfo(l,s.dtype,[]);const f=t.data.get(r.dataId).values,p=t.bufferSync(s),g=$4(f,p,s.dtype,u,a,c,h,s.shape,i);return t.makeTensorInfo(l,s.dtype,g.values)}const cde={kernelName:pN,backendName:"cpu",kernelFunc:ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s;Dt([r,i],"gatherV2");const l=Cn(o,r.shape)[0],u=t.data.get(i.dataId).values,c=r.shape[l];for(let C=0;C<u.length;++C){const N=u[C];q(N<=c-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const f=Oe(i.shape),p=cM(r,i,l,h),g=ds({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),S=ds({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,f/p.batchSize]}}),x=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],w=t.bufferSync(S),_=t.bufferSync(g),T=z4(_,w,x);return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(S),t.makeTensorInfo(p.outputShape,T.dtype,T.values)}const dde={kernelName:Ob,backendName:"cpu",kernelFunc:hde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fde(n){const{inputs:e,backend:t}=n,{input:s}=e,r=Oe(s.shape),i=s.shape[s.shape.length-1],o=r/i,a=ds({inputs:{x:s},backend:t,attrs:{shape:[o,i]}}),l=NV(a,!0,t),u=ds({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const pde={kernelName:mN,backendName:"cpu",kernelFunc:fde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mde=qn(Px,n=>Number.isFinite(n)?1:0,"bool"),gde={kernelName:Px,backendName:"cpu",kernelFunc:mde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yde=qn(Lx,n=>Math.abs(n)===1/0?1:0,"bool"),xde={kernelName:Lx,backendName:"cpu",kernelFunc:yde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vde=qn(Ox,n=>Number.isNaN(n)?1:0,"bool"),wde={kernelName:Ox,backendName:"cpu",kernelFunc:vde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sde(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=G4(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const bde={kernelName:yN,backendName:"cpu",kernelFunc:Sde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _de=qn($x,n=>Math.log1p(n)),Tde={kernelName:$x,backendName:"cpu",kernelFunc:_de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cde=Ks((n,e)=>n&&e),Ede=Tr(Bb,Cde,null,"bool"),Ide={kernelName:Bb,backendName:"cpu",kernelFunc:Ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nde=qn(Vb,n=>n?0:1,"bool"),Ade={kernelName:Vb,backendName:"cpu",kernelFunc:Nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mde=Ks((n,e)=>n||e),kde=Tr(Wb,Mde,null,"bool"),Rde={kernelName:Wb,backendName:"cpu",kernelFunc:kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s;Dt(r,"LRN");const u=r.shape[3],c=u-1,h=t.data.get(r.dataId).values,f=Oe(r.shape),p=new Float32Array(f);function g(S){const x=S%u;let w=S-x+Math.max(0,x-i);const _=S-x+Math.min(x+i,c);let T=0;for(;w<=_;w++){const C=h[w];T+=C*C}return T}for(let S=0;S<f;S++){const x=g(S),w=h[S]*Math.pow(o+a*x,-l);p[S]=w}return t.makeTensorInfo(r.shape,r.dtype,p)}const Pde={kernelName:Gb,backendName:"cpu",kernelFunc:Dde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s;Dt(o,"LRNGrad");const h=Oe(o.shape),f=o.shape[3],p=t.data.get(o.dataId).values,g=t.data.get(r.dataId).values,S=t.data.get(i.dataId).values,x=new Float32Array(h),w=h;for(let _=0;_<w;_++){const T=_%f,C=_-T+Math.max(0,T-a),N=_-T+Math.min(f,T+a+1);let M=0;for(let P=C;P<N;P++)M+=Math.pow(g[P],2);M=u*M+l;for(let P=C;P<N;P++){let $=-2*u*c*g[P]*S[_]/M;_===P&&($+=Math.pow(M,-c)),$*=p[_],x[P]+=$}}return t.makeTensorInfo(o.shape,r.dtype,x)}const Ode={kernelName:xN,backendName:"cpu",kernelFunc:Lde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=t;let l=r.shape;const u=l.length,c=Cn(i,l);let h=c;const f=ks(h,u);let p=a.data.get(r.dataId).values;if(f!=null){const C=new Array(u);for(let N=0;N<C.length;N++)C[N]=l[f[N]];p=FM(p,l,r.dtype,f,C),h=Xs(h.length,u),l=C}Dt(r,"max"),Jr("max",h,u);const[g,S]=zr(l,h),x=Oe(S),w=j4(p,x,g,r.dtype),_=a.write(w,g,r.dtype);let T=g;return o&&(T=js(g,c)),{dataId:_,shape:T,dtype:r.dtype}}const Fde={kernelName:Hb,backendName:"cpu",kernelFunc:AV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $de(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Dt(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;q(Zr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Fa(r.shape,i,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&Mn(c.inShape,c.outShape))h=mu({inputs:{x:r},backend:t});else{const f=t.data.get(r.dataId).values,p=Wt(r.shape),g=UM(f,r.shape,r.dtype,p,c,"max");h=t.makeTensorInfo(c.outShape,r.dtype,g.values)}return h}const zde={kernelName:jb,backendName:"cpu",kernelFunc:$de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s;Dt(r,"maxPool3d");const c=wc(r.shape,i,o,1,a,l,u),h=t.data.get(r.dataId).values,f=CV(h,r.shape,r.dtype,Wt(r.shape),c,"max");return t.makeTensorInfo(f.shape,"float32",f.values)}const Bde={kernelName:Xb,backendName:"cpu",kernelFunc:Ude};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=s;Dt([r,i],"maxPool3DGrad");const c=wc(i.shape,o,a,1,l,u),h=t.bufferSync(i),f=Mce(h,c),p=c.strideDepth,g=c.strideHeight,S=c.strideWidth,x=c.dilationDepth,w=c.dilationHeight,_=c.dilationWidth,T=c.effectiveFilterDepth,C=c.effectiveFilterHeight,N=c.effectiveFilterWidth,M=T-1-c.padInfo.front,P=N-1-c.padInfo.left,$=C-1-c.padInfo.top,R=yn(i.shape,"float32"),D=t.bufferSync(r);for(let L=0;L<c.batchSize;++L)for(let G=0;G<c.inChannels;++G)for(let Q=0;Q<c.inDepth;++Q)for(let W=0;W<c.inHeight;++W)for(let H=0;H<c.inWidth;++H){const J=Q-M,ie=W-$,V=H-P;let Y=0;for(let B=0;B<T;B+=x){const K=(J+B)/p;if(!(K<0||K>=c.outDepth||Math.floor(K)!==K))for(let se=0;se<C;se+=w){const te=(ie+se)/g;if(!(te<0||te>=c.outHeight||Math.floor(te)!==te))for(let ue=0;ue<N;ue+=_){const fe=(V+ue)/S;if(fe<0||fe>=c.outWidth||Math.floor(fe)!==fe)continue;const _e=T*C*N-1-f.get(L,K,te,fe,G),Ie=B*C*N+se*N+ue,Ve=_e===Ie?1:0;if(Ve===0)continue;const qe=D.get(L,K,te,fe,G);Y+=qe*Ve}}}R.set(Y,L,Q,W,H,G)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const Wde={kernelName:wN,backendName:"cpu",kernelFunc:Vde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gde(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;Dt([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,f=Fa(a.shape,l,u,1,c,h),p=t.data.get(a.dataId).values,g=yn(f.outShape,a.dtype,TV(p,a.shape,a.dtype,f).values),S=f.strideHeight,x=f.strideWidth,w=f.dilationHeight,_=f.dilationWidth,T=f.effectiveFilterHeight,C=f.effectiveFilterWidth,N=C-1-f.padInfo.left,M=T-1-f.padInfo.top,P=yn(a.shape,"float32"),$=t.data.get(r.dataId).values,R=yn(r.shape,"float32",$);for(let D=0;D<f.batchSize;++D)for(let L=0;L<f.inChannels;++L)for(let G=0;G<f.inHeight;++G)for(let Q=0;Q<f.inWidth;++Q){const W=G-M,H=Q-N;let J=0;for(let ie=0;ie<T;ie+=w){const V=(W+ie)/S;if(!(V<0||V>=f.outHeight||Math.floor(V)!==V))for(let Y=0;Y<C;Y+=_){const B=(H+Y)/x;if(B<0||B>=f.outWidth||Math.floor(B)!==B)continue;const K=T*C-1-g.get(D,V,B,L),se=ie*C+Y,te=K===se?1:0;if(te===0)continue;const ue=R.get(D,V,B,L);J+=ue*te}}P.set(J,D,G,Q,L)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}const Hde={kernelName:vN,backendName:"cpu",kernelFunc:Gde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jde(n,e,t,s,r){const i=Wt(e),o=UM(n,e,t,i,r,"max"),a=TV(n,e,t,r,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xde={kernelName:SN,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;Dt(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Fa(s.shape,r,i,[1,1],o),[h,f]=jde(u,s.shape,s.dtype,a,c),p=l.write(h,c.outShape,s.dtype),g=l.write(f,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:g,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=Cn(i,r.shape),u=zr(r.shape,a)[1],c=Oe(u),h=[],f=t.makeTensorInfo([],"float32",new Float32Array([c]));h.push(f);const p=Gh({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});h.push(p);const g=BM({inputs:{a:p,b:f},backend:t});h.push(g);const S=Iv({inputs:{x:g},backend:t,attrs:{axis:i,keepDims:o}});return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),S}const Kde={kernelName:qb,backendName:"cpu",kernelFunc:qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;Dt(r,"min");const a=Cn(i,r.shape);let l=a;const u=ks(l,r.shape.length);let c=r;u!=null&&(c=io({inputs:{x:r},backend:t,attrs:{perm:u}}),l=Xs(l.length,r.shape.length)),Jr("min",l,c.shape.length);const[h,f]=zr(c.shape,l),p=Oe(f),g=gi(Oe(h),c.dtype),S=t.data.get(c.dataId).values;for(let w=0;w<g.length;++w){const _=w*p;let T=S[_];for(let C=0;C<p;++C){const N=S[_+C];(Number.isNaN(N)||N<T)&&(T=N)}g[w]=T}u!=null&&t.disposeIntermediateTensorInfo(c);const x=t.makeTensorInfo(h,c.dtype,g);if(o){const w=js(h,a),_=ds({inputs:{x},backend:t,attrs:{shape:w}});return t.disposeIntermediateTensorInfo(x),_}return x}const Zde={kernelName:Kb,backendName:"cpu",kernelFunc:Yde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:o}=s;Dt(r,"mirrorPad");const a=i.map((T,C)=>T[0]+r.shape[C]+T[1]),l=i.map(T=>T[0]),u=i.map((T,C)=>T[0]+r.shape[C]),c=o==="reflect"?0:1,h=t.data.get(r.dataId).values,f=r.shape.length,p=Wt(r.shape),g=Oe(a),S=a.length,x=Wt(a),w=Yr(r.dtype,g);for(let T=0;T<g;T++){let C=Dg(T,S,x);for(let M=0;M<S;M++)C[M]<l[M]?C[M]=l[M]*2-C[M]-c:C[M]>=u[M]&&(C[M]=(u[M]-1)*2-C[M]+c);C=C.map((M,P)=>M-l[P]);const N=lu(C,f,p);w[T]=h[N]}return{dataId:t.write(w,a,r.dtype),shape:a,dtype:r.dtype}}const Qde={kernelName:Yb,backendName:"cpu",kernelFunc:Jde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const efe=Ks(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),tfe=Tr(Bx,efe),nfe={kernelName:Bx,backendName:"cpu",kernelFunc:tfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MV(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=r.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Cn([a],r.shape),u=AV({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=js(u.shape,l),h=ds({inputs:{x:u},backend:t,attrs:{shape:c}}),f=zM({inputs:{a:r,b:h},backend:t}),p=P4({inputs:{x:f},backend:t}),g=Iv({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),S=ds({inputs:{x:g},backend:t,attrs:{shape:c}}),x=BM({inputs:{a:p,b:S},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(S),x}const sfe={kernelName:p_,backendName:"cpu",kernelFunc:MV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rfe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s;Dt(r,"multinomial");const l=a?r:MV({inputs:{logits:r},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=t.data.get(l.dataId).values,f=[u,i],p=gi(Oe(f),"int32");for(let g=0;g<u;++g){const S=g*c,x=new Float32Array(c-1);x[0]=h[S];for(let T=1;T<x.length;++T)x[T]=x[T-1]+h[S+T];const w=R_.alea(o.toString()),_=g*i;for(let T=0;T<i;++T){const C=w();p[_+T]=x.length;for(let N=0;N<x.length;N++)if(C<x[N]){p[_+T]=N;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(f,"int32",p)}const ife={kernelName:bN,backendName:"cpu",kernelFunc:rfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ofe=DA;function afe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;Dt(r,"NonMaxSuppression");const u=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,{selectedIndices:h}=ofe(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const lfe={kernelName:_N,backendName:"cpu",kernelFunc:afe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ufe=PA;function cfe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s;Dt(r,"NonMaxSuppressionPadded");const c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:f,validOutputs:p}=ufe(c,h,o,a,l,u);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const hfe={kernelName:TN,backendName:"cpu",kernelFunc:cfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dfe=LA;function ffe(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s;Dt(r,"NonMaxSuppressionWithScore");const c=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,f=o,p=a,g=l,S=u,{selectedIndices:x,selectedScores:w}=dfe(c,h,f,p,g,S);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const pfe={kernelName:CN,backendName:"cpu",kernelFunc:ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mfe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s;Dt(r,"oneHot");const u=Oe(r.shape),c=new Float32Array(u*o);c.fill(l);const h=t.data.get(r.dataId).values;for(let f=0;f<u;++f)h[f]>=0&&h[f]<o&&(c[f*o+h[f]]=a);return t.makeTensorInfo([...r.shape,o],i,c)}const gfe={kernelName:e_,backendName:"cpu",kernelFunc:mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Gf({inputs:{input:s},backend:t}),i=FS({inputs:{x:r},backend:t}),o=vg({inputs:{input:s},backend:t}),a=FS({inputs:{x:o},backend:t}),l=Mo({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return VM({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const yfe={kernelName:x_,backendName:"cpu",kernelFunc:FS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kV(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=Gf({inputs:{input:s},backend:t}),i=kV({inputs:{x:r},backend:t}),o=vg({inputs:{input:s},backend:t}),a=FS({inputs:{x:o},backend:t}),l=Mo({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return VM({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const xfe={kernelName:Qb,backendName:"cpu",kernelFunc:kV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RV(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return OS({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{Vo(i,c.shape,"All tensors passed to stack must have matching shapes"),q(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=OS({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=wg({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const vfe={kernelName:t_,backendName:"cpu",kernelFunc:RV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;Dt(r,"pad");const a=i.map((_,T)=>_[0]+r.shape[T]+_[1]),l=i.map(_=>_[0]),u=t.data.get(r.dataId).values,c=Oe(r.shape),h=r.shape.length,f=Wt(r.shape),p=Oe(a),g=a.length,S=Wt(a),x=Yr(r.dtype,p);o!==0&&x.fill(o);for(let _=0;_<c;_++){const C=Dg(_,h,f).map((M,P)=>M+l[P]),N=lu(C,g,S);x[N]=u[_]}return{dataId:t.write(x,a,r.dtype),shape:a,dtype:r.dtype}}const DV={kernelName:n_,backendName:"cpu",kernelFunc:wfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sfe=Ks((n,e)=>Math.pow(n,e)),bfe=Tr(Wx,Sfe),_fe={kernelName:Wx,backendName:"cpu",kernelFunc:bfe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,l=r.map(w=>t.data.get(w.dataId).values),u=r.map(w=>w.shape),c=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,[f,p,g]=J4(l,u,c,i.shape,i.dtype,h,o.shape),S=f.map(w=>t.makeTensorInfo([w.length],"int32",w)),x=t.makeTensorInfo(g,i.dtype,p);return S.concat([x])}const Cfe={kernelName:EN,backendName:"cpu",kernelFunc:Tfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Efe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[u,c]=Q4(o,s.shape,s.dtype,a,r.shape,l,i.shape),h=t.makeTensorInfo([u.length],"int32",u),f=t.makeTensorInfo([c.length],s.dtype,c);return[h,f]}const Ife={kernelName:IN,backendName:"cpu",kernelFunc:Efe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nfe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,f=a.map(x=>t.data.get(x.dataId).values),p=a.map(x=>x.shape),[g,S]=eV(u,r.shape,c,i.shape,i.dtype,h,o.shape,f,p,l);return t.makeTensorInfo(g,i.dtype,S)}const Afe={kernelName:NN,backendName:"cpu",kernelFunc:Nfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:o}=t,a=tV(s,r,o,i);return e.makeTensorInfo([a.length],i,a)}const kfe={kernelName:AN,backendName:"cpu",kernelFunc:Mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rfe=qn(Gx,n=>1/n),Dfe={kernelName:Gx,backendName:"cpu",kernelFunc:Rfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pfe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;Dt(r,"resizeBilinear");const l=Wt(r.shape),[u,c]=a,[h,f,p,g]=r.shape,S=t.data.get(r.dataId).values,x=new Float32Array(Oe([h,u,c,g])),w=[i&&u>1?f-1:f,i&&c>1?p-1:p],_=[i&&u>1?u-1:u,i&&c>1?c-1:c];let T=0;const C=w[0]/_[0],N=w[1]/_[1];for(let M=0;M<h;M++)for(let P=0;P<u;P++){let $;o?$=C*(P+.5)-.5:$=C*P;const R=Math.max(0,Math.floor($)),D=$-R,L=Math.min(f-1,Math.ceil($)),G=M*l[0]+R*l[1],Q=M*l[0]+L*l[1];for(let W=0;W<c;W++){let H;o?H=N*(W+.5)-.5:H=N*W;const J=Math.max(0,Math.floor(H)),ie=H-J,V=Math.min(p-1,Math.ceil(H)),Y=G+J*l[2],B=Q+J*l[2],K=G+V*l[2],se=Q+V*l[2];for(let te=0;te<g;te++){const ue=S[Y+te],fe=S[B+te],_e=S[K+te],Ie=S[se+te],Ve=ue+(_e-ue)*ie,qe=fe+(Ie-fe)*ie,Ye=Ve+(qe-Ve)*D;x[T++]=Ye}}}return t.makeTensorInfo([h,u,c,g],"float32",x)}const Lfe={kernelName:a_,backendName:"cpu",kernelFunc:Pfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ofe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;Dt([i,r],"resizeBilinearGrad");const a=Wt(r.shape),[l,u,c,h]=r.shape,[,f,p]=i.shape,g=new Float32Array(l*u*c*h),S=[o&&f>1?u-1:u,o&&p>1?c-1:c],x=[o&&f>1?f-1:f,o&&p>1?p-1:p],w=S[0]/x[0],_=S[1]/x[1],T=t.data.get(i.dataId).values;let C=0;for(let N=0;N<l;N++){const M=N*a[0];for(let P=0;P<f;P++){const $=P*w,R=Math.floor($),D=Math.min(Math.ceil($),u-1),L=M+R*a[1],G=M+D*a[1],Q=$-R,W=1-Q;for(let H=0;H<p;H++){const J=H*_,ie=Math.floor(J),V=Math.min(Math.ceil(J),c-1),Y=J-ie,B=1-Y,K=L+ie*a[2],se=L+V*a[2],te=G+ie*a[2],ue=G+V*a[2],fe=W*B,_e=W*Y,Ie=Q*B,Ve=Q*Y;for(let qe=0;qe<h;qe++){const Ye=T[C++];g[K+qe]+=Ye*fe,g[se+qe]+=Ye*_e,g[te+qe]+=Ye*Ie,g[ue+qe]+=Ye*Ve}}}}return t.makeTensorInfo([l,c,u,h],"float32",g)}const Ffe={kernelName:RN,backendName:"cpu",kernelFunc:Ofe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $fe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s;Dt(r,"resizeNearestNeighbor");const l=Wt(r.shape),[u,c]=a,[h,f,p,g]=r.shape,S=t.data.get(r.dataId).values,x=new Float32Array(h*u*c*g),w=[i&&u>1?f-1:f,i&&c>1?p-1:p],_=[i&&u>1?u-1:u,i&&c>1?c-1:c],T=w[0]/_[0],C=w[1]/_[1];let N=0;for(let M=0;M<h;M++){const P=M*l[0];for(let $=0;$<u;$++){const R=o?T*($+.5):T*$;let D=Math.min(f-1,i?Math.round(R):Math.floor(R));o&&(D=Math.max(0,D));const L=P+D*l[1];for(let G=0;G<c;G++){const Q=o?C*(G+.5):C*G;let W=Math.min(p-1,i?Math.round(Q):Math.floor(Q));o&&(W=Math.max(0,W));const H=L+W*l[2];for(let J=0;J<g;J++){const ie=S[H+J];x[N++]=ie}}}}return t.makeTensorInfo([h,u,c,g],r.dtype,x)}const zfe={kernelName:o_,backendName:"cpu",kernelFunc:$fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ufe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s;Dt([i,r],"resizeNearestNeighborGrad");const a=Wt(r.shape),l=Wt(i.shape),[u,c,h,f]=r.shape,[,p,g]=i.shape,S=new Float32Array(u*c*h*f),x=t.data.get(i.dataId).values,w=[o&&p>1?c-1:c,o&&g>1?h-1:h],_=[o&&p>1?p-1:p,o&&g>1?g-1:g],T=w[0]/_[0],C=w[1]/_[1],N=1/T,M=1/C,P=Math.ceil(N)*2+2,$=Math.ceil(M)*2+2;for(let R=0;R<u;R++){const D=R*a[0];for(let L=0;L<c;L++){const G=D+L*a[1],Q=Math.floor(L*N),W=Math.floor(Q-P/2);for(let H=0;H<h;H++){const J=G+H*a[2],ie=Math.floor(H*M),V=Math.floor(ie-$/2);for(let Y=0;Y<f;Y++){let B=0;for(let K=0;K<P;K++){const se=K+W;if(se<0||se>=p)continue;const te=D+se*l[1],ue=se*T,fe=Math.min(c-1,o?Math.round(ue):Math.floor(ue));if(L===fe)for(let _e=0;_e<$;_e++){const Ie=_e+V;if(Ie<0||Ie>=g)continue;const Ve=te+Ie*l[2],qe=Ie*C,Ye=Math.min(h-1,o?Math.round(qe):Math.floor(qe));H===Ye&&(B+=x[Ve+Y])}}S[J+Y]=B}}}}return t.makeTensorInfo(r.shape,r.dtype,S)}const Bfe={kernelName:kN,backendName:"cpu",kernelFunc:Ufe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;Dt(r,"reverse");const o=r.shape.length,a=Cn(i,r.shape);if(o===0)return mu({inputs:{x:r},backend:t});const l=new wr(r.shape,r.dtype),u=t.bufferSync(r);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),f=h.slice();a.forEach(p=>f[p]=r.shape[p]-1-f[p]),l.set(u.get(...f),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Wfe={kernelName:l_,backendName:"cpu",kernelFunc:Vfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe={kernelName:KN,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,l=Yr(s.dtype,Oe(s.shape)),[u,c,h,f]=s.shape,[p,g]=qA(o,c,h),S=255,x=Math.sin(r),w=Math.cos(r),_=a.data.get(s.dataId).values;for(let C=0;C<u;C++){const N=C*h*c*f;for(let M=0;M<c;M++){const P=M*(h*f);for(let $=0;$<h;$++){const R=$*f;for(let D=0;D<f;D++){const L=[u,M,$,D],G=L[2],Q=L[1];let W=(G-p)*w-(Q-g)*x,H=(G-p)*x+(Q-g)*w;W=Math.round(W+p),H=Math.round(H+g);let J=i;if(typeof i!="number"&&(D===3?J=S:J=i[D]),W>=0&&W<h&&H>=0&&H<c){const V=H*(h*f),Y=W*f,B=N+V+Y+D;J=_[B]}const ie=N+P+R+D;l[ie]=J}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hfe=qn(Xx,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),jfe={kernelName:Xx,backendName:"cpu",kernelFunc:Hfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xfe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Jf(i,r,o),f=!0,p=t.bufferSync(r),g=t.bufferSync(i),S=Sf(p,g,o,h,u,l,a,c,0,f);return t.makeTensorInfo(o,S.dtype,S.values)}const qfe={kernelName:DN,backendName:"cpu",kernelFunc:Xfe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function Yfe(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function Zfe(n,e,t,s,r,i){const o=Gs("int32",t*r);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),u=a*r;for(let c=0;c<r;++c)o[u+c]=i==="left"?Kfe(l,e[c+u]):Yfe(l,e[c+u])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jfe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,u=Zfe(a,l,r.shape[0],r.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",u)}const Qfe={kernelName:LN,backendName:"cpu",kernelFunc:Jfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function epe(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;Dt([s,r,i],"select");const o=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,c=Lo(r.dtype,i.dtype),h=gi(Oe(r.shape),c);let f=0;const p=o===0||o>1||r.shape.length===1?1:Oe(r.shape.slice(1));for(let g=0;g<a.length;g++)for(let S=0;S<p;S++)a[g]===1?h[f++]=l[g]:h[f++]=u[g];return t.makeTensorInfo(r.shape,c,h)}const tpe={kernelName:u_,backendName:"cpu",kernelFunc:epe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const npe=G_,spe=H_,rpe=qn(Kx,n=>n>=0?spe*n:npe*(Math.exp(n)-1)),ipe={kernelName:Kx,backendName:"cpu",kernelFunc:rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ope=qn(Jx,n=>n<0?-1:n>0?1:0),ape={kernelName:Jx,backendName:"cpu",kernelFunc:ope};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lpe=qn(Yx,n=>Math.sin(n)),upe={kernelName:Yx,backendName:"cpu",kernelFunc:lpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cpe=qn(Zx,n=>Math.sinh(n)),hpe={kernelName:Zx,backendName:"cpu",kernelFunc:cpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dpe=11920928955078125e-23,nL=Math.log(dpe)+2,fpe=qn(ev,n=>{const e=n>-nL,t=n<nL,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),ppe={kernelName:ev,backendName:"cpu",kernelFunc:fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;Dt([r],"spaceToBatchND");const a=Oe(i),l=[[0,0]];l.push(...o);for(let M=1+i.length;M<r.shape.length;++M)l.push([0,0]);const u=DV.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),c=gv(u.shape,i,a,!1),h=yv(c.length,i.length,!1),f=xv(u.shape,i,a,!1),S=ds({inputs:{x:u},backend:t,attrs:{shape:c}}),_=io({inputs:{x:S},backend:t,attrs:{perm:h}}),N=ds({inputs:{x:_},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(_),N}const gpe={kernelName:d_,backendName:"cpu",kernelFunc:mpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ype(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,c=t.data.get(o.dataId).values[0],[h,f,p,g,S]=iV(a,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(f,s.dtype,h),t.makeTensorInfo([f[0]],r.dtype,p),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(x=>Number(x)))),t.makeTensorInfo([S.length],s.dtype,new Int32Array(S))]}const xpe={kernelName:ON,backendName:"cpu",kernelFunc:ype};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vpe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(r.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(i.dataId).values),[u,c,h]=oV(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const wpe={kernelName:FN,backendName:"cpu",kernelFunc:vpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Spe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[u,c]=$M(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const bpe={kernelName:$N,backendName:"cpu",kernelFunc:Spe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _pe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[u,c]=$M(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(c,s.dtype,u)}const Tpe={kernelName:zN,backendName:"cpu",kernelFunc:_pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cpe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:f}=Jf(i,r,a),p=!1,g=t.bufferSync(r);let S;switch(i.dtype){case"bool":{const x=t.bufferSync(i),w=!!t.data.get(o.dataId).values[0];S=Sf(g,x,a,f,c,u,l,h,w,p);break}case"float32":{const x=t.bufferSync(i),w=t.data.get(o.dataId).values[0];S=Sf(g,x,a,f,c,u,l,h,w,p);break}case"int32":{const x=t.bufferSync(i),w=t.data.get(o.dataId).values[0];S=Sf(g,x,a,f,c,u,l,h,w,p);break}case"string":{const x=t.bufferSync(i),w=Ph(t.data.get(o.dataId).values[0]);S=Sf(g,x,a,f,c,u,l,h,w,p);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,S.dtype,S.values)}const Epe={kernelName:UN,backendName:"cpu",kernelFunc:Cpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ipe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Cn(o,r.shape)[0],l=uM(r,i,a),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(h=>{const f=[...c];f[a]=h;const p=Hf({inputs:{x:r},backend:t,attrs:{begin:u,size:f}});return u[a]+=h,p})}const Npe={kernelName:f_,backendName:"cpu",kernelFunc:Ipe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ape={kernelName:BN,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Dt(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];i[a]=l*l}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mpe=qn(av,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),kpe={kernelName:av,backendName:"cpu",kernelFunc:Mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:f}=s;Dt(r,"stridedSlice");const{finalShapeSparse:p,finalShape:g,isIdentity:S,sliceDim0:x,isSimpleSlice:w,begin:_,end:T,strides:C}=HA(r.shape,i,o,a,l,u,c,h,f);let N;if(S)N=ds({inputs:{x:r},backend:t,attrs:{shape:g}});else if(x||w){q(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const M=VA(_,T,C),P=Hf({inputs:{x:r},backend:t,attrs:{begin:_,size:M}});N=ds({inputs:{x:P},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(P)}else{const M=t.bufferSync(r),P=uV(p,M,C,_);N=t.makeTensorInfo(g,P.dtype,P.values)}return N}const Dpe={kernelName:VN,backendName:"cpu",kernelFunc:Rpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ppe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,f=t.data.get(c.dataId).values,p=t.data.get(h.dataId).values,[g,S]=cV(f,p,r,i,o,a,l,u);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(h.shape,"int32",S)]}const Lpe={kernelName:WN,backendName:"cpu",kernelFunc:Ppe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ope(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values[0],[u,c,h]=hV(a,l,r),f=c.length;return[t.makeTensorInfo([f,2],"int32",u),t.makeTensorInfo([f],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const Fpe={kernelName:GN,backendName:"cpu",kernelFunc:Ope};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $pe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=dV(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const zpe={kernelName:HN,backendName:"cpu",kernelFunc:$pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Upe=qn(rv,n=>Math.tan(n)),Bpe={kernelName:rv,backendName:"cpu",kernelFunc:Upe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpe=qn(iv,n=>Math.tanh(n)),Wpe={kernelName:iv,backendName:"cpu",kernelFunc:Vpe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gpe(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=Jf(i,r,s.shape),h=!1,f=t.bufferSync(r),p=t.bufferSync(i),g=t.bufferSync(s),S=Sf(f,p,s.shape,c,l,a,o,u,g,h);return t.makeTensorInfo(s.shape,S.dtype,S.values)}const Hpe={kernelName:PN,backendName:"cpu",kernelFunc:Gpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;Dt(r,"tile");const o=pV(t.bufferSync(r),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const Xpe={kernelName:ov,backendName:"cpu",kernelFunc:jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s;Dt(r,"topk");const a=t.data.get(r.dataId).values,[l,u]=gV(a,r.shape,r.dtype,i,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const Kpe={kernelName:jN,backendName:"cpu",kernelFunc:qpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ype(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=t,[c,h,f,p]=r.shape,[g,S]=u??[h,f],x=[c,g,S,p],w=Wt(r.shape),_=w[0],T=w[1],C=w[2],N=Wt(x),M=N[0],P=N[1],$=N[2],R=Yr(r.dtype,Oe(x));R.fill(l);const D=s.data.get(r.dataId).values,L=s.data.get(i.dataId).values;for(let Q=0;Q<c;++Q){const W=i.shape[0]===1?L:L.subarray(Q*8,Q*8+8);for(let H=0;H<g;++H)for(let J=0;J<S;++J)for(let ie=0;ie<p;++ie){let V;const Y=W[6]*J+W[7]*H+1;if(Y===0)continue;const B=(W[0]*J+W[1]*H+W[2])/Y,K=(W[3]*J+W[4]*H+W[5])/Y,se=sL(B,f,a),te=sL(K,h,a);switch(o){case"nearest":V=nme(D,h,f,_,T,C,Q,te,se,ie,l);break;case"bilinear":V=sme(D,h,f,_,T,C,Q,te,se,ie,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ue=Q*M+H*P+J*$+ie;R[ue]=V}return s.makeTensorInfo(x,r.dtype,R)}return{dataId:s.write(R,x,r.dtype),shape:r.shape,dtype:r.dtype}}const Zpe={kernelName:XN,backendName:"cpu",kernelFunc:Ype};function sL(n,e,t){switch(t){case"reflect":return Jpe(n,e);case"wrap":return Qpe(n,e);case"nearest":return tme(n,e);case"constant":default:return eme(n)}}function Jpe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Df(0,t,e-1)}function Qpe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Df(0,t,e-1)}function eme(n,e){return n}function tme(n,e){return Df(0,n,e-1)}function o0(n,e,t,s,r,i,o,a,l,u,c){const h=o*s+a*r+l*i+u;return 0<=a&&a<e&&0<=l&&l<t?n[h]:c}function nme(n,e,t,s,r,i,o,a,l,u,c){const h=Math.round(a),f=Math.round(l);return o0(n,e,t,s,r,i,o,h,f,u,c)}function sme(n,e,t,s,r,i,o,a,l,u,c){const h=Math.floor(a),f=Math.floor(l),p=h+1,g=f+1,S=(g-l)*o0(n,e,t,s,r,i,o,h,f,u,c)+(l-f)*o0(n,e,t,s,r,i,o,h,g,u,c),x=(g-l)*o0(n,e,t,s,r,i,o,p,f,u,c)+(l-f)*o0(n,e,t,s,r,i,o,p,g,u,c);return(p-a)*S+(a-h)*x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rme(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Dt(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:u}=yV(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const ime={kernelName:qN,backendName:"cpu",kernelFunc:rme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ome(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,a=r.shape[i],l=new Array(o-1);let u=0;for(let p=0;p<o;p++)p!==i&&(l[u++]=r.shape[p]);const c=new Array(o).fill(0),h=r.shape.slice();h[i]=1;const f=new Array(a);for(let p=0;p<f.length;p++){c[i]=p;const g=Hf({inputs:{x:r},backend:t,attrs:{begin:c,size:h}});f[p]=ds({inputs:{x:g},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(g)}return f}const ame={kernelName:g_,backendName:"cpu",kernelFunc:ome};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s;Dt(r,"unsortedSegmentSum");const a=r.shape.length,l=i.shape.length,u=[],c=[],h=a-l;let f=i;for(let g=0;g<h;++g){const S=OS({inputs:{input:f},backend:t,attrs:{dim:g+1}});f=S,c.push(S)}for(let g=0;g<o;++g){const S=Qh(g,"int32"),x=t.makeTensorInfo([],"int32",S),w=R4({inputs:{a:x,b:f},backend:t}),_=Gh({inputs:{x:w},backend:t,attrs:{dtype:"float32"}}),T=sT({inputs:{a:_,b:r},backend:t}),C=Iv({inputs:{x:T},backend:t,attrs:{axis:0,keepDims:!1}});u.push(C),c.push(x),c.push(w),c.push(_),c.push(T),c.push(C)}const p=RV({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const ume={kernelName:y_,backendName:"cpu",kernelFunc:lme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cme=[rce,$le,oce,lce,Gle,cce,dce,pce,gce,xce,wce,bce,Tce,Ice,Ace,Rce,Pce,Oce,$ce,nce,Uce,Vce,Gce,jle,jce,Vle,qle,qce,zle,Yce,Jce,Qce,the,she,ihe,ahe,uhe,hhe,fhe,mhe,yhe,vhe,She,_he,The,Ehe,Nhe,Mhe,khe,Rhe,Dhe,Lhe,$he,Kue,Uhe,Kle,qhe,Yle,Khe,Jle,tde,nde,rde,eue,nue,ode,lde,cde,dde,rue,oue,Ule,pde,Zce,gde,xde,wde,Yue,lue,cue,bde,due,Tde,Ide,Ade,Rde,Pde,Ode,Fde,pue,zde,Bde,Wde,Hde,Xde,Kde,Zde,gue,Qde,nfe,ife,xue,wue,lfe,hfe,pfe,bue,gfe,xfe,vfe,DV,_fe,Jue,Cue,Cfe,Ife,Afe,kfe,Ble,G2,Dfe,Que,ece,tce,Lfe,Ffe,zfe,Bfe,Wfe,Gfe,jfe,Due,qfe,Qfe,tpe,ipe,Lue,ape,upe,hpe,Oue,sfe,ppe,gpe,xpe,wpe,bpe,Tpe,Epe,Npe,zue,Ape,Bue,Wue,kpe,Dpe,Lpe,Fpe,zpe,Xue,Ohe,Bpe,Wpe,Hpe,Xpe,Kpe,Zpe,_ue,ime,ame,ume,yfe];for(const n of cme)NF(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pf={},Aw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function hme(n,e){pf[n]=e}function Nl(n,e){if(!(n in pf)||e!=null){const s=fme(n,e);if(s!==null)pf[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=pf[n];return t==null||t.isContextLost()?(delete pf[n],Nl(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),pf[n])}function dme(n){if(!Te().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function fme(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??dme(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete pf[n]},!1),Te().getBool("SOFTWARE_WEBGL_ENABLED")&&(Aw.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Aw)||t.getContext("experimental-webgl",Aw):t.getContext("webgl2",Aw)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var X0;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(X0||(X0={}));var ia;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(ia||(ia={}));var qr;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(qr||(qr={}));function Nv(n,e){return[e,n]}function pme(n,e){return n*e}function Mw(n){const e=Oe(n),t=Math.ceil(e/4);return JE(t)}function Bg(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function mme(n,e){const[t,s]=Bg(n,e);return t*s*4}function WM(n,e){const t=n;let s,r,i,o,a,l,u,c,h,f;return Te().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,u=4,c=1,h=t.HALF_FLOAT,f=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,f=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function St(n,e){const t=e();return Te().getBool("DEBUG")&&gme(n),t}function gme(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+wme(n,e))}const yme=596e-10,xme=65504;function vme(n){return!!(Te().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||yme<Math.abs(n)&&Math.abs(n)<xme)}function wme(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function kw(n,e){return Tc(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Sme(n,e){const t=Tc(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(St(n,()=>n.shaderSource(t,e)),St(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function bme(n,e){const t=Tc(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(St(n,()=>n.shaderSource(t,e)),St(n,()=>n.compileShader(t)),Te().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw PV(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const _me=/ERROR: [0-9]+:([0-9]+):/g;function PV(n,e){const t=_me.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((h,f)=>Ym((f+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,s-1),u=o.slice(s-1,s),c=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Ym(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function Tme(n){return Tc(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Cme(n,e){if(St(n,()=>n.linkProgram(e)),!Te().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function tE(n,e){if(St(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Eme(n,e){const t=Tc(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return St(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),St(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Ime(n,e){const t=Tc(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return St(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),St(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Nme(n){return Tc(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Ame(n,e){const t=Te().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Mme(n){return Tc(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function rL(n,e,t,s,r,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(St(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),St(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,i,o)),St(n,()=>n.enableVertexAttribArray(a)),!0)}function kme(n,e,t){Ome(n,t),St(n,()=>n.activeTexture(n.TEXTURE0+t)),St(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Rme(n,e,t){return Tc(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Dme(n,e,t){return n.getUniformLocation(e,t)}function Pme(n,e,t,s){St(n,()=>kme(n,e,s)),St(n,()=>n.uniform1i(t,s))}function nE(n,e,t){St(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),St(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function iL(n,e){St(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),St(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Rw(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Lme(n,e))}function Lme(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Tc(n,e,t){const s=St(n,()=>e());if(s==null)throw new Error(t);return s}function Ome(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Sg(n,e=2){return Oe(n.slice(0,n.length-e))}function bg(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Dw(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Sg(n),...bg(n)]),e}function Fme(n,e=!1){let t=Te().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=Te().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&Te().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?WI(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Jh(n).newShape);let r=Oe(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=Sg(n);let l=2,u=2;n.length&&([l,u]=bg(n)),r=a*(l/2)*(u/2),i=JE(r).map(c=>c*2)}else i=JE(r);return i}function Pw(n){return n%2===0}function $S(n,e){if(n=n.slice(-2),e=e.slice(-2),Mn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Pw(t)&&Pw(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Pw(n[0])&&Pw(e[0])}let sE,rE;function $me(n){if(sE==null){const e=Nl(n);sE=e.getParameter(e.MAX_TEXTURE_SIZE)}return sE}function zme(n){if(rE==null){const e=Nl(n);rE=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,rE)}function Ume(n){if(n===0)return 0;let e;const t=Nl(n);return ka(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:ka(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function ka(n,e){return n.getExtension(e)!=null}function oL(n){try{if(Nl(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Bme(n){if(n===0)return!1;const e=Nl(n);if(n===1){if(!ka(e,"OES_texture_float"))return!1}else if(!ka(e,"EXT_color_buffer_float"))return!1;return j2(e)}function Vme(n){if(n===0)return!1;const e=Nl(n);if(n===1){if(!ka(e,"OES_texture_float")||!ka(e,"WEBGL_color_buffer_float"))return!1}else{if(ka(e,"EXT_color_buffer_float"))return j2(e);const s="EXT_color_buffer_half_float";if(ka(e,s)){const r=e.getExtension(s);return Wme(e,r)}return!1}return j2(e)}function j2(n){const e=WM(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function Wme(n,e){const t=WM(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function Gme(n){return n!==2?!1:Nl(n).fenceSync!=null}function Av(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&q(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lt=Te();Lt.registerFlag("HAS_WEBGL",()=>Lt.getNumber("WEBGL_VERSION")>0);Lt.registerFlag("WEBGL_VERSION",()=>oL(2)?2:oL(1)?1:0);Lt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Lt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Lt.get("WEBGL_VERSION")===2);Lt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Lt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Lt.registerFlag("WEBGL_PACK",()=>Lt.getBool("HAS_WEBGL"));Lt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_CLIP",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_REDUCE",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_CONV_IM2COL",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Lt.getBool("WEBGL_PACK"));Lt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>$me(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>zme(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Lt.getNumber("WEBGL_VERSION");return n===0?0:Ume(n)});Lt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Lt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!BF());Lt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Bme(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Lt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Lt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Lt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Vme(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Gme(Lt.getNumber("WEBGL_VERSION")));Lt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Lt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Lt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Lt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>BF()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Lt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Lt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Lt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Lt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Lt.registerFlag("WEBGL_EXP_CONV",()=>!1);Lt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Lt.getBool("IS_TEST"));Lt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Lt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Lt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Lt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ui(){let n,e,t,s,r,i,o,a,l,u;return Te().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=Te().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tp(n,e,t="index"){const s=Wt(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / ${r}`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${a};`}).join("")}function rT(n,e,t="index"){const s=Wt(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function Hme(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function jme(n,e,t="index"){const s=n.map((i,o)=>o),r=Hme(s,e);return r.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${r[o]}`,l=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function GM(n){const e=Wt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function HM(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const LV=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:OV}=use;function Xme(n,e,t){const s=[];if(n.forEach(p=>{const g=Oe(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${g>1?`[${g}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:S}=jM(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(S.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(p=>qme(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Ui(),l=Zme(a);let u,c,h=ege(a);return e.isPacked?(u=Kme(e.logicalShape,o,t.enableShapeUniforms),c=Qme(a)):(u=Yme(e.logicalShape,o,t.enableShapeUniforms),c=Jme(a)),t.packedInputs&&(h+=rge),[h,l,c,r,u,i,t.userCode].join(`
`)}function Vg(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return gge(n,e);case 1:return xge(n,e);case 2:return wge(n,e);case 3:return bge(n,e);case 4:return Tge(n,e);case 5:return Cge(n);case 6:return Ege(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function FV(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return mge(n);case 1:return yge(n,e);case 2:return vge(n,e);case 3:return Sge(n,e);default:return _ge(n,e)}}function qme(n,e,t=!1,s){let r="";t?r+=FV(n,s):r+=Vg(n,s);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?r+=Ige(n,e):r+=Nge(n,e)),r}function Kme(n,e,t){switch(n.length){case 0:return $V();case 1:return ige(n,e,t);case 2:return fge(n,e,t);case 3:return age(n,e,t);default:return uge(n,e,t)}}function Yme(n,e,t){switch(n.length){case 0:return $V();case 1:return oge(n,e,t);case 2:return pge(n,e,t);case 3:return lge(n,e,t);case 4:return cge(n,e,t);case 5:return hge(n,e);case 6:return dge(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Zme(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Jme(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Qme(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function ege(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${tge}
    ${nge}
    ${sge}
  `}const tge=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,nge=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,sge=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,rge=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function $V(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ige(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function oge(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function age(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function lge(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${rT(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=tp(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function uge(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)o*=n[n.length-u-1],a=`
      int b${u} = index / ${o};
      index -= b${u} * ${o};
    `+a,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function cge(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${rT(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=tp(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function hge(n,e){const t=tp(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function dge(n,e){const t=tp(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function fge(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Mn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function pge(n,e,t){return Mn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function np(n){return`offset${n}`}function mge(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ui();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function gge(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=np(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function yge(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Ui();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function xge(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Wg(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=np(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function vge(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Ui();if(i!=null&&Mn(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function wge(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Mn(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const f=i[0],p=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=Jh(t),l=o;if(l.length<t.length){const f=Gg(n,l),p=["row","col"];return`
      ${Vg(f,e)}
      float ${r}(int row, int col) {
        return ${r}(${Hg(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Wg(n)}
      }
    `;const u=i[0],c=i[1],h=np(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${s}, uv);
    }
  `:u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function Sge(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const f=t.slice(1),p=[1,2],g=Gg(n,f),S=["b","row","col"];return`
        ${FV(g,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Hg(S,p)});
        }
      `}const a=Ui();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],u=o[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function bge(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Jh(t),u=a;if(u.length<t.length){const S=Gg(n,u),x=["row","col","depth"];return`
        ${Vg(S,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Hg(x,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Wg(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],f=c[1],p=n.shapeInfo.flatOffset;if(f===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(f===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const g=np(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${g};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${s}, uv);
      }
  `}function _ge(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ui();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],h=Math.ceil(i[o-1]/2);let f=h*Math.ceil(i[o-2]/2),p="int b, int row, int col",g=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let S=2;S<o-1;S++)p=`int b${S}, `+p,f*=i[o-S-1],g=`b${S} * ${f} + `+g;return`
    vec4 ${s}(${p}) {
      int index = ${g};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${r.texture2D}(${t}, uv);
    }
  `}function Tge(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:u}=Jh(t);if(l.length<t.length){const _=Gg(n,l),T=["row","col","depth","depth2"];return`
      ${Vg(_,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Hg(T,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Wg(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1],g=`int stride2 = ${s}Shape[3];`,S=`int stride1 = ${s}Shape[2] * stride2;`,x=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${g}
        ${S}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===i&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${s}, uv);
      }
    `;const w=np(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${S}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${w});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${f}, ${p}, index + ${w});
      return sampleTexture(${s}, uv);
    }
  `}function Cge(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:u}=Jh(e);if(l.length<e.length){const S=Gg(n,l),x=["row","col","depth","depth2","depth3"];return`
      ${Vg(S)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Hg(x,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Wg(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=np(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${g};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Ege(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Jh(e);if(r.length<e.length){const x=Gg(n,r),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${Vg(x)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Hg(w,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Wg(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,p=f[0],g=f[1];if(g===c&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===o&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const S=np(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${S};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Wg(n){const e=n.name,t=Oe(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Ige(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=OV(n.shapeInfo.logicalShape,e.logicalShape),l=es(o),u=o-i;let c;const h=["x","y","z","w","u","v"];i===0?c="":o<2&&a.length>=1?c="coords = 0;":c=a.map(_=>`coords.${h[_+u]} = 0;`).join(`
`);let f="";o<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((_,T)=>`coords.${h[T+u]}`).join(", ");let p="return outputValue;";const S=Oe(n.shapeInfo.logicalShape)===1,w=Oe(e.logicalShape)===1;if(i===1&&!S&&!w)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(S&&!w)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const _=i-2,T=i-1;a.indexOf(_)>-1&&a.indexOf(T)>-1?p="return vec4(outputValue.x);":a.indexOf(_)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(T)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${f});
      ${p}
    }
  `}function Nge(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Mn(o,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=es(l),c=OV(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let f;const p=["x","y","z","w","u","v"];a===0?f="":l<2&&c.length>=1?f="coords = 0;":f=c.map(S=>`coords.${p[S+h]} = 0;`).join(`
`);let g="";return l<2&&a>0?g="coords":g=n.shapeInfo.logicalShape.map((S,x)=>`coords.${p[x+h]}`).join(", "),`
    float ${r}() {
      ${u} coords = getOutputCoords();
      ${f}
      return get${s}(${g});
    }
  `}function es(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function jM(n,e,t){const{newShape:s,keptDims:r}=Jh(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):s,l=!n&&i>1&&!Mn(e,t)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function Gg(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Hg(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Age(n,e,t,s){const r=t.map((c,h)=>{const f={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(f.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:f}}),i=r.map(c=>c.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=Xme(r,o,e),l=bme(n.gl,a),u=n.createProgram(l);return Te().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},zV(n,e,u)))}function zV(n,e,t){const s=[],r=[];let i,o,a,l=null,u=null;u=n.getUniformLocation(t,"NAN",!1),Te().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const f={name:h,uniform:n.getUniformLocation(t,h,c),offset:n.getUniformLocation(t,`offset${h}`,c)};e.enableShapeUniforms&&(f.shape=n.getUniformLocation(t,`${h}Shape`,c),f.texShape=n.getUniformLocation(t,`${h}TexShape`,c)),s.push(f)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",c),a=n.getUniformLocation(t,"outShapeStrides",c),o=n.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)r.push(n.getUniformLocation(t,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function aL(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],o=i.shape;if(!Mn(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!Mn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Mge(n,e,t,s,r){e.program.enableShapeUniforms||(aL(e.inShapeInfos,t),aL([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),Te().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:h,shape:f,texShape:p}=e.variablesLocations[l];if(f){const{uniformShape:g}=jM(e.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(f,new Int32Array(g));break;case 2:n.gl.uniform2iv(f,new Int32Array(g));break;case 3:n.gl.uniform3iv(f,new Int32Array(g));break;case 4:n.gl.uniform4iv(f,new Int32Array(g));break}}if(p&&n.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Oe(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(c,g)}continue}u.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=Wt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=r[l];if(u.type==="float")n.gl.uniform1fv(c,h);else if(u.type==="vec2")n.gl.uniform2fv(c,h);else if(u.type==="vec3")n.gl.uniform3fv(c,h);else if(u.type==="vec4")n.gl.uniform4fv(c,h);else if(u.type==="int")n.gl.uniform1iv(c,h);else if(u.type==="ivec2")n.gl.uniform2iv(c,h);else if(u.type==="ivec3")n.gl.uniform3iv(c,h);else if(u.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function kge(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=jM(n.packedInputs,o.shape,l);let f="",p="",g="";if(c.length===1&&n.packedInputs){const N=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${N[0]>1}_${N[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const N=Wt(c);g=`${N[0]===l[1]}_${N[N.length-1]===l[1]}`}const S=o.shape.length,x=c.length===2&&Mn(o.shape,l),w=Oe(o.shape)===1,_=pg(o.shape,t.shape),T=!n.packedInputs&&S===t.shape.length&&Mn(l,t.texData.texShape),C=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${S}_${T}_${u?h:""}_${c.length}_${w}_${_}_${x}_${f}_${p}_${g}_${C}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${Te().getNumber("WEBGL_VERSION")}`,i}function vi(n){return Te().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rge{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=X0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ui();this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?rT(["r","c","d"],e):tp(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dge{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=X0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ui();this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?rT(["r","c","d"],e):tp(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pge{constructor(e){this.variableNames=["A"],this.outTexUsage=ia.DOWNLOAD;const t=Ui();this.outputShape=e,this.userCode=`
      ${LV}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lge{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ia.DOWNLOAD;const t=Ui();this.outputShape=e,this.userCode=`
      ${LV}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oge={R:0,G:1,B:2,A:3};class lL{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ui();this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${Oge[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?HM():GM(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fge{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ui();this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?HM():GM(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ge(n){const e=Ui(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Sme(n,t)}function zge(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Eme(n,e)}function Uge(n){const e=new Uint16Array([0,1,2,2,1,3]);return Ime(n,e)}function Mv(n,e,t,s,r,i){Ame(e,t);const o=Nme(n),a=n.TEXTURE_2D;return St(n,()=>n.bindTexture(a,o)),St(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),St(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),St(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),St(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),Te().getNumber("WEBGL_VERSION")===1?St(n,()=>n.texImage2D(a,0,s,e,t,0,r,i,null)):St(n,()=>n.texStorage2D(a,1,s,e,t)),St(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function UV(n){return n.internalFormatFloat}function Bge(n,e,t,s){const[r,i]=Nv(e,t);return Mv(n,r,i,UV(s),s.textureFormatFloat,n.FLOAT)}function BV(n){return n.internalFormatHalfFloat}function Vge(n,e,t,s){const[r,i]=Nv(e,t);return Mv(n,r,i,BV(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function VV(n){return n.downloadTextureFormat}function Wge(n,e,t,s){const[r,i]=Nv(e,t);return Mv(n,r,i,VV(s),n.RGBA,n.UNSIGNED_BYTE)}function WV(n){return n.internalFormatPackedFloat}function Gge(n,e,t,s){const[r,i]=Bg(e,t);return Mv(n,r,i,WV(s),n.RGBA,n.FLOAT)}function GV(n){return n.internalFormatPackedHalfFloat}function Hge(n,e,t,s){const[r,i]=Bg(e,t);return Mv(n,r,i,GV(s),n.RGBA,s.textureTypeHalfFloat)}function jge(n,e,t){return St(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),rL(n,e,"clipSpacePos",t,3,20,0)&&rL(n,e,"uv",t,2,20,12)}function Xge(n,e,t,s,r,i){St(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(r),Te().getNumber("WEBGL_VERSION")===2?St(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):St(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,o)),St(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function qge(n,e,t){St(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?Te().getNumber("WEBGL_VERSION")===2?St(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):St(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):Te().getNumber("WEBGL_VERSION")===2?St(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):St(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),St(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Kge(n,e,t,s){const r=n.createBuffer();St(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return St(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),St(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),St(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function Yge(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function Zge(n,e,t,s){const[r,i]=Nv(e,t),o=4,a=new Uint8Array(pme(e*t,o));return St(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Jge(n,e,t,s,r,i,o,a){const l=n,u=new Float32Array(mme(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Qge(n,e,t){const s=new Float32Array(e*t*4);return St(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iE{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Te().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,hme(t,e)):this.gl=Nl(t),e=this.gl,Te().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>St(i,()=>i.createVertexArray()),this.bindVertexArray=o=>St(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>St(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>St(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>St(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>St(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>St(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>St(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Te().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=kw(this.gl,i),ka(this.gl,o))this.textureHalfFloatExtension=kw(this.gl,o);else if(Te().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ka(this.gl,r))this.colorBufferHalfFloatExtension=kw(this.gl,r);else if(Te().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ka(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(ka(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=zge(this.gl),this.indexBuffer=Uge(this.gl),this.framebuffer=Mme(this.gl),this.textureConfig=WM(this.gl,this.textureHalfFloatExtension)}get debug(){return Te().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;St(e,()=>e.finish()),St(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),St(e,()=>e.deleteFramebuffer(this.framebuffer)),St(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),St(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),St(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Bge(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Vge(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Wge(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),qge(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),Xge(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Hge(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Gge(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(iL(this.gl,this.framebuffer),this.outputTexture=null),St(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Zge(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,o){return Jge(this.gl,e,t,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Yge(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=Kge(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(Te().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=i}else Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Qge(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=$ge(t));const s=Tme(t);St(t,()=>t.attachShader(s,this.vertexShader)),St(t,()=>t.attachShader(s,e)),Cme(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&tE(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;St(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),jge(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(St(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&tE(this.gl,this.program),St(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Rme(this.gl,e,t):Dme(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),St(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Pme(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Bg(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&tE(this.gl,this.program),Rw(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}St(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),St(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=kw(this.gl,Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await zD(()=>this.disposed||this.isQueryAvailable(e,Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=eye(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in Te().platform&&(s=Te().platform.setTimeoutCustom.bind(Te().platform)),zD(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),nE(this.gl,e,this.framebuffer),this.debug&&Rw(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(nE(this.gl,this.outputTexture,this.framebuffer),this.debug&&Rw(this.gl)):iL(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;nE(r,e,this.framebuffer),this.debug&&Rw(r),this.outputTexture=e,St(r,()=>r.viewport(0,0,t,s)),St(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),St(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function eye(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:tye,bincountImpl:HV,bincountReduceImpl:nye,bitwiseAndImpl:sye,castImpl:rye,ceilImpl:iye,concatImpl:oye,equalImpl:aye,expImpl:lye,expm1Impl:uye,floorImpl:cye,gatherNdImpl:hye,gatherV2Impl:dye,greaterImpl:fye,greaterEqualImpl:pye,lessImpl:mye,lessEqualImpl:gye,linSpaceImpl:yye,logImpl:xye,maxImpl:vye,maximumImpl:wye,minimumImpl:Sye,multiplyImpl:bye,negImpl:_ye,notEqualImpl:Tye,prodImpl:Cye,raggedGatherImpl:Eye,raggedRangeImpl:Iye,raggedTensorToTensorImpl:Nye,rangeImpl:Aye,rsqrtImpl:Mye,scatterImpl:kye,sigmoidImpl:Rye,simpleAbsImpl:jV,sliceImpl:Dye,sparseFillEmptyRowsImpl:Pye,sparseReshapeImpl:Lye,sparseSegmentReductionImpl:XV,sqrtImpl:Oye,staticRegexReplaceImpl:Fye,stridedSliceImpl:$ye,stringNGramsImpl:zye,stringSplitImpl:Uye,stringToHashBucketFastImpl:Bye,subImpl:Vye,tileImpl:Wye,topKImpl:Gye,transposeImpl:XM,uniqueImpl:Hye}=que;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Li(n,e){return e===1?[n]:qV(n,e)}function jye(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xye{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=vi(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Li("rc",this.rank),s=es(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KV{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${qye(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?HM():GM(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function qye(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?jme(["r","c","d"],"inputShape"):tp(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kye{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=cL(t,s),i=hL(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=uL(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return r===qr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===qr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===qr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===qr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===qr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=cL(s,r),o=hL(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=uL(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=Te().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Yye(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function uL(n,e,t,s,r){const i=Zye(e,s);let o;if(r){const[l,u]=Bg(n[0],n[1]);o=l*u}else{const[l,u]=Nv(n[0],n[1]);o=l*u}const a=Yye(t,i);return o*a}function Zye(n,e){switch(n){case qr.PACKED_2X2_FLOAT32:return WV(e);case qr.PACKED_2X2_FLOAT16:return GV(e);case qr.UNPACKED_FLOAT32:return UV(e);case qr.UNPACKED_FLOAT16:return BV(e);case qr.PACKED_4X1_UNSIGNED_BYTE:return VV(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function Jye(n){return Te().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?qr.PACKED_2X2_FLOAT32:qr.UNPACKED_FLOAT32:n?qr.PACKED_2X2_FLOAT16:qr.UNPACKED_FLOAT16}function cL(n,e){if(n===ia.UPLOAD)return qr.PACKED_2X2_FLOAT32;if(n===ia.RENDER||n==null)return Jye(e);if(n===ia.DOWNLOAD||n===ia.PIXELS)return qr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function hL(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ru{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const za="if (isnan(x)) return x;",Qye="return x;",dL="return abs(x);",e0e="return (x >= 0.0) ? x : (exp(x) - 1.0);",t0e=za+`
  return (x < 0.0) ? 0.0 : x;
`,n0e=za+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,vh="return x;",s0e="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r0e="return x;",i0e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,o0e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,a0e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,l0e="return 1.0 / (1.0 + exp(-1.0 * x));";class _h{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u0e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length);const t=e.length,s=Li("rc",t),r=es(t),i=jye(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0e=MA,h0e=1e-7,d0e=1e-4,Lw={};function f0e(n){return n in Lw||(Lw[n]={}),Lw[n]}const p0e=Te().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),m0e=600;function g0e(){return Te().global.screen==null?1024:Te().global.screen.height*Te().global.screen.width*window.devicePixelRatio*m0e/1024/1024}class iT extends VI{nextDataId(){return iT.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Te().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof iE)t=e;else{const s=Nl(Te().getNumber("WEBGL_VERSION"),e);t=new iE(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Nl(Te().getNumber("WEBGL_VERSION"));t=new iE(s),this.binaryCache=f0e(Te().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Kye(this.gpgpu),this.numMBBeforeWarning=g0e(),this.texData=new SF(this,Ql())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,o){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,i]},l.texShape=[r,i];const u=Dw(t),c=new lL(u,!1,o),h=this.runWebGLProgram(c,[a],s,[[r,i]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,s){if((Te().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Te().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:ia.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(Te().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:ia.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let f;l?f=new _h(a,vh):f=new ru(a,vh);const p=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:r}],r),g=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const u=this.activeTimers!=null;let c;u&&(c=Ji());let h;if(r==="complex64"){const f=this.readSync(i.real.dataId),p=this.readSync(i.imag.dataId);h=gc(f,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Ji()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const g=this.pendingRead.get(e);return new Promise(S=>g.push(S))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let g;l?g=new _h(r,vh):g=new ru(r,vh);const S=this.runWebGLProgram(g,[{dataId:e,shape:r,dtype:o}],o),x=this.read(S.dataId);return this.disposeIntermediateTensorInfo(S),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(Te().getBool("DEBUG")&&!Te().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Te().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(o!=="complex64"&&Te().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const g=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(g.texture.texture,...Mw(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const g=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),S=g[0],x=g[1];h=gc(S,x)}else if(u==null)h=this.getValuesFromTexture(e);else{const g=Oe(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const g=this.gpgpu.gl;St(g,()=>g.deleteBuffer(u))}const f=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(g=>g(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ql().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:o,dtype:a,isPacked:l,texture:u}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new _h(i,vh):p=new ru(i,vh);const g=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:a}],a),S=this.readToGPU(g,t);return this.disposeIntermediateTensorInfo(g),S}if(u==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=Ql().makeTensorFromTensorInfo(c),f=this.texData.get(c.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ph(r));return yn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return yn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!vme(s))throw Te().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=Oe(t);if(Te().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Mw(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),g}const o=Te().getBool("WEBGL_PACK")&&r===!0,a=o?Dw(t):t,l=o?new Lge(a):new Pge(a),u=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Lf(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Lf(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=P7(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ji(),endMs:null}}endTimer(e){return Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ji(),e)}async getQueryTime(e){if(Te().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=p0e){return Te().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Oe(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){ra("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return c0e(e.shape,t)}packedUnaryOp(e,t,s){const r=new _h(e.shape,t),i=this.compileAndRun(r,[e],s);return Ql().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=jV(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(Te().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,dL,e.dtype);const t=new ru(e.shape,dL),s=this.compileAndRun(t,[e]);return Ql().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&dx(s[0])){const i=s.map(o=>Nh(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return Ql().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new u0e(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Xye(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[Sg(e.shape),...bg(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Sg(t),...bg(t)],o=new KV(i,s),a=!0,l=[s],u=this.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:o}=s;if(t!=null){const f=Oe(i),p=t[0]*t[1]*4;q(f<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Dw(i);let l;r?l=new Dge(a):l=new Rge(a);const u=!0,c=[t??Mw(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,c,u,t);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(e,t,s,r,i=!1,o){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===X0.DENSE){const w=o??Mw(e.outputShape);l.texShape=w.map(_=>_*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Oe(a.shape)===0)return l.values=Yr(a.dtype,0),a;const u=[],c=t.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(w.dataId);if(_.texture==null){if(!e.packedInputs&&Oe(w.shape)<=Te().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:_.values};e.packedInputs&&(_.isPacked=!0,_.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!_.isPacked!=!!e.packedInputs)w=_.isPacked?this.unpackTensor(w):this.packTensor(w),u.push(w),_=this.texData.get(w.dataId);else if(_.isPacked&&!$S(_.shape,w.shape)){const T=w,C=w.shape;w.shape=_.shape,w=this.packedReshape(w,C),u.push(w),_=this.texData.get(w.dataId),T.shape=C}return{shape:w.shape,texData:_,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},f=kge(e,c,h),p=this.getAndSaveBinary(f,()=>Age(this.gpgpu,e,c,h)),g=this.activeTimers!=null;let S;g&&(S=this.startTimer()),Te().get("ENGINE_COMPILE_ONLY")||Mge(this.gpgpu,p,c,h,r),u.forEach(w=>this.disposeIntermediateTensorInfo(w)),g&&(S=this.endTimer(S),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(S)}));const x=Te().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){const w=Ji();w-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!Te().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const w=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),w}return a}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Te().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=be(()=>{if(!Te().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Te().getBool("DEBUG");Te().set("DEBUG",!1);const t=this.abs(Ht(1e-8)).dataSync()[0];if(Te().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?h0e:d0e}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Ji());let h=t.texShape;if(h==null&&(h=Fme(s,l),t.texShape=h),i!=null){const f=Dw(s);let p,g=h[1],S=h[0];const x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!x)&&([g,S]=Bg(h[0],h[1])),l?p=new Fge(f,x):p=new lL(f,x);const w=x?[S,g]:h,_=this.makeTensorInfo(w,r),T=this.texData.get(_.dataId);x?T.usage=ia.PIXELS:T.usage=ia.UPLOAD,T.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),g,S,i);const C=[[S,g]],M=this.runWebGLProgram(p,[_],r,C,!0),P=this.texData.get(M.dataId);t.texShape=P.texShape,t.isPacked=P.isPacked,t.usage=P.usage,Te().get("ENGINE_COMPILE_ONLY")?this.disposeData(M.dataId):(t.texture=P.texture,t.values=null,this.texData.delete(M.dataId)),this.disposeIntermediateTensorInfo(_),u&&(this.uploadWaitMs+=Ji()-c)}else{const f=this.acquireTexture(h,a,r,l);t.texture=f}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=y0e(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*fS(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Pz(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(PV(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=zV(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:o,channels:a}=e,l=Ql().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(r,t,s,i,o,a);return Ql().makeTensorFromDataId(u,t,s,l)}}iT.nextDataId=0;function y0e(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */VF()&&HF("webgl",()=>new iT,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qM=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class jf{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=dn(t,s),this.enableShapeUniforms=vi(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sp=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class jg{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=dn(t,s);const i=this.outputShape.length;this.enableShapeUniforms=vi(i);let o="";if(r)if(i===0||Oe(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${es(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Li("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uo(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const x0e={kernelName:Dx,backendName:"webgl",kernelFunc:Uo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ud(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(i.dataId),a=Uo({inputs:{x:s},backend:t}),l=Uo({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const v0e={kernelName:JI,backendName:"webgl",kernelFunc:ud};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YV="return (a < 0.) ? b * a : a;",ZV=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function w0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=t.makeTensorInfo([],"float32",Qh(i,"float32")),a=Te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new jg(ZV,r.shape,o.shape):new jf(YV,r.shape,o.shape),l=t.runWebGLProgram(a,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const S0e={kernelName:$b,backendName:"webgl",kernelFunc:w0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JV="return (a < 0.) ? b * a : a;",QV=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function b0e(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=Te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new jg(QV,s.shape,r.shape):new jf(JV,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const _0e={kernelName:s_,backendName:"webgl",kernelFunc:b0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xg="if (isnan(x)) return x;";function On({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),f=t(h.values,l);return a.makeTensorInfo(o.shape,l,f)}const u=Te().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new _h(o.shape,e):c=new ru(o.shape,n),a.runWebGLProgram(c,[o],l)}}function ei({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(s&&l.dtype==="complex64"){const g=c.texData.get(l.dataId),S=c.texData.get(u.dataId),[x,w]=[[g.complexTensorInfos.real,S.complexTensorInfos.real],[g.complexTensorInfos.imag,S.complexTensorInfos.imag]].map(T=>{const[C,N]=T,M={dataId:C.dataId,dtype:C.dtype,shape:l.shape},P={dataId:N.dataId,dtype:N.dtype,shape:u.shape},$=new jf(n,l.shape,u.shape);return c.runWebGLProgram($,[M,P],Lo(C.dtype,N.dtype))}),_=ud({inputs:{real:x,imag:w},backend:c});return c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(w),_}const h=i||Lo(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&r!=null){const g=c.texData.get(l.dataId).values,S=c.texData.get(u.dataId).values,x=l.dtype==="string"?yc(g):g,w=l.dtype==="string"?yc(S):S,[_,T]=r(l.shape,u.shape,x,w,h),C=c.makeTensorInfo(T,h),N=c.texData.get(C.dataId);return N.values=_,C}const f=Te().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return f?p=new jg(e,l.shape,u.shape,t):p=new jf(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function q0(n,e=!1){if(n==="linear")return e?r0e:Qye;if(n==="relu")return e?o0e:t0e;if(n==="elu")return e?i0e:e0e;if(n==="relu6")return e?a0e:n0e;if(n==="prelu")return e?QV:JV;if(n==="leakyrelu")return e?ZV:YV;if(n==="sigmoid")return e?l0e:s0e;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eW{constructor(e,t,s,r=!1,i=!1,o=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=vi(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),f=r?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",g=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],S=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",w="";a&&(l?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:x=`vec4 activation(vec4 x) {
          ${a}
        }`,w="result = activation(result);");const _=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let T="rc.x",C="rc.x";e[0]<t[0]?T=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(C=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${x}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${T};
        int batchB = ${C};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${S[0]});
          result += (${g[1]} * ${S[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${_}

        ${w}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fL={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class pL{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=dn(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mL="return a * b;";function KM(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=Lo(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),u=new pL(fL.REAL,s.shape,r.shape),c=new pL(fL.IMAG,s.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],f=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),g=ud({inputs:{real:f,imag:p},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),g}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[u,c]=bye(s.shape,r.shape,a.values,l.values,i),h=t.makeTensorInfo(c,i),f=t.texData.get(h.dataId);return f.values=u,h}let o;return Te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new jg(mL,s.shape,r.shape):o=new jf(mL,s.shape,r.shape),t.runWebGLProgram(o,[s,r],i)}const T0e={kernelName:Vx,backendName:"webgl",kernelFunc:KM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(n,e,t){const s=[Sg(n.shape),...bg(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[Sg(e),...bg(e)],o=new KV(i,s),a=!0,l=[s],u=t.runWebGLProgram(o,[r],n.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=t,a=Oe(r.shape),l=bF(i,a),u=Oe(l);q(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return c.isPacked&&!$S(r.shape,l)&&!(c.texture!==null&&$S(c.shape,l))?C0e(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const E0e={kernelName:i_,backendName:"webgl",kernelFunc:ft};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gL{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(s/4)*4,l=s%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${cg(h)?h.toPrecision(2):h}, ones);`}let c="";i%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I0e{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(s/4)*4,h=s%4;let f=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let g="";i%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=W_(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function rp(n,e,t,s){const r=N0e(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:u}=r[o];let c,h;t==="mean"?c=o===0?new gL({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new gL({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):c=new I0e({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},t),h=i,i=s.runWebGLProgram(c,[i],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A0e{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=es(this.rank),i=M0e(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function M0e(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k0e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[t[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=es(this.rank),i=qV("rc",this.rank),o=new Array(this.rank);for(let c=0;c<t.length;c++)o[t[c]]=i[c];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oT(n,e,t){const s=Te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new k0e(n.shape,e):new A0e(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(n,e,t,s){const r=e,i=n.shape.length,o=Cn(r,n.shape);let a=o;const l=ks(a,i),u=l!=null;let c=n;u&&(c=oT(n,l,s),a=Xs(a.length,i)),Jr("sum",a,i);const[h,f]=zr(c.shape,a);let p=h;t&&(p=js(h,o));const g=Oe(f),x=Oe(n.shape)/g,w=ft({inputs:{x:c},attrs:{shape:[x,g]},backend:s}),_=YN(n.dtype),T=rp(w,_,"sum",s),C=ft({inputs:{x:T},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(T),u&&s.disposeIntermediateTensorInfo(c),C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return R0e(r,i,o,t)}const D0e={kernelName:h_,backendName:"webgl",kernelFunc:aT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $i(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,a=r.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=r.shape[i[c]];let u;if(o.shouldExecuteOnCPU([r])){const h=o.texData.get(r.dataId).values,f=XM(h,r.shape,r.dtype,i,l);u=o.makeTensorInfo(l,r.dtype);const p=o.texData.get(u.dataId);p.values=f}else u=oT(r,i,o);return u}const P0e={kernelName:Zm,backendName:"webgl",kernelFunc:$i};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tW=1e3;function zS({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],f=s?e.shape[c-1]:e.shape[c-2],p=t?n.shape[u-1]:n.shape[u-2],g=s?e.shape[c-2]:e.shape[c-1],S=n.shape.slice(0,-2),x=e.shape.slice(0,-2),w=Oe(S),_=Oe(x),C=dn(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,g]);q(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const N=t?[w,h,p]:[w,p,h],M=s?[_,g,f]:[_,f,g],P=ft({inputs:{x:n},backend:r,attrs:{shape:N}}),$=ft({inputs:{x:e},backend:r,attrs:{shape:M}}),R=[P,$],D=Math.max(w,_),L=t?P.shape[1]:P.shape[2],G=i!=null,Q=o!=null,W=l==="leakyrelu",H=l!=null?q0(l,!0):null,J=G||Q||W||H!=null;let ie;if((p===1||g===1)&&L>tW&&J===!1){let Y=P,B=$;t&&(Y=$i({inputs:{x:P},backend:r,attrs:{perm:[0,2,1]}}),R.push(Y)),s&&(B=$i({inputs:{x:$},backend:r,attrs:{perm:[0,2,1]}}),R.push(B));const K=g!==1,se=g===1;let te=Y;K&&(te=ft({inputs:{x:Y},backend:r,attrs:{shape:[D,L,1]}}),R.push(te));const ue=g===1?2:1;let fe=B;se&&(fe=ft({inputs:{x:B},backend:r,attrs:{shape:[D,1,L]}}),R.push(fe));const _e=KM({inputs:{a:te,b:fe},backend:r});ie=aT({inputs:{x:_e},backend:r,attrs:{axis:ue,keepDims:!0}}),R.push(_e)}else{const Y=Lo(n.dtype,e.dtype),B=new eW(N,M,[D,p,g],t,s,G,H,Q,W),K=[P,$];if(i!=null&&K.push(i),Q&&K.push(o),W){const se=r.makeTensorInfo([],"float32",Qh(a,"float32"));K.push(se),R.push(se)}ie=r.runWebGLProgram(B,K,Y)}const V=ft({inputs:{x:ie},backend:r,attrs:{shape:C}});R.push(ie);for(const Y of R)r.disposeIntermediateTensorInfo(Y);return V}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return zS({a:r,b:i,transposeA:l,transposeB:u,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const O0e={kernelName:pS,backendName:"webgl",kernelFunc:L0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yL="return abs(x);";function F0e(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),o=jV(i.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return Te().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new _h(s.shape,yL):r=new ru(s.shape,yL),t.runWebGLProgram(r,[s],s.dtype)}const $0e={kernelName:gb,backendName:"webgl",kernelFunc:F0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e=za+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,U0e=On({opSnippet:z0e}),B0e={kernelName:fx,backendName:"webgl",kernelFunc:U0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V0e=za+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,W0e=On({opSnippet:V0e}),G0e={kernelName:px,backendName:"webgl",kernelFunc:W0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xL="return a + b;",H0e=ei({opSnippet:xL,packedOpSnippet:xL,supportsComplex:!0,cpuKernelImpl:tye}),j0e={kernelName:Pg,backendName:"webgl",kernelFunc:H0e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X0e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q0e{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nS(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Uo({inputs:{x:s[0]},backend:t});if(s.length>Te().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=nS({inputs:s.slice(0,l),backend:t}),c=nS({inputs:s.slice(l),backend:t});return nS({inputs:[u,c],backend:t})}const r=s.map(l=>l.dtype).reduce((l,u)=>Lo(l,u)),i=s.map(l=>l.shape),a=Te().getBool("WEBGL_PACK")?new q0e(s[0].shape,i):new X0e(s[0].shape,i);return t.runWebGLProgram(a,s,r)}const K0e={kernelName:yb,backendName:"webgl",kernelFunc:nS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=Cn(i,r.shape);let u=l;const c=ks(u,a);let h=r;c!=null&&(h=$i({inputs:{x:r},backend:t,attrs:{perm:c}}),u=Xs(u.length,a)),Jr("all",u,a);const[f,p]=zr(h.shape,u),g=Oe(p),S=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),x=rp(S,S.dtype,"all",t);let w;if(o){const _=js(f,l);w=ft({inputs:{x},backend:t,attrs:{shape:_}})}else w=ft({inputs:{x},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(x),c!=null&&t.disposeIntermediateTensorInfo(h),w}const Z0e={kernelName:jI,backendName:"webgl",kernelFunc:Y0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=Cn(i,r.shape);let u=l;const c=ks(u,a);let h=r;c!=null&&(h=$i({inputs:{x:r},backend:t,attrs:{perm:c}}),u=Xs(u.length,a)),Jr("any",u,a);const[f,p]=zr(h.shape,u),g=Oe(p),S=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),x=rp(S,S.dtype,"any",t);let w;if(o){const _=js(f,l);w=ft({inputs:{x},backend:t,attrs:{shape:_}})}else w=ft({inputs:{x},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(x),c!=null&&t.disposeIntermediateTensorInfo(h),w}const Q0e={kernelName:XI,backendName:"webgl",kernelFunc:J0e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class exe{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class txe{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,q(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=es(l),c=Li("coords",l);let h,f;if(o===1){f=l+1;const $=es(f);h=`
        ${$} sourceLocR = ${$}(${c.join()}, 0);
        ++${c[l-1]};
        ${$} sourceLocG = ${$}(${c.join()}, 0);
        ++${c[l-2]};
        ${$} sourceLocA = ${$}(${c.join()}, 0);
        --${c[l-1]};
        ${$} sourceLocB = ${$}(${c.join()}, 0);
        --${c[l-2]};`}else f=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,f),g="."+p[f-1],S=p.map($=>"int "+$),x=Li("sourceLocR",f-1).concat("inIdx.r"),w=Li("sourceLocG",f-1).concat("inIdx.g"),_=Li("sourceLocB",f-1).concat("inIdx.b"),T=Li("sourceLocA",f-1).concat("inIdx.a"),C=s==="max"?"greaterThan":"lessThan",N=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${_.join()}),
                             getBestIndicesAChannel(${T.join()})));`,M=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${_.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,P=r?"":`
      float getBestIndicesAChannel(${S.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${S.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${P}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${M};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${M};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nW(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=W_(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new exe(a,t,s==null),u=[e];s!=null&&u.push(s);const c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=nW(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function sW(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=W_(i),a=new txe(r,o,t,s==null),l=s==null?[e]:[e,s],u=n.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=sW(n,e,t,u);return n.disposeIntermediateTensorInfo(u),c}return u}function rW(n,e,t,s){const r=[t];if(Jr("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!Te().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[u,c]=zr(l.shape,r),h=Oe(c),f=ft({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});i.push(f);const p=nW(n,f,s);i.push(p);const g=ft({inputs:{x:p},backend:n,attrs:{shape:u}});return i.forEach(S=>n.disposeIntermediateTensorInfo(S)),g}return sW(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Cn(i,r.shape);const a=ks(o,r.shape.length);let l=r;const u=[];a!=null&&(l=$i({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Xs(o.length,l.shape.length)),Jr("argMax",[o[0]],l.shape.length);const c=rW(t,l,o[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const sxe={kernelName:xb,backendName:"webgl",kernelFunc:nxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=Cn(i,r.shape);const a=ks(o,r.shape.length);let l=r;const u=[];a!=null&&(l=$i({inputs:{x:r},backend:t,attrs:{perm:a}}),u.push(l),o=Xs(o.length,l.shape.length)),Jr("argMin",[o[0]],l.shape.length);const c=rW(t,l,o[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const ixe={kernelName:vb,backendName:"webgl",kernelFunc:rxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oxe=za+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,axe=On({opSnippet:oxe}),lxe={kernelName:mx,backendName:"webgl",kernelFunc:axe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uxe=za+"return log(x + sqrt(x * x + 1.0));",cxe=On({opSnippet:uxe}),hxe={kernelName:gx,backendName:"webgl",kernelFunc:cxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dxe=za+`
  return atan(x);
`,fxe=On({opSnippet:dxe}),pxe={kernelName:yx,backendName:"webgl",kernelFunc:fxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mxe=qM+`
  return atan(a, b);
`,gxe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+sp+`
  return result;
`,yxe=ei({opSnippet:mxe,packedOpSnippet:gxe}),xxe={kernelName:vx,backendName:"webgl",kernelFunc:yxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vxe=za+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,wxe=On({opSnippet:vxe}),Sxe={kernelName:xx,backendName:"webgl",kernelFunc:wxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K0{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const S=t==="avg",x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let _="0.0";if(S||(_="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?x:w:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const T="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const N=Math.floor(o/4)*4,M=o%4,P=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${g});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${P}
          }

          int xC = xCCorner + ${N};
          if (${M===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${P}
          } else if (${M===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${P}
          } else if (${M===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${P}
          }
        }
        setOutput(${C});
      }
    `}}class YM{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,p=e.effectiveFilterDepth,g=e.effectiveFilterHeight,S=e.effectiveFilterWidth,x=e.padInfo.front,w=e.padInfo.top,_=e.padInfo.left;this.outputShape=e.outShape;const T=t==="avg";let C="0.0";if(T||(C="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${x}, ${w}, ${_});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${S};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${S} +
                      wR * ${S} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let M=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(M="avgValue / max(count, 1.0)");const P=Math.floor(o/4)*4,$=o%4,R=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${x}, ${w}, ${_});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${P}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${P};
            if (${$===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${$===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${$===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${R}
            }
          }
        }
        setOutput(${M});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Av(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;q(Zr(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Fa(r.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&Mn(c.inShape,c.outShape))return Uo({inputs:{x:r},backend:t});const h=new K0(c,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const _xe={kernelName:wb,backendName:"webgl",kernelFunc:bxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=s,c=[1,1,1],h=wc(r.shape,i,o,c,a,l,u),f=new YM(h,"avg",!1);return t.runWebGLProgram(f,[r],"float32")}const Cxe={kernelName:Sb,backendName:"webgl",kernelFunc:Txe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Exe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,f=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Ixe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=h-1-e.padInfo.front,S=f-1-e.padInfo.top,x=p-1-e.padInfo.left,w=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${S}, ${x});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],f=wc(o.shape,a,l,h,u,c),p=new Ixe(f);return t.runWebGLProgram(p,[r],o.dtype)}const Axe={kernelName:KI,backendName:"webgl",kernelFunc:Nxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mxe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;Av([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=s,c=Fa(o.shape,a,l,1,u),h=new Exe(c);return t.runWebGLProgram(h,[r],o.dtype)}const kxe={kernelName:qI,backendName:"webgl",kernelFunc:Mxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rxe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return zS({a:r,b:i,transposeA:o,transposeB:a,backend:t})}const Dxe={kernelName:bb,backendName:"webgl",kernelFunc:Rxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pxe{constructor(e,t,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],dn(e,t),dn(e,s);let a="0.0";r!=null&&(dn(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(dn(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lxe{constructor(e,t,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],dn(e,t),dn(e,s);let a="vec4(0.0)";r!=null&&(dn(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(dn(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oxe=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=n;q(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),q(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),q(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[s,r,i];let c=null;o!=null&&(c=o.shape,u.push(o));let h=null;a!=null&&(h=a.shape,u.push(a));const f=Te().getBool("WEBGL_PACK_NORMALIZATION")?new Lxe(s.shape,r.shape,i.shape,c,h,l):new Pxe(s.shape,r.shape,i.shape,c,h,l);return e.runWebGLProgram(f,u,u[0].dtype)},Fxe={kernelName:Lb,backendName:"webgl",kernelFunc:Oxe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $xe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=es(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=zxe(this.rank);let r;const i=e.map((o,a)=>`sourceLoc.${X2[a]} = start[${a}] + coords.${X2[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const X2=["x","y","z","w","u","v"];function zxe(n){if(n===1)return"sourceLoc";if(n<=6)return X2.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uxe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=es(this.rank),s=Li("coords",this.rank),r=Li("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=GA(e,Wt(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}function qg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[a,l]=V_(r,i,o);if(BA(r,a,l),Oe(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),f=Dye(h.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,f)}const{isPacked:u}=t.texData.get(r.dataId),c=WA(r.shape,a,l);if(u||!c){const h=Te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uxe(l):new $xe(l),f=[a];return t.runWebGLProgram(h,[r],r.dtype,f)}return t.uploadToGPU(r.dataId),Bxe(r,a,l,t)}const Vxe={kernelName:c_,backendName:"webgl",kernelFunc:qg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wxe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;q(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((_,T)=>_*T),l=gv(r.shape,i,a),u=yv(l.length,i.length),c=xv(r.shape,i,a),h=KA(o,i.length),f=YA(c,o,i.length),p=[],g=ft({inputs:{x:r},backend:t,attrs:{shape:l}}),S=$i({inputs:{x:g},backend:t,attrs:{perm:u}}),x=ft({inputs:{x:S},backend:t,attrs:{shape:c}}),w=qg({inputs:{x},backend:t,attrs:{begin:h,size:f}});return p.push(g),p.push(S),p.push(x),p.forEach(_=>t.disposeIntermediateTensorInfo(_)),w},Gxe={kernelName:_b,backendName:"webgl",kernelFunc:Wxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.readSync(r.dataId),l=t.readSync(i.dataId),u=HV(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}const jxe={kernelName:YI,backendName:"webgl",kernelFunc:Hxe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xxe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,qxe=`
  return float(int(a.r) & int(b.r));
`;function Kxe(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=Te().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Te().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||o===1){const l=t.texData.get(s.dataId).values,u=t.texData.get(r.dataId).values,[c,h]=sye(s.shape,r.shape,l,u,s.dtype),f=t.makeTensorInfo(h,s.dtype),p=t.texData.get(f.dataId);return p.values=c,f}let a;return i?a=new jg(Xxe,s.shape,r.shape,!1):a=new jf(qxe,s.shape,r.shape),t.runWebGLProgram(a,[s,r],s.dtype)}const Yxe={kernelName:Tb,backendName:"webgl",kernelFunc:Kxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zxe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),a=dn(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Jxe={kernelName:ZI,backendName:"webgl",kernelFunc:Zxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qxe="return float(a != b);",iW=ei({opSnippet:Qxe,cpuKernelImpl:Tye,dtype:"bool"}),eve={kernelName:Jb,backendName:"webgl",kernelFunc:iW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Uo({inputs:{x:r.complexTensorInfos.real},backend:t})}const tve={kernelName:MN,backendName:"webgl",kernelFunc:kv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nve="return float(int(x));";function sve(n,e){const t=new ru(n.shape,nve),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Uo({inputs:{x:r},backend:t});const o=yr(r.shape),a=q2({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=ud({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=kv({inputs:{input:r},backend:t}),a=q2({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!_F(r.dtype,i)){const o=Uo({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[a,l,u]=rye(o,r.shape,r.dtype,i);return t.makeTensorInfo(a,l,u)}if(i==="int32")return sve(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",Yr("bool",1)),l=iW({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const rve={kernelName:wx,backendName:"webgl",kernelFunc:q2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vL="return ceil(x);",ive=On({opSnippet:vL,packedOpSnippet:vL,cpuKernelImpl:iye}),ove={kernelName:Sx,backendName:"webgl",kernelFunc:ive};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ave{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;Te().getBool("WEBGL_PACK_CLIP")?a=new lve(r.shape):a=new ave(r.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[r],r.dtype,l)}const cve={kernelName:bx,backendName:"webgl",kernelFunc:uve};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hve{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wL(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function dve(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new hve(s.shape),o=[wL(s,r.complexTensorInfos.real),wL(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const fve={kernelName:Cb,backendName:"webgl",kernelFunc:dve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pve{constructor(e){this.outputShape=[],this.outputShape=uu(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mve{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=uu(e,t);const s=this.outputShape,r=s.length,i=es(r),o=Li("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((S,x)=>`T${x}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let S=1;S<l.length;S++)l[S]=l[S-1]+e[S][t];const u=a[t],c=a.slice(-2),h=a.join();let f=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let S=1;S<l.length;S++){const x=l[S-1];f+=`
        if (${u} < ${l[S]}  && ${u} >= ${l[S-1]}) {
          return getChannel(
            getT${S}(${Ow(a,u,x)}),
            vec2(${Ow(c,u,x)}));
        }`}const p=l.length,g=l[l.length-1];f+=`
        return getChannel(
          getT${p}(${Ow(a,u,g)}),
          vec2(${Ow(c,u,g)}));`,this.userCode=`
      float getValue(${a.map(S=>"int "+S)}) {
        ${f}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Ow(n,e,t){const s=n.indexOf(e);return n.map((i,o)=>o===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lT(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Uo({inputs:{x:r.complexTensorInfos.imag},backend:t})}const gve={kernelName:gN,backendName:"webgl",kernelFunc:lT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(_=>kv({inputs:{input:_},backend:t})),g=n.map(_=>lT({inputs:{input:_},backend:t})),S=a0(p,e,t),x=a0(g,e,t),w=ud({inputs:{real:S,imag:x},backend:t});return p.forEach(_=>t.disposeIntermediateTensorInfo(_)),g.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(x),w}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const p=n.map(C=>{const M=[-1,Oe(C.shape.slice(e))];return ft({inputs:{x:C},backend:t,attrs:{shape:M}})}),g=p.map(C=>({vals:t.readSync(C.dataId),shape:C.shape})),S=uu(p.map(C=>C.shape),1),x=p[0].shape[0]===1,w=oye(g,S,s,x),_=uu(n.map(C=>C.shape),e),T=t.makeTensorInfo(_,s,w);return p.forEach(C=>t.disposeIntermediateTensorInfo(C)),T}const i=n.filter(p=>Oe(p.shape)>0),o=Te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const p=o?new ru(n[0].shape,vh):new _h(n[0].shape,vh);return t.runWebGLProgram(p,n,s)}const a=Te().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const p=[];for(let S=0;S<i.length;S+=a){const x=i.slice(S,S+a);p.push(a0(x,e,t))}const g=a0(p,e,t);for(const S of p)t.disposeIntermediateTensorInfo(S);return g}if(o){const p=new mve(i.map(g=>g.shape),e);return t.runWebGLProgram(p,i,s)}const{tensors2D:l,outShape:u}=yve(i,e,t),c=new pve(l.map(p=>p.shape)),h=t.runWebGLProgram(c,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const f=ft({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),f}function yve(n,e,t){const s=uu(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>ft({inputs:{x:i},attrs:{shape:[-1,Oe(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=Cn(r,e[0].shape)[0],o=e.map(u=>u.shape);jA(o,i);const a=uu(e.map(u=>u.shape),i);if(Oe(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>Oe(u.shape)>0);return l.length===1?Uo({inputs:{x:l[0]},backend:t}):a0(l,i,t)}const xve={kernelName:Eb,backendName:"webgl",kernelFunc:oW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aW{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,p=e.filterWidth,g=Math.floor(e.inChannels/4)*4,S=e.inChannels%4,x=e.dataFormat==="channelsLast",w=x?1:2,_=x?2:3,T=x?3:1;let C="",N="";s&&(r?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:C=`
          float activation(float x) {
            ${s}
          }
        `,N="result = activation(result);");const M=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${_}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${x}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${S===1}) {

              if (${x}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${S===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${x}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${S===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${x}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${M}
        ${N}
        setOutput(result);
      }
    `}}class vve{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,f=e.filterHeight,p=e.filterWidth,g=Math.floor(e.inChannels/4)*4,S=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${S===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${S===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${S===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lW{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=vi(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<c;x++)f+=`
           vec4 xTexelC${x*2};
           int xTexelC${x*2}Ready;
           vec4 xTexelC${x*2+1};
           int xTexelC${x*2+1}Ready;
           vec4 xC${x};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let x=0;x<c;x++)f+=`
           xTexelC${x*2} = vec4(0.0);
           xTexelC${x*2}Ready = 0;
           xTexelC${x*2+1} = vec4(0.0);
           xTexelC${x*2+1}Ready = 0;
           xC${x} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let x=0;x<(h+1)/2;x++){const w=x*2;if(f+=`
           xC = xCCorner + ${w*l};
           `,a===1){if(w<c&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }
               `,l===1&&w>0?f+=`
                 xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                   } else {
                     xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xC${w} = xTexelC${w};
                 `,w+1<c)){const _=o%2===0?WI(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${_};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                     xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${w+1}.zw = vec2(0.0);
                     }
                     xTexelC${w+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                     } else {
                      xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                     }
                     `:f+=`
                     xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                     `):_===1?f+=`
                     xC${w+1} = xTexelC${w};
                     `:f+=`
                     xCOffset = xC + ${_};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                       xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${w+1}.zw = vec2(0.0);
                       }
                       xTexelC${w+1}Ready = 1;
                     }

                     xC${w+1} = xTexelC${w+1};
                     `}}else w<c&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.0);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
               `,w+1<c&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(
                   xTexelC${w}.xy, xTexelC${w+1}.xy);
               `,w+1<c&&(f+=`
                   xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                 `)));w<c&&(f+=`
             wTexel = getW(r, ${w}, d1, d2);
             dotProd += xC${w}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${w}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,w+1<c&&(f+=`
               wTexel = getW(r, ${w+1}, d1, d2);
               dotProd += xC${w+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${w+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let p="",g="";s&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,g="result = activation(result);");const S=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${S}
         ${g}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wve{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=vi(this.outputShape.length);const{dataFormat:s}=t,r=Ui(),i=s==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function uW({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,u=s.texData.get(n.dataId),c=t.inChannels,h=l[0]*l[1]*l[2],f=t.outChannels,p=t.dataFormat==="channelsLast",g=!1,S=!1;let x;const w=[];if(i!=null){const C=US(i.shape,p);C!=null&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:C}}),w.push(i))}if(r!=null){const C=US(r.shape,p);C!=null&&(r=ft({inputs:{x:r},backend:s,attrs:{shape:C}}),w.push(r))}if(!((h===1||f===1)&&c>tW)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&Mn(u.shape.slice(-3),l.slice(-3))){const C=l[0]*l[1]*(l[2]+1),N={dataId:n.dataId,shape:[1,C,t.inChannels],dtype:n.dtype},M=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,q($S(u.shape,N.shape),()=>`packed reshape ${u.shape} to ${N.shape} isn't free`);const P=ft({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});w.push(P);const $=zS({a:N,b:P,backend:s,transposeA:g,transposeB:S,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),R=s.texData.get($.dataId);q(R.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=M,R.shape=t.outShape,x=Uo({inputs:{x:$},backend:s}),x.shape=t.outShape,w.push($)}else{const C=t.outHeight*t.outWidth,N=ft({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,C,t.inChannels]:[t.batchSize,t.inChannels,C]}}),M=ft({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),P=zS({a:p?N:M,b:p?M:N,transposeA:!p,transposeB:S,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});x=ft({inputs:{x:P},backend:s,attrs:{shape:t.outShape}}),w.push(N),w.push(M),w.push(P)}for(const C of w)s.disposeIntermediateTensorInfo(C);return x}function cW({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:f,dataFormat:p}=t,g=p==="channelsLast",S=l*u*c,x=f*h,w=[t.batchSize,S,x],_=!0,T=!1,C=[];if(i!=null){const V=US(i.shape,g);V!=null&&(i=ft({inputs:{x:i},backend:s,attrs:{shape:V}}),C.push(i))}if(r!=null){const V=US(r.shape,g);V!=null&&(r=ft({inputs:{x:r},backend:s,attrs:{shape:V}}),C.push(r))}const N=ft({inputs:{x:e},backend:s,attrs:{shape:[1,S,Oe(e.shape)/S]}});C.push(N);const M=new wve(w,t),P=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],$=s.runWebGLProgram(M,[n],"float32",P),R=ft({inputs:{x:$},backend:s,attrs:{shape:w}});C.push($),C.push(R);const D=r!=null,L=i!=null,G=a==="leakyrelu",Q=a?q0(a,!0):null,W=new eW(g?R.shape:N.shape,g?N.shape:R.shape,g?[t.batchSize,x,t.outChannels]:[t.batchSize,t.outChannels,x],_,T,D,Q,L,G),H=g?[R,N]:[N,R];if(r&&H.push(r),L&&H.push(i),G){const V=s.makeTensorInfo([],"float32",Qh(o,"float32"));H.push(V),C.push(V)}const J=s.runWebGLProgram(W,H,"float32"),ie=ft({inputs:{x:J},backend:s,attrs:{shape:t.outShape}});C.push(J);for(const V of C)s.disposeIntermediateTensorInfo(V);return ie}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=Sc(l),f=$r(r.shape,i.shape,o,u,a,c,!1,h);let p;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))p=uW({x:r,filter:i,convInfo:f,backend:t});else if(f.strideWidth<=2&&h==="channelsLast"&&Te().getBool("WEBGL_EXP_CONV")){const S=new lW(f),x=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];p=t.runWebGLProgram(S,[r,i],"float32",x)}else if(Te().getBool("WEBGL_CONV_IM2COL"))p=cW({x:r,filter:i,convInfo:f,backend:t});else{const S=new aW(f);p=t.runWebGLProgram(S,[r,i],"float32")}const g=ft({inputs:{x:p},backend:t,attrs:{shape:f.outShape}});return t.disposeIntermediateTensorInfo(p),g}const bve={kernelName:Ib,backendName:"webgl",kernelFunc:Sve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Tve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,u=o?1:2,c=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Cve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Eve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,u=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=Sc(l),f=$r(r.shape,c,o,1,a,u,!1,h),p=new _ve(f);return t.runWebGLProgram(p,[r,i],"float32")}const Nve={kernelName:QI,backendName:"webgl",kernelFunc:Ive};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ave{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=vi(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=Sc(u),f=$r(o,i.shape,a,1,l,c,!1,h);if(Te().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[f.strideHeight,f.strideWidth]],g=new Ave(f);return t.runWebGLProgram(g,[r,i],"float32",p)}else{const p=new Tve(f);return t.runWebGLProgram(p,[r,i],"float32")}}const kve={kernelName:Nb,backendName:"webgl",kernelFunc:Mve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=nd(r.shape,i.shape,o,l,a),c=new vve(u);return t.runWebGLProgram(c,[r,i],"float32")}const Dve={kernelName:Ab,backendName:"webgl",kernelFunc:Rve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s,u=nd(r.shape,l,o,1,a),c=new Cve(u);return t.runWebGLProgram(c,[r,i],"float32")}const Lve={kernelName:eN,backendName:"webgl",kernelFunc:Pve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ove(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s,u=nd(l,i.shape,a,1,o),c=new Eve(u);return t.runWebGLProgram(c,[r,i],"float32")}const Fve={kernelName:tN,backendName:"webgl",kernelFunc:Ove};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ve=Xg+`
  return cos(x);
`,zve=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${sp}
  return result;
`,Uve=On({opSnippet:$ve,packedOpSnippet:zve}),Bve={kernelName:_x,backendName:"webgl",kernelFunc:Uve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vve=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Wve=On({opSnippet:Vve}),Gve={kernelName:Tx,backendName:"webgl",kernelFunc:Wve};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hve{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,u]=e,[c]=t,[h,f]=s;this.outputShape=[c,h,f,u];const p=r==="bilinear"?1:0,[g,S]=[`${a-1}.0`,`${l-1}.0`],[x,w,_]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[T,C,N]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${S} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${S}`];this.userCode=`
      const float height_ratio = float(${x});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${C};

        float in_y = ${_};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${S} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jve=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=s,c=new Hve(r.shape,i.shape,a,l,u);return t.runWebGLProgram(c,[r,i,o],"float32")},Xve={kernelName:sN,backendName:"webgl",kernelFunc:jve};var Y0;(function(n){n.Prod="*",n.Sum="+"})(Y0||(Y0={}));class SL{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Y0.Prod?"1.0":"0.0",a=s?o:`getX(${bL(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?`end != ${l-1}`:"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${es(i)} coords = getOutputCoords();
        int end = ${_L(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${_L(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${bL(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function bL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function _L(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hW(n,e,t,s,r,i){const o=e.shape.length,a=ks([s],o);let l=e;a!=null&&(l=$i({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=Xs(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=Uo({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(c))-1;f++){const p=new SL(n,l.shape,!1,i),g=[[f]],S=h;h=t.runWebGLProgram(p,[h],h.dtype,g),t.disposeIntermediateTensorInfo(S)}if(r){const f=new SL(n,l.shape,r,i),p=h;h=t.runWebGLProgram(f,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const f=sd(a),p=$i({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return hW(Y0.Prod,r,t,i,o,a)}const Kve={kernelName:nN,backendName:"webgl",kernelFunc:qve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s;return hW(Y0.Sum,r,t,i,o,a)}const Zve={kernelName:Mb,backendName:"webgl",kernelFunc:Yve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),u=t.readSync(i.dataId),c=HV(l,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}else if(r.shape.length===2){const l=t.bufferSync(r),u=t.bufferSync(i),c=nye(l,u,o,a);return t.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Qve={kernelName:rN,backendName:"webgl",kernelFunc:Jve};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e1e{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],u=o==="NHWC"?r.shape[2]:r.shape[3],c=o==="NHWC"?r.shape[3]:r.shape[1],h=l*i,f=u*i,p=c/(i*i),g=o==="NHWC"?[a,h,f,p]:[a,p,h,f],S=new e1e(g,i,o);return t.runWebGLProgram(S,[r],r.dtype)}const n1e={kernelName:iN,backendName:"webgl",kernelFunc:t1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dW{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=vi(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";s&&(r?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:u=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fW{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=vi(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,f=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<h;w++)p+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let w=0;w<h;w++)p+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(f+1)/2;w++){const _=w*2;if(p+=`
          xC = xCCorner + ${_*u};
          `,l===1){if(_<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }
              `,u===1&&_>0?p+=`
                xC${_} = vec4(xTexelC${_-2}.zw, xTexelC${_}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${_} = vec4(previous.zw, xTexelC${_}.xy);
                  } else {
                    xC${_} = vec4(0.0, 0.0, xTexelC${_}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                xC${_} = xTexelC${_};
                `,_+1<h)){const T=a%2===0?WI(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${T};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                    xTexelC${_+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${_+1}.zw = vec2(0.0);
                    }
                    xTexelC${_+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${_+1} = vec4(previous.zw, xTexelC${_+1}.xy);
                    } else {
                     xC${_+1} = vec4(0.0, 0.0, xTexelC${_+1}.xy);
                    }
                    `:p+=`
                    xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.xy);
                    `):T===1?p+=`
                    xC${_+1} = xTexelC${_};
                    `:p+=`
                    xCOffset = xC + ${T};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                      xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${_+1}.zw = vec2(0.0);
                      }
                      xTexelC${_+1}Ready = 1;
                    }

                    xC${_+1} = xTexelC${_+1};
                    `}}else _<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${_+1}Ready == 0) {
                  xTexelC${_+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${_+1}.zw = vec2(0.0);
                  }
                  xTexelC${_+1}Ready = 1;
                }

                xC${_} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
              `,_+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${_+1} = vec4(xTexelC${_+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                  xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_+1}.zw = vec2(0.);
                  }
                  xTexelC${_+1}Ready = 1;
                }

                xC${_} = vec4(
                  xTexelC${_}.xy, xTexelC${_+1}.xy);
              `,_+1<h&&(p+=`
                  xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
                `)));_<h&&(p+=`
            wTexel = getW(r, ${_}, d1, q);
            dotProd += xC${_} * vec4(wTexel.xz, wTexel.xz);
          `,_+1<h&&(p+=`
              wTexel = getW(r, ${_+1}, d1, q);
              dotProd += xC${_+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let g="",S="";s&&(r?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:g=`vec4 activation(vec4 x) {
          ${s}
        }`,S="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${x}
        ${S}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=s;let c=l;c==null&&(c=[1,1]),q(Zr(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=$r(r.shape,i.shape,o,c,a,u,!0);let f;Te().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?f=new fW(h):f=new dW(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(f,[r,i],"float32",p)}const r1e={kernelName:kb,backendName:"webgl",kernelFunc:s1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class o1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=s,h=$r(r.shape,c,o,a,l,u,!0),f=new i1e(h);return t.runWebGLProgram(f,[r,i],"float32")}const l1e={kernelName:oN,backendName:"webgl",kernelFunc:a1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=s,h=$r(c,i.shape,o,a,l,u,!0),f=new o1e(h);return t.runWebGLProgram(f,[r,i],"float32")}const c1e={kernelName:aN,backendName:"webgl",kernelFunc:u1e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h1e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d1e(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=Oe(s.shape),o=ft({inputs:{x:s},backend:t,attrs:{shape:[i]}}),a=new h1e(i),l=t.runWebGLProgram(a,[o],o.dtype),u=ft({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}const f1e={kernelName:lN,backendName:"webgl",kernelFunc:d1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p1e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:f}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,u=uv(r.shape,i.shape,o,a,"NHWC",l);let c;const h=new p1e(u);c=t.runWebGLProgram(h,[r,i],"float32");const f=ft({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),f}const g1e={kernelName:Rb,backendName:"webgl",kernelFunc:m1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1e(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=rM(r,i.length);oM(o.length,l,i);const{path:u,steps:c}=aM(a,l),h=c.length;let f=null,p=o.length;const g=[];for(let S=0;S<h;++S){for(const x of c[S]){const{permutationIndices:w,expandDims:_}=iM(p,l[x]);let T;lM(w)?T=i[x]:(T=$i({inputs:{x:i[x]},backend:t,attrs:{perm:w}}),g.push(T));const C=T.shape.slice();for(let N=0;N<_.length;++N)C.splice(_[N],0,1);Mn(T.shape,C)||(T=ft({inputs:{x:T},backend:t,attrs:{shape:C}}),g.push(T)),f===null?f=T:(f=KM({inputs:{a:T,b:f},backend:t}),g.push(f))}S<h-1&&(u[S]>=0&&(f=aT({inputs:{x:f},backend:t,attrs:{axis:u[S]-(o.length-p),keepDims:!1}}),g.push(f)),p--)}for(const S of g)S!==f&&t.disposeIntermediateTensorInfo(S);return f}const x1e={kernelName:uN,backendName:"webgl",kernelFunc:y1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",w1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,S1e=On({opSnippet:v1e,packedOpSnippet:w1e}),b1e={kernelName:Ex,backendName:"webgl",kernelFunc:S1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _1e="return (b >= 0.0) ? a : a * (b + 1.0);",T1e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,C1e=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=Te().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new jg(T1e,s.shape,r.shape):new jf(_1e,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},E1e={kernelName:cN,backendName:"webgl",kernelFunc:C1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I1e=`
  return vec4(equal(a, b));
`,N1e="return float(a == b);",A1e=ei({opSnippet:N1e,packedOpSnippet:I1e,dtype:"bool",cpuKernelImpl:aye}),M1e={kernelName:Db,backendName:"webgl",kernelFunc:A1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ZA};
  float a1 = ${JA};
  float a2 = ${QA};
  float a3 = ${eM};
  float a4 = ${tM};
  float a5 = ${nM};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,R1e=On({opSnippet:k1e}),D1e={kernelName:Ix,backendName:"webgl",kernelFunc:R1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P1e=Xg+`
  return exp(x);
`,L1e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,pW=On({opSnippet:P1e,packedOpSnippet:L1e,cpuKernelImpl:lye,dtype:"float32"}),O1e={kernelName:Nx,backendName:"webgl",kernelFunc:pW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(q(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),ft({inputs:{x:i},backend:s,attrs:{shape:a}})}const F1e={kernelName:Pb,backendName:"webgl",kernelFunc:K2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TL="return exp(x) - 1.0;",$1e=On({opSnippet:TL,packedOpSnippet:TL,cpuKernelImpl:uye}),z1e={kernelName:Ax,backendName:"webgl",kernelFunc:$1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CL{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mW(n,e,t){const s=t.texData.get(n.dataId),r=Oe(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=ft({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,u=new CL("real",l,e),c=new CL("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],f=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),g=ud({inputs:{real:f,imag:p},backend:t});t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p);const S=ft({inputs:{x:g},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(g),S}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1e(n){const{inputs:e,backend:t}=n,{input:s}=e;return mW(s,!1,t)}const B1e={kernelName:hN,backendName:"webgl",kernelFunc:U1e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V1e{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||Rg(r),i==="string"){const o=Gs(i,Oe(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new V1e(s,r),a=[[r]];return e.runWebGLProgram(o,[],i,a)}}const W1e={kernelName:dN,backendName:"webgl",kernelFunc:Rv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G1e{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H1e={kernelName:fN,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new G1e(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EL="return floor(x);",j1e=On({opSnippet:EL,packedOpSnippet:EL,cpuKernelImpl:cye}),X1e={kernelName:Mx,backendName:"webgl",kernelFunc:j1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q1e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,K1e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Y1e=ei({opSnippet:q1e,packedOpSnippet:K1e,dtype:"int32"}),Z1e={kernelName:kx,backendName:"webgl",kernelFunc:Y1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J1e{constructor(e){this.variableNames=["A"];const t=Ui(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q1e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ui(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ewe={kernelName:r2,backendName:"webgl",kernelFunc:twe};let Lm,oE=Te().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function twe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];if(a||o){const S=Te().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Lm==null||S!==oE)&&(oE=S,Lm=document.createElement("canvas").getContext("2d",{willReadFrequently:oE})),Lm.canvas.width=l,Lm.canvas.height=u,Lm.drawImage(r,0,0,l,u),r=Lm.canvas}const f=t.makeTensorInfo(c,"int32");t.texData.get(f.dataId).usage=ia.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(f.dataId),r);const p=Te().getBool("WEBGL_PACK")?new Q1e(h):new J1e(h),g=t.runWebGLProgram(p,[f],"int32");return t.disposeData(f.dataId),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f,activation:p,leakyreluAlpha:g}=s,S=Sc(c),x=$r(r.shape,i.shape,l,h,u,f,!1,S);let w;const _=[],T=o!=null,C=a!=null,N=p==="leakyrelu",M=()=>{const $=[r,i],R=(D,L)=>{if(L==="NCHW"&&D.shape.length===1&&D.shape[0]!==1){const G=ft({inputs:{x:D},backend:t,attrs:{shape:[D.shape[0],1,1]}});return _.push(G),G}return D};if(T&&$.push(R(o,c)),C&&$.push(R(a,c)),N){const D=t.makeTensorInfo([],"float32",Qh(g,"float32"));$.push(D),_.push(D)}return $};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))w=uW({x:r,filter:i,convInfo:x,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:g});else if(x.strideWidth<=2&&S==="channelsLast"&&Te().getBool("WEBGL_EXP_CONV")){const $=p?q0(p,!0):null,R=new lW(x,T,$,C,N),D=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],L=M();w=t.runWebGLProgram(R,L,"float32",D)}else if(Te().getBool("WEBGL_CONV_IM2COL"))w=cW({x:r,filter:i,convInfo:x,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:g});else{const $=p?q0(p,!1):null,R=new aW(x,T,$,C,N),D=M();w=t.runWebGLProgram(R,D,"float32")}const P=ft({inputs:{x:w},backend:t,attrs:{shape:x.outShape}});return _.push(w),_.forEach($=>t.disposeIntermediateTensorInfo($)),P}const swe={kernelName:mS,backendName:"webgl",kernelFunc:nwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=s,g=[];let S=c;S==null&&(S=[1,1]),q(Zr(l,S),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${S}'`);const x=$r(r.shape,i.shape,l,S,u,h,!0),w=Te().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,_=f?q0(f,w):null,T=[r,i],C=o!=null,N=a!=null,M=f==="leakyrelu";if(C&&T.push(o),N&&T.push(a),M){const D=t.makeTensorInfo([],"float32",Qh(p,"float32"));T.push(D),g.push(D)}let P;w?P=new fW(x,C,_,N,M):P=new dW(x,C,_,N,M);const $=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],R=t.runWebGLProgram(P,T,"float32",$);return g.forEach(D=>t.disposeIntermediateTensorInfo(D)),R}const iwe={kernelName:gS,backendName:"webgl",kernelFunc:rwe};class owe{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=es(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=Oe(s.shape),[l,u,c,h]=UA(s,r),f=ft({inputs:{x:r},backend:t,attrs:{shape:[u,o]}}),p=ft({inputs:{x:s},backend:t,attrs:{shape:[Oe(s.shape)/c,c]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const w=t.readSync(r.dataId),_=t.bufferSync(s),T=hye(w,_,s.dtype,u,o,c,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,T.values)}const g=new owe(o,h,[u,c],s.shape),S=t.runWebGLProgram(g,[p,f],p.dtype),x=ft({inputs:{x:S},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(S),x}const lwe={kernelName:pN,backendName:"webgl",kernelFunc:awe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uwe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=es(this.rank),r=cwe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function cwe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,l=Cn(o,r.shape)[0];if(Te().get("DEBUG")){const _=t.readSync(i.dataId),T=r.shape[l];for(let C=0;C<_.length;++C){const N=_[C];q(N<=T-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${T-1}]`)}}const u=cM(r,i,l,a),c=Oe(i.shape),h=[],f=ft({inputs:{x:r},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=ft({inputs:{x:i},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(f),h.push(p);const g=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const _=t.bufferSync(p),T=t.bufferSync(f),C=dye(T,_,g);return h.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.makeTensorInfo(u.outputShape,C.dtype,C.values)}const S=new uwe(f.shape,g),x=t.runWebGLProgram(S,[f,p],f.dtype);h.push(x);const w=ft({inputs:{x},backend:t,attrs:{shape:u.outputShape}});return h.forEach(_=>t.disposeIntermediateTensorInfo(_)),w}const hwe={kernelName:Ob,backendName:"webgl",kernelFunc:gW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dwe="return float(a > b);",fwe=`
  return vec4(greaterThan(a, b));
`,pwe=ei({opSnippet:dwe,packedOpSnippet:fwe,cpuKernelImpl:fye,dtype:"bool"}),mwe={kernelName:Fb,backendName:"webgl",kernelFunc:pwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gwe="return float(a >= b);",ywe=`
  return vec4(greaterThanEqual(a, b));
`,xwe=ei({opSnippet:gwe,packedOpSnippet:ywe,dtype:"bool",cpuKernelImpl:pye}),vwe={kernelName:Rx,backendName:"webgl",kernelFunc:xwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wwe(n){const{inputs:e,backend:t}=n,{input:s}=e;return mW(s,!0,t)}const Swe={kernelName:mN,backendName:"webgl",kernelFunc:wwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bwe="return float(!isnan(x) && !isinf(x));",_we=On({opSnippet:bwe,dtype:"bool"}),Twe={kernelName:Px,backendName:"webgl",kernelFunc:_we};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cwe="return float(isinf(x));",Ewe=On({opSnippet:Cwe,dtype:"bool"}),Iwe={kernelName:Lx,backendName:"webgl",kernelFunc:Ewe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nwe="return float(isnan(x));",Awe=On({opSnippet:Nwe,dtype:"bool"}),Mwe={kernelName:Ox,backendName:"webgl",kernelFunc:Awe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kwe="return float(a < b);",Rwe=`
  return vec4(lessThan(a, b));
`,Dwe=ei({opSnippet:kwe,packedOpSnippet:Rwe,cpuKernelImpl:mye,dtype:"bool"}),Pwe={kernelName:zb,backendName:"webgl",kernelFunc:Dwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lwe="return float(a <= b);",Owe=`
  return vec4(lessThanEqual(a, b));
`,Fwe=ei({opSnippet:Lwe,packedOpSnippet:Owe,cpuKernelImpl:gye,dtype:"bool"}),$we={kernelName:Ub,backendName:"webgl",kernelFunc:Fwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=yye(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const Uwe={kernelName:yN,backendName:"webgl",kernelFunc:zwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bwe=Xg+`
  return x < 0.0 ? 0./0. : log(x);
`,Vwe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Wwe=On({opSnippet:Bwe,packedOpSnippet:Vwe,cpuKernelImpl:xye}),Gwe={kernelName:Fx,backendName:"webgl",kernelFunc:Wwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hwe=Xg+`
  return log(1.0 + x);
`,jwe=On({opSnippet:Hwe}),Xwe={kernelName:$x,backendName:"webgl",kernelFunc:jwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qwe="return float(a >= 1.0 && b >= 1.0);",Kwe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Ywe=ei({opSnippet:qwe,packedOpSnippet:Kwe,dtype:"bool"}),Zwe={kernelName:Bb,backendName:"webgl",kernelFunc:Ywe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jwe="return float(!(x >= 1.0));",Qwe=On({opSnippet:Jwe}),eSe={kernelName:Vb,backendName:"webgl",kernelFunc:Qwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tSe="return float(a >= 1.0 || b >= 1.0);",nSe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,sSe=ei({opSnippet:tSe,packedOpSnippet:nSe,dtype:"bool"}),rSe={kernelName:Wb,backendName:"webgl",kernelFunc:sSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iSe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oSe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aSe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s,u=Te().getBool("WEBGL_PACK_NORMALIZATION")?new oSe(r.shape,i,o,a,l):new iSe(r.shape,i,o,a,l);return t.runWebGLProgram(u,[r],r.dtype)},lSe={kernelName:Gb,backendName:"webgl",kernelFunc:aSe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uSe{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cSe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=s,h=new uSe(r.shape,a,l,u,c);return t.runWebGLProgram(h,[r,i,o],r.dtype)},hSe={kernelName:xN,backendName:"webgl",kernelFunc:cSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dSe(n,e,t,s){const r=Oe(e),o=Oe(n.shape)/r,a=ft({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=rp(a,n.dtype,"max",s),u=ft({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=Cn(i,r.shape);let u=l;const c=ks(u,a),h=c!=null,f=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(f){const T=t.texData.get(p.dataId).values,C=new Array(a);for(let P=0;P<C.length;P++)C[P]=r.shape[c[P]];const N=XM(T,r.shape,r.dtype,c,C);p=t.makeTensorInfo(C,r.dtype);const M=t.texData.get(p.dataId);M.values=N}else p=oT(r,c,t);u=Xs(u.length,a)}Jr("max",u,a);const[g,S]=zr(p.shape,u);let x=g;o&&(x=js(g,l));let w;if(f){const T=t.texData.get(p.dataId).values,C=vye(T,Oe(S),x,r.dtype);w=t.makeTensorInfo(x,r.dtype);const N=t.texData.get(w.dataId);N.values=C}else w=dSe(p,S,x,t);return h&&t.disposeIntermediateTensorInfo(p),w}const fSe={kernelName:Hb,backendName:"webgl",kernelFunc:yW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pSe=qM+`
  return max(a, b);
`,mSe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+sp+`
  return result;
`,gSe=ei({opSnippet:pSe,packedOpSnippet:mSe,cpuKernelImpl:wye}),ySe={kernelName:zx,backendName:"webgl",kernelFunc:gSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Av(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,u=1;q(Zr(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Fa(r.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&Mn(c.inShape,c.outShape))return Uo({inputs:{x:r},backend:t});const h=new K0(c,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const vSe={kernelName:jb,backendName:"webgl",kernelFunc:xSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=s,c=[1,1,1],h=wc(r.shape,i,o,c,a,u,l),f=new YM(h,"max",!1);return t.runWebGLProgram(f,[r],r.dtype)}const SSe={kernelName:Xb,backendName:"webgl",kernelFunc:wSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bSe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,u=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class _Se{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=u-1-e.padInfo.top,p=c-1-e.padInfo.left,g=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TSe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=s,h=[1,1,1],f=wc(o.shape,a,l,h,u,c),p=new YM(f,"max",!0),g=t.runWebGLProgram(p,[o],o.dtype),S=new _Se(f),x=t.runWebGLProgram(S,[r,g],o.dtype);return t.disposeIntermediateTensorInfo(g),x}const CSe={kernelName:wN,backendName:"webgl",kernelFunc:TSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ESe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;Av([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,f=Fa(a.shape,l,u,1,c,h),p=!0,g=new K0(f,"max",p),S=t.runWebGLProgram(g,[a],a.dtype),x=new bSe(f),w=t.runWebGLProgram(x,[r,S],a.dtype);return t.disposeIntermediateTensorInfo(S),w}const ISe={kernelName:vN,backendName:"webgl",kernelFunc:ESe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NSe(n,e,t,s){let r=new K0(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new K0(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ASe={kernelName:SN,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;q(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];q(Zr(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=Fa(s.shape,r,i,u,o),[h,f]=NSe(s,a,c,l);return[h,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MSe(n,e,t,s){const r=Oe(e),o=Oe(n.shape)/r,a=ft({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=rp(a,"float32","mean",s),u=ft({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kSe={kernelName:qb,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,o=t,a=s.shape.length,l=Cn(i,s.shape);let u=l;const c=ks(u,a),h=c!=null,f=o.shouldExecuteOnCPU([s]),p=[];let g=s;if(h){if(f){const C=o.texData.get(g.dataId).values,N=new Array(a);for(let $=0;$<N.length;$++)N[$]=s.shape[c[$]];const M=XM(C,s.shape,s.dtype,c,N);g=o.makeTensorInfo(N,s.dtype);const P=o.texData.get(g.dataId);P.values=M}else g=oT(s,c,o);p.push(g),u=Xs(u.length,a)}Jr("sum",u,a);const[S,x]=zr(g.shape,u);let w=S;r&&(w=js(S,l));const _=MSe(g,x,w,o);for(const T of p)o.disposeIntermediateTensorInfo(T);return _}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=Cn(i,r.shape);let u=l;const c=ks(u,a);let h=r;c!=null&&(h=$i({inputs:{x:r},backend:t,attrs:{perm:c}}),u=Xs(u.length,r.shape.length)),Jr("min",u,a);const[f,p]=zr(h.shape,u),g=Oe(p),S=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),x=rp(S,S.dtype,"min",t);let w;if(o){const _=js(f,l);w=ft({inputs:{x},backend:t,attrs:{shape:_}})}else w=ft({inputs:{x},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(x),c!=null&&t.disposeIntermediateTensorInfo(h),w}const DSe={kernelName:Kb,backendName:"webgl",kernelFunc:RSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PSe=qM+`
  return min(a, b);
`,LSe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+sp+`
  return result;
`,OSe=ei({opSnippet:PSe,packedOpSnippet:LSe,cpuKernelImpl:Sye}),FSe={kernelName:Ux,backendName:"webgl",kernelFunc:OSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Se{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,i=es(r),o=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zSe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,S)=>g[0]+e[S]+g[1]);const r=e.length,i=es(r),o=t.map(g=>g[0]).join(","),a=t.map((g,S)=>g[0]+e[S]).join(","),l=Li("rc",r),u=Li("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,f=s==="reflect"?0:1;let p="";if(r===1){const g=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const g=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[r-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[r-1]} += 1;
          if(${c}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const USe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,o=Te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zSe(s.shape,r,i):new $Se(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},BSe={kernelName:Yb,backendName:"webgl",kernelFunc:USe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VSe=`if (b == 0.0) return NAN;
  return mod(a, b);`,WSe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+sp+`
  return result;
`,GSe=ei({opSnippet:VSe,packedOpSnippet:WSe}),HSe={kernelName:Bx,backendName:"webgl",kernelFunc:GSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jSe{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XSe=`
if (a == b) {
  return 1.0;
};
return a / b;`,qSe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,xW=ei({opSnippet:XSe,packedOpSnippet:qSe,checkOutOfBounds:!0}),KSe={kernelName:Cx,backendName:"webgl",kernelFunc:xW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IL="return a - b;",vW=ei({opSnippet:IL,packedOpSnippet:IL,supportsComplex:!0,cpuKernelImpl:Vye}),YSe={kernelName:sv,backendName:"webgl",kernelFunc:vW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wW(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=Cn([i],r.shape),a=yW({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=js(a.shape,o),u=ft({inputs:{x:a},backend:t,attrs:{shape:l}}),c=vW({inputs:{a:r,b:u},backend:t}),h=pW({inputs:{x:c},backend:t}),f=aT({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),p=ft({inputs:{x:f},backend:t,attrs:{shape:l}}),g=xW({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),g}const ZSe={kernelName:p_,backendName:"webgl",kernelFunc:wW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JSe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,l=a?r:wW({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new jSe(u,c,i),f=[[o]],p=t.runWebGLProgram(h,[l],"int32",f);return a||t.disposeIntermediateTensorInfo(l),p}const QSe={kernelName:bN,backendName:"webgl",kernelFunc:JSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ebe=za+`
  return -x;
`,tbe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function nbe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[o,a]=_ye(i.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let r;return Te().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new _h(s.shape,tbe):r=new ru(s.shape,ebe),t.runWebGLProgram(r,[s],s.dtype)}const sbe={kernelName:Zb,backendName:"webgl",kernelFunc:nbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rbe=DA;function ibe(n){ra("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,u=t.readSync(r.dataId),c=t.readSync(i.dataId),{selectedIndices:h}=rbe(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const obe={kernelName:_N,backendName:"webgl",kernelFunc:ibe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const abe=PA;function lbe(n){ra("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=s,c=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:f,validOutputs:p}=abe(c,h,o,a,l,u);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const ube={kernelName:TN,backendName:"webgl",kernelFunc:lbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cbe=LA;function hbe(n){ra("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=s,c=t.readSync(r.dataId),h=t.readSync(i.dataId),f=o,p=a,g=l,S=u,{selectedIndices:x,selectedScores:w}=cbe(c,h,f,p,g,S);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const dbe={kernelName:CN,backendName:"webgl",kernelFunc:hbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fbe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pbe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:o,onValue:a,offValue:l}=s,u=Oe(r.shape),c=new fbe(u,o,a,l),h=ft({inputs:{x:r},backend:t,attrs:{shape:[u]}}),f=t.runWebGLProgram(c,[h],i);t.disposeIntermediateTensorInfo(h);const p=[...r.shape,o],g=ft({inputs:{x:f},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(f),g},mbe={kernelName:e_,backendName:"webgl",kernelFunc:pbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=kv({inputs:{input:s},backend:t}),i=BS({inputs:{x:r},backend:t}),o=lT({inputs:{input:s},backend:t}),a=BS({inputs:{x:o},backend:t}),l=ud({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Rv({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const gbe={kernelName:x_,backendName:"webgl",kernelFunc:BS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SW(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=kv({inputs:{input:s},backend:t}),i=SW({inputs:{x:r},backend:t}),o=lT({inputs:{input:s},backend:t}),a=BS({inputs:{x:o},backend:t}),l=ud({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return Rv({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const ybe={kernelName:Qb,backendName:"webgl",kernelFunc:SW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return K2({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{Vo(i,c.shape,"All tensors passed to stack must have matching shapes"),q(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=K2({inputs:{input:c},backend:t,attrs:{dim:r}});return a.push(h),h}),u=oW({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const vbe={kernelName:t_,backendName:"webgl",kernelFunc:xbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wbe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const r=e.length,i=es(r),o=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sbe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((S,x)=>S[0]+e[x]+S[1]);const r=e.length,i=es(r),o=t.map(S=>S[0]).join(","),a=t.map((S,x)=>S[0]+e[x]).join(","),l=Li("rc",r),u=Li("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${c}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let S=0,x=r===1?2:4;S<x;S++)g+=`
        ${f[S]}
        if (${p}) {
          result[${S}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${S}] = getChannel(getX(${u.join()}), ${h});
        }
      `;g+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bW=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(Oe(r.shape)===0){const u=i.map((c,h)=>c[0]+r.shape[h]+c[1]);return Rv({backend:t,attrs:{shape:u,value:o,dtype:r.dtype}})}const a=Te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sbe(r.shape,i,o):new wbe(r.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[r],r.dtype,l)},bbe={kernelName:n_,backendName:"webgl",kernelFunc:bW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _be=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Tbe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+sp+`
  return result;
`,Cbe=ei({opSnippet:_be,packedOpSnippet:Tbe}),Ebe={kernelName:Wx,backendName:"webgl",kernelFunc:Cbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],u=Cn(i,r.shape);let c=u;const h=ks(c,a);let f=r;h!=null&&(f=$i({inputs:{x:r},backend:t,attrs:{perm:h}}),c=Xs(c.length,a),l.push(f)),Jr("prod",c,a);let p;if(t.shouldExecuteOnCPU([f])){const g=t.texData.get(f.dataId).values,{outVals:S,outShape:x,outDtype:w}=Cye(f.shape,f.dtype,g,c);p=t.makeTensorInfo(x,w,S)}else{const[g,S]=zr(f.shape,c),x=Oe(S),w=ft({inputs:{x:f},backend:t,attrs:{shape:[-1,x]}}),_=YN(r.dtype),T=rp(w,_,"prod",t);p=ft({inputs:{x:T},backend:t,attrs:{shape:g}}),l.push(w),l.push(T)}if(o){l.push(p);const g=js(p.shape,u);p=ft({inputs:{x:p},backend:t,attrs:{shape:g}})}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const Nbe={kernelName:r_,backendName:"webgl",kernelFunc:Ibe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Abe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=s,l=r.map(w=>t.readSync(w.dataId)),u=r.map(w=>w.shape),c=t.readSync(i.dataId),h=t.readSync(o.dataId),[f,p,g]=Eye(l,u,c,i.shape,i.dtype,h,o.shape,a),S=f.map(w=>t.makeTensorInfo([w.length],"int32",w)),x=t.makeTensorInfo(g,i.dtype,p);return S.concat([x])}const Mbe={kernelName:EN,backendName:"webgl",kernelFunc:Abe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[u,c]=Iye(o,s.shape,s.dtype,a,r.shape,l,i.shape),h=t.makeTensorInfo([u.length],"int32",u),f=t.makeTensorInfo([c.length],s.dtype,c);return[h,f]}const Rbe={kernelName:IN,backendName:"webgl",kernelFunc:kbe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,u=t.readSync(r.dataId),c=t.readSync(i.dataId),h=t.readSync(o.dataId),f=a.map(x=>t.readSync(x.dataId)),p=a.map(x=>x.shape),[g,S]=Nye(u,r.shape,c,i.shape,i.dtype,h,o.shape,f,p,l);return t.makeTensorInfo(g,i.dtype,S)}const Pbe={kernelName:NN,backendName:"webgl",kernelFunc:Dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _W=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,a=Aye(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},Lbe={kernelName:AN,backendName:"webgl",kernelFunc:_W};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obe="return 1.0 / x;",Fbe=On({opSnippet:Obe}),$be={kernelName:Gx,backendName:"webgl",kernelFunc:Fbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zbe=za+`
  return (x < 0.0) ? 0.0 : x;
`,Ube=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bbe=On({opSnippet:zbe,packedOpSnippet:Ube}),Vbe={kernelName:Hx,backendName:"webgl",kernelFunc:Bbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wbe=za+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Gbe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Hbe=On({opSnippet:Wbe,packedOpSnippet:Gbe}),jbe={kernelName:jx,backendName:"webgl",kernelFunc:Hbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xbe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let f;i?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qbe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let f;i?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=Te().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qbe(r.shape,l,u,i,o):new Xbe(r.shape,l,u,i,o);return t.runWebGLProgram(c,[r],"float32")}const Ybe={kernelName:a_,backendName:"webgl",kernelFunc:Kbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zbe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],u=[s&&o>1?o-1:o,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],f=1/c,p=1/h,g=Math.ceil(f)*2+2,S=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${p});

        const int winHeight = int(${g});
        const int winWidth = int(${S});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new Zbe(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const Qbe={kernelName:RN,backendName:"webgl",kernelFunc:Jbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e_e{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],f=r?"0.5":"0.0";let p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t_e{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,s,u];const c=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],f=r?"0.5":"0.0";let p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n_e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,u]=a,c=Te().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new t_e(r.shape,l,u,i,o):new e_e(r.shape,l,u,i,o);return t.runWebGLProgram(c,[r],r.dtype)}const s_e={kernelName:o_,backendName:"webgl",kernelFunc:n_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r_e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],u=[s&&o>1?o-1:o,s&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],f=1/c,p=1/h,g=Math.ceil(f)*2+2,S=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${p});

        const int winHeight = int(${g});
        const int winWidth = int(${S});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new r_e(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const o_e={kernelName:kN,backendName:"webgl",kernelFunc:i_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a_e{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>r(l)).join(","),o=es(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l_e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=Li("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=es(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${u(r.slice())};
          }
          if(${o}) {
            result.b = ${c(r.slice())};
            if(${i}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(g){return f(g)}function u(g){return g[s-1]="("+g[s-1]+" + 1)",f(g)}function c(g){return g[s-2]="("+g[s-2]+" + 1)",f(g)}function h(g){return g[s-1]="("+g[s-1]+" + 1)",g[s-2]="("+g[s-2]+" + 1)",f(g)}function f(g){const S=e.map((_,T)=>p(T,g)),x=S.join(","),w=S.slice(-2).join(",");return`getChannel(getX(${x}), vec2(${w}))`}function p(g,S){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${S[g]} - 1`:`${S[g]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length,a=Cn(i,r.shape);if(o===0)return Uo({inputs:{x:r},backend:t});const l=Te().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l_e(r.shape,a):new a_e(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const c_e={kernelName:l_,backendName:"webgl",kernelFunc:u_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h_e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d_e={kernelName:KN,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,l=new h_e(s.shape,i),[u,c]=qA(o,s.shape[1],s.shape[2]),h=[[u,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f_e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,p_e=On({opSnippet:f_e}),m_e={kernelName:Xx,backendName:"webgl",kernelFunc:p_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g_e="return inversesqrt(x);",y_e=On({opSnippet:g_e,cpuKernelImpl:Mye}),x_e={kernelName:qx,backendName:"webgl",kernelFunc:y_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZM{constructor(e,t,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=es(i.length),c=es(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const f=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const g=`getUpdates(${p})`;let S="";l&&(S="coords[0], coords[1]");const x=`getDefaultValue(${S})`,w=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${w};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${x}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v_e{constructor(e,t,s,r,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const u=es(i.length),c=es(o.length);let h="";s===1?h="i":s===2&&(h="i, j");const f=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const g=`getUpdates(${p})`;let S="";l&&(S="coords[0], coords[1]");const x=`getDefaultValue(${S})`,w=t>1?"strides[j]":"strides",_=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${w};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${_};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${x}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Jf(i,r,o),f=[h/u,u];if(h===0)return t.makeTensorInfo(o,r.dtype);const p=ft({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),g=ft({inputs:{x:i},backend:t,attrs:{shape:[l,u]}}),S=t.makeTensorInfo([],"float32",new Float32Array([0]));let x;Te().getBool("WEBGL_PACK")?x=new v_e(l,a,p.shape.length,g.shape.length,c,f):x=new ZM(l,a,p.shape.length,g.shape.length,c,f);const w=t.runWebGLProgram(x,[g,p,S],g.dtype),_=ft({inputs:{x:w},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(S),_}const S_e={kernelName:DN,backendName:"webgl",kernelFunc:w_e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b_e{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=Te().getNumber("WEBGL_VERSION")===2?i:o,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:o}=s,a=new b_e(r.shape[0],r.shape[1],i.shape[1],o),l=[[r.shape[1]]];return t.runWebGLProgram(a,[r,i],"int32",l)}const T_e={kernelName:LN,backendName:"webgl",kernelFunc:__e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C_e{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);r=l.join(),i=u.join()}const o=es(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_e(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new C_e(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,i],Lo(r.dtype,i.dtype))}const I_e={kernelName:u_,backendName:"webgl",kernelFunc:E_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${G_};
  float scale = ${H_};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,A_e=On({opSnippet:N_e}),M_e={kernelName:Kx,backendName:"webgl",kernelFunc:A_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k_e=Xg+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,R_e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,D_e=On({opSnippet:k_e,packedOpSnippet:R_e,cpuKernelImpl:Rye}),P_e={kernelName:Qx,backendName:"webgl",kernelFunc:D_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L_e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,O_e=On({opSnippet:L_e}),F_e={kernelName:Jx,backendName:"webgl",kernelFunc:O_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $_e=Xg+`
  return sin(x);
`,z_e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${sp}
  return result;
`,U_e=On({opSnippet:$_e,packedOpSnippet:z_e}),B_e={kernelName:Yx,backendName:"webgl",kernelFunc:U_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V_e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,W_e=On({opSnippet:V_e}),G_e={kernelName:Zx,backendName:"webgl",kernelFunc:W_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H_e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,j_e=On({opSnippet:H_e}),X_e={kernelName:ev,backendName:"webgl",kernelFunc:j_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;q(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((w,_)=>w*_),l=[[0,0]];l.push(...o);for(let w=1+i.length;w<r.shape.length;++w)l.push([0,0]);const u=[],c=bW({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=gv(c.shape,i,a,!1),f=yv(h.length,i.length,!1),p=xv(c.shape,i,a,!1),g=ft({inputs:{x:c},backend:t,attrs:{shape:h}}),S=$i({inputs:{x:g},backend:t,attrs:{perm:f}}),x=ft({inputs:{x:S},backend:t,attrs:{shape:p}});return u.push(c),u.push(g),u.push(S),u.forEach(w=>t.disposeIntermediateTensorInfo(w)),x},K_e={kernelName:d_,backendName:"webgl",kernelFunc:q_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_e(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),u=t.readSync(i.dataId),c=t.readSync(o.dataId)[0],[h,f,p,g,S]=Pye(a,s.shape,s.dtype,l,r.dtype,u,c);return[t.makeTensorInfo(f,s.dtype,h),t.makeTensorInfo([f[0]],r.dtype,p),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(x=>Number(x)))),t.makeTensorInfo([S.length],s.dtype,new Int32Array(S))]}const Z_e={kernelName:ON,backendName:"webgl",kernelFunc:Y_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_e(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(i.dataId)),[u,c,h]=Lye(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(c,s.dtype,u),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const Q_e={kernelName:FN,backendName:"webgl",kernelFunc:J_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eTe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[u,c]=XV(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(c,s.dtype,u)}const tTe={kernelName:$N,backendName:"webgl",kernelFunc:eTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nTe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[u,c]=XV(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(c,s.dtype,u)}const sTe={kernelName:zN,backendName:"webgl",kernelFunc:nTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rTe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:f}=Jf(i,r,a),p=!1;if(i.dtype==="string"){const w=t.bufferSync(r),_=t.bufferSync(i),T=Ph(t.readSync(o.dataId)[0]),C=kye(w,_,a,f,c,u,l,h,T,p);return t.makeTensorInfo(a,C.dtype,C.values)}const g=new ZM(u,l,r.shape.length,i.shape.length,h,[f,1],p),S=t.runWebGLProgram(g,[i,r,o],i.dtype),x=ft({inputs:{x:S},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(S),x}const iTe={kernelName:UN,backendName:"webgl",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=Cn(o,r.shape)[0],l=uM(r,i,a),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map(f=>{const p=[...h];p[a]=f;const g=qg({inputs:{x:r},backend:t,attrs:{begin:c,size:p}});return c[a]+=f,g})}const aTe={kernelName:f_,backendName:"webgl",kernelFunc:oTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NL="return sqrt(x);",lTe=On({opSnippet:NL,packedOpSnippet:NL,cpuKernelImpl:Oye}),uTe={kernelName:tv,backendName:"webgl",kernelFunc:lTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cTe="return x * x;",hTe=On({opSnippet:cTe}),dTe={kernelName:BN,backendName:"webgl",kernelFunc:hTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AL="return (a - b) * (a - b);",fTe=ei({opSnippet:AL,packedOpSnippet:AL}),pTe={kernelName:nv,backendName:"webgl",kernelFunc:fTe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),o=yc(i),a=Fye(o,"string",s);return t.makeTensorInfo(r.shape,"string",a)}const gTe={kernelName:m_,backendName:"webgl",kernelFunc:mTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yTe({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=za+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new ru(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const xTe={kernelName:av,backendName:"webgl",kernelFunc:yTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vTe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=es(s.length),o=es(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((u,c)=>(l++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:f}=s,{finalShapeSparse:p,finalShape:g,isIdentity:S,sliceDim0:x,isSimpleSlice:w,begin:_,end:T,strides:C}=HA(r.shape,i,o,a,l,u,c,h,f);let N;if(S)N=ft({inputs:{x:r},backend:t,attrs:{shape:g}});else if(x||w){q(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const P=VA(_,T,C),$=qg({inputs:{x:r},backend:t,attrs:{begin:_,size:P}});N=ft({inputs:{x:$},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo($)}else if(t.shouldExecuteOnCPU([r])){const $=t.readSync(r.dataId),R=yn(r.shape,r.dtype,$),D=$ye(p,R,C,_);N=t.makeTensorInfo(g,r.dtype,D.values)}else{const $=new vTe(_,C,p);N=t.runWebGLProgram($,[r],r.dtype)}const M=ft({inputs:{x:N},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(N),M}const STe={kernelName:VN,backendName:"webgl",kernelFunc:wTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bTe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=e,f=t.readSync(c.dataId),p=t.readSync(h.dataId),[g,S]=zye(f,p,r,i,o,a,l,u);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(h.shape,"int32",S)]}const _Te={kernelName:WN,backendName:"webgl",kernelFunc:bTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TTe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[u,c,h]=Uye(a,l,r),f=c.length;return[t.makeTensorInfo([f,2],"int32",u),t.makeTensorInfo([f],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const CTe={kernelName:GN,backendName:"webgl",kernelFunc:TTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ETe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=Bye(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const ITe={kernelName:HN,backendName:"webgl",kernelFunc:ETe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NTe="return tan(x);",ATe=On({opSnippet:NTe}),MTe={kernelName:rv,backendName:"webgl",kernelFunc:ATe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kTe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,RTe=On({opSnippet:kTe}),DTe={kernelName:iv,backendName:"webgl",kernelFunc:RTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PTe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Jf(o,i,r.shape),f=[h/u,u];if(h===0)return t.makeTensorInfo(r.shape,i.dtype);const p=ft({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),g=ft({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),S=ft({inputs:{x:r},backend:t,attrs:{shape:f}}),x=new ZM(l,a,p.shape.length,g.shape.length,c,f,!1,!0),w=t.runWebGLProgram(x,[g,p,S],S.dtype),_=ft({inputs:{x:w},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(w),_}const LTe={kernelName:PN,backendName:"webgl",kernelFunc:PTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OTe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=es(this.rank),i=FTe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function FTe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),u=r.dtype==="string"?l.map(f=>Ph(f)):l,c=yn(r.shape,r.dtype,u),h=Wye(c,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new OTe(r.shape,i);return t.runWebGLProgram(o,[r],r.dtype)}const $Te={kernelName:ov,backendName:"webgl",kernelFunc:TW};class zTe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class UTe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function of(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function ML(n){let e=1;for(;e<n;)e*=2;return e}function BTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,a=Te().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Te().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([r])||c<a||i>l){const D=t.readSync(r.dataId),[L,G]=Gye(D,u,r.dtype,i,o);return[t.makeTensorInfo(L.shape,L.dtype,L.values),t.makeTensorInfo(G.shape,G.dtype,G.values)]}if(i===0)return u[u.length-1]=0,[t.makeTensorInfo(u,r.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[r,Rv({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),f=h!==null&&h.isPacked,p=f?t.unpackTensor(r):r,S=Oe(u)/c,x=ft({inputs:{x:p},attrs:{shape:[S,c]},backend:t});f&&of(t,p);const w=ML(i),_=ML(c);let T=null;const C=()=>T===null?[x,x]:[x,T],N=(D,L,G)=>{const Q=C(),W=new zTe(G),J=[[c],[T===null?1:0],[Number.NEGATIVE_INFINITY],[D],[L]],ie=T;T=t.runWebGLProgram(W,Q,"int32",J),of(t,ie)};for(let D=1;D<w;D*=2){const L=D*2;for(let G=D;G>=1;G/=2)N(L,G,[S,_])}for(let D=_;D>w;D/=2){const L=C(),G=new UTe([S,D/2]),W=[[c],[T===null?1:0],[w]],H=T;T=t.runWebGLProgram(G,L,"int32",W),of(t,H);const J=w/2,ie=J*2;for(let V=J;V>=1;V/=2)N(ie,V,T.shape)}let M=T;T=qg({inputs:{x:T},backend:t,attrs:{begin:0,size:[S,i]}}),of(t,M);let P=gW({inputs:{x,indices:T},backend:t,attrs:{axis:1,batchDims:1}});of(t,x);const $=u.slice(0,-1);$.push(i),M=T,T=ft({inputs:{x:T},attrs:{shape:$},backend:t}),of(t,M);const R=P;return P=ft({inputs:{x:P},attrs:{shape:$},backend:t}),of(t,R),[P,T]}const VTe={kernelName:jN,backendName:"webgl",kernelFunc:BTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WTe{constructor(e,t,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GTe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=s,[c,h,f,p]=r.shape,[g,S]=u??[h,f],x=[c,g,S,p],w=new WTe(h,f,o,a,l,x);return t.runWebGLProgram(w,[r,i],"float32")}const HTe={kernelName:XN,backendName:"webgl",kernelFunc:GTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jTe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Av(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:u}=Hye(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([u.length],"int32",u)]}const XTe={kernelName:qN,backendName:"webgl",kernelFunc:jTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qTe(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],u=new Array(a-1);let c=0;for(let S=0;S<a;S++)S!==i&&(u[c++]=o.shape[S]);const h=[],f=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const g=new Array(l);for(let S=0;S<g.length;S++){f[i]=S;const x=qg({inputs:{x:o},backend:t,attrs:{begin:f,size:p}}),w=ft({inputs:{x},backend:t,attrs:{shape:u}});g[S]=w,h.push(x)}return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),g}const KTe={kernelName:g_,backendName:"webgl",kernelFunc:qTe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YTe{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const l="0.0",u="sumValue",c=Math.floor(s/4)*4,h=s%4,f=`
        sumValue += dot(values, segFilter);
    `;let p="";i%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let g="";i%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,l=[];let u=0;const c=ks([u],a);let h=r;c!=null&&(h=$i({inputs:{x:r},backend:t,attrs:{perm:c}}),l.push(h),u=Xs(1,a)[0]);const f=sU(h.shape,u,o),p=Oe([h.shape[u]]),g=ft({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(g);const S=YN(r.dtype),x=(C,N,M,P,$)=>{const R=C.shape[0],D=C.shape[1],L=nU(D,$),G={windowSize:L,inSize:D,batchSize:R,numSegments:$},Q=new YTe(G,N),W=t.compileAndRun(Q,[C,M],P);if(l.push(W),W.shape[1]===$)return W;const H=_W({backend:t,attrs:{start:0,stop:$,step:1,dtype:"float32"}}),J=TW({inputs:{x:H},backend:t,attrs:{reps:[D/L]}});return l.push(H),l.push(J),x(W,N,J,P,$)},w=x(g,"unsortedSegmentSum",i,S,o),_=ft({inputs:{x:w},backend:t,attrs:{shape:f}});let T=_;if(c!=null){l.push(_);const C=sd(c);T=$i({inputs:{x:T},backend:t,attrs:{perm:C}})}return l.forEach(C=>t.disposeIntermediateTensorInfo(C)),T}const JTe={kernelName:y_,backendName:"webgl",kernelFunc:ZTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QTe=[O0e,$0e,B0e,G0e,j0e,K0e,Z0e,Q0e,sxe,ixe,lxe,hxe,pxe,xxe,Sxe,_xe,Cxe,Axe,kxe,Dxe,Fxe,Gxe,jxe,Yxe,Jxe,rve,ove,cve,v0e,fve,xve,bve,Nve,kve,Dve,Lve,Fve,Bve,Gve,Xve,Kve,Zve,Qve,n1e,r1e,l1e,c1e,f1e,g1e,x1e,b1e,E1e,M1e,D1e,O1e,F1e,z1e,B1e,W1e,H1e,X1e,Z1e,ewe,swe,iwe,lwe,hwe,mwe,vwe,x0e,Swe,gve,Twe,Iwe,Mwe,S0e,Pwe,$we,Uwe,Gwe,Xwe,Zwe,eSe,rSe,lSe,hSe,fSe,ySe,vSe,SSe,CSe,ISe,ASe,kSe,DSe,FSe,BSe,HSe,QSe,T0e,sbe,obe,ube,dbe,eve,mbe,ybe,vbe,bbe,Ebe,_0e,Nbe,Mbe,Rbe,Pbe,Lbe,tve,KSe,$be,Vbe,jbe,E0e,Ybe,Qbe,s_e,o_e,c_e,d_e,m_e,x_e,S_e,T_e,I_e,M_e,P_e,F_e,B_e,G_e,Vxe,ZSe,X_e,K_e,Z_e,Q_e,tTe,sTe,iTe,aTe,uTe,dTe,pTe,gTe,xTe,STe,_Te,CTe,ITe,YSe,D0e,MTe,DTe,LTe,$Te,VTe,HTe,P0e,XTe,KTe,JTe,gbe];for(const n of QTe)NF(n);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function Hh(n,e,t,s){return new(t||(t=Promise))((function(r,i){function o(u){try{l(s.next(u))}catch(c){i(c)}}function a(u){try{l(s.throw(u))}catch(c){i(c)}}function l(u){var c;u.done?r(u.value):(c=u.value,c instanceof t?c:new t((function(h){h(c)}))).then(o,a)}l((s=s.apply(n,[])).next())}))}function jh(n,e){var t,s,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(u){return(function(c){if(t)throw new TypeError("Generator is already executing.");for(;i&&(i=0,c[0]&&(o=0)),o;)try{if(t=1,s&&(r=2&c[0]?s.return:c[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,c[1])).done)return r;switch(s=0,r&&(c=[2&c[0],r.value]),c[0]){case 0:case 1:r=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,s=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(r=o.trys,!((r=r.length>0&&r[r.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!r||c[1]>r[0]&&c[1]<r[3])){o.label=c[1];break}if(c[0]===6&&o.label<r[1]){o.label=r[1],r=c;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(c);break}r[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(n,o)}catch(h){c=[6,h],s=0}finally{t=r=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}})([l,u])}}}function Om(n,e,t){if(t||arguments.length===2)for(var s,r=0,i=e.length;r<i;r++)!s&&r in e||(s||(s=Array.prototype.slice.call(e,0,r)),s[r]=e[r]);return n.concat(s||Array.prototype.slice.call(e))}function JM(n){return[Math.abs(n.endPoint[0]-n.startPoint[0]),Math.abs(n.endPoint[1]-n.startPoint[1])]}function VS(n){return[n.startPoint[0]+(n.endPoint[0]-n.startPoint[0])/2,n.startPoint[1]+(n.endPoint[1]-n.startPoint[1])/2]}function kL(n,e){e===void 0&&(e=1.5);var t=VS(n),s=JM(n),r=[e*s[0]/2,e*s[1]/2];return{startPoint:[t[0]-r[0],t[1]-r[1]],endPoint:[t[0]+r[0],t[1]+r[1]],palmLandmarks:n.palmLandmarks}}function RL(n){var e=VS(n),t=JM(n),s=Math.max.apply(Math,t)/2;return{startPoint:[e[0]-s,e[1]-s],endPoint:[e[0]+s,e[1]+s],palmLandmarks:n.palmLandmarks}}function DL(n,e){var t=[n.endPoint[0]-n.startPoint[0],n.endPoint[1]-n.startPoint[1]],s=[t[0]*e[0],t[1]*e[1]];return{startPoint:[n.startPoint[0]+s[0],n.startPoint[1]+s[1]],endPoint:[n.endPoint[0]+s[0],n.endPoint[1]+s[1]],palmLandmarks:n.palmLandmarks}}var eCe=(function(){function n(e,t,s,r,i,o){this.model=e,this.width=t,this.height=s,this.iouThreshold=i,this.scoreThreshold=o,this.anchors=r.map((function(a){return[a.x_center,a.y_center]})),this.anchorsTensor=tg(this.anchors),this.inputSizeTensor=Kr([t,s]),this.doubleInputSizeTensor=Kr([2*t,2*s])}return n.prototype.normalizeBoxes=function(e){var t=this;return be((function(){var s=mn(e,[0,0],[-1,2]),r=mn(e,[0,2],[-1,2]),i=Ze(Rt(s,t.inputSizeTensor),t.anchorsTensor),o=Rt(r,t.doubleInputSizeTensor),a=de(Tt(i,o),t.inputSizeTensor),l=de(Ze(i,o),t.inputSizeTensor);return sA([a,l],1)}))},n.prototype.normalizeLandmarks=function(e,t){var s=this;return be((function(){var r=Ze(Rt(pe(e,[-1,7,2]),s.inputSizeTensor),s.anchors[t]);return de(r,s.inputSizeTensor)}))},n.prototype.getBoundingBoxes=function(e){return Hh(this,void 0,void 0,(function(){var t,s,r,i,o,a,l,u,c,h,f,p,g,S,x,w=this;return jh(this,(function(_){switch(_.label){case 0:return t=be((function(){return de(Tt(e,.5),2)})),ZN()==="webgl"?(r=Te().get("WEBGL_PACK_DEPTHWISECONV"),Te().set("WEBGL_PACK_DEPTHWISECONV",!0),s=this.model.predict(t),Te().set("WEBGL_PACK_DEPTHWISECONV",r)):s=this.model.predict(t),i=mc(s),o=be((function(){return mc(Sl(mn(i,[0,0],[-1,1])))})),a=mn(i,[0,1],[-1,4]),l=this.normalizeBoxes(a),u=console.warn,console.warn=function(){},c=Ro.nonMaxSuppression(l,o,1,this.iouThreshold,this.scoreThreshold),console.warn=u,[4,c.array()];case 1:return h=_.sent(),f=[t,s,c,i,l,a,o],h.length===0?(f.forEach((function(T){return T.dispose()})),[2,null]):(p=h[0],g=mn(l,[p,0],[1,-1]),S=mn(i,[p,5],[1,14]),x=be((function(){return pe(w.normalizeLandmarks(S,p),[-1,2])})),f.push(S),f.forEach((function(T){return T.dispose()})),[2,{boxes:g,palmLandmarks:x}])}}))}))},n.prototype.estimateHandBounds=function(e){return Hh(this,void 0,void 0,(function(){var t,s,r,i,o,a,l,u,c=this;return jh(this,(function(h){switch(h.label){case 0:return t=e.shape[1],s=e.shape[2],r=be((function(){return Rt(Ro.resizeBilinear(e,[c.width,c.height]),255)})),[4,this.getBoundingBoxes(r)];case 1:return(i=h.sent())===null?(r.dispose(),[2,null]):(o=i.boxes.arraySync(),a=o[0].slice(0,2),l=o[0].slice(2,4),u=i.palmLandmarks.arraySync(),r.dispose(),i.boxes.dispose(),i.palmLandmarks.dispose(),[2,(f={startPoint:a,endPoint:l,palmLandmarks:u},p=[s/this.width,t/this.height],{startPoint:[f.startPoint[0]*p[0],f.startPoint[1]*p[1]],endPoint:[f.endPoint[0]*p[0],f.endPoint[1]*p[1]],palmLandmarks:f.palmLandmarks.map((function(g){return[g[0]*p[0],g[1]*p[1]]}))})])}var f,p}))}))},n})(),aE={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};function tCe(n,e){var t,s=Math.PI/2-Math.atan2(-(e[1]-n[1]),e[0]-n[0]);return(t=s)-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}var PL=function(n,e){return[[1,0,n],[0,1,e],[0,0,1]]};function bf(n,e){for(var t=0,s=0;s<n.length;s++)t+=n[s]*e[s];return t}function nCe(n,e){for(var t=[],s=0;s<n.length;s++)t.push(n[s][e]);return t}function LL(n,e){for(var t=[],s=n.length,r=0;r<s;r++){t.push([]);for(var i=0;i<s;i++)t[r].push(bf(n[r],nCe(e,i)))}return t}function OL(n,e){var t=Math.cos(n),s=Math.sin(n),r=[[t,-s,0],[s,t,0],[0,0,1]],i=LL(PL(e[0],e[1]),r);return LL(i,PL(-e[0],-e[1]))}function FL(n,e){return[bf(n,e[0]),bf(n,e[1])]}var sCe=[0,-.4],rCe=[0,-.1],$L=[0,5,9,13,17,1,2],iCe=(function(){function n(e,t,s,r,i,o){this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=s,this.meshHeight=r,this.maxContinuousChecks=i,this.detectionConfidence=o,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return n.prototype.getBoxForPalmLandmarks=function(e,t){var s=e.map((function(r){return FL(Om(Om([],r,!0),[1],!1),t)}));return kL(RL(DL(this.calculateLandmarksBoundingBox(s),sCe)),3)},n.prototype.getBoxForHandLandmarks=function(e){for(var t=kL(RL(DL(this.calculateLandmarksBoundingBox(e),rCe)),1.65),s=[],r=0;r<$L.length;r++)s.push(e[$L[r]].slice(0,2));return t.palmLandmarks=s,t},n.prototype.transformRawCoords=function(e,t,s,r){var i,o,a,l,u=this,c=JM(t),h=[c[0]/this.meshWidth,c[1]/this.meshHeight],f=e.map((function(_){return[h[0]*(_[0]-u.meshWidth/2),h[1]*(_[1]-u.meshHeight/2),_[2]]})),p=OL(s,[0,0]),g=f.map((function(_){return Om(Om([],FL(_,p),!0),[_[2]],!1)})),S=(o=[[(i=r)[0][0],i[1][0]],[i[0][1],i[1][1]]],a=[i[0][2],i[1][2]],l=[-bf(o[0],a),-bf(o[1],a)],[o[0].concat(l[0]),o[1].concat(l[1]),[0,0,1]]),x=Om(Om([],VS(t),!0),[1],!1),w=[bf(x,S[0]),bf(x,S[1])];return g.map((function(_){return[_[0]+w[0],_[1]+w[1],_[2]]}))},n.prototype.estimateHand=function(e){return Hh(this,void 0,void 0,(function(){var t,s,r,i,o,a,l,u,c,h,f,p,g,S,x,w,_,T,C,N;return jh(this,(function(M){switch(M.label){case 0:return(t=this.shouldUpdateRegionsOfInterest())!==!0?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(e)];case 1:return(s=M.sent())===null?(e.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(s,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,M.label=3;case 3:return r=this.regionsOfInterest[0],i=tCe(r.palmLandmarks[0],r.palmLandmarks[2]),o=VS(r),a=[o[0]/e.shape[2],o[1]/e.shape[1]],l=Ro.rotateWithOffset(e,i,0,a),u=OL(-i,o),c=t===!0?this.getBoxForPalmLandmarks(r.palmLandmarks,u):r,h=(function(P,$,R){var D=$.shape[1],L=$.shape[2],G=[[P.startPoint[1]/D,P.startPoint[0]/L,P.endPoint[1]/D,P.endPoint[0]/L]];return Ro.cropAndResize($,G,[0],R)})(c,l,[this.meshWidth,this.meshHeight]),f=Rt(h,255),h.dispose(),l.dispose(),ZN()==="webgl"?(g=Te().get("WEBGL_PACK_DEPTHWISECONV"),Te().set("WEBGL_PACK_DEPTHWISECONV",!0),p=this.meshDetector.predict(f),Te().set("WEBGL_PACK_DEPTHWISECONV",g)):p=this.meshDetector.predict(f),S=p[0],x=p[1],f.dispose(),w=S.dataSync()[0],S.dispose(),w<this.detectionConfidence?(x.dispose(),this.regionsOfInterest=[],[2,null]):(_=pe(x,[-1,3]),T=_.arraySync(),x.dispose(),_.dispose(),C=this.transformRawCoords(T,c,i,u),N=this.getBoxForHandLandmarks(C),this.updateRegionsOfInterest(N,!1),[2,{landmarks:C,handInViewConfidence:w,boundingBox:{topLeft:N.startPoint,bottomRight:N.endPoint}}])}}))}))},n.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(r){return r[0]})),s=e.map((function(r){return r[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,s)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,s)]}},n.prototype.updateRegionsOfInterest=function(e,t){if(t)this.regionsOfInterest=[e];else{var s=this.regionsOfInterest[0],r=0;if(s!=null&&s.startPoint!=null){var i=e.startPoint,o=i[0],a=i[1],l=e.endPoint,u=l[0],c=l[1],h=s.startPoint,f=h[0],p=h[1],g=s.endPoint,S=g[0],x=g[1],w=Math.max(o,f),_=Math.max(a,p),T=(Math.min(u,S)-w)*(Math.min(c,x)-_);r=T/((u-o)*(c-a)+(S-f)*(x-a)-T)}this.regionsOfInterest[0]=r>.8?s:e}},n.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},n})();function oCe(){return Hh(this,void 0,void 0,(function(){return jh(this,(function(n){return[2,_4("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function aCe(){return Hh(this,void 0,void 0,(function(){return jh(this,(function(n){return[2,_4("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function lCe(){return Hh(this,void 0,void 0,(function(){return jh(this,(function(n){return[2,oK("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(e){return e.json()}))]}))}))}function uCe(n){var e=n===void 0?{}:n,t=e.maxContinuousChecks,s=t===void 0?1/0:t,r=e.detectionConfidence,i=r===void 0?.8:r,o=e.iouThreshold,a=o===void 0?.3:o,l=e.scoreThreshold,u=l===void 0?.5:l;return Hh(this,void 0,void 0,(function(){var c,h,f,p,g,S;return jh(this,(function(x){switch(x.label){case 0:return[4,Promise.all([lCe(),oCe(),aCe()])];case 1:return c=x.sent(),h=c[0],f=c[1],p=c[2],g=new eCe(f,256,256,h,a,u),S=new iCe(g,p,256,256,s,i),[2,new cCe(S)]}}))}))}var cCe=(function(){function n(e){this.pipeline=e}return n.getAnnotations=function(){return aE},n.prototype.estimateHands=function(e,t){return t===void 0&&(t=!1),Hh(this,void 0,void 0,(function(){var s,r,i,o,a,l,u,c,h;return jh(this,(function(f){switch(f.label){case 0:return s=(function(p){return p instanceof gs?[p.shape[0],p.shape[1]]:[p.height,p.width]})(e),r=s[1],i=be((function(){return e instanceof gs||(e=Jne(e)),pi(gt(e,"float32"))})),[4,this.pipeline.estimateHand(i)];case 1:if(o=f.sent(),i.dispose(),o===null)return[2,[]];for(a=o,t===!0&&(a=(function(p,g){var S=p.handInViewConfidence,x=p.landmarks,w=p.boundingBox;return{handInViewConfidence:S,landmarks:x.map((function(_){return[g-1-_[0],_[1],_[2]]})),boundingBox:{topLeft:[g-1-w.topLeft[0],w.topLeft[1]],bottomRight:[g-1-w.bottomRight[0],w.bottomRight[1]]}}})(o,r)),l={},u=0,c=Object.keys(aE);u<c.length;u++)h=c[u],l[h]=aE[h].map((function(p){return a.landmarks[p]}));return[2,[{handInViewConfidence:a.handInViewConfidence,boundingBox:a.boundingBox,landmarks:a.landmarks,annotations:l}]]}}))}))},n})();const hCe=({onGesture:n,isGuiVisible:e})=>{const t=Ee.useRef(null),[s,r]=Ee.useState(null),[i,o]=Ee.useState(!0),[a,l]=Ee.useState(!1),[u,c]=Ee.useState("-"),[h,f]=Ee.useState("Initializing AI Engine..."),p=Ee.useRef(n);Ee.useEffect(()=>{p.current=n},[n]);const g=Ee.useRef(0),S=Ee.useRef([]),x=Ee.useRef([]),w=Ee.useRef(!1),_=Ee.useRef(0),T=Ee.useRef([]),C=Ee.useRef([]),N=Ee.useRef(!1),M=Ee.useRef(null),P=Ee.useRef(0);Ee.useEffect(()=>{let D=!0;const L=async()=>{try{f("Connecting to GPU..."),await TK(),D&&f("Loading Local AI Model...");const W=await uCe({modelUrl:"public/models/handpose/model.json"});D&&(r(W),o(!1))}catch(Q){console.error("Failed to load handpose model:",Q),D&&f("Network Error: Check Connection")}},G=setTimeout(()=>{i&&D&&f("Downloading (First Run Takes Time)...")},5e3);return L(),()=>{D=!1,clearTimeout(G)}},[]);const $=Ee.useCallback(async()=>{if(s&&t.current&&t.current.video&&t.current.video.readyState===4){const D=Date.now();if(D-g.current<100){requestAnimationFrame($);return}g.current=D;const L=t.current.video;if(L.videoWidth===0||L.videoHeight===0){requestAnimationFrame($);return}try{const G=await s.estimateHands(L);if(G.length>0){_.current=0;const W=G[0].landmarks,H=W[0];if(!H||!Number.isFinite(H[0])||!Number.isFinite(H[1])){requestAnimationFrame($);return}const J=-1*(H[0]/L.videoWidth*2-1),ie=-1*(H[1]/L.videoHeight*2-1);x.current.push({x:J,y:ie}),x.current.length>8&&x.current.shift();const V=x.current.reduce((We,Xe)=>({x:We.x+Xe.x,y:We.y+Xe.y}),{x:0,y:0}),Y=x.current.length,B=V.x/Y,K=V.y/Y,se=[8,12,16,20],te=[5,9,13,17],ue=(We,Xe)=>Math.sqrt(Math.pow(We[0]-Xe[0],2)+Math.pow(We[1]-Xe[1],2));let fe=0,_e=0;for(let We=0;We<4;We++)fe+=ue(H,W[te[We]]),_e+=ue(H,W[se[We]]);const Ie=fe/4,qe=_e/4/(Ie||1);S.current.push(qe),S.current.length>5&&S.current.shift();const Ye=S.current.reduce((We,Xe)=>We+Xe,0)/S.current.length;!w.current&&Ye>1.6?w.current=!0:w.current&&Ye<1.2&&(w.current=!1);const et=w.current,ae=W[4],Be=W[8],De=W[12],He=W[16],Re=W[20];let at,Qe=!1,ee=!1,X=0;if(ae&&Be&&Number.isFinite(ae[0])&&Number.isFinite(ae[1])&&Number.isFinite(Be[0])&&Number.isFinite(Be[1])){const We=-1*(Be[0]/L.videoWidth*2-1),Xe=-1*(Be[1]/L.videoHeight*2-1);at={x:We,y:Xe},T.current.push({x:We,y:Xe}),T.current.length>5&&T.current.shift(),C.current.push({x:-1*(ae[0]/L.videoWidth*2-1),y:-1*(ae[1]/L.videoHeight*2-1)}),C.current.length>5&&C.current.shift();const je=T.current.reduce((yt,jt)=>({x:yt.x+jt.x,y:yt.y+jt.y}),{x:0,y:0}),xt=C.current.reduce((yt,jt)=>({x:yt.x+jt.x,y:yt.y+jt.y}),{x:0,y:0}),it=T.current.length,dt=je.x/it,It=je.y/it,Yt=xt.x/it,Ke=xt.y/it,hn=Math.sqrt(Math.pow((Be[0]-ae[0])/L.videoWidth,2)+Math.pow((Be[1]-ae[1])/L.videoHeight,2));let un=!0;if(De&&He&&Re&&H){const yt=ue(H,De),jt=ue(H,He),Nn=ue(H,Re),jn=W[9],sn=W[13],ut=W[17];if(jn&&sn&&ut){const ge=ue(H,jn),ct=ue(H,sn),pt=ue(H,ut),Kt=yt/(ge||1),Gt=jt/(ct||1),Bn=Nn/(pt||1),kn=1.1;un=Kt>kn&&Gt>kn&&Bn>kn}}if(Qe=hn<.05&&un,N.current=Qe,Qe&&M.current!==null){const yt=M.current-It;X=yt,ee=yt>.02}M.current=It,P.current=X,at={x:dt,y:It}}else M.current!==null&&!N.current&&(M.current=null);let Se=et?"OPEN":"CLOSED";Qe&&(Se=ee?"PULL":"PINCH"),c(Se),p.current&&p.current({isOpen:et,position:{x:B,y:K},isDetected:!0,indexFinger:at,isPinching:Qe,isPulling:ee,pullVelocity:P.current})}else _.current++,_.current>5&&(w.current=!1,S.current=[],x.current=[],T.current=[],C.current=[],N.current=!1,M.current=null,P.current=0,c("NO HAND"),p.current&&p.current({isOpen:!1,position:{x:0,y:0},isDetected:!1,isPinching:!1,isPulling:!1,pullVelocity:0}))}catch{}}requestAnimationFrame($)},[s]);return Ee.useEffect(()=>{if(s&&!i){const D=requestAnimationFrame($);return()=>cancelAnimationFrame(D)}},[s,i,$]),Ae.jsxs("div",{className:`fixed bottom-4 right-4 z-50 transition-all duration-500 ease-in-out ${e?"opacity-100 translate-y-0":"opacity-0 translate-y-10 pointer-events-none"}`,children:[Ae.jsxs("div",{className:"relative w-28 h-36 md:w-48 md:h-36 rounded-lg border-[#d4af37]/50 bg-black/90 border overflow-hidden shadow-[0_0_20px_rgba(212,175,55,0.2)]",children:[a?Ae.jsxs("div",{className:"flex flex-col items-center justify-center h-full text-[#d4af37] p-2 text-center gap-2",children:[Ae.jsx("span",{className:"text-xl",children:""}),Ae.jsx("span",{className:"text-[10px] font-luxury uppercase tracking-widest",children:"Camera Unavailable"}),Ae.jsx("span",{className:"text-[9px] text-white/50",children:"Use mouse instead"})]}):Ae.jsxs(Ae.Fragment,{children:[Ae.jsx(M7,{ref:t,mirrored:!0,videoConstraints:{facingMode:"user"},className:`w-full h-full object-cover transition-opacity duration-500 ${i?"opacity-20":"opacity-80"}`,onUserMediaError:()=>l(!0)}),!i&&Ae.jsx("div",{className:"absolute inset-0 bg-gradient-to-b from-transparent via-[#d4af37]/10 to-transparent animate-scan pointer-events-none"})]}),i&&!a&&Ae.jsxs("div",{className:"absolute inset-0 flex flex-col items-center justify-center text-[#d4af37] gap-2 p-4 bg-black/80 backdrop-blur-sm",children:[Ae.jsx("div",{className:"w-5 h-5 border-2 border-[#d4af37] border-t-transparent rounded-full animate-spin"}),Ae.jsx("span",{className:"text-[9px] font-luxury uppercase tracking-widest text-center animate-pulse",children:h})]}),Ae.jsxs("div",{className:"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/90 to-transparent pt-6 pb-2 px-3 flex flex-col md:flex-row justify-end md:justify-between items-start md:items-end gap-0 md:gap-0",children:[Ae.jsx("span",{className:"text-[9px] md:text-[8px] text-[#d4af37]/80 font-luxury tracking-widest uppercase mb-0.5 md:mb-0",children:"Sensors"}),Ae.jsx("span",{className:`text-[11px] md:text-[9px] font-mono font-bold ${u.includes("OPEN")?"text-white drop-shadow-[0_0_5px_rgba(255,255,255,0.8)]":"text-[#d4af37]"}`,children:u})]})]}),Ae.jsx("style",{children:`
        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .animate-scan {
            animation: scan 3s linear infinite;
        }
      `})]})};console.log("App.tsx: Component loading...");const dCe=()=>{console.log("App.tsx: Component rendering...");const[n,e]=Ee.useState(1),[t]=Ee.useState({bottom:"#022b1c",top:"#217a46"}),s=Ee.useRef({x:0,y:0,isDetected:!1}),[r,i]=Ee.useState([]),[o,a]=Ee.useState(!1),l=Ee.useRef(null),[u,c]=Ee.useState(!1),[h,f]=Ee.useState(""),[p,g]=Ee.useState(null),[S,x]=Ee.useState(!1),[w,_]=Ee.useState(null),T=Ee.useRef(!1),C=Ee.useRef(null),N=Ee.useRef(null),[M,P]=Ee.useState(!0),$=Ee.useCallback(H=>{if(H.isDetected){if(H.isPinching&&H.indexFinger&&r.length>0){if(!T.current&&H.isPulling&&(T.current=!0),T.current){const J=(H.indexFinger.x+1)/2,ie=(H.indexFinger.y+1)/2,V=Math.floor((J*.8+ie*.2)*r.length)%r.length;C.current!==V&&(_(r[V]),C.current=V),x(!0);return}}else T.current&&(T.current=!1,C.current=null,x(!1));if(!T.current){const J=H.isOpen?0:1;e(ie=>ie!==J?J:ie),s.current={x:H.position.x*1.2,y:H.position.y,isDetected:!0}}}else s.current.isDetected=!1,T.current&&(T.current=!1,C.current=null,x(!1))},[r]),R=()=>{e(H=>H===1?0:1)},D=()=>{var H;(H=l.current)==null||H.click()},L=()=>{if(r.length>0){const H=r[Math.floor(Math.random()*r.length)];g(H)}else g(null);c(!0)},G=H=>{H.target.files&&H.target.files.length>0&&(a(!0),e(0),setTimeout(()=>{const ie=Array.from(H.target.files).slice(0,30).map(V=>URL.createObjectURL(V));i(V=>(V.forEach(Y=>URL.revokeObjectURL(Y)),ie)),l.current&&(l.current.value=""),setTimeout(()=>{a(!1),setTimeout(()=>{e(1)},800)},1200)},50))},Q=`
    group relative 
    w-10 h-10 md:w-12 md:h-12
    rounded-full 
    bg-black/30 backdrop-blur-md 
    border border-white/20 
    text-slate-300 
    transition-all duration-500 ease-out 
    hover:border-white/60 hover:text-white hover:bg-white/10 
    hover:shadow-[0_0_25px_rgba(255,255,255,0.2)] 
    active:scale-90 active:bg-white/20
    flex justify-center items-center cursor-pointer
  `,W=`
    group relative 
    w-auto px-8 h-10
    overflow-hidden rounded-sm 
    bg-black/80 backdrop-blur-md 
    border border-white/40 
    text-slate-300 font-luxury text-[11px] uppercase tracking-[0.25em] 
    transition-all duration-500 ease-out 
    hover:border-white/80 hover:text-black hover:bg-white 
    hover:shadow-[0_0_25px_rgba(255,255,255,0.2)] 
    active:scale-95
    flex justify-center items-center cursor-pointer
  `;return Ee.useEffect(()=>{console.log("App.tsx: Component mounted, checking DOM...");const H=document.getElementById("root");H&&console.log("App.tsx: Root element found, children count:",H.children.length)},[]),Ae.jsxs("div",{className:"relative w-full h-screen bg-black overflow-hidden",children:[Ae.jsx("div",{style:{position:"absolute",top:0,left:0,zIndex:9999,color:"white",padding:"10px",background:"red"},children:"DEBUG: React is rendering!"}),Ae.jsx("input",{type:"file",ref:l,onChange:G,accept:"image/*",multiple:!0,className:"hidden"}),o&&Ae.jsxs("div",{className:"absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black/90 backdrop-blur-md transition-all duration-500 animate-in fade-in",children:[Ae.jsxs("div",{className:"relative w-16 h-16 mb-6",children:[Ae.jsx("div",{className:"absolute inset-0 border-2 border-t-[#d4af37] border-r-transparent border-b-[#d4af37] border-l-transparent rounded-full animate-spin"}),Ae.jsx("div",{className:"absolute inset-2 border-2 border-t-transparent border-r-white/30 border-b-transparent border-l-white/30 rounded-full animate-spin-reverse"}),Ae.jsx("div",{className:"absolute inset-0 flex items-center justify-center text-[#d4af37] text-xl animate-pulse",children:""})]}),Ae.jsx("div",{className:"text-[#d4af37] font-luxury tracking-[0.25em] text-xs uppercase animate-pulse",children:"..."}),Ae.jsx("style",{children:`
                @keyframes spin-reverse {
                    from { transform: rotate(360deg); }
                    to { transform: rotate(0deg); }
                }
                .animate-spin-reverse {
                    animation: spin-reverse 2s linear infinite;
                }
              `})]}),Ae.jsx("div",{className:`absolute top-[5%] left-0 w-full flex justify-center pointer-events-none z-0 transition-opacity duration-700 ${u?"opacity-0":"opacity-100"}`,children:Ae.jsx("h1",{className:"font-script text-6xl md:text-9xl text-center leading-[1.5] py-10",style:{background:"linear-gradient(to bottom, #ffffff 20%, #e8e8e8 50%, #b0b0b0 90%)",WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent",filter:"drop-shadow(0px 5px 5px rgba(0,0,0,0.8)) drop-shadow(0px 0px 20px rgba(255,255,255,0.4))"},children:"Merry Christmas"})}),Ae.jsx("div",{className:`absolute inset-0 z-10 transition-all duration-700 ${u?"blur-sm scale-95 opacity-50":"blur-0 scale-100 opacity-100"}`,children:Ae.jsx(wF,{mixFactor:n,colors:t,inputRef:s,userImages:r,signatureText:h,ref:N})}),S&&w&&Ae.jsx("div",{className:"absolute inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-md transition-opacity duration-300 animate-in fade-in",children:Ae.jsxs("div",{className:"relative w-full h-full max-w-4xl max-h-[90vh] flex items-center justify-center",children:[Ae.jsx("button",{onClick:()=>x(!1),className:"absolute top-4 right-4 w-10 h-10 rounded-full bg-black/80 border border-white/30 text-white flex items-center justify-center hover:bg-white hover:text-black transition-colors z-50 text-xl",children:""}),Ae.jsx("div",{className:"relative w-full h-full flex items-center justify-center",children:Ae.jsx("img",{src:w,alt:"Viewing",className:"max-w-full max-h-full object-contain rounded-lg shadow-2xl",style:{animation:"zoomIn 0.3s ease-out"}})}),Ae.jsx("div",{className:"absolute bottom-8 left-0 right-0 text-center text-white/60 text-sm font-luxury tracking-widest",children:""}),Ae.jsx("style",{children:`
              @keyframes zoomIn {
                from {
                  transform: scale(0.8);
                  opacity: 0;
                }
                to {
                  transform: scale(1);
                  opacity: 1;
                }
              }
            `})]})}),u&&Ae.jsxs("div",{className:"absolute inset-0 z-40 flex items-center justify-center p-4 bg-black/60 backdrop-blur-md transition-opacity duration-500 animate-in fade-in",children:[Ae.jsxs("div",{className:"relative bg-[#f8f8f8] p-4 pb-12 shadow-[0_0_50px_rgba(255,255,255,0.2)] transform transition-transform duration-700 scale-100 rotate-[-2deg]",style:{width:"min(80vw, 320px)",aspectRatio:"3.5/4.2"},children:[Ae.jsx("button",{onClick:()=>c(!1),className:"absolute -top-4 -right-4 w-8 h-8 rounded-full bg-black border border-white/20 text-white flex items-center justify-center hover:bg-white hover:text-black transition-colors z-50",children:""}),Ae.jsxs("div",{className:"w-full h-[75%] bg-[#1a1a1a] overflow-hidden relative shadow-inner",children:[p?Ae.jsx("img",{src:p,alt:"Memory",className:"w-full h-full object-cover"}):Ae.jsx("div",{className:"w-full h-full flex items-center justify-center text-white/40 font-body text-lg italic tracking-widest text-center px-4",children:"~~"}),Ae.jsx("div",{className:"absolute inset-0 bg-gradient-to-tr from-white/0 via-white/5 to-white/20 pointer-events-none"})]}),Ae.jsx("div",{className:"absolute bottom-0 left-0 w-full h-[25%] flex items-center justify-center px-4",children:Ae.jsx("input",{autoFocus:!0,type:"text",placeholder:"Sign here...",value:h,onChange:H=>f(H.target.value),className:"w-full text-center bg-transparent border-none outline-none font-script text-3xl md:text-4xl text-[#1a1a1a] placeholder:text-gray-300/50",style:{transform:"translateY(-5px) rotate(-1deg)"},maxLength:20})})]}),Ae.jsx("div",{className:"absolute bottom-10 left-0 w-full flex justify-center",children:Ae.jsx("button",{onClick:()=>c(!1),className:W,children:""})})]}),Ae.jsxs("div",{className:`absolute top-6 right-6 md:top-10 md:right-10 z-30 pointer-events-auto flex flex-row md:flex-col items-center md:items-end gap-3 md:gap-4 transition-opacity duration-500 ${u||o?"opacity-0 pointer-events-none":"opacity-100"}`,children:[Ae.jsx("button",{onClick:()=>P(H=>!H),className:`${Q} ${M?"text-white border-white/60 bg-white/10":"text-slate-300"}`,title:M?"":"",children:M?Ae.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z"})}):Ae.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:[Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M12 18.75H4.5a2.25 2.25 0 01-2.25-2.25V9m12.841 9.091L16.5 19.5m-1.409-1.409c.407-.407.659-.97.659-1.591v-9a2.25 2.25 0 00-2.25-2.25h-9c-.621 0-1.184.252-1.591.659m3.75-3.75l3.75-3.75"}),Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3 3l18 18"})]})}),Ae.jsx("button",{onClick:D,className:Q,title:"",children:Ae.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z"})})}),Ae.jsx("button",{onClick:L,className:Q,title:"",children:Ae.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10"})})}),Ae.jsx("button",{onClick:R,className:Q,title:n===1?"":"",children:n===1?Ae.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"})}):Ae.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ae.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25"})})})]}),Ae.jsx("div",{className:`absolute bottom-6 left-6 z-20 pointer-events-none transition-opacity duration-500 ${u?"opacity-0":"opacity-100"}`,children:Ae.jsxs("div",{className:"text-white/20 text-[10px] uppercase tracking-widest font-luxury",children:[Ae.jsx("div",{children:""}),Ae.jsx("div",{className:"text-slate-500",children:"Made by Southpl"})]})}),Ae.jsx(hCe,{onGesture:$,isGuiVisible:M})]})};console.log("index.tsx: Starting app initialization...");const Y2=document.getElementById("root");if(!Y2)throw new Error("Could not find root element to mount to");console.log("index.tsx: Root element found, creating root...");try{const n=oG.createRoot(Y2);console.log("index.tsx: Root created, rendering App..."),n.render(Ae.jsx(Ju.StrictMode,{children:Ae.jsx(dCe,{})})),console.log("index.tsx: App rendered successfully")}catch(n){console.error("index.tsx: Error rendering app:",n),Y2.innerHTML=`
    <div style="color: white; padding: 20px; font-family: monospace;">
      <h1>Error Loading App</h1>
      <pre>${n instanceof Error?n.message:String(n)}</pre>
      <pre>${n instanceof Error?n.stack:""}</pre>
    </div>
  `}
